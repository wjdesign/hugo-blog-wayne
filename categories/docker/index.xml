<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Wayne's blog | 偉恩的部落格 | 技術博客</title><link>https://wayneblog.ga/categories/docker/</link><description>Recent content in Docker on Wayne's blog | 偉恩的部落格 | 技術博客</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Thu, 08 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://wayneblog.ga/categories/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET Core Docker 筆記 3 - 共用 Nginx 容器與 Certbot 整合</title><link>https://wayneblog.ga/2022-12-08/dotnet-core-docker-note-3/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><guid>https://wayneblog.ga/2022-12-08/dotnet-core-docker-note-3/</guid><description>&lt;img src="https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png" alt="Featured image of post ASP.NET Core Docker 筆記 3 - 共用 Nginx 容器與 Certbot 整合" />&lt;style>
.article-content p code {
background-color: #f5f5f5;
color: #ff3860;
}
.focus {
background: #f1e2e2;
color: #d62c2c;
padding: 0 5px;
}
&lt;/style>
&lt;p>&lt;a class="link" href="https://blog.darkthread.net/blog/aspnetcore-docker-notes-3/" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>&lt;a class="link" href="https://wayneblog.ga/2022-12-07/dotnet-core-docker-note-2/" target="_blank" rel="noopener"
>前篇文章&lt;/a>介紹過使用 Docker Compose 設定關聯容器(Web、DB、Reverse Proxy)組成系統，容器被隔離在專用網段(Compose 自動建立的 Bridge)，並可透過容器名稱彼此溝通，Compose 也確保相關服務一起啟動一起關閉，是用多個容器建構系統最簡便的做法。&lt;/p>
&lt;p>註：關於容器管理 &lt;a class="link" href="https://blog.gcp.expert/kubernetes-gke-introduction/" target="_blank" rel="noopener"
>Kubernetes&lt;/a>，K8S 提供更強大的功能，支援 Cluster 高可用架構 (單一容器、主機掛掉系統不會死)，為當今在雲端掛載容器以及中大型企業實做容器架構的主流，K8S 無疑可取代 Docker Compose，但其複雜性較高。 目前我在單一 Linux 機跑 Docker 還用不到牛刀(雖然有單機版 &lt;a class="link" href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener"
>Minikube&lt;/a> 可用)，未來若要將 Docker 應用於工作，K8S 已成必要技能。&lt;/p>
&lt;p>用 Docker Compose 組合容器建立服務看似完美，但應用在 Reverse Proxy (Nginx) 時需要額外考量。&lt;/p>
&lt;p>我打算在同一台 Linux 上跑多個網站，對外用同一個 IP，再依 HTTP Request 的 &lt;strong>Host 標頭&lt;/strong>導向不同網站。&lt;/p>
&lt;hr>
&lt;h2 id="舉例">舉例&lt;/h2>
&lt;p>舉個例子：假設 Linux 的對外 IP 是 123.123.123.123，我申請兩個 DNS 名稱 web1.xxx.com.tw、web2.xxx.com.tw 都指向 123.123.123.123。&lt;/p>
&lt;p>使用者用 &lt;a class="link" href="http://web1.xxx.com.tw" target="_blank" rel="noopener"
>http://web1.xxx.com.tw&lt;/a> 連上 123.123.123.123 的 80 Port 時，Reverse Proxy 導向 &lt;strong>Web1&lt;/strong> 網站；用 &lt;a class="link" href="http://web2.xxx.com.tw" target="_blank" rel="noopener"
>http://web2.xxx.com.tw&lt;/a> 時連線時則導向 &lt;strong>Web2&lt;/strong> 網站。由於對外靜態 IP 為珍貴資源，多網站透過 Host 共用 IP 是節省成本的常見做法。&lt;/p>
&lt;p>上述以 HTTP Host 名稱導向的做法，若用 Docker Compose 將網站連同 Reverse Proxy 包在一起，就可能出問題。&lt;/p>
&lt;p>例如：某 Host OS 跑兩個網站，若各自用 Docker Compose 連同 Nginx 一起包進去，網站 A 由 Web-A + MySQL-A + Nginx-A 組成，網站 B 由 Web-B + MySQL-B + Nginx-B 組成，二者跑在自己的專屬網段，僅 Nginx-A 跟 Nginx-B 對映到 Host OS IP 的 80 Port&amp;hellip; 哦哦，衝突出現了，Nginx-A 與 Nginx-B 都需對映 Host IP 的 80 Port，但 Host OS 的 80 Port 只允許被一個程序使用。&lt;/p>
&lt;hr>
&lt;h2 id="解決方式">解決方式&lt;/h2>
&lt;p>有幾個解決方向：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Nginx-A 與 Nginx-B 各自對應到主機不同 Port，更前端再掛一台 Nginx 聽 80 Port，依 Host Name 導向到 Nginx-A 與 Nginx- B，如此 Nginx-A 與 Nginx-B 的角色顯得多餘，多了一次轉接但未看到明顯效益，徒增複雜性又耗損效能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>將兩個系統包成一個大 Docker Compose，Web-A + MySQL-A + Web-B + MySQL-B + Nginx，共用 Nginx 可避免 Port 80 繫結衝突，但將不相關系統綁架成一團，被迫一起啟動一起停止挺鳥的，更不用提一旦加跑新服務就要改 Docker Compose，我覺得不行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>將 Nginx 從 Docker Compose 抽離，讓 Web-A 與 Web-B 對映到 Host IP 的不同 Port，整個 Host OS 只跑一份 Nginx 聽 80 Port，依 Host Name 分派給網站 A 或網站 B。也就是用 Docker Compose 執行三個容器：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Web-A + MySQL-A&lt;/li>
&lt;li>Web-B + MySQL-B&lt;/li>
&lt;li>Ngnix&lt;/li>
&lt;/ul>
&lt;p>3 是我認為較可行且有效率的做法。&lt;/p>
&lt;p>Nginx 包容器的做法在&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/" target="_blank" rel="noopener"
>第一篇筆記&lt;/a>已提過，這次我們將重點放在整合 Certbot 及 docker-compose.yml 定義。&lt;/p>
&lt;p>原本想抓 Nginx 的 Docker Image 自行加裝 certbot 實現自動安裝與更新 &lt;a class="link" href="https://zh.wikipedia.org/wiki/Let%27s_Encrypt" target="_blank" rel="noopener"
>Let&amp;rsquo;s Encrypt SSL 憑證&lt;/a>。&lt;/p>
&lt;p>用 Docker 的好處是資源豐富，很快在網路上找到現成解決方案，超級好用的全自動化 Nginx + Certbot -&amp;gt; &lt;a class="link" href="https://github.com/staticfloat/docker-nginx-certbot" target="_blank" rel="noopener"
>staticfloat/nginx-certbot&lt;/a>。&lt;/p>
&lt;hr>
&lt;h2 id="staticfloatnginx-certbot">staticfloat/nginx-certbot&lt;/h2>
&lt;p>&lt;a class="link" href="https://github.com/staticfloat/docker-nginx-certbot" target="_blank" rel="noopener"
>staticfloat/nginx-certbot&lt;/a>&lt;/p>
&lt;p>使用方法很簡單，在 &lt;code>/etc/nginx/conf.d&lt;/code> 放一個 &lt;code>certbot.conf&lt;/code> 接受 80 Port 流量，只用於接收 Let&amp;rsquo;s Encrypt 的 &lt;code>/.well-known/acme-challenge&lt;/code> 要求導向 Certbot 完成自動驗證，其餘則一律導向 HTTPS：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Listen on plain old HTTP
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">80&lt;/span> &lt;span class="s">default_server&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Pass this particular URL off to certbot, to authenticate HTTPS certificates
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kn">location&lt;/span> &lt;span class="s">&amp;#39;/.well-known/acme-challenge&amp;#39;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">default_type&lt;/span> &lt;span class="s">&amp;#34;text/plain&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="s">http://localhost:1337&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Everything else gets shunted over to HTTPS
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">return&lt;/span> &lt;span class="mi">301&lt;/span> &lt;span class="s">https://&lt;/span>&lt;span class="nv">$http_host$request_uri&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著在 &lt;code>/etc/nginx/conf.d&lt;/code> 為每個網站新增一個 someweb.conf 承接 HTTPS 請求。server_name 註明該網站綁定的 Host 名稱(DNS 名稱)，ssl_certificate、ssl_certficate_key 則指向 &lt;code>/etc/letsencrypt/live/DNS名稱&lt;/code> 的 &lt;code>fullchain.pem&lt;/code> 及 &lt;code>private.pem&lt;/code>，這兩個檔案不需事先準備，Certbot 會自動產生，至於 &lt;code>proxy_*&lt;/code> 相關設定比照先前介紹過的做法。完整範例如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">443&lt;/span> &lt;span class="s">ssl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">blog.darkthread.net&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">ssl_certificate&lt;/span> &lt;span class="s">/etc/letsencrypt/live/blog.darkthread.net/fullchain.pem&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">ssl_certificate_key&lt;/span> &lt;span class="s">/etc/letsencrypt/live/blog.darkthread.net/privkey.pem&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="s">http://localhost:5000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_http_version&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="s">.1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Upgrade&lt;/span> &lt;span class="nv">$http_upgrade&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Connection&lt;/span> &lt;span class="s">keep-alive&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Host&lt;/span> &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_cache_bypass&lt;/span> &lt;span class="nv">$http_upgrade&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-For&lt;/span> &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-Proto&lt;/span> &lt;span class="nv">$scheme&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這個 Docker Image 有一段精巧設計，它在啟動時會主動掃瞄 /etc/nginx/conf.d 下的 config，一旦偵測缺少 &lt;code>/etc/letsencrypt/live/*/fullchain.pem&lt;/code> 就連上 &lt;a class="link" href="https://zh.wikipedia.org/wiki/Let%27s_Encrypt" target="_blank" rel="noopener"
>Let&amp;rsquo;s Encrypt 網站&lt;/a>進行驗證下載 SSL 憑證，另外還設了每週一次的排程，憑證到期前會自動更新，一氣喝成，全不沾手，貼心到我想起立鼓掌。&lt;/p>
&lt;p>若對它的運作原理有興趣，&lt;a class="link" href="https://github.com/staticfloat/docker-nginx-certbot/tree/master/src/scripts" target="_blank" rel="noopener"
>Github&lt;/a> 有原始碼可以參考。&lt;/p>
&lt;p>為了瞭解原理，我是依著 &lt;a class="link" href="https://github.com/staticfloat/docker-nginx-certbot/tree/master/src/scripts" target="_blank" rel="noopener"
>Github 原始碼&lt;/a>自己跑 Dockerfile 製作 Nginx + Certbot 的 Image，如果嫌麻煩，直接從 &lt;a class="link" href="https://hub.docker.com/r/staticfloat/nginx-certbot/" target="_blank" rel="noopener"
>Docker Hub&lt;/a> 下載也成。&lt;/p>
&lt;p>以下是我的 Nginx docker-compose.yml：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">nginx&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx-certbot&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">container_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">80&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">443&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">443&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/var/log/nginx:/var/log/nginx&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/etc/nginx/conf.d:/etc/nginx/conf.d&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/etc/letsencrypt:/etc/letsencrypt&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">restart&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">always&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">CERTBOT_EMAIL=your-email@mail.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">network_mode&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;host&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我設了三個 Volume 對映：&lt;/p>
&lt;ul>
&lt;li>/var/log/nginx：Log 檔&lt;/li>
&lt;li>/etc/nginx/conf.d：設定檔&lt;/li>
&lt;li>/etc/letsencrypt：用來存放 SSL 憑證&lt;/li>
&lt;/ul>
&lt;p>若為 &lt;strong>SELinux&lt;/strong> 記得要 &lt;code>chcon -Rt&lt;/code> &lt;a class="link" href="https://blog.darkthread.net/blog/aspnetcore-docker-notes-2/" target="_blank" rel="noopener"
>參考&lt;/a>，另外 network_mode 指定 host 表示 Nginx 容器將直接使用 Host OS 網段，不另設 Bridge。&lt;/p>
&lt;p>參考：&lt;a class="link" href="https://notes.doublemine.me/2017-06-12-Docker-Compose-%E9%93%BE%E6%8E%A5%E5%A4%96%E9%83%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html" target="_blank" rel="noopener"
>Docker Compose：链接外部容器的几种方式&lt;/a>&lt;/p>
&lt;p>就醬，Nginx Reverse Proxy 準備好了，下一篇來再來分享我將 ASP.NET Core 搬進 Docker 的經驗。&lt;/p>
&lt;hr></description></item><item><title>ASP.NET Core Docker 筆記 2 - 組合容器建構系統</title><link>https://wayneblog.ga/2022-12-07/dotnet-core-docker-note-2/</link><pubDate>Wed, 07 Dec 2022 00:00:00 +0000</pubDate><guid>https://wayneblog.ga/2022-12-07/dotnet-core-docker-note-2/</guid><description>&lt;img src="https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png" alt="Featured image of post ASP.NET Core Docker 筆記 2 - 組合容器建構系統" />&lt;style>
.article-content p code {
background-color: #f5f5f5;
color: #ff3860;
}
.focus {
background: #f1e2e2;
color: #d62c2c;
padding: 0 5px;
}
&lt;/style>
&lt;p>&lt;a class="link" href="https://github.com/wekan/wekan/wiki/Install-Wekan-Docker-for-testing" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.darkthread.net/blog/aspnetcore-docker-notes-2/" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;/p>
&lt;hr>
&lt;p>&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/" target="_blank" rel="noopener"
>上篇文章&lt;/a>體驗過在 CentOS 用 Docker Container 分別跑 Nginx 跟 ASP.NET Core 網站，並建立 Reverse Proxy 關係，接著探討在實務上當需要多個 Container 協同運作時應如何規劃整合。&lt;/p>
&lt;p>一個系統常可再拆解成多個服務。以線上購物網站為例，就可能是由 ASP.NET Core 網站(Kestrel)、MySQL 資料庫、Reverse Proxy、金流 Gateway&amp;hellip; 等多個服務組成，若要以 Docker Container 實現，有幾種策略：&lt;/p>
&lt;h2 id="策略">策略&lt;/h2>
&lt;h3 id="1-全部裝在單一-container">1. 全部裝在單一 Container&lt;/h3>
&lt;p>撰寫一個 Dockerfile，以 MySQL 資料資料庫為基底，在上面安裝 ASP.NET Core Runtime、Nginx 組裝合成獸。&lt;/p>
&lt;p>好處是一個 Container 搞定，高內聚低耦合，不會因相依服務沒配置好或未啟動而故障。但缺點挺明顯：&lt;/p>
&lt;ul>
&lt;li>某些 Container Image 為求輕巧作業系統層次的工具、程式庫很精簡(例如：Nginx Container 連 ping 都沒有)，只求目標程式能執行就好，要加裝其他軟體時要點技巧，得多花些心思。&lt;/li>
&lt;li>全部綁在一起便失去動態調配的彈性，例如：當前端 Web 負載過高時，擴充不易。&lt;/li>
&lt;li>當需要個別升級資料庫、ASP.NET Core 版本，或是想抽換服務組合時手續複雜，有違模組化精神。&lt;/li>
&lt;/ul>
&lt;h3 id="2-以個別-container-執行獨立控制">2. 以個別 Container 執行，獨立控制&lt;/h3>
&lt;p>如同&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/" target="_blank" rel="noopener"
>前篇文章&lt;/a>的做法，ASP.NET Core 網站跑 Cotainer 繫結到 Host OS 的 5000 Port，用 Container 跑 MySQL，再用 Container 跑 Ngnix 繫結到 Host OS 80 Port，再設定 Reverse Proxy 規則。&lt;/p>
&lt;p>Container 間串接配置全靠人工，系統管理員需協助哪個 Container 聽哪個 Port，確保彼此不衝突。如此做有兩個缺點：&lt;/p>
&lt;ul>
&lt;li>相依服務的啟動狀態未連動，需靠人為控制確保先啟動資料庫 Container 再啟動網站 Container 的順序。&lt;/li>
&lt;li>若 Host OS 跑多個系統都用到 MySQL，系統管理員需協調 TCP Port 不衝突，Docker 的 Bridge (橋接器)隔離網段機制全無用武之地。&lt;/li>
&lt;/ul>
&lt;h3 id="3-以個別-container-執行但使用-docker-compose-關聯">3. 以個別 Container 執行，但使用 Docker Compose 關聯&lt;/h3>
&lt;p>為滿足多 Container 協同作業需求，&lt;a class="link" href="https://docs.docker.com/compose/overview/#/common-use-cases" target="_blank" rel="noopener"
>Docker Compose&lt;/a> 應運而生。&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.docker.com/compose/overview/#/common-use-cases" target="_blank" rel="noopener"
>Docker Compose&lt;/a> 定義了一套宣告語法(採用 YAML 格式)，在其中定義各服務 Container 的啟動參數、與 Host OS Port 對映、隸屬 Bridge 網段、Volume 資料夾/檔案對應等等。&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.docker.com/compose/overview/#/common-use-cases" target="_blank" rel="noopener"
>Docker Compose&lt;/a> 會自動為 Container 建立隔離網段並設好名稱解析，讓 Container 使用容器名稱解析成 IP 找到其他 Container，因此設定連線字串或 URL 時便可寫成 httq://myweb:5000、mongodb://mydb，清楚又方便。&lt;/p>
&lt;p>最重要是透過 docker-compose up/down 指令可以一次啟動或停用相關服務，&lt;a class="link" href="https://docs.docker.com/compose/overview/#/common-use-cases" target="_blank" rel="noopener"
>Docker Compose&lt;/a> 還會依據相依 depends_on 指定關聯先啟動 DB 再啟動 Web，先關閉 Web 再關閉 DB，便利性讓人工操作望塵莫及。&lt;/p>
&lt;p>參考：&lt;a class="link" href="http://blog.maxkit.com.tw/2017/03/docker-compose.html" target="_blank" rel="noopener"
>Docker Compose 初步閱讀與學習記錄&lt;/a>&lt;/p>
&lt;hr>
&lt;h2 id="實例">實例&lt;/h2>
&lt;p>針對上述三種做法，以 ASP.NET Core + Ngninx 為題，對映到以下實例：&lt;/p>
&lt;h3 id="1-安裝成單一-container">1. 安裝成單一 Container&lt;/h3>
&lt;p>以 ASP.NET Core Image 為基底，安裝 Nginx，設定 nginx.conf，複製 ASP.NET Core 網站檔案並設定 service nginx start 及 dotnet /app/web.dll 分別啟動 Nginx 及 Kestrel。&lt;/p>
&lt;p>細節做法可參考這篇文章：&lt;a class="link" href="https://www.sep.com/sep-blog/2017/02/24/nginx-reverse-proxy-to-asp-net-core-same-container/" target="_blank" rel="noopener"
>Nginx Reverse Proxy to ASP.NET Core – Same Docker Container&lt;/a>&lt;/p>
&lt;p>不過，該文用的 ASP.NET Core 版本偏舊，若為 ASP.NET Core 2.1 包成 Docker Container 的做法請參考&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/" target="_blank" rel="noopener"
>前文&lt;/a>&lt;/p>
&lt;h3 id="2-aspnet-corenginx-各自跑-container">2. ASP.NET Core、Nginx 各自跑 Container&lt;/h3>
&lt;p>就是我們在&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/" target="_blank" rel="noopener"
>前篇文章&lt;/a>採行的方式，但有一點要補充，除了直接對映到 Host OS IP 的 TCP Port，也可考慮自訂 Bridge，讓 Container 在隔離網段內溝通，例如：ASP.NET Core 的 5000 Port 只有 Nginx 看得到，從 Host OS 無法存取，如此可避免網路介面(網站、資料庫&amp;hellip;)外露到 Host OS，減少被攻擊的風險，這部分後面再找時間介紹。&lt;/p>
&lt;h3 id="3-使用-docker-compose-串連">3. 使用 Docker Compose 串連&lt;/h3>
&lt;p>ASP.NET Core 與 Nginx 各有自己的容器，使用 Docker Compose 組合串連，一次啟動兩個服務。&lt;/p>
&lt;p>細節做法可參考這篇文章：&lt;a class="link" href="https://www.sep.com/sep-blog/2017/02/27/nginx-reverse-proxy-to-asp-net-core-separate-docker-containers/" target="_blank" rel="noopener"
>Nginx Reverse Proxy to ASP.NET Core – Separate Docker Containers&lt;/a>&lt;/p>
&lt;p>綜合以上分析，Docker Compose 無疑是整合關聯 Container 較佳的方式。&lt;/p>
&lt;hr>
&lt;h2 id="練習">練習&lt;/h2>
&lt;p>光說不練是假把式，寫技術文沒實作感覺怪怪的，來個 Docker Compose 練習好了。手邊沒有 ASP.NET Core + DB Server 的範例，就用 Docker 可以找到的 Image 當題材(也方便大家實地驗證)，試試用 Container 跑 &lt;a class="link" href="https://wekan.github.io/" target="_blank" rel="noopener"
>Wekan 看板系統&lt;/a>。&lt;a class="link" href="https://wekan.github.io/" target="_blank" rel="noopener"
>Wekan&lt;/a> 在 Node.js 執行，另外需要 MongoDB，這個練習會用 Docker Compose 組合兩個 Container 架設看板網站。&lt;/p>
&lt;p>開始前，記得先&lt;a class="link" href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener"
>安裝 Docker Compose&lt;/a>，如果發生 sudo docker-compose 找不到指令，要再加上 &lt;code>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose&lt;/code> &lt;a class="link" href="https://stackoverflow.com/a/50243566/288936" target="_blank" rel="noopener"
>參考&lt;/a>。&lt;/p>
&lt;p>要使用 Docker Compose 很簡單，說穿了就是將 Container 設定寫成 docker-compose.yml，寫好寫對再呼叫 docker-compose up -d 即大功告成。以 Wekan 為例，docker-compose.yml 如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;3&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">services&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">wekan&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">wekanteam/wekan:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">depends_on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">wekandb&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">MONGO_URL=mongodb://wekandb/wekan&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">ROOT_URL=http://localhost:80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="m">80&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">wekandb&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mongo:3.2.14&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">volumes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">/var/www/wekan/db:/data/db&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在這個 YAML 裡，我定義了兩個 Service Container，分別叫 &lt;strong>wekan&lt;/strong> 及 &lt;strong>wekandb&lt;/strong>。&lt;/p>
&lt;p>Wekan Container Image 來自 wekanteam/wekan 最新版，depends_on 宣告 wekan 依賴 wekandb，故 Docker Compose 會先啟動 wekandb 再啟動 wekan。&lt;/p>
&lt;p>MONGO_URL、ROOTL_URL 為環境變數，其中 MONGO_URL 寫成 mongodb://wekandb/wekan，docker-compose.yml 所定義的各 Container 預設隸屬同一個 Bridge 網段，彼此可用機器名稱解析。&lt;/p>
&lt;p>Wekan 網站在 Container 掛在 8080 Port，透過 ports 80:8080 會將其對映到 Host IP 80 Port。&lt;/p>
&lt;p>wekandb Container 則以 Mongo DB Container Image 為基底，資料庫檔案以 Volume 方式對映到 Host OS /var/www/wekan/db 資料夾。&lt;/p>
&lt;p>這裡補充一個眉角，由於 SELinux 資安管控較嚴，在 CentOS/REHL/Fedora 版 Linux 上 Docker Container 讀取 Volume 對映資料夾可能會出現 permission denied 錯誤，需對該資料夾執行 &lt;code>chcon -Rt svirt\_sandbox\_file\_t /var/www/wekan/db&lt;/code> 調整權限，或在目錄名稱後方加上 &lt;code>:Z&lt;/code> 由 Docker 自動執行。&lt;/p>
&lt;p>參考：&lt;a class="link" href="https://www.projectatomic.io/blog/2015/06/using-volumes-with-docker-can-cause-problems-with-selinux/" target="_blank" rel="noopener"
>Using Volumes with Docker can Cause Problems with SELinux&lt;/a>&lt;/p>
&lt;p>寫好 docker-compose.yml，執行 &lt;code>sudo docker-compose up -d&lt;/code>，Docker Compose 依序帶起 weknadb、wekan 兩個容器，Wekan 看板已在 Host OS 80 Port 運行成功。&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52564919984_4f7956db54_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>最後補充一點，前面提到 Docker Compose 會為整組 Container 建立專屬 Bridge，上圖一開始的 Create network &amp;ldquo;wekan_default&amp;rdquo; with the default driver 訊息就是證明。&lt;/p>
&lt;p>執行 docker network ls，可看到 wekan_default 是個 bridge，執行 docker inspect wekan_default 則可進一步看到這個網段為 172.18.&lt;em>.&lt;/em>，而兩個 Container 的 IP 分別為 172.28.0.3 及 172.28.0.2。&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52564641066_0975c2159e_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>Docker Compose 非常適合用來組裝 Web、DB 等多個 Container 構建系統，但我發現針對 Nginx 時有些額外考量，這部分留待下集分解。&lt;/p>
&lt;hr></description></item><item><title>ASP.NET Core Docker 筆記 1 - 初探</title><link>https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/</guid><description>&lt;img src="https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png" alt="Featured image of post ASP.NET Core Docker 筆記 1 - 初探" />&lt;style>
.article-content p code {
background-color: #f5f5f5;
color: #ff3860;
}
.focus {
background: #f1e2e2;
color: #d62c2c;
padding: 0 5px;
}
&lt;/style>
&lt;p>&lt;a class="link" href="https://blog.miniasp.com/post/2018/08/25/How-to-deploy-ASPNET-Core-to-Docker-Container.aspx" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.darkthread.net/blog/aspnetcore-docker-notes1/" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;/p>
&lt;p>前面研究過&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-nginx-install-on-centos/" target="_blank" rel="noopener"
>在 CentOS 安裝及設定 ASP.NET Core + Nginx&lt;/a>，習得徒手在 CentOS 安裝部署伺服器的技能，依循 Roadmap 來到下一階段 - 學習使用 Docker 簡化部署。&lt;/p>
&lt;p>容器化及 Docker 這幾年熱到發燙，有些人甚至認為它已在軟體產業掀起一波革命。(我親身體驗的感想也是：Wow! 難怪會爆紅) 此刻才起步已算遲了，但也不是沒有好處，晚起鳥兒有更多蟲可以吃，Docker 相關的文章資源多如牛毛，這裡便不多花篇幅贅述觀念與基本操作，只簡單整理我對 Docker 的理解。&lt;/p>
&lt;h2 id="docker-相關介紹">Docker 相關介紹&lt;/h2>
&lt;h3 id="container">Container&lt;/h3>
&lt;p>Container (容器)可以想成極度輕量化的虛擬機器(Virtual Machine)，用法及優點與 VM 相同，能在一台 Host OS 同時運行多個彼此隔離的應用程式環境，但差別在 Container 會共用底層 Host OS，相較 VM 需各跑一份 Guest OS 能省下可觀的記憶體、磁碟，因此 Container 多了啟動速度快，耗用資源少(與直接跑應用程式相去不遠)的優勢。&lt;/p>
&lt;p>一台 4GB RAM 的機器頂多跑 2 - 3 台 VM 就緊繃了，但執行數十上百個 Container 不是問題。&lt;/p>
&lt;p>2 Container 跟 VM 一樣具有很好的隔離效果，每個 Container 有自己的獨立作業環境(記憶體、磁碟空間、網路)，不會彼此干擾，不必擔心 Container A 改系統設定害 Container B 跑不起來，或是兩個 Container 互相搶奪 80 Port，拿到 Image 就一定能在自己的機器跑起來。&lt;/p>
&lt;p>Container 在這方面的特性與 VM 完全相同，但因為不用包入作業系統，體積縮小許多，耗用記憶體也少，但便利性完全不減，取得 Container Image，靠一行指令幾秒內就能在機器把程式跑起來。&lt;/p>
&lt;h3 id="docker-hub">Docker Hub&lt;/h3>
&lt;p>&lt;a class="link" href="https://hub.docker.com/" target="_blank" rel="noopener"
>Docker Hub&lt;/a> 上有超過 10 萬個 Container Image，從 PHP、Node,js、Apache、MySQL、Mongo DB、Nginx、Redis、ASP.NET Core&amp;hellip; 幾乎想得到的都有，下指令自動下載 Image，幾秒鐘就裝好一台 DB、Web 伺服器，再下個指令又裝好第二台，不用擔心跟作業系統不相容、與其他軟體相衝、系統環境有誤導致安裝失敗，這就是 Docker 最迷人的所在。&lt;/p>
&lt;p>而我們也可將自己的專案網站做成 Image，交給測試人員測試，交付 OP 幾秒部署上線，也能將做好的 Image 上傳到 Docker Hub 與全世界分享。&lt;/p>
&lt;h3 id="docker-container">Docker Container&lt;/h3>
&lt;p>Docker Container 起初是基於 Linux Container 技術，故在 Container 只能跑 Linux 平台應用程式，雖然在 Windows 也有 &lt;a class="link" href="https://blog.miniasp.com/post/2016/08/01/Docker-for-Windows-1-12-Released.aspx" target="_blank" rel="noopener"
>Docker for Windows&lt;/a>，但背後是用 Hyper-V 跑 Linux 虛擬機執行 Docker Engine 再跑 Docker Container。&lt;/p>
&lt;p>後來微軟也依循相同概念發展出 Windows Container，並融入 Docker 體系，自此 Docker Container 開始有 Linux Container、Windows Container 之分，Windows Container 裡跑的就是不折不扣的 Windows 程式。&lt;/p>
&lt;p>參考：&lt;a class="link" href="http://www.weithenn.org/2017/02/docker-install-ws2016.html" target="_blank" rel="noopener"
>安裝 Docker 容器環境 - Windows Server 2016&lt;/a>&lt;/p>
&lt;p>從此，&lt;a class="link" href="https://blog.gss.com.tw/index.php/2017/01/16/docker_for_windows_asp_net_webforms/" target="_blank" rel="noopener"
>在 Container 裡跑 ASP.NET WebForm&lt;/a>不再是夢。&lt;/p>
&lt;h3 id="windows-container">Windows Container&lt;/h3>
&lt;p>Windows Container 問市後，ASP.NET Core 程式容器化有 Linux Container 與 Windows Container 兩種選擇。&lt;/p>
&lt;p>基於 Linux Container 資源數量上的優勢，加上耗用資源較少，軟硬體成本低，我選擇 Linux Container。&lt;/p>
&lt;p>雖然 Container 間共用底層作業系統，Docker Engine 為容器中的應用程式提供隔離不受干擾的空間（記憶體、檔案系統、網路 Port）。&lt;/p>
&lt;p>例如：容器 A 寫入 /etc/aaa/default.conf 不影響容器 B /etc/aaa/default.conf 的內容、容器 A 與容器 B 都繫結到 80 Port 也不會衝突。&lt;/p>
&lt;p>&lt;a class="link" href="https://wayneblog.ga/2014-10-28/docker-10-qa/" target="_blank" rel="noopener"
>先前文章&lt;/a>提過將 Kestrel 轉為 Linux 服務、設定 www-data 執行權限&amp;hellip; 等步驟，改用 Docker 後簡單很多，生命週期由 Docker 控制，在容器內部權限一律為 root 不需額外規劃權限，直接跑 dotnet WebApp.dll 聽 5000 Port 就好。&lt;/p>
&lt;p>參考資料：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.ithome.com.tw/news/91847" target="_blank" rel="noopener"
>10個Q&amp;amp;A快速認識Docker&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://philipzheng.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="noopener"
>《Docker —— 從入門到實踐­》正體中文版&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener"
>Docker 入门教程 by 阮一峰&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="練習">練習&lt;/h2>
&lt;p>Docker 安裝與基本操作的參考資料很多，這裡不多介紹，直接來幾個練習暖身：在 CentOS 上用 Docker 下載現成 Conatiner Image 執行 Nginx 伺服器，再用預設專案範本建立 ASP.NET Core 網站並包進 Container 執行。最後將二者串接在一起，使用 Nginx 做為 ASP.NET Core 網站的 Reverse Proxy。&lt;/p>
&lt;h3 id="執行-nginx-container">執行 Nginx Container&lt;/h3>
&lt;p>執行 Nginx Container&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker run --name mynginx -d -p 80:80 --rm nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不誇張，真的只要這行 Nginx 就好了。&lt;/p>
&lt;ul>
&lt;li>&lt;code>-d&lt;/code>：把 Container 丟到背景執行不要佔用命令列視窗&lt;/li>
&lt;li>&lt;code>-p 80:80&lt;/code>：表示將 Container 的 80 Port 對應到 Host OS 的 80 Port&lt;/li>
&lt;li>&lt;code>--rm&lt;/code>：表示 Container 停止時自動刪除。&lt;/li>
&lt;/ul>
&lt;p>開個 Chrome 連上 Host OS 的 80 Port，Nginx 已經準備就緒！&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52565024765_48a069238f_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>註：docker 指令需繫結 Unix Socket，必須以 SuperUser 權限執行，將使用者加入 Docker 群組可省去每次加 sudo 的麻煩。參考：&lt;a class="link" href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener"
>Manage Docker as a non-root user&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo groupadd docker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo usermod -aG docker &lt;span class="nv">$USER&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但這招在 &lt;a class="link" href="https://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/" target="_blank" rel="noopener"
>CentOS/Fedora/RHEL 不管用!&lt;/a>，但有替代方案：在 &lt;code>/etc/sudoers&lt;/code> 加入 &lt;code>yourUserAccount ALL=(ALL) NOPASSWD: /usr/bin/docker&lt;/code> 開放 sudo docker 時不用敲密碼，再用 &lt;code>alias docker=&amp;quot;sudo /usr/bin/docker&amp;quot;&lt;/code> 建立同義詞，也可做到不必 sudo 敲密碼跑 docker 指令。&lt;/p>
&lt;h3 id="將-aspnet-core-專案包進-container">將 ASP.NET Core 專案包進 Container&lt;/h3>
&lt;p>將 ASP.NET Core 專案包進 Container 使用 .NET Core CLI 建立 MVC 專案，修改 Startup.cs 取消 app.UseHttpsRedirection()，以 Kestrel 執行 ASP.NET Core 網站。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">dotnet new mvc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sed -i -e &lt;span class="s1">&amp;#39;s/app.UseHttps/\/\/app.UseHttps/&amp;#39;&lt;/span> Startup.cs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dotnet publish
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">dotnet bin/Debug/netcoreapp2.1/web.dll
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由於 5000 Port 預設不對外開放，懶得開防火牆，在本機用 &lt;code>curl httq://localhost:5000&lt;/code> 驗證網站運行中。&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52565101738_65791a45d2_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>驗證程式可執行後，寫個 Dockerfile 腳本將程式封裝成 Docker Image，這部分細節可參考保哥的文章：&lt;a class="link" href="https://blog.miniasp.com/post/2018/08/25/How-to-deploy-ASPNET-Core-to-Docker-Container.aspx" target="_blank" rel="noopener"
>如何將 ASP.NET Core 2.1 網站部署到 Docker 容器中&lt;/a>。&lt;/p>
&lt;p>在實務環境可以設計成全自動化測試流程，到版控抓原始碼放進內含 .NET Core SDK 的 Container 編譯，將結果包成只有 .NET Core Runtime 的 Container Image，用它建立 Container 進行 E2E 測試，一切自動化。這裡為求簡便，我選擇用只有 Runtime 的 Container Image 當成基底，將在 Host OS 編譯好的檔案複製到 Container /app 目錄，Dockerfile 內容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> microsoft/dotnet:2.1-aspnetcore-runtime&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /app&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> ./bin/Debug/netcoreapp2.1 ./&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENTRYPOINT&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;dotnet&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;web.dll&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>做好 Dockerfile 後執行 &lt;code>docker build&lt;/code>，Docker 會從 Docker Hub 下載 &lt;strong>microsoft/dotnet:2.1-aspnetcore-runtime&lt;/strong> (microsoft/dotnet 是 Image 名稱，同一 Image 常有多種版本可選擇，:2.1-aspnetcore-runtime 是標籤可用來指定版本)，&lt;code>-t&lt;/code> 參數指定 Image 名稱為 testapp。&lt;/p>
&lt;p>Container Image 做好後接著用 &lt;code>docker run -d --rm --name myapp -p 5000:80 testapp&lt;/code> 用剛做好的 Image 建立 Container，ASP.NET Core 專案在 Container 執行時，預設聽 80 Port，故我們用 -p 5000:80 將 Container 的 80 Port 導向 Host OS 的 5000 Port。用 curl 驗證網站運行中。&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52564572251_d6b523fb3e_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>使用 docker images 及 docker ps 我們可以看到剛才建立的 Image testapp 及 Container myapp：&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52564111477_5a5d7b7acf_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;h3 id="將-nginx-設成-aspnet-core-網站的-reverse-proxy">將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy&lt;/h3>
&lt;p>至此，我們做了兩個 Container，myginx 聽 Host OS 80 Port，myapp 聽 Host OS 的 5000 Port，下一步要將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy。&lt;/p>
&lt;p>做法跟&lt;a class="link" href="https://wayneblog.ga/2022-12-06/dotnet-nginx-install-on-centos/" target="_blank" rel="noopener"
>先前文章&lt;/a>介紹過的概念差不多，為求簡便我們直接修改 &lt;strong>conf.d/default.conf&lt;/strong> 將進入 80 Port 的請求導向 5000 Port。(正規做法建議一個網站開一個 conf 檔) Container 的檔案系統是隔離的，將設定檔保存在 Container 裡不是好主意 - 除非每次修改設定存檔就重新產生 Image 並要求未來一律改用新版 Image 建立 Container，否則一旦 Conatiner 被刪除，設定就會消失。同樣問題也會發生在資料庫檔、Log 檔等執行期間要動態更新的內容，這類檔案保存在 Host OS 檔案系統上比較合理，程式換版換了 Container Image 資料才不受影響。Docker 靠 Volume 解決資料保存及共用需求，docker run 有個 -v host-path:container-path 可將 Host OS 特定目錄或檔案對映到 Container，讓 Container 能讀寫 Host OS 的檔案。&lt;/p>
&lt;p>對 Nginx Container 來說，Reverse Proxy 設定放在 &lt;strong>/etc/nginx/conf.d&lt;/strong>，我選擇在 Host OS 也建立相同路徑並將 Container 的 default.conf 複製出來(指令如下)，修改後在 docker run 加上 &lt;strong>-v /etc/nginx/conf.d:/etc/nginx/conf.d&lt;/strong> 對映回去：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker cp mynginx:/etc/nginx/conf.d /etc/nginx/conf.d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://live.staticflickr.com/65535/52564111512_3656ea3919_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>修改 &lt;strong>/etc/nginx/conf.d/default.conf&lt;/strong>，目前是將進入 Nginx 80 Port 的請求導向 Host OS 5000 Port，但從 Docker Container 存取 Host OS IP 有些眉角，Mac 或 Windows Docker 18.3+ 可用 DNS 名稱 host.docker.internal 指向 Host OS IP，但 Docker for Linux 18.4+ 這招己失效。&lt;a class="link" href="https://stackoverflow.com/a/24326540/288936" target="_blank" rel="noopener"
>參考&lt;/a>&lt;/p>
&lt;p>省事做法是 docker run 時用 &lt;code>--network host&lt;/code> 讓 Container 直接繫結本機 IP 而非 Docker 所屬的隔離網段，如此 default.conf 的 proxy_pass 指向 localhost:5000 即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nginx" data-lang="nginx">&lt;span class="line">&lt;span class="cl">&lt;span class="k">server&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">listen&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">server_name&lt;/span> &lt;span class="s">localhost&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#charset koi8-r;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">#access_log /var/log/nginx/host.access.log main;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">location&lt;/span> &lt;span class="s">/&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_pass&lt;/span> &lt;span class="s">http://localhost:5000&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_http_version&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="s">.1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Upgrade&lt;/span> &lt;span class="nv">$http_upgrade&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Connection&lt;/span> &lt;span class="s">keep-alive&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">Host&lt;/span> &lt;span class="nv">$host&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_cache_bypass&lt;/span> &lt;span class="nv">$http_upgrade&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-For&lt;/span> &lt;span class="nv">$proxy_add_x_forwarded_for&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">proxy_set_header&lt;/span> &lt;span class="s">X-Forwarded-Proto&lt;/span> &lt;span class="nv">$scheme&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>完整啟動指令如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker run --name mynginx -d -v /etc/nginx/conf.d:/etc/nginx/conf.d --network host nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>從遠端開啟 Chrome 連上 Host OS 的 80 Port，我們已被順利導向 ASP.NET Core 網站，顯示設定成功。&lt;/p>
&lt;p>&lt;img src="https://live.staticflickr.com/65535/52565024725_966ab6577d_o.png"
max-width="100%"
max-height="100%"
class="gallery-image"
>&lt;/p>
&lt;p>經過以上練習，我們體驗了從 Docker Hub 下載 Image 建立 Docker Containter 跑 Nginx、用 Dockerfile 將 ASP.NET Core 網站包成 Container、用 Port 映對 Host OS TCP Port 到 Container、使用 -v(&amp;ndash;volume) 映對資料夾讓 Container 讀寫 Host OS 檔案。&lt;/p>
&lt;p>而在實務應用上，相關的 Conatiner 需要組合在一起執行，例如一個 Container 跑網站，一個 Container 跑資料庫，此時可用 docker-compose 簡化管理；另外 Docker 也提供 Bridge 為相關 Container 建立專屬的隔離網段，防止外界接觸到不想對外公開的網路服務，也避免不相干的 Container 彼此干擾&amp;hellip; 這些議題就留待下一篇文章討論。&lt;/p>
&lt;hr></description></item><item><title>10 個 Q&amp;A 快速認識 Docker</title><link>https://wayneblog.ga/2014-10-28/docker-10-qa/</link><pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate><guid>https://wayneblog.ga/2014-10-28/docker-10-qa/</guid><description>&lt;img src="https://live.staticflickr.com/65535/52564831824_2754e80d0b_o.png" alt="Featured image of post 10 個 Q&amp;A 快速認識 Docker" />&lt;style>
.article-content p code {
background-color: #f5f5f5;
color: #ff3860;
}
.focus {
background: #f1e2e2;
color: #d62c2c;
padding: 0 5px;
}
&lt;/style>
&lt;p>&lt;a class="link" href="https://www.ithome.com.tw/news/91847" target="_blank" rel="noopener"
>參考網站&lt;/a>&lt;/p>
&lt;p>不論是 Google、Amazon、微軟、VMware 都紛紛擁戴，加入 Docker 和 Container 所掀起的新世代雲端虛擬化行列，這 2 項技術成為了 IT 界的新顯學。Docker 和 Container 到底是什麼？以下 10 個 Q&amp;amp;A 告訴你。&lt;/p>
&lt;p>&lt;strong>Q1：Container 技術和伺服器虛擬化是一樣的技術嗎？&lt;/strong>&lt;/p>
&lt;p>**A：**不是。兩者雖然都屬於虛擬化的技術，目標都是為了將一套應用程式所需的執行環境打包起來，建立一個孤立環境，方便在不同的硬體中移動，但兩者的運作思維截然不同。簡單來說，常見的傳統虛擬化技術如 vSphere 或 Hyper-V 是以作業系統為中心，而 Container 技術則是一種以應用程式為中心的虛擬化技術。&lt;/p>
&lt;p>傳統虛擬化技術從作業系統層下手，目標是建立一個可以用來執行整套作業系統的沙箱獨立執行環境，習慣以虛擬機器(Virtual Machine)來稱呼。而 Container 技術則是直接將一個應用程式所需的相關程式碼、函式庫、環境配置檔都打包起來建立沙箱執行環境，為了和傳統虛擬化技術產生的虛擬機器區分，Container 技術產生的環境就稱為 Container。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q2：一般常見的虛擬機器和 Container 有何不同？&lt;/strong>&lt;/p>
&lt;p>**A：**最明顯的差別是，虛擬機器需要安裝作業系統(安裝 Guest OS)才能執行應用程式，而 Container 內不需要安裝作業系統就能執行應用程式。Container 技術不是在 OS 外來建立虛擬環境，而是在 OS 內的核心系統層來打造虛擬執行環境，透過共用 Host OS 的作法，取代一個一個 Guest OS 的功用。Container 也因此被稱為是 OS 層的虛擬化技術。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q3：為何 Container 是輕量級虛擬化技術？&lt;/strong>&lt;/p>
&lt;p>**A：**因為 Container 技術採取共用 Host OS 的作法，而不需在每一個 Container 內執行 Guest OS，因此建立 Container 不需要等待作業系統開機時間，不用 1 分鐘或幾秒鐘就可以啟用，遠比需要數分鐘甚至數十分鐘才能開啟的傳統虛擬機器來的快。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q4：Container 技術是全新的技術嗎？&lt;/strong>&lt;/p>
&lt;p>**A：**不是，早在 1982 年，Unix 系統內建的 chroot 機制也是一種 Container 技術。其他如 1998 年的 FreeBSD jails、2005 年出現的 Solaris Zones 和 OpenVZ，或像是 Windows 系統 2004 年就有的 Sandboxie 機制都屬於在作業系統內建立孤立虛擬執行環境的作法，都可稱為是 Container 的技術。&lt;/p>
&lt;p>直到 2013 年，dotCloud 這家 PaaS 服務公司開源釋出了一套將 Container 標準化的平臺 Docker，大受歡迎，所以，dotCloud 決定以 Docker 為名成立新公司力推。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q5：Docker 如何實現 Container 標準化？&lt;/strong>&lt;/p>
&lt;p>**A：**Docker 採用了 aufs 檔案系統來設計一個可以層層堆疊的 Container 映象檔，將 Container 內的所有程式(包括應用程式、相關函式庫、設定檔)，都打包進 Docker 映象檔，並且提供了一個 Dockerfile 設定檔來記錄建立 Container 過程的每一個步驟包括參數。只要在任何支援 Docker 平臺的環境中，就可以從這個映象檔來建立出一個一模一樣的 Container 來執行同一個應用程式。如此一來，應用程式等於是可以透過 Docker 映象檔，或甚至只需要 Dockerfile，就能將程式執行環境帶著走，移動到任何支援 Docker 的環境中。Docker 公司也釋出 API，可以用來控制所有的 Container 相關指令，任何人只要使用同一套 Docker，就等於有了同一套管理和建立 Container 的方法，也就等同於將 Container 運用標準化了。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q6：一個 Container 映象檔內可以安裝多少應用程式？&lt;/strong>&lt;/p>
&lt;p>**A：**一個 Container 的映象檔內可以安裝多支程式，例如同時安裝 Ubuntu、Apache、MySQL、Node.js、Ruby 等。不過，Docker 官方建議，一隻程式安裝在一個 Container 內，再把這些 Container 疊起來提供一個完整的服務。&lt;/p>
&lt;p>Docker 稱這是一種 Microservices(微服務)的新軟體架構，將組成一個應用系統的每一個 Stack，拆解成許多小型服務，例如 Apache 服務、MySQL 服務、Node.js 服務、Ruby 服務，每一個服務都是包在 Container 裡的一隻程式，例如 MySQL 服務就是部署在 Container 內的 MySQL。&lt;/p>
&lt;p>這麼做的好處是可以建立一個鬆散耦合的彈性應用程式架構，也能輕易地抽換其中一個 Container，例如要升級 MySQL，只需要重新載入新版 MySQL 的 Container 映象檔，就可以完成資料庫升級，不用將整套應用系統停機。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q7：Container 內不是不需要 OS，為何需要 OS 的基礎映象檔？&lt;/strong>&lt;/p>
&lt;p>**A：**OS 基礎映象檔的用途是讓 Container 擁有這 OS 的檔案系統，例如使用 ubuntu 基礎映象檔就可以讓 Container 建立 ubuntu 的根目錄架構，而不是用來執行一個 OS 執行實例。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q8：Docker 對 Devops 有何幫助？&lt;/strong>&lt;/p>
&lt;p>**A：**因為 Docker 透過 Dockerfile 來記錄建立 Container 映象檔的每一個步驟，可以將建立應用程式執行環境的過程和配置參數，完整地記錄下來。開發人員和維運人員之間可以利用 Dockerfile 來溝通對執行環境的討論。甚至結合版本控制服務如 GitHub，可以讓 Dockerfile 具備版本控制功能，能將基礎架構程式化(Infrastructure as code)來管理。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q9：可以在 Windows Server 環境中執行 Docker 嗎？&lt;/strong>&lt;/p>
&lt;p>**A：**還不行。目前 Docker 只能在 Linux 平臺上執行，但是微軟 10 月中剛宣布要在下一波 Windows Server 改版時內建 Docker 引擎，未來同一份 Docker 映象檔能否跨 Linux 和 Windows OS，還需待微軟揭露更多細節才能得知。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Q10：在臺灣，如何找到懂 Docker 技術的人？&lt;/strong>&lt;/p>
&lt;p>**A：**目前 Docker 公司還未在臺設點，但有一個 Docker Taipei 社群，成員截至 10 月有 383 人。&lt;/p>
&lt;p>Docker Taipei 也預計配合 Docker 總公司舉辦的全球 HackDay 活動，在 11 月 1 日舉辦臺北場 HackDay。參加作品將直接發布到美國和全球 Docker 開發者一起評比，獎品是明年到美國參加 Docker 技術大會的資格。&lt;/p>
&lt;hr></description></item></channel></rss>