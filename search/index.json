[{"content":" 本文適合 Vue3 初學者，或者 Vue2 遷移者，當然還是建議 Vue3 官網完全過一遍。\n先推薦兩個 vscode 外掛 Volar 首先推薦 Volar ，使用 vscode 開發 Vue 專案的小夥伴肯定都認識 Vetur 這個神級外掛，有了它可以讓我們得開發如魚得水。 那麼 Volar 可以理解為 Vue3 版本的 Vetur ，程式碼高亮，語法提示，基本上 Vetur 有的它都有。\n功能一：多個根節點編譯器不會報錯 Vue3 是允許我們有多個根節點的，但是我們如果使用 Vetur 就會報錯，不會影響執行，但是看起來就很煩。所以當我們轉向 Volar，那麼就不會出現這個問題了。\n功能二：編輯器分隔 即便 Vue 的元件化開發，可以將單檔案的程式碼長度大幅縮短，但還是動輒幾百行甚是上千行。那麼我們切換 template、script、style 的時候就要頻繁上下翻，雖然有的外掛可以直接定位到 css，但是你回不去啊！所以這個功能簡直是太人性化了。\n安裝完 Volar 以後，開啟一個 .vue 檔案，看 vscode 的右上角，有這麼一個圖示，點一下。\n它就會自動給你分隔成三個頁面，分別對應 template、script、style，這樣就太舒服了有沒有。\n還有很多新功能，可以參考下面這篇文章：\nVolar - vue終極開發神器！\n功能三：ref sugar 語法快捷改動支持 ref sugar 是一個還在 rfc 階段的功能，但是已經持續很久了，現在的 vue3 版本已經可以嚐鮮使用了。具體的用法以及語法我就不展開贅述了，我主要說一下 Volar 和 ref sugar 的結合。\n報錯先不管，是 eslint-plugin-vue 的原因。\n可以看到，在使用了 ref sugar 之後，script 上面出現了一個 ref sugar 的小圖標，並且打了個對勾，那麼我們點一下那個對勾，看看會發生什麼。\n可以看到，我們點擊這個小對勾之後，它由原本的 ref sugar 語法變為了普通的 script setup 模式，驚不驚喜，意不意外。\n功能四：style 裡面的 class 引用 可以看到，在 .foo 這個類名上面，出現了一個 1 reference 的小圖標，代表著當前 class 有一次引用，我們點擊一下這個 1 reference。\n出現了一個彈窗，裡面是當前 class 的具體使用位置。\n功能五：class 追朔 我們創建一個 template 根元素，在裡面寫入：\nsample.vue 1 2 3 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 style 中寫入：\nsample.vue 1 2 3 \u0026lt;style scoped\u0026gt; .foo {} \u0026lt;/style\u0026gt; 除了 style 中的 .foo 上面會出現 1 reference 的小圖標之外，在 class=\u0026quot;foo\u0026quot; 的 foo 下面，會出現一道橫線。\n對於經常使用 vscode 的開發人員來說，這代表什麼意義就不必多說了，我們根據提示，按住 ctrl(command) 然後點擊，會發現光標自己移動到了 style 中的 .foo 之前，哇! awesome!\n功能六：css module 類型提示 css module 一般是 react 技術棧用的會比較多一些，就我個人來說，是從沒在 vue 裡面使用它的，因為 vue 提供了 scoped 作用域，不用擔心樣式衝突，直接使用預處理器會更加簡單方便。\n我們創建如下代碼：\nsample.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$style.foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style module\u0026gt; .foo { } \u0026lt;/style\u0026gt; 然後將鼠標移動到 $style 上\n有點意思，看來 vscode 是讓 Volar 玩明白了。\n功能七：lang 語法提示 vue 可以使用 lang 屬性來選擇使用的語言，比如 template 中的 html/pug、script 中的 ts、style 中的 scss 等。\n但是在以前，我們都是手動輸入的，編輯器，或者說 Vetur 並沒有給我們提供任何提示，有可能你找了很久的莫名其妙的問題，就是因為 lang 寫錯了。\n但是這一切，在有了 Volar 之後，都不同了。\n功能八：template 語法轉換 vue 默認提供了兩種模板供我們使用，但是一般都會使用 html，另外一種叫做 pug。\n相對於 html，pug 更偏向於 yml 那種，簡潔程度特別高。\n在 Volar 中，為我們提供了 html 和 pug 互相轉換的功能。\nsample.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;img /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在我們書寫 template 之後，template 頂部會出現一個小小的 pug 圖標，我們可以看到此時它是沒有被選中的。\n這個時候我們點擊一下這個圖標，讓它選中，神奇的事情發生了。\n我們寫好的 html 模板，被自動轉化成了 pug，再點擊一下，又回到了我們熟悉的 html。\n從功能三開始，基本都是算內測的新功能，我是機緣巧合之下，將 Volar 下到本地進行查看的時候發現的這些。想嚐鮮的可以自己下載源碼，然後在packages/vscode-vue-languageservice/testCases目錄下體驗，希望這些功能可以盡快發布！\nVue 3 Snippets 推薦的第二個外掛叫做 Vue 3 Snippets ，同樣的，他也有自己的 Vue2 版本。它是幹什麼的呢，可以看一下下面這張圖，我只輸入了 \u0026quot;v3\u0026quot; ，它有很多提示，我們就先選擇 v3computed ，選中 Enter 即可。\n然後它就給我們自動寫了如下程式碼：\n是不是超級省事，摸魚的時間又增加了！還有更多有趣的使用方式，小夥伴們自行探索吧。\n建立 Vue3 專案 那麼正式開始學習我們的 Vue3 ，先從建立專案開始。\n使用 vue-cli 建立 輸入下面的命令然後選擇配置項進行安裝即可，這裡注意 vue-cli 的版本一定要在 ==4.5.0== 以上。\n1 2 3 4 5 6 7 8 ### 安裝或者升級 npm install -g @vue/cli ### 檢視版本 保證 vue cli 版本在 4.5.0 以上 vue --version ### 建立專案 vue create my-project ### 然後根據提示一步一步傻瓜式操作就行了 ### ... 使用 Vite 建立 都說 Vue3.0 和 Vite2 更配，各種優化各種快，但都不屬於本文的內容，本文的目的我們只需要知道它特別好用、怎麼用就行了。我這裡是多選擇了 TS，每行都有註釋，一目瞭然。\n1 2 3 4 5 6 7 8 ### 初始化 viete 專案 npm init vite-app \u0026lt;project-name\u0026gt; ### 進入專案資料夾 cd \u0026lt;project-name\u0026gt; ### 安裝依賴 npm install ### 啟動專案 npm run dev 建立完以後我們先來看看入口檔案 main.ts\nmain.ts 1 2 3 4 5 6 // 引入 createApp 函式，建立對應的應用，產生應用的例項物件 import { createApp } from \u0026#39;vue\u0026#39;; // 引入 app 元件 (所有元件的父級元件) import App from \u0026#39;./App.vue\u0026#39;; // 建立 app 應用返回對應的例項物件，呼叫 mount 方法進行掛載，掛載到 #app 節點上去 createApp(App).mount(\u0026#39;#app\u0026#39;); 然後看看根元件 app.vue\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- Vue2 元件中的 html 模板中必須要有一對根標籤，Vue3 元件的 html 模板中可以沒有根標籤 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;!-- 使用子級元件 --\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js + TypeScript App\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // 這裡可以書寫 TS 程式碼 // defineComponent 函式，目的是定義一個元件，內部可以傳入一個配置物件 import { defineComponent } from \u0026#39;vue\u0026#39;; // 引入子級元件 import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; // 暴露出去一個定義好的元件 export default defineComponent({ // 當前元件的名字 name: \u0026#39;App\u0026#39;, // 註冊元件 components: { // 註冊一個子級元件 HelloWorld, }, }); \u0026lt;/script\u0026gt; Composition API 接下來到了重頭戲，Vue3 的招牌特性，Composition API。\n關於 Composition API 這裡有圖解演示，極力推薦。\n圖解 Option API vs Composition API\nComposition API 可以更方便的抽取共通邏輯，但是不要過於在意邏輯程式碼複用，以功能提取程式碼也是一種思路。 順便提一句，Vue3 相容大部分 Vue2 語法，所以在 Vue3 中書寫 Vue2 語法是沒有問題的（廢除的除外），但是既然我們已經升級 Vue3 了，不建議混合使用，除非一些大型特殊專案需要相容兩個版本。\n生命週期鉤子 setup setup 是組合 Composition API 中的入口函式，也是第一個要使用的函式。 setup 只在初始化時執行一次，所有的 Composition API 函式都在此使用。 1 2 3 setup() { console.log(\u0026#39;我執行了\u0026#39;) // 我執行了 }, 可以通過 console.log 看到 setup 是在 beforeCreate 生命週期之前執行的(只執行一次)：\n1 2 3 4 5 6 7 8 9 beforeCreate() { console.log(\u0026#39;beforeCreate執行了\u0026#39;); }, setup() { console.log(\u0026#39;setup執行了\u0026#39;); return {}; }, // setup執行了 // beforeCreate執行了 由此可以推斷出 setup 執行的時候，元件物件還沒有建立，元件實例物件 this 還不可用，此時 this 是 undefined，不能通過 this 來訪問 data、computed、methods、props。 返回物件中的^1.^屬性會與 data 函式返回物件的屬性合併成為元件物件的屬性；^2.^返回物件中的方法會與 methods 中的方法合併成功元件物件的方法。 如果有重名，setup 優先。因為在 setup 中 this 不可用，methods 中可以訪問 setup 提供的屬性和方法，但在 setup 方法中不能訪問 data 和 methods 裡的內容，所以還是不建議混合使用。 setup 函式如果返回物件，物件中的屬性或方法，template 中可以直接使用。 sample.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{number}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const number = 18; return { number, }; }, // ... \u0026lt;/script\u0026gt; 注意：setup 不能是一個 async 函式，因為返回值不再是 return 的物件，而是 promise，template 中就不可以使用 return 中返回物件的資料了。\nsetup 的參數(^1.^props, ^2.^context)：\nprops：是一個物件，裡面有父級元件向子級元件傳遞的資料，並且是在子級元件中使用 props 接收到的所有的屬性。 context：上下文物件，可以通過 es6 語法解構 setup(props, {^(a).^attrs, ^(b).^slots, ^(c).^emit})\n\u0026gt; a). attrs：獲取當前元件標籤上所有沒有通過 props 接收的屬性的物件，相當於 this.$attrs。\n\u0026gt; b). slots：包含所有傳入的插槽內容的物件，相當於 this.$slots。\n\u0026gt; c). emit：用來分發自定義事件的函式，相當於 this.$emit。 演示 attrs 和 props： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;child :msg=\u0026#34;msg\u0026#34; msg2=\u0026#39;哈哈哈\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, ref } from \u0026#39;vue\u0026#39;; // 引入子元件 import Child from \u0026#39;./components/Child.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { Child, }, setup() { const msg = ref(\u0026#39;hello,vue3\u0026#39;); return { msg, }; }, }); \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;msg:{{ msg }}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, props: [\u0026#39;msg\u0026#39;], setup(props, {attrs, slots, emit}) { console.log(\u0026#39;props:\u0026#39;, props); // msg: \u0026#34;hello,vue3\u0026#34; console.log(\u0026#39;attrs:\u0026#39;, attrs); // msg2: \u0026#34;哈哈哈\u0026#34; return {}; }, }); \u0026lt;/script\u0026gt; 演示 emit： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;child @click=\u0026#34;show\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; setup() { const show = () =\u0026gt; { console.log(\u0026#39;name:\u0026#39;, \u0026#39;hzw\u0026#39;); }; return { show, }; }, \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;button\u0026gt;事件分發\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, setup(props, { emit }) { const emitFn = () =\u0026gt; { emit(\u0026#39;show\u0026#39;); }; return { emitFn, }; }, }); \u0026lt;/script\u0026gt; ref 作用：定義一個響應式的資料(一般用來定義一個基本型別的響應式資料 Undefined、Null、Boolean、Number、String) 語法： 1 const xxx = ref(initValue); 注意：script 中操作資料需要使用 xxx.value 的形式，而 template 中不需要新增 .value 用一個例子來演示，實現一個按鈕，點選可以增加數字：\naddNum.vue 1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{count}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;updateCount\u0026#39;\u0026gt;增加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在 Vue2 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // ... data() { return { conunt: 0, }; }, methods: { updateCount() { this.conunt++; }, }, // ... \u0026lt;/script\u0026gt; 在 Vue3 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; // ... setup() { // ref 用於定義一個響應式的資料，返回的是一個 Ref 物件，物件中有一個 value 屬性 // 如果需要對資料進行操作，需要使用該 Ref 物件的 value 屬性 const count = ref(0); function updateCount() { count.value++; } return { count, updateCount }; }, // ... \u0026lt;/script\u0026gt; 在 Vue2 中我們通過 this.$refs 來獲取 dom 節點，Vue3 中我們通過 ref 來獲取節點。\n首先需要在標籤上新增 ref='xxx'，然後再 setup 中定義一個初始值為 null 的 ref 型別，名字要和標籤的 ref 屬性一致。\n1 const xxx = ref(null) 注意 ：一定要在 setup 的 return 中返回，不然會報錯。\n用一個例子來演示，讓輸入框自動獲取焦點：\nautoFocus.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;--- \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; /* ref獲取元素: 利用 ref 函式獲取元件中的標籤元素 功能需求: 讓輸入框自動獲取焦點 */ export default { setup() { const inputRef = ref\u0026lt;HTMLElement|null\u0026gt;(null) onMounted(() =\u0026gt; { inputRef.value \u0026amp;\u0026amp; inputRef.value.focus() }) return { inputRef } }, } \u0026lt;/script\u0026gt; reactive 作用：定義多個數據的響應式，接收一個普通物件然後返回該普通物件的響應式代理器物件(Proxy)，響應式轉換是\u0026quot;深層的\u0026quot;：會影響物件內部所有巢狀的屬性，所有的資料都是響應式的。 語法： 1 const proxy = reactive(obj) 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;h3\u0026gt;姓名:{{user.name}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;年齡:{{user.age}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;wife:{{user.wife}}\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;updateUser\u0026#34;\u0026gt;更新\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const user = reactive({ name: \u0026#39;hzw\u0026#39;, age: 18, wife: { name: \u0026#39;xioaohong\u0026#39;, age: 18, books: [\u0026#39;紅寶書\u0026#39;, \u0026#39;設計模式\u0026#39;, \u0026#39;演算法與資料結構\u0026#39;], }, }); const updateUser = () =\u0026gt; { user.name = \u0026#39;小紅\u0026#39;; user.age += 2; user.wife.books[0] = \u0026#39;金瓶梅\u0026#39;; }; return { user, updateUser, }; }, // ... \u0026lt;/script\u0026gt; computed 與 Vue2 中的 computed 配置功能一致，返回的是一個 ref 型別的物件。 computed 的函式中如果只傳入一個箭頭函式 表示的是 get 操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName1 = computed(() =\u0026gt; { return user.firstName + user.lastName; }); return { user, fullName1, }; computed 的函式中可以傳入一個物件，可以包含 set 和 get 函式，進行讀取和修改的操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName2 = computed({ get() { return user.firstName + \u0026#39;_\u0026#39; + user.lastName; }, set(val: string) { const names = val.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }, }); return { user, fullName2, }; watch 與 Vue2 中的 watch 配置功能一致。 作用：監視指定的一個或多個響應式資料，一旦資料變化，就自動執行監視回撥。 語法：watch(要監聽的資料, 回調函式, 配置) 預設初始時不執行回調，但可以通過配置的 immediate 為 true，來指定初始時立即執行第一次。 通過配置的 deep 為 true，來指定深度監視。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { watch, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName3 = ref(\u0026#39;\u0026#39;); watch( user, ({ firstName, lastName }) =\u0026gt; { fullName3.value = firstName + \u0026#39;_\u0026#39; + lastName; }, { immediate: true, deep: true } ); return { user, fullName3, }; watch 監聽多個數據，使用陣列。\nwatch 監聽非響應式資料的時候需要使用回調函式的形式。\n1 2 3 4 5 6 7 8 9 10 watch( [ () =\u0026gt; user.firstName, () =\u0026gt; user.lastName, fullName3 ], () =\u0026gt; { console.log(\u0026#39;我執行了\u0026#39;) } ) watchEffect 作用：監視資料發生變化時執行回調，不用直接指定要監視的資料，回調函式中使用的哪些響應式資料就監視哪些響應式資料，預設初始時就會執行第一次，從而可以收集需要監視的資料。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { watchEffect, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName4 = ref(\u0026#39;\u0026#39;); watchEffect(() =\u0026gt; { fullName4.value = user.firstName + \u0026#39;_\u0026#39; + user.lastName; }); return { user, fullName4, }; // watchEffect可以實現計算屬性set方法 watchEffect(() =\u0026gt; { const names = fullName3.value.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }); 生命週期對比：\n注意：3.0 中的生命週期鉤子要比 2.X 中相同生命週期的鉤子要快。 Composition API 還新增了以下用於除錯的鉤子函式，但是不怎麼常用：onRenderTracked、onRenderTriggered。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;--onBeforeMount\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;--onMounted\u0026#39;) }) onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;--onBeforeUpdate\u0026#39;) }) onUpdated(() =\u0026gt; { console.log(\u0026#39;--onUpdated\u0026#39;) }) onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;--onBeforeUnmount\u0026#39;) }) onUnmounted(() =\u0026gt; { console.log(\u0026#39;--onUnmounted\u0026#39;) }) } toRefs 作用：把一個響應式物件轉換成普通物件，該普通物件的每個屬性都是一個 ref。 應用：我們使用 reactive 建立的物件，如果想在模板中使用，就必須得使用 xxx.xxx 的形式，如果大量用到的話還是很麻煩的，但是使用 es6 解構以後，會失去響應式，那麼 toRefs 的作用就體現在這，利用 toRefs 可以將一個響應式 reactive 物件的所有原始屬性轉換為響應式的 ref 屬性。當然小夥伴們可以自行開發更多應用場景。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; name:{{name}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, reactive, toRefs } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const state = reactive({ name: \u0026#39;hzw\u0026#39;, }); const state2 = toRefs(state); setInterval(() =\u0026gt; { state.name += \u0026#39;===\u0026#39;; }, 1000); return { // 通過 toRefs 返回的物件，解構出來的屬性也是響應式的 ...state2, }; }, }); \u0026lt;/script\u0026gt; provide 與 inject 作用：實現跨層級元件(祖孫)間通訊。 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;父元件\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;當前顏色: {{color}}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;red\u0026#39;\u0026#34;\u0026gt;紅\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;yellow\u0026#39;\u0026#34;\u0026gt;黃\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;blue\u0026#39;\u0026#34;\u0026gt;藍\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { provide, ref } from \u0026#39;vue\u0026#39; import Son from \u0026#39;./son.vue\u0026#39; export default { name: \u0026#39;ProvideInject\u0026#39;, components: { Son }, setup() { const color = ref(\u0026#39;red\u0026#39;) provide(\u0026#39;color\u0026#39;, color) return { color } } } \u0026lt;/script\u0026gt; son.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;GrandSon /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import GrandSon from \u0026#39;./grandson.vue\u0026#39; export default { components: { GrandSon }, } \u0026lt;/script\u0026gt; grandson.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h3 :style=\u0026#34;{color}\u0026#34;\u0026gt;孫子元件: {{color}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39; export default { setup() { const color = inject(\u0026#39;color\u0026#39;) return { color } } } \u0026lt;/script\u0026gt; 其他特性 Teleport(瞬移) 作用：Teleport 提供了一種乾淨的方法，讓元件的 html 在父元件介面外的特定標籤(很可能是 body )下插入顯示，換句話說就是可以把子元件或者dom節點插入到任何你想插入到的地方去。 語法：使用 to 屬性，引號內使用選擇器。 1 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/teleport\u0026gt; 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;modal-button\u0026gt;\u0026lt;/modal-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import ModalButton from \u0026#39;./components/ModalButton.vue\u0026#39; export default { setup() { return {} }, components: { ModalButton, }, } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;modalOpen = true\u0026#34;\u0026gt; 點我開啟對話方塊 \u0026lt;/button\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;modalOpen\u0026#34; class=\u0026#34;looklook\u0026#34;\u0026gt; 看看我出現在了哪裡 \u0026lt;button @click=\u0026#34;modalOpen = false\u0026#34;\u0026gt; Close \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;modal-button\u0026#39;, setup() { const modalOpen = ref(false) return { modalOpen, } }, } \u0026lt;/script\u0026gt; 可以看到在子元件中的 looklook 元素跑到了 body 下面，而之前的位置默認出現了兩行註釋。\nSuspense(不確定的) 作用：它們允許我們的應用程式在等待非同步元件時渲染一些後備內容，可以讓我們建立一個平滑的使用者體驗。 語法： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;!-- 非同步元件 --\u0026gt; \u0026lt;AsyncComp /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;!-- 後備內容 --\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; vue3 中引入非同步元件的方式：\n1 const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #defaul --\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;AsyncComp/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #fallback --\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) export default { setup() { return { } }, components: { AsyncComp, } } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;AsyncComp22\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name: \u0026#39;AsyncComp\u0026#39;, setup () { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ msg: \u0026#39;abc\u0026#39; }) }, 2000) }) } } \u0026lt;/script\u0026gt; 通過下圖可以看到在非同步元件加載出來之前，顯示的是 fallback 中的內容：\n響應式資料的判斷 作用 isRef：檢查一個值是否為一個 ref 物件 isReactive：檢查一個物件是否是由 reactive 建立的響應式代理 isReadonly：檢查一個物件是否是由 readonly 建立的只讀代理 isProxy：檢查一個物件是否是由 reactive 或者 readonly 方法建立的代理 程式碼演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 setup() { const state1 = ref(1); console.log(\u0026#39;isref:\u0026#39;, isRef(state1)); // isref: true const state2 = reactive({}); console.log(\u0026#39;isReactive:\u0026#39;, isReactive(state2)); // isReactive: true const state3 = readonly({}); console.log(\u0026#39;isReadonly:\u0026#39;, isReadonly(state3)); // isReadonly: true const state4 = reactive({}); console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state2)); // isProxy: true console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state4)); // isProxy: true return {}; }, 其他不常用特性 還有很多很多不常用的新特性，我在日常開發中是沒有用到的，很多都是用來做優化的，感興趣的小夥伴們自行去官網檢視，或者大佬們可以介紹一下應用場景。\nshallowReactive shallowRef readonly shallowReadonly markRaw customRef \u0026hellip; 語法糖 雖然 Composition API 用起來已經非常方便了，但是我們還是有很煩的地方，比如：\n元件引入了還要註冊。 屬性和方法都要在 setup 函式中返回，有的時候僅一個 return 就十幾行甚至幾十行。 \u0026hellip; 不想寫啊怎麼辦\n好辦， Vue3 官方提供了 script setup 語法糖，只需要在 script 標籤中==新增 setup==，元件只需引入不用註冊，屬性和方法也不用返回，setup 函式也不需要，甚至 export default 都不用寫了，不僅是資料、計算屬性和方法，甚至是自定義指令也可以在我們的 template 中自動獲得。\n但是這麼過癮的語法糖，還是稍微添加了一點點心智負擔，因為沒有了 setup 函式，那麼 props、emit、attrs 怎麼獲取呢，就要介紹一下新的語法了。\nsetup script 語法糖提供了三個新的 API 來供我們使用： ==defineProps==、==defineEmit== 和 ==useContext==。\ndefineProps：用來接收父元件傳來的值 props。 defineEmit：用來宣告觸發的事件表。 useContext：用來獲取元件上下文 context。 程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Children msg=\u0026#34;hello\u0026#34; @child-click=\u0026#34;handleClick\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;./components/children.vue\u0026#39; const handleClick = (ctx) =\u0026gt; { console.log(ctx) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;span @click=\u0026#34;sonClick\u0026#34;\u0026gt;msg: {{ props.msg }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useContext, defineProps, defineEmit } from \u0026#39;vue\u0026#39; const emit = defineEmit([\u0026#39;child-click\u0026#39;]) const ctx = useContext() const props = defineProps({ msg: String, }) const sonClick = () =\u0026gt; { emit(\u0026#39;child-click\u0026#39;, ctx) } \u0026lt;/script\u0026gt; 我們點選一下子元件：\n可以看到 context 被列印了出來，其中的 attrs、emit、slots、expose 屬性和方法依然可以使用。props 也可以輸出在頁面上，事件也成功派發。\n其他知識點 接下來介紹一下我使用 Vue3 過程中遇到的問題或者小技巧，不全面，想起什麼就寫什麼吧。\nscript setup 語法糖的坑\n這個很多大佬已經在 Vue3 的 github 上提交 Issues 了，或許會在不久的將來修復，但現在還是要注意一下。\n如果在父元件中通過 ref='xxx' 的方法來獲取子元件實例，那麼子元件不可以使用 script setup 語法糖，否則會報錯。\n程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child ref=\u0026#39;son\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/children.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const son = ref(null) console.log(\u0026#39; ~ son:\u0026#39;, son) \u0026lt;/script\u0026gt; 子元件先不使用語法糖：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const msg = ref(\u0026#39;hello\u0026#39;) return { msg, } }, } 現在把子元件換成 script setup 語法糖再來試一試：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;hello\u0026#39;) \u0026lt;/script\u0026gt; 可以看到現在是獲取不到子元件定義的 msg 屬性的。\nEmit 派發事件可以對引數進行驗證 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child @sonClick=\u0026#39;sonClick\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/Child.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const sonClick = (value) =\u0026gt; { console.log(value) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{ msg }} \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(1)\u0026#34;\u0026gt;我是按鈕1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(2)\u0026#34;\u0026gt;我是按鈕2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;\u0026#39;, emits: { sonClick: (value) =\u0026gt; { if (value === 1) { return true } else { return false } }, }, setup(props, { emit }) { const msg = ref(\u0026#39;hello\u0026#39;) const handleClick = (value) =\u0026gt; { emit(\u0026#39;sonClick\u0026#39;, value) } return { msg, handleClick, } }, } \u0026lt;/script\u0026gt; 我們分別點一下按鈕1和按鈕2，可以看到當我們點了按鈕2的時候，控制檯會發出警告，但是程式會繼續執行，還沒想到什麼適合的應用場景，但是要知道這個知識點，小夥伴們可以在這搞事情。\n跨元件通訊 mitt.js Vue2 中怎麼實現跨元件通訊呢？很多人第一想法就是 event bus。但是 Vue3 移除了 $on、$once、$off 導致不能使用這個方法。但是 Vue 官方給大家推薦了 ==mitt.js==，它的原理就是 event bus。\nmitt.js 教學\n程式碼演示 先安裝： 1 npm i mitt -s 然後封裝成一個 hook： mitt.js 1 2 3 4 import mitt from \u0026#39;mitt\u0026#39; const emitter = mitt(); export default emitter; 使用： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child1 /\u0026gt; \u0026lt;Child2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child1 from \u0026#39;./components/children1.vue\u0026#39; import Child2 from \u0026#39;./components/children2.vue\u0026#39; \u0026lt;/script\u0026gt; children1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件1 \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onUnmounted } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { // 初始化 const msg = ref(\u0026#39;hello\u0026#39;) const changeMsg = () =\u0026gt; { msg.value = \u0026#39;world\u0026#39; } // 監聽事件，更新資料 emitter.on(\u0026#39;change-msg\u0026#39;, changeMsg) // 顯式解除安裝 onUnmounted(() =\u0026gt; { emitter.off(\u0026#39;change-msg\u0026#39;, changeMsg) }) return { msg, changeMsg, } }, } \u0026lt;/script\u0026gt; children2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件2 \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;changeMsg\u0026#39;\u0026gt;點選修改msg\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { const changeMsg = () =\u0026gt; { emitter.emit(\u0026#39;change-msg\u0026#39;) } return { changeMsg, } }, } \u0026lt;/script\u0026gt; 演示 自定義指令 先看看 Vue2 自定義指令的鉤子：\nbind：當指令繫結在對應元素時觸發，只會觸發一次。 inserted：當對應元素被插入到 DOM 的父元素時觸發。 update：當元素更新時，這個鉤子會被觸發（此時元素的後代元素還沒有觸發更新）。 componentUpdated：當整個元件（包括子元件）完成更新後，這個鉤子觸發。 unbind：當指令被從元素上移除時，這個鉤子會被觸發，也只觸發一次。 在 Vue3 中，官方為了更有助於程式碼的可讀性和風格統一，把自定義指令的鉤子名稱改的更像是元件生命週期，儘管他們是兩回事：\nbind =\u0026gt; beforeMount。 inserted =\u0026gt; mounted。 beforeUpdate：新的鉤子，會在元素自身更新前觸發。 update =\u0026gt; 移除！ componentUpdated =\u0026gt; updated。 beforeUnmount：新的鉤子，當元素自身被解除安裝前觸發。 unbind =\u0026gt; unmounted。 過渡動畫 這個沒有什麼大的改動，只是修改了兩個 class 名字，正是因為沒有什麼大的改動，導致我曾經在這裡栽了大跟頭，寫完了怎麼都不對，後來查官網才知道。\n以下是直接引用官網的原文：\nv-enter-from：定義進入過渡的開始狀態。在元素被插入之前生效，在元素被插入之後的下一幀移除。 v-enter-active：定義進入過渡生效時的狀態。在整個進入過渡的階段中應用，在元素被插入之前生效，在過渡/動畫完成之後移除。這個類可以被用來定義進入過渡的過程時間，延遲和曲線函式。 v-enter-to：定義進入過渡的結束狀態。在元素被插入之後下一幀生效 (與此同時 v-enter-from 被移除)，在過渡/動畫完成之後移除。 v-leave-from：定義離開過渡的開始狀態。在離開過渡被觸發時立刻生效，下一幀被移除。 v-leave-active：定義離開過渡生效時的狀態。在整個離開過渡的階段中應用，在離開過渡被觸發時立刻生效，在過渡/動畫完成之後移除。這個類可以被用來定義離開過渡的過程時間，延遲和曲線函式。 v-leave-to：離開過渡的結束狀態。在離開過渡被觸發之後下一幀生效 (與此同時 v-leave-from 被刪除)，在過渡/動畫完成之後移除。 特別注意的是：\nv-enter 改成了 v-enter-form\nv-leave 改成了 v-leave-from\n其他小知識 Vue3 移除了 filter。 獲取元件實例的方法 getCurrentInstance()：\n這個方法可以獲取到當前元件的實例，相當於 Vue2 中的 this，但是它只在==開發環境==起效果，打包以後會報錯，所以大家不要依賴 getCurrentInstance 方法去獲取元件實例來完成一些主要功能。\n更詳細的可以檢視下面這篇文章：\n關於Vue3獲取當前元件例項的 getCurrentInstance 方法的補充 最後，畢竟是個人總結，難免會出現紕漏和錯誤，期待各路大神的補充和糾正。\n參考 參考網站 Vue3官方中文文件 Vue3.0光速上手 Volar - vue終極開發神器！ Vue3.0 新特性以及使用經驗總結 尚矽谷2021最新Vue.JS教程快速入門到專案實戰（Vue3/VueJS技術詳解） 那個忙了一夜的Vue3動畫很好，就是太短了 ","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277578302_d4a3e0c4aa_o.png","permalink":"/2022-08-11/vue3-quick-start/","title":"Vue3.0 快速入門，看完基本可以上手搞開發"},{"content":" 參考網站\n參考網站\n回顧 Option API 在了解 Composition Api 之前，首先回顧下我們使用 Option Api 遇到的問題，我們在 Vue2 中常常會需要在特定的區域（data、methods、watch、computed\u0026hellip;）編寫負責相同功能的代碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return{ val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; Option Api 的缺陷 反覆橫跳 隨著業務複雜度越來越高，代碼量會不斷的加大；由於相關業務的代碼需要遵循 option 的配置寫到特定的區域，導致後續維護非常的複雜，代碼可複用性也不高。\n相信大部分同學都維護過超過200行的 .vue 組件，新增或者修改一個需求，就需要分別在 data、methods、computed 裡修改，滾動條反复上下移動，我稱之為『反复橫跳』，比如我們簡單的加個拍腦門的需求加個累加器，這種寫代碼上下反复橫條的感覺，相信大家都懂的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1 @click=\u0026#34;add\u0026#34;\u0026gt;LSP {{count}}号 double is{{double}}\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ return{ count:1, val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, computed: { double() { return this.count * 2 } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; }, add(){ this.count++ } } } \u0026lt;/script\u0026gt; mixin 和 this 反覆橫跳的本質，在於功能的分塊組織，以及代碼量太大了，如果我們能把代碼控制在一屏，自然就解決了，vue2 裡的解決方案，是使用 mixin 來混合, 我們抽離一個 counter.js： counter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export default { data() { return { count:1 } }, computed: { double() { return this.count * 2 } }, methods:{ add(){ this.count++ } } } App.vue 1 2 3 4 5 6 7 8 import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ ... }, ... } 這樣確實拆分了代碼，但是有一個很嚴重的問題，就是不打開 counter.js，App.vue 裡的 this 上，count、add這些屬性，是完全不知道從哪來的，你不知道是 mixin，還是全局 install，還是 Vue.prototype.count 設置的，數據來源完全模糊，調試爽死你，這也是 option 的一個大問題，this 是個黑盒，template 裡寫的 count 和 double，完全不知道從哪來的。\n如果有兩個 mixin，就更有意思了，比如我們又有一個需求，實時顯示鼠標的坐標位置 x，並且有一個乘以 2 的計算屬性湊巧也叫 double，再整一個 mixin：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { data() { return { x:0 } }, methods:{ update(e){ this.x = e.pageX } }, computed:{ double(){ return this.x*2 } }, mounted(){ window.addEventListener(\u0026#39;mousemove\u0026#39;, this.update) }, destroyed(){ window.removeEventListener(\u0026#39;mousemove\u0026#39;, this.update) } } 這是一個獨立維護的 mixin，可能在 N 個地方用到，他根本不知道會不會有人和他衝突，然後用一下：\nApp.vue 1 2 3 4 5 6 import Counter from \u0026#39;./counter\u0026#39; import Mouse from \u0026#39;./mouse\u0026#39; export default { mixins:[Counter,Mouse], ...... } 兩個 mixin 裡都有 double 這個數，尷尬，看效果，lsp 的 count 被覆蓋了很尷尬，而且在 App.vue 這裡，你完全不知道這個 double 到底是哪個，調試很痛苦。\nComposition Api composition 就是為了解決這個問題存在的，通過組合的方式，把零散在各個 data、methods 的代碼重新組合，一個功能的代碼都放在一起維護，並且這些代碼可以單獨拆分成函數，顯然我們可以更加優雅的組織我們的代碼，函數。讓相關功能的代碼更加有序的組織在一起。\n我們用vue3演示一下功能，具體api就不解釋了直接vue3文檔搞起就可以：\nApp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) let todos = reactive([ { id:0, title:\u0026#39;吃饭\u0026#39;, done:false }, { id:1, title:\u0026#39;睡觉\u0026#39;, done:false }, { id:2, title:\u0026#39;lsp\u0026#39;, done:false }, ]) function addTodo(){ todos.push({ id: todos.length, title: val.value, done: false }) val.value = \u0026#39;\u0026#39; } return {val, todos, addTodo} } } \u0026lt;/script\u0026gt; 利用函數我們可以把功能完整獨立的拆分成模塊或者函數，方便組織代碼，並且解決了 mixin 混亂的問題。\n比如我們的累加器，抽離一個counter.js：\ncounter.js 1 2 3 4 5 6 7 8 9 10 import { ref, computed } from \u0026#39;vue\u0026#39; export default function useCounter(){ let count = ref(1) function add(){ count.value++ } let double = computed(()=\u0026gt;count.value*2) return { count, double, add } } 直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; + import useCounter from \u0026#39;./counter\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) ... + let { count,double,add } = useCounter() return { val, todos, addTodo, + count, double, add } } } 再來一個鼠標位置也不在話下，而且可以很好地利用解構賦值的別名，解決 mixin 的命名衝突問題：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { ref, onMounted, onUnmounted, computed } from \u0026#39;vue\u0026#39; export default function useMouse(){ let x = ref(0) function update(e){ x.value = e.pageX } let double = computed(()=\u0026gt;x.value*2) onMounted(()=\u0026gt;{ window.addEventListener(\u0026#39;mousemove\u0026#39;, update) }) onUnmounted(()=\u0026gt;{ window.removeEventListener(\u0026#39;mousemove\u0026#39;, update) }) return { x, double } } 模板裡直接用 doubelX：\n1 2 3 4 5 6 7 let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } script setup 不過有的同學可能，還有一個小小的吐槽，那就是 setup 函數最後的 return 也是集中的，如果行數太多，一樣會橫條一下下。\n這個好解決，因為本身我們可以把 todos 也抽離成函數，這樣 setup 就全部是數據的來源，非常精簡絲滑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; export default { setup(){ let { val, todos, addTodo } = useTodo() let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } } } 是不是賊爽呢，如果有些同學就是不想啥都抽離，還是覺得統一 return 很麻煩， 我們可以使用 vue3 的 setup script 功能，把 setup 這個配置也優化掉一個功能 export 一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; let { val, todos, addTodo } = useTodo() export { val, todos, addTodo } let { count, double, add } = useCounter() export { count, double, add } let { x, double:doubleX } = useMouse() export { x, doubleX } \u0026lt;/script\u0026gt; 具體看這裡\n","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277524312_b6dc5e213c_o.png","permalink":"/2022-08-11/option-api-vs-composition-api/","title":"圖解 Option API vs Composition API"},{"content":" 【尚硅谷】ES6教程 - 涵盖 ES6~ES11\n給進入 Vue.js 前的 ES6 必備知識\n超级实用的 ES6 特性\n【詳細 MDN 文件】\nECMAScript ES 是 ECMAScript 的簡稱，ECMAScript 是腳本語言的規範。而我們所使用的 JavaScript 是 ECMAScript 的一種實現。 簡言之：ECMA做出規範，各瀏覽器依照規範做出實現，因而不同瀏覽器會有兼容性不同的情況。 ES6 是 ES 的經典版本，是前端工程師崗位的高頻需求，是前端開發工程師求職的必備技能。 現階段前端行業發展迅猛，前端技術也在高速迭代， ES6-ES11 規范增加了很多 JavaScript 新特性。 ES 新特性已經成為前端技術發展的趨勢，語法簡潔，功能豐富，部分特性還有性能提升，前端開發三大框架 Vue、React、Angular 都用到了大量的新特性代碼，框架的升級也在向著新特性語法靠攏。 var 、 let 與 const var 、 let 與 const 在 Javascript 都是用來宣告變數的語法，最大的差別是他們的scope(變數有效範圍)的不同。切分var作用範圍的最小單位為 function，而 let 與 const 的作用範圍是 block 也就是俗稱的大括號：{ } 來切分。 const 所宣告的變數還有另一個特性是無法被重新賦值 (re-assign)。 let 特性 var 可以重複聲明，但 let 不能重複聲明。 演示： 1 2 3 4 5 var testA = \u0026#34;AAA\u0026#34;; var testA = \u0026#34;BBB\u0026#34;; // 不會報錯 let testB = \u0026#34;AAA\u0026#34;; let testB = \u0026#34;BBB\u0026#34;; // 會報錯 let 為塊級作用域 塊級作用域：變數只在代碼塊裡面有效({ ... }、if else、while、for) 在 ES5 中，作用域有：全局、函數、eval(嚴格模式下) 演示： 1 2 3 4 5 6 7 8 9 { var b = \u0026#34;BBB\u0026#34;; } console.log(b); // \u0026#34;BBB\u0026#34;，因為 var 非塊級作用域，所以聲明時會往外層(全局window)添加這個屬性 { let a = \u0026#34;AAA\u0026#34;; } console.log(a); // 會報錯 a is not defined 不存在變數提升 變數提升：代碼執行前會先進行變數搜集，var 聲明的變量在搜集時會先定義一個 undefined 的初始值。 演示： 1 2 3 4 5 6 7 // 在 a 用 var 聲明前輸出 console.log(a); // 不會報錯，會輸出 undefined var a = \u0026#34;AAA\u0026#34;; // 在 b 用 let 聲明前輸出 console.log(b); // 會報錯，Cannot access \u0026#39;b\u0026#39; before initialization let b = \u0026#34;BBB\u0026#34;; 不影響作用域鏈 演示： 1 2 3 4 5 6 7 { let school = \u0026#34;尚硅谷\u0026#34;; function fn() { console.log(school); } fn(); // 輸出 \u0026#34;尚硅谷\u0026#34;，在 fn 內沒有 school，會往外層尋找 } let 經典範例實踐 實作點擊 div 時切換顏色 代碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-header\u0026#34;\u0026gt; 點擊切換顏色 \u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 獲取 div 元素對象 let items = document.getElementsByClassName(\u0026#34;item\u0026#34;); // 遍歷並綁定事件 for (var i = 0; i\u0026lt; items.length; i++) { item[i].onclick = function() { // 修改當前元素的背景顏色 // 最佳寫法應為： this.style.background = \u0026#34;pink\u0026#34;; // 常見錯誤寫法： // items[i].style.background = \u0026#34;pink\u0026#34;; // // 原因： // i 使用 var 來聲明，var 聲明的變數非塊級作用域， // 因此 i 被聲明在全局(window)，此處取 i 會發現 window.i 已經等於 3 // 所以 items[3].style 會找不到。 // // 修正方式： // 將 i 改用 let 來聲明，讓 i 只存在於 for 迴圈中。 } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const 特性 一定要賦初始值，且聲明後值不能被修改。 一般常數使用大寫(淺規則)。 也是塊級作用域 演示： 1 2 3 4 5 { const PLAYER = \u0026#34;UZI\u0026#34;; } console.log(PLAYER); // 會報錯，PLAYER is not defined 對於 Array 和 Object 的元素修改，不算對常數的修改，不會報錯。 演示： 1 2 3 4 { const TEAM = [\u0026#34;UZI\u0026#34;, \u0026#34;MXLG\u0026#34;, \u0026#34;Ming\u0026#34;, \u0026#34;Letme\u0026#34;]; TEAM.push(\u0026#34;Meiko\u0026#34;); // 不會報錯，因為變數所指向的地址沒有改變 } 函式的參數默認值 在 ES5 中必須這麼寫： 1 2 3 4 function printText(text) { text = text || \u0026#34;default\u0026#34;; console.log(text); } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 function printText(text = \u0026#34;default\u0026#34;) { console.log(text); } 二進制與八進制字面量 ES6 支持二進制與八進制的字面量，通過在數字前面添加 0o 或者 0O 即可將其轉換為八進制值、添加 0b 或者 0B 即可將其轉換為二進制值。 1 2 3 4 5 6 7 let oValue = \u0026#34;0o10\u0026#34;; console.log(oValue); // \u0026gt;\u0026gt;\u0026gt; 8 let bValue = 0b10; console.log(bValue); // \u0026gt;\u0026gt;\u0026gt; 2 ES Module 與 import 、 export Javascript 自從 ES6 開始新增了模組系統(ES Module)，我們可以將每個 Javascript 的檔案當作是一個獨立的模組來看待，在 A 檔案匯出(export)在 B 檔案匯入(import)。 a.js 1 2 3 4 5 6 7 export const aString = \u0026#34;This is A String\u0026#34;; export function aFunction() { console.log(\u0026#34;A Function test\u0026#34;) } export const aObject = { a: 1 }; b.js 1 2 3 4 5 6 7 8 9 10 import { aString, aFunction, aObject } from \u0026#34;./a.js\u0026#34;; console.log(aString); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;This is A String\u0026#34; console.log(aObject); // \u0026gt;\u0026gt;\u0026gt; { a: 1 } aFounction(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;A Function test\u0026#34; 當然在 export 也可以不用給變數名稱： c.js 1 2 3 export default function() { console.log(\u0026#34;Hello 008 JS!!!\u0026#34;); } 在另一個檔案就可以這樣來使用： d.js 1 2 3 4 import greeting from \u0026#34;./c.js\u0026#34;; greeting(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello 008 JS!!!\u0026#34; 箭頭函數與 this 從 ES6 開始新增了一種叫做 「箭頭函式表示式」 (Arrow Function expression) 的函式表達式。快速看一下，如何將一般的函式轉換成箭頭函式的寫法： 1 2 3 const plus = function(numA, numB) { return numA + numB; }; 首先我們把參數往前提，然後把關鍵字 function 刪掉改成箭頭符號 =\u0026gt;： 1 2 3 const plus = (numA, numB) =\u0026gt; { return numA + numB; }; 如果這個函式只是想要回傳某個運算結果的時候，可以將 return 以及大括號 { } 省略： 1 const plus = (numA, numB) =\u0026gt; numA + numB; 而只有一個參數的時候，參數前面的小括號( )則可以省略： 1 2 3 4 const saySomething = msg =\u0026gt; console.log(msg); saySomething(\u0026#34;Hello!\u0026#34;); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello!\u0026#34; 另外需要注意的是，在箭頭函式使用 this 時，這時 this 會指向箭頭函式外面的 this，這個規則與原本 function 所宣告的函式不同，而且箭頭函式無法透過 bind() 強制指定裡面的 this。 字串模板 (Template literals) 以往我們在組合 JavaScript 的變數與 HTML 模板的時候，大多會透過「字串結合」 + 的模式，或透過陣列來新增字串，最後再用 [].join(\u0026quot;\u0026quot;) 的方式串接起來。但自 ES6 起，我們可以透過字串模板的語法，將變數、運算式等插入至我們的網頁模板當中，像這樣： 1 2 // 用「`...`」取代單/雙引號 `string text ${expression} string text` 這樣我們就可以將這個 expression 所代表的運算式或數值置入到字串裡頭了。 解構賦值 (Destructuring assignment) ES6 提供了解構賦值的語法，可以將陣列或者物件裡面的資料解開變成獨立的變數： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const user = { id: 42, displayName: \u0026#34;jdoe\u0026#34;, fullName: { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } }; const { id, displayName, fullName } = user; console.log(id); // \u0026gt;\u0026gt;\u0026gt; 42 console.log(displayName); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;jdoe\u0026#34; console.log(fullName); // \u0026gt;\u0026gt;\u0026gt; { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } 除了物件以外，陣列也可以： 1 2 3 4 5 6 7 8 9 const number = [1, 2, 3, 4, 5]; const [x, y] = number; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 ... 展開運算子 (Spread Operator) / 其餘運算子 (Rest Operator) 雖然 ES6 提供的展開運算子與其餘運算子的語法都是 ...，不過它們兩者所代表的涵意還是不太一樣。 展開運算子 展開運算子通常會用在陣列，或者是函式的參數，如： 1 2 3 4 5 const frameworks = [\u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;]; const arr = [\u0026#34;Awesome\u0026#34;, ...frameworks]; console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] 其餘運算子 延續前面的例子，我們可以透過 「其餘運算子」 將剩下的部分拆解出來： 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] const [a, b, ...others] = arr; console.log(a); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Awesome\u0026#34; console.log(b); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Vue.js\u0026#34; console.log(others); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34; 像這樣，我們可以搭配解構賦值的語法，將 arr 陣列拆解處來，並將剩餘的元素透過 ...others 分離。 當然，使用在物件上也是可以的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 其餘 Properties const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 console.log(z); // \u0026gt;\u0026gt;\u0026gt; { a: 3, b: 4 } // 展開 Properties const obj = { x, y, ...z }; console.log(obj); // \u0026gt;\u0026gt;\u0026gt; { x: 1, y: 2, a: 3, b: 4 } 要注意的是，其餘運算子所分離的部分只是陣列或物件的「淺拷貝」，若在多層物件使用時要特別小心。 Promise 物件 為了解決過去同步與非同步的問題，ES6 提供了 Promise 物件： 1 2 3 4 const myPromiseFunc = new Promise((resolve, reject) =\u0026gt; { resolve(someValue); // 完成 // reject(\u0026#34;failure reason\u0026#34;); // 拒絕 }); 當 Promise 的任務被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕這個 Promise，那麼就裡面呼叫 reject() 來拒絕他。 1 2 3 4 5 6 7 8 9 function myAsyncFunction(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } // 透過 .then() 來取代過去的 callback hell myAsyncFunction(...) .then(() =\u0026gt; { ... }); async 與 await 在後來，從 Promise 物件又延伸出 async 與 await 兩個新特性，其實本質上是更簡便的語法糖。 假設我們有兩個非同步任務要處理，並且我們希望在 asyncFunc1 執行完成之後才去執行 asyncFunc2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function asyncFunc1(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } function asyncFunc2(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } const asyncCall = async() =\u0026gt; { const result1 = await asyncFunc1(); const result2 = await asyncFunc2(); }; 像這樣，透過 async 與 await 我們就可以擺脫過去一層層 callback 的惡夢，程式碼也更加簡潔。\n簡寫屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 6 function createCoord(x, y) { return { x: x, y: y } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 6 function createCoord(x, y) { return { x, y } } 方法屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 const math = { add: function(a, b) { return a + b; }, sub: function(a, b) { return a - b; }, multiply: function(a, b) { return a * b; } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 const math = { add(a, b) { return a + b; }, sub(a, b) { return a - b; }, multiply(a, b) { return a * b; } } 陣列方法 ES6 引入了許多有用的陣列方法，例如： find()：查找陣列中的成員，返回 null 表示沒找到 findIndex()：查找陣列成員的索引 some()：檢查某個斷言是否至少一個成員在陣列中 includes：陣列是否包含某項目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const array = [{ id: 1, checked: true }, { id: 2 }]; arr.find(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; { id: 2 } arr.findIndex(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; 1 arr.some(item =\u0026gt; item.checked) // \u0026gt;\u0026gt;\u0026gt; true const numberArray = [1,2,3,4]; numberArray.includes(2); // \u0026gt;\u0026gt;\u0026gt; true ES6 的 class ES6 支持 class 語法，但不是新的對象繼承模型，只是原型鍊的語法糖。 函式中使用 static 關鍵字定義構造函式的方法與屬性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Student { constructor() { console.log(\u0026#34;I\u0026#39;m a student.\u0026#34;); } study() { console.log(\u0026#34;study!\u0026#34;); } static read() { console.log(\u0026#34;Reading Now.\u0026#34;); } } console.log(typeof Student); // \u0026gt;\u0026gt;\u0026gt; Function let stu = new Student(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a student.\u0026#34; stu.study(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;study!\u0026#34; stu.read(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Reading Now.\u0026#34; class 的繼承(extends) extends 允許一個子類繼承父類，需要注意的是，子類的 constructor 函式中需要執行 supre() 函式。 當然你也可以在子類方法中調用父類的方法，如 supre.parentMethodName()。 class 的聲明不會提升 hoisting ，如果你要使用某個 class ，那你必須在使用之前定義他，否則會拋出 reference error 的錯誤。 在 class 中定義函式不需要使用 function 關鍵字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Phone { constructor() { console.log(\u0026#34;I\u0026#39;m a phone.\u0026#34;); } } class MI extends Phone { constructor() { supre(); console.log(\u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34;); } } let mi8 = new MI(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone.\u0026#34; // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34; class 的 super 方法 super 關鍵字被使用於通過函式存取父層 【詳細 MDN 文件】\n語法 1 2 super([arguments]); // calls the parent constructor. super.functionOnParent([arguments]); 當使用建構子，super 關鍵字必須出現在 this 關鍵字之前使用，super 關鍵字也可以使用在呼叫函式與父對象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let parent = { foo() { console.log(\u0026#34;Hello from the Parent\u0026#34;); } } let child = { foo() { super.foo(); console.log(\u0026#34;Hello from the Child\u0026#34;); } } Object.setPrototypeOf(child, parent); child.foo(); // \u0026gt;\u0026gt;\u0026gt; Hello from the Parent // \u0026gt;\u0026gt;\u0026gt; Hello from the Child 非同步處理工具 - Generator(生成器函式) 生成器函式 生成器對像是由一個 generator function 返回的,並且它符合可迭代協議和迭代器協議。 【詳細 MDN 文件】\n語法 1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } let g = gen(); // \u0026#34;Generator { }\u0026#34; 方法 Generator.prototype.next()：返回一個由 yield表達式生成的值。 Generator.prototype.return()：返回給定的值並結束生成器。 Generator.prototype.throw()：向生成器拋出一個錯誤。 範例：一個無限迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function* idMaker() { let index = 0; while(true) yield index++; } let gen = idMaker(); // \u0026#34;Generator { }\u0026#34; console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 0 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 2 // ... 生成器對象 Generator.prototype.next()：返回 yield 表達式生成的值。 Generator.prototype.close()：關閉生成器，因此執行該函式後調用next()方法時將會拋出 StopIteration 錯誤。 Generator.prototype.send()：用於將值發送到生成器。該值由yield表達式返回，並且返回下一個yield表達式生成的值。 Generator.prototype.throw()：向生成器拋出錯誤。 ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52276889089_0bb5aa46f7_o.png","permalink":"/2022-08-10/javascript-es6/","title":"Javascript ES6 特性"},{"content":" 參考網站\nVue CLI 官方webpack相關文檔\n0、前言 webp 是 2010年 Google 釋出的圖片格式，針對 PNG 可減少 26%，JPEG 約可減少 25% ~ 34%，目前僅 safari、IE 尚不支援，但 safari 在 ios 14 以後開始支援。 若在未提供 .webp 格式圖檔的情況下，使用套件於 webpack 時進行圖片轉檔，但於 development 下會因抓不到虛擬的 XXX.webp 圖檔而導致 npm run 起時噴錯，可使用以下設定解決此問題。 1、使用 webpack-plugin-image-transform-webp-and-mini 套件將 image 轉檔成 webp 格式 1 npm i webpack-plugin-image-transform-webp-and-mini 2、新增一個自訂的 webploader 此 loader 功用為：若 resource 的 query (使用 chainWebpack 提供的變數\u0026quot;resourceQuery\u0026ldquo;抓) 字符中含有 \u0026quot;type=webp\u0026quot; 且 resource 為圖片時，將附檔名轉換成 XXX.webp 。 1 2 3 4 5 6 7 8 9 10 11 12 const path = require(\u0026#34;path\u0026#34;) module.exports = function(source, map) { let result = source if (this.resourceQuery \u0026amp;\u0026amp; this.resourceQuery.includes(\u0026#34;type=webp\u0026#34;) \u0026amp;\u0026amp; !this.resource.includes(\u0026#34;data:image\u0026#34;)) { let extname = path.extname(this.resourcePath) result = source.replace(extname, \u0026#34;.webp\u0026#34;) } // return result this.callback(null, result, map) } 3、chainWebpack 設定 套件安裝完成後，vue.config.js 引入套件，並指定webp圖檔存放位置。 引入自訂的 webploader ， 並設定 chainWebpack 的 images 需優先跑 webploader，再跑 url-loader 與 file-loader。 主要解決 Vue-cli 的 development 下，會因實際不存在 \u0026ldquo;XXX.webp\u0026rdquo; 圖檔而導致開發時報錯的問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... const ImageminWebpWebpackPlugin = require(\u0026#34;webpack-plugin-image-transform-webp-and-mini\u0026#34;) // ... chainWebpack: config =\u0026gt; { // ... config.plugins.delete(\u0026#34;preload-index\u0026#34;) config.plugins.delete(\u0026#34;prefetch-index\u0026#34;) // 相關設定建議放於移除 preload-index 與 prefetch-index 之後 config.plugin(\u0026#34;webP\u0026#34;).use(ImageminWebpWebpackPlugin, [ { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34;, logger: false, paths: { dir: path.resolve(__dirname, \u0026#34;./src/assets\u0026#34;), exclude: [] }, miniOptions: false } ]) let rule = config.module.rule(\u0026#34;images\u0026#34;) rule.uses.clear() rule .use(\u0026#34;./webploader.js\u0026#34;) .loader(\u0026#34;./webploader.js\u0026#34;) .end() .use(\u0026#34;url-loader\u0026#34;) .loader(\u0026#34;url-loader\u0026#34;) .options({ limit: 4096, fallback: { loader: \u0026#34;file-loader\u0026#34;, options: { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34; } } }) // ... } 4、補上是否支援 Webp 的判斷，若支援則於 \u0026lt;html\u0026gt; 補上 class name，供CSS抓取 class name 後改讀 webp 圖片 main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function isSupportWebp() { return new Promise(resolve =\u0026gt; { let result = false const elem = document.createElement(\u0026#34;canvas\u0026#34;) if (elem.getContext \u0026amp;\u0026amp; elem.getContext(\u0026#34;2d\u0026#34;)) { result = elem.toDataURL(\u0026#34;image/webp\u0026#34;).indexOf(\u0026#34;data:image/webp\u0026#34;) === 0 } resolve(result) }) } // 使用自定义过滤器 filter(Vue) ;(async () =\u0026gt; { Vue.prototype.$supportWebp = await isSupportWebp() if (Vue.prototype.$supportWebp) { document.documentElement.classList.add(\u0026#34;webp\u0026#34;) } })() 5、若有使用 vue-lazyload，則補上 vue-lazyload 提供的 webp 相關設定 \u0026lt;img\u0026gt; 使用 v-lazy 時，src的圖片附檔名皆會轉換成 XXX.webp 1 2 3 4 5 6 7 8 9 10 vue.use(VueLazyload, { filter: { webp(listener) { if (vue.prototype.$supportWebp \u0026amp;\u0026amp; !~listener.src.indexOf(\u0026#34;.webp\u0026#34;)) { listener.src = listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;) listener.el.setAttribute(\u0026#34;data-src\u0026#34;, listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;)) } } } }) 6、於各個 CSS 中，若 background 使用到需轉 .webp 格式的 img ，補上自行設定的 query (\u0026quot;?type=webp\u0026quot;)，以便 webploader 抓該 query 進行轉換圖檔格式 例如： 1 2 3 4 5 6 7 8 9 10 .page-wrap-main { background: url(\u0026#34;~assets/images/main/bg.png\u0026#34;); background-size: cover; width: 100%; position: relative; .webp \u0026amp; { background-image: url(\u0026#34;~assets/images/main/bg.png?type=webp\u0026#34;); } } ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52282467469_7cf86509a9_o.jpg","permalink":"/2022-08-10/vue-cli-use-webp/","title":"Vue-cli plugin：使用套件將圖片自動轉檔為webp格式"},{"content":" 參考網站\nJavaScript的記憶體空間 在 JavaScript 中，每一個數據都需要一個記憶體空間。記憶體空間分為兩種，棧記憶體（stock） 與 堆記憶體（heap）。 棧是系統自動分配的記憶體空間，由系統自動釋放，堆則是動態分配的記憶體，大小不定不會自動釋放。 基礎資料型別 JavaScript 中的基礎資料型別，這些值都有固定的大小，儲存在 棧記憶體中，由系統自動分配儲存空間，在棧記憶體空間的值，我們可以直接進行操作，因此基礎資料型別都是按照值訪問。 在棧記憶體中的資料發生複製的行為時，系統會自動為新變數開闢一個新的記憶體空間，當複製執行後，兩個記憶體空間的值就互不影響，改變其中一個不會影響另一個 棧記憶體空間資料複製示例 1 2 3 4 5 6 var a = `I am variable a`; var b = a; console.log(b); //`I am variable a` b = `I am variable b`; console.log(a); //`I am variable a` console.log(b); //`I am variable b` 引用資料型別 引用型別的值是儲存在 堆記憶體中的物件，在 JavaScript 中我們不能直接操作物件的堆記憶體空間。因為引用型別的值都是按引用訪問的，所以在操作物件時，實際上是操作物件的引用而不是實際的物件。 引用可以理解為儲存在棧記憶體中的一個地址，該地址指向堆記憶體中的一個實際物件。 引用型別值的複製，系統會為新的變數自動分配一個新的棧記憶體空間 這個棧記憶體空間，儲存著與被複制變量相同的指標，儘管他們在棧記憶體中的記憶體空間的位置互相獨立，但是在堆記憶體中訪問到的物件實際上是同一個，因此當我們改變其中一個物件的值時，實際上就是改變原來的物件。 棧記憶體空間儲存指標（地址），堆記憶體空間儲存實際的物件，我們通過變數訪問物件時，實際上訪問的是物件的引用（地址）。 記憶體中的棧區域存放變數（基本型別的變數包括變數宣告和值）以及指向堆區域儲存位置的指標（引用型別的變數包括變數宣告和指向內容的指標）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var a = { name : `I am object a`, type : \u0026#39;object\u0026#39; } var b = a; console.log(b); // {name: \u0026#34;I am object a\u0026#34;, type: \u0026#34;object\u0026#34;} b.name = `I am object b`; console.log(a); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} console.log(b); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} 基本型別總結 基本資料型別： 基本資料型別 包括 null、undefined、number、string、boolean、symbol(es6) 存放位置 記憶體中的棧區域中 比較 值的比較，判斷是否相等，如果值相等，就相等。一般使用 === 進行比較，因為 == 會進行型別的轉換 拷貝 賦值（通過 = 賦值操作符來賦值），兩個變數的值之間相互沒有影響 引用型別總結 包括 陣列、物件、函式 存放位置 記憶體的棧區域中存放變數和指標，堆區域儲存實際的物件 比較 是引用的比較（就是地址的比較，變數在棧記憶體中對應的指標地址相等就指向同一個物件）判斷是否為同一個物件，示例如下 變數a和變數b的引用不同，物件就不是同一個物件 1 2 3 var a = {name:\u0026#39;Jay\u0026#39;}; var b = {name:\u0026#39;Jay\u0026#39;}; a===b //false 我們對JavaScript中引用型別進行操作的時候，都是操作其物件的引用（儲存在棧記憶體中的指標） 賦值、深拷貝和淺拷貝 (Assignment, deep copy and shallow copy) 賦值：兩個變數的都指向同一個物件，改變其中一個，另一個也會受到影響。 所謂拷貝就是複製，通過複製原物件生成一個新的物件。 淺拷貝 重新在堆記憶體中開闢一個空間，拷貝後新物件獲得一個獨立的基本資料型別 資料，和原物件共用一個原物件內的引用型別 資料，改變基本型別 資料，兩個物件互不影響，改變其中一個物件內的引用型別 資料，另一個物件會受到影響。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var obj1 = obj; function shallowCopy(obj){ var scObj = {}; for(var prop in obj){ if(obj.hasOwnProperty(prop)){ scObj[prop] = obj[prop] } } return scObj; } var obj2 = shallowCopy(obj); console.log(obj === obj1,\u0026#39;obj === obj1\u0026#39;,\u0026#39;賦值\u0026#39;); console.log(obj === obj2,\u0026#39;obj === obj2\u0026#39;,\u0026#39;淺拷貝\u0026#39;); // true \u0026#34;obj === obj1\u0026#34; \u0026#34;賦值\u0026#34; // false \u0026#34;obj === obj2\u0026#34; \u0026#34;淺拷貝\u0026#34; console.log(obj.song === obj2.song); //true obj2.song.name=\u0026#39;雙截棍\u0026#39;; obj2.name=\u0026#39;Jay\u0026#39;; console.log(obj) // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj1); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj2); {name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj===obj1) //true console.log(obj===obj2) //false 深拷貝 不論是物件內的基本型別還是引用型別 都被完全拷貝,拷貝後兩個物件互不影響。 一種比較簡單實現方法是使用 var dcObj = JSON.parse(JSON.stringify(obj)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var dcObj=JSON.parse(JSON.stringify(obj)); console.log(dcObj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj.song === obj.song); //false dcObj.name=\u0026#39;Jay\u0026#39;; dcObj.song.name=\u0026#39;雙截棍\u0026#39;; console.log(obj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj); //{name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} 比較：賦值、深拷貝、淺拷貝： 賦值 新物件仍然指向原物件，改變新物件的基本型別和引用型別的值都會使原物件對應的值一同改變。 淺拷貝 改變新物件基本型別的值不會使原物件對應的值一起改變，但是改變新物件引用型別的值會使原物件對應的值一同改變。 深拷貝 改變新物件基本型別和引用型別的值，都不會影響原物件，兩者互相獨立，互不影響。 ","date":"2022-08-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52277851687_14d13f49a6_o.jpg","permalink":"/2022-08-09/js-deep-copy-vs-shallow-copy/","title":"JavaScript的記憶體空間、賦值和深淺拷貝"},{"content":" 安裝 hugo homebrew (MacOs) 1 brew install hugo scoop (Windows) 1 2 3 4 5 6 7 8 9 10 11 12 # 若未安裝過 Scoop，需先： # 1. 第一次需先設定，允許遠端腳本 # Set-ExecutionPolicy RemoteSigned -Scope CurrentUser # 2. 下載並安裝 Scoop # irm get.scoop.sh | iex # 透過 Scoop 安裝 Hugo scoop install hugo # or 安裝擴展版本 # scoop install hugo-extended apt-get (Linux) 1 sudo apt-get install hugo 利用 hugo 建立網站 1 2 # 進到本地資料夾根目錄後 hugo new site . --force 下載主題模板 (以 hugo-theme-stack 為例) 1 git submodule add git://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack clone 完畢後，把 exampleSite 文件夾中的 config.yaml 複製到站點目錄下，同時刪除此目錄下的 config.toml 文件。\n將 exampleSite/content/* 複製到站點目錄下的 content/\n剩餘主題的設定與文章內容，可依個人需求自行設定，本篇不再贅述。\ngithub 創建一個 public 的 repo，用於存放發布用的 public 資料夾。 前往 repo 的 Settings -\u0026gt; Pages 設定好欲發布的分支與 root path 設定完畢後，github 會分配給你一個公開的網址：https://{your-account}.github.io/{your-repo-name}/，若不需自定義網址與 CI/CD 流程，到此步驟即可完畢。\n設定自定義網址 註冊一個網址 本文使用 freenom 註冊一組免費的網址 註冊完畢後，前往 Manage Domain 選擇 Management Tools -\u0026gt; NameServers 後，此頁面先暫時放置著，待會再回來繼續設定 前往 Cloudflare 後台 登入 Cloudflare 後台，並選擇 網站 DNS 設定如圖： 將註冊的 domain 設定指向到 github server ip 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 設定 CNAME www 指向到剛剛 github 分配給你的 domain (path不需要)： https://{your-account}.github.io/ 將下方兩個 Cloudflare 名稱伺服器複製下來 選擇 Use custom nameservers (enter below) 將剛剛從 Cloudflare 複製的兩個 NameServer，貼到 NameServer 1、NameServer 2 Cloudflare 後台設定強制使用 SSL 點選 SSL/TLS 的 邊緣憑證 打開 一律使用HTTPS 回到 github pages，將網址填寫至 Custom domain，短暫驗證完畢後，即可點選 Save 送出設定 自定義網址已設定完畢，可使用網址打開網站。\n設定 github actions 做 CI/CD 準備材料1：生成 github personal access tokens 前往 github 的個人設定 \u0026quot;Settings\u0026quot;，下方點選 Developer settings\n點選 Generate new token\n設定備註、過期時間、權限後即可生成 token\n建議過期時間可以設定 No expiration (無過期時間)、權限設定 repo 全部勾選 生成後，token 請複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。\n準備材料2：登入 Cloudflare 後台，取得 區域識別碼(Zone) 登入 Cloudflare，選擇自己的 domain 點選 概觀，並於圖中標示處取得 區域識別碼(Zone Id) 準備材料3：取得 Global API Key 於 概觀 下方點選 取得您的 API Token 點選 檢視，輸入密碼後取得 Global API Key 準備材料4：生成 API token 點選 建立 Token -\u0026gt; 建立自訂 Token 設定 token 名稱、權限、TTL PS：權限必須至少擁有 區域 -\u0026gt; 快取清除 -\u0026gt; 清除，以便 CI/CD 後使用 token 清除 DNS cache 設定完畢後即可建立 token 建立後，也請將 token 複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。 材料準備完畢，開始設定 secret 進入 source code 的 repo，點選 Settings -\u0026gt; Secret -\u0026gt; Actions，並將剛剛的四個準備材料設定到 Actions secrets 中 此處 Actions secrets 的名稱如需修改，則待會的 github-actions.yml 內的名稱也需跟著修改，否則會抓不到 secrets 中設定的值哦!\n於 source code repo 根目錄新增 .github/workflows/github-actions.yml github-actions.yml 內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 name: Auto build and publish to public site repository # 只有推送到 main 才觸發 on: push: branches: - \u0026#34;main\u0026#34; pull_request: branches: [\u0026#34;main\u0026#34;] jobs: hugo-publish: name: publish content to public site runs-on: ubuntu-latest steps: # 使用當前 source code 的 repo - name: checkout source code repo uses: actions/checkout@v3 with: # 因為目前的 repo 有使用到 submodule(hugo themes)，所以 submodule 也要一併同步，不然原本的 repo 是沒有 submodule 的內容 submodules: true token: ${{ secrets.ACCESS_TOKEN }} # public 網站是放置在另一個 repo 所以這裡也要 clone 一份下來處理 # 因為我 Hugo 預設是產生檔案到 public 資料夾，所以將 public repo clone 到 ./public/ 內，以便後續 publish - name: clone and checkout public repo uses: actions/checkout@v3 with: # 這裡是 public 網站在 github 上的 repo 名稱 repository: {template/template-public-repo-name} path: public # tip: 需事先產生一把 personal access token 放到 repo 的 secrets 裡 # 然後 secrets 裡的名稱就叫 ACCESS_TOKEN # 參考 https://help.github.com/en/actions/automating-your-workflow-with-github-actions/authenticating-with-the-github_token token: ${{ secrets.ACCESS_TOKEN }} # 使用別人做好的 Hugo Actions - name: setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true # 用 Hugo 產生檔案 - name: build content to public site working-directory: ./ # --cleanDestinationDir 清除舊檔案 run: hugo --minify --gc --cleanDestinationDir # 將檔案 commit 到 網站 public repo - name: deploy and publish updates working-directory: ./public # user.email 還有 user.name 可以取自己喜歡的，一定要設定不然會出錯 run: | # 當 git 有更動時才進行動作 if [[ `git status --porcelain` ]]; then git config --local user.email \u0026#34;{typing your email}\u0026#34; git config --local user.name \u0026#34;{typing your name}\u0026#34; git add . -A git commit -m \u0026#34;build: auto publish\u0026#34; git push origin else echo \u0026#34;content no changes\u0026#34; fi # 清除 cloudflare dns cache - name: clear cloudflare cache uses: nathanvaughn/actions-cloudflare-purge@master with: # Using Zone Id cf_zone: ${{ secrets.CLOUDFLARE_ZONE }} # Using API Token cf_auth: ${{ secrets.CLOUDFLARE_API_TOKEN }} 內容 {} 內的資訊請更換成自己的資訊\n附上 yaml 範例，詳細 github-actions.yaml 文件請查閱 github 官方文件\n建立檔案後，將 commit push 後，即可於 source code repo 的 Actions 頁面查看 CI/CD 的過程。 ","date":"2022-08-01T00:00:00Z","image":"https://live.staticflickr.com/65535/52274839367_8325e83fea_o.jpg","permalink":"/2022-08-01/hugo-github-pages-actions-and-cloudflare/","title":"架設部落格之一條龍免費寶典：Hugo 生成靜態網站、Pages 發布網站、設定 custom domain(free 12 months)、Actions 做 CI/CD"},{"content":" 參考網站 - 初學者都該學會的 HTTP 通訊協定基礎\n參考網站 - Http/2 是什麼?\n目前 HTTP 通訊協定的版本 HTTP/0.9 於 1991 年發表(已廢止) HTTP/1.0 於 1996 年 5 月發表(RFC 1945) HTTP/1.1 於 1997 年 1 月發表(RFC 2068) 於 1999 年 6 月發布 HTTP/1.1 更新版(RFC 2616) 於 2014 年 6 月再次更新 HTTP/1.1 並將規格文件拆成六份 HTTP/2(Wikipedia) 於 2015 年 5 月發布(RFC 7540)(瀏覽器相容性) 僅針對 HTTP/1.1 的 Message Syntax 部分作出強化 HTTP/0.9 (已廢止) 概要 於 1990 年由 Tim Berners-Lee 提出最初的 HTTP 建議(WWW)\n實作重點\n用戶端要求是以 ASCII 字元為主(單行命令即可發出請求 GET/) 用戶端要求會以一個 換行字元 (CRLF) 來結束 伺服器回應是以 ASCII 字元為主，回應內容是 HTML 文件 每次執行完 Request / Response 就會自動關閉連線 主要特色\nClient / Server 架構、Request / Response 協定 跑在 TCP/IP 上的 ASCII 協定 (要求/回應) 被設計用來傳輸 HTML 文件 每完成一次 ASCII 協定就會自動關閉連線 使用 bash 測試 1 2 3 4 5 6 7 8 # 建立連線到 google $ telnet google.com 80 \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about \u0026gt; ... HTTP/1.0 概要 在 1991 到 1995 年之間，所謂 瀏覽器 騰空出世！\n於 1996 年 5 月發表 HTTP/1.0 版 (RFC 1945)\n與 HTTP/0.9 不同的部分\n用戶端要求是以 ASCII 字元為主，但可發送多行命令(含要求標頭) 先送出要求方法，再送出要求標頭，最後以一個額外的換行字元結束 伺服器回應是以 ASCII 字元為主，回應內容會區分為 狀態列 回應標頭 回應內文主體(不僅僅是 HTML 文件，可以是更多內容類型) 每完成一次 Request / Response 交握就會自動關閉 TCP/IP 連線 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.0 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，會自動中斷 TCP 連線 # 若需再發送請求，需重新建立 TCP 連線 $ telnet google.com 80 ... HTTP/1.1 概要 於 1997 年 1 月發表 HTTP/1.1 版 (RFC 1945)\n於 1999 年 6 月發布 HTTP/1.1 更新版 (RFC 2616)\n與 HTTP/1.0 不同的部分\n傳輸協議的效能改進(新增不少 HTTP 標頭定義) 持續連線狀態(persistent connection) 切塊編碼傳輸(chunked encoding transfer) 位元範圍請求(byte range request) 額外快取機制(cache control) 請求管線作業(request pipelining)(需搭配持續連線狀態特性才能用) 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，不會自動中斷 TCP 連線，可再發送請求 $ GET /abc HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.1 404 Page Not Found \u0026gt; ... 目前 HTTP/1.1 的六大規格 RFC 7230 HTTP/1.1：Message Syntax and Routing RFC 7231 HTTP/1.1：Semantics and Content(最重要) RFC 7232 HTTP/1.1：Conditional Requests RFC 7233 HTTP/1.1：Range Requests RFC 7234 HTTP/1.1：Caching RFC 7235 HTTP/1.1：Authentication 關於 HTTP 通訊協定的基本常識 無狀態特性(stateless)：相同的 request，都會得到相同的 response，不會因為狀態不同而改變 分散式架構(distributed)：相同的 request，不同載體發送，都會得到相同的 response 協作的架構(collaborative)：不一定只有 client / server，也可以是 client / proxy / reverse proxy / server 超文本(hypertext = not just \u0026ldquo;text) but with \u0026ldquo;links\u0026rdquo;)：除了內容，還包含連結 初學者應了解 HTTP 的基本運作方式 如何發出 HTTP 要求(HTTP Request)\n要求方法(Request Methods) GET、POST、PUT、DELETE、PATCH、\u0026hellip; 要求標頭(Request Headers) Connection、COntent-Type、\u0026hellip; 斷行符號(CRLF) 要求內容主體(Request Body) 如何回應 HTTP 訊息(HTTP Response)\n回應狀態碼(Response Status Codes) HTTP/1.1 200 OK 回應標頭(Response Headers) 斷行符號(CRLF) 回應內容主題(Response Body) HTTP/2 HTTP/2 各個瀏覽器的支援度 點我查看瀏覽器支援度\nEdge / Firefox / Chrome / Opera 皆在 2015 年起就支援 HTTP/2，基本上不需要太擔心主流瀏覽器的支援性問題。\nPS：如何在 Node.js 中使用 HTTP/2\nHTTP/2 改善了什麼？ http/2標準發布於2015年5月，其主要目的是透過一些措施改善瀏覽器瀏覽網頁 加載的速度(page load) 。目前大多數的瀏覽器已支援 http/2 (chrome, firefox, safari等)標準，又 http/2與 http/1.1有著高度的相容信，舉凡request method(post, get..etc), http status code, url, header 等等，因此對於web developer來說，只需要確保你的網站有支援https(因為瀏覽器只支援https 在http/2上)。那麼http/1.1與http/2到底相差多快呢，點我體驗!\nHTTP/2 是如何改善？ 只需要單一網路連線 (Single TCP connection) 只需要單一網路連線，就可以連接網站伺服器，下載所有需要的資源。大大節省 HTTP/1.1 需要一直建立多個網路連線時的啟動時間浪費。\nRequest and response multiplexing (多路複用) 在 http/1.1 中，client 端時常會同時發起多個 request 至 server 拿取檔案(像是js, css, image等)，以此方式達到快速載入頁面。如下圖在 http/1.1 中會同時與 server 建立3個 TCP connection，但是瀏覽器通常會限制 TCP connection 同時建立的數目。因此在 http/2 協定中，允許 client 端與同一 server 建立單一 TCP connection 並以非同步方式傳輸要的檔案。\n優先權設計 (Prioritization) 伺服器可以決定例如 CSS 或 JavaScript 檔案，哪些要優先傳送。\nHeader compression (標頭壓縮) 每一個 http 的傳輸中都會攜帶一組 header，在 http/1.1 中，header 會是以明文(plain text)傳輸大小通常會是500-800 bytes，若有攜帶 cookie 也有可能會更大。因此在 http/2 中，會將 request 以及 response 的 header 使用 HPACK 演算法壓縮 header 的內容，此方法壓縮後可以減少 85%-88% 的大小。\nServer push (伺服器推送) 在 http/1.1 中，通常 client 端 request 甚麼 server 就會回傳甚麼，例如: 當 client request html 那麼 server 將只會回傳 html。但在 http/2 中，允許 server 主動推送有相關的資料給 client，例如: 當 client 只 request html，但是 server 知道 client request 此 html 後續也會 request css, js 等，因此 server 就會在 client 沒有 request 的情況下主動推送 css, js 檔給 client。那 server 怎麼知道這些檔案是有相關性的呢? web developer 將需要 server push 的檔案加上特定的描述即可。(描述)\n不過，這個功能比較有爭議，一來他需要 Web 開發者額外描述有哪些檔案需要隨著 HTML 一起推送給瀏覽器，不是 Web 伺服器升級 HTTP/2 就自動會有。二來它不管瀏覽器是不是已經有快取這個資源，都會推送而造成頻寬浪費。因此實務上筆者認為可以改用瀏覽器的 Prefetch 功能，讓客戶端的瀏覽器自己處理即可。\nBinary framing layer (二進制影格層) 在 http/2 中，header 與 body 所挾帶的 property 與 http/1.1 相同(ex. verbs, methods)，然而兩者在傳輸上會有不同。在 http/2 中，會將 header 以及 body 編碼成二進制在 server 與 client 端中傳輸，在 http/1.1 中，則是以明文的方式傳輸。將訊息編碼成二進制進行傳輸，此特性是 http/2 的其他特性的根本基礎。\n冷知識：在 HTTP/1.1 定義了四種解析訊息的方式，在 HTTP/2 只需要一種。\n總結 根據 w3Techs 網站，目前使用http/2的網站有45.7%，未來確實會變成主流，身為軟體工程師，還是多少理解來的好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤資訊還請直接點出，萬分感謝。\n","date":"2022-07-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52276290470_787c77a1b5_o.jpg","permalink":"/2022-07-24/beginner-http-lesson/","title":"初學者都該了解的 HTTP 通訊協定基礎"},{"content":" 參考網站 - 初學者學演算法｜從時間複雜度認識常見演算法\n溫故知新 演算法的簡單定義：輸入 + 演算法 = 輸出 時間複雜度：衡量演算法執行好壞的工具 大 O 符號：用來描述演算法在輸入 n 個東西時，所需時間與 n 的關係 在 n 非常大時，好的演算法設計可以省下非常多時間 演算法的速度不是以秒計算，而是以步驟次數 實務上，我們只會紀錄最高次方的那一項，並忽略其所有的係數 目錄：常見的六種時間複雜度與演算法 O(1)：陣列讀取 O(n)：簡易搜尋 O(log n)：二分搜尋 O(nlogn)：合併排序 O(n²)：選擇排序 O(2^n)：費波那契數列 O(1)：陣列讀取 說明 時間複雜度為 O(1) 的演算法，代表著不管你輸入多少個東西，程式都會在同一個時間跑完。在程式設計中，最簡單的例子就是讀取一個陣列中特定索引值的元素(程式麻瓜先別急著吐血，且讓我們在下面慢慢說明)。\n陣列讀取 陣列是程式中儲存東西的一種容器，我們可以想像成一排已經編號好的櫃子。每一個櫃子上的編號我們稱為「索引值」（Index，在程式中這個編號通常從 0 開始），而櫃子裡的物品我們稱為「元素」。例如：假設神奇寶貝大師小明在一個名叫 Pokemons 的陣列裡依序放入他的神奇寶貝們，我們來複習一下陣列、元素、索引值的關係：\n在程式碼中我們把七隻神奇寶貝這樣表達：\n1 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] 這時，假設我們想要知道在這個 Pokemons 陣列中任一個編號所對應到的神奇寶貝，我們都只需要把這個編號對應的元素印出來，就能知道對應的神奇寶貝是誰了。如果我想知道這個陣列中的第 n 號櫃的神奇寶貝是誰（以下假設我們想知道 n= 0），在程式碼中我們可以這樣表達：\n1 2 3 4 n = 0 print(Pokemons[n]) \u0026gt;\u0026gt; \u0026#34;卡丘\u0026#34; 陣列讀取時，因為我們已經知道櫃子的索引值，不管放入的 n 等於多少，程式都可以在 “一個步驟” 就到達 n 所對應到編號的櫃子並取出該元素，像這樣的案例，我們就會說陣列讀取演算法的時間複雜度為 O(1)。\nO(n)：簡易搜尋 說明 時間複雜度為 O(n) 的演算法，代表著執行步驟會跟著輸入 n 等比例的增加。例如當 n = 8，程式就會在 8 個步驟完成。最簡單的例子，就是所謂的簡易搜尋。\n這邊要特別提醒一點，通常程式步驟的時間複雜度會是用程式執行會碰到的最壞狀況 (Worst Case) 來表示，詳細例子我們可以在下面看到。\n簡易搜尋 讓我們沿用上一段的 Pokemons 陣列作為例子。Pokemons 這一排櫃子裡有八隻神奇寶貝，假設每個櫃子的門都被關上，我們事前也不知道各個神奇寶貝的位置，這時如果想要知道「呆獸」神奇寶貝在哪裡時，我們第一個想到的方法會是什麼呢？\n最直觀地想，我們會從第一個櫃子開始試，一次開一個櫃子，直到找到「呆獸」為止。像這樣的搜尋方法，就是最經典簡單的「簡易搜尋」。\n在程式碼中，簡易搜尋的方法可以這樣表達：\n1 2 3 4 5 6 7 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] for Pokemon in Pokemons: if Pokemon == \u0026#34;呆獸\u0026#34;: print(\u0026#34;找到呆獸！\u0026#34;) break else: print(\u0026#34;這個櫃子裡不是呆獸\u0026#34;) 觀察上面的程式碼時，我們可以發現，如果呆獸在第 0 號櫃，我們一個步驟就會找到它，但如果他是在第 6 號櫃，我們要花七個步驟才能找到他。\n還記得我們在上面提過的小小提醒嗎？我們通常會用程式執行會碰到的「最壞狀況」來決定複雜度的表示，也因此，當我們要從 n 個櫃子中找到一隻特定的神奇寶貝，我們最慘最慘的情況需要花剛好 n 個步驟才能找到（想像要找的神奇寶貝在最後一個櫃子的情況）。像這樣的案例，我們就會說簡易搜尋演算法的時間複雜度為 O(n)。\nO(log n)：二分搜尋法 說明 時間複雜度為 O(log n) 的演算法（這邊的 log 都是以二為底），代表當輸入的數量是 n 時，執行的步驟數會是 log n。（讓忘記 log 是什麼的同學們複習一下，當 log n = x 的意思是 n = 2^x，如果這部分的腦細胞尚未復活，且讓我們先記住 n = 2^x，再來看看例子）。\n舉例來說，當 n = 4，程式會在 2 個步驟完成（4 = 2²）；n = 16 時，程式會在 4 個步驟完成（16 = 2⁴），以此類推。\n在程式中，O(log n) 的最常見例子是二分搜尋法。\n二分搜尋法 假設我們在一本字典中想要找到一個單字，這個字以 W 開頭，我們可以用前面提過「簡易搜尋」的邏輯，從第一頁的 A 開始找起，一個一個找到天荒地老海枯石爛。也可以用更珍惜生命的方式，直接翻到字典的後面，找到以 W 開頭的第一個字後再開始往後找。\n同樣的邏輯，假設有一長串有小到大排序好的數字們，我要在其中找特定一個數字，我們一樣可以從第一個往後一個一個檢查。但假設我們想要更珍惜生命，聰明的讀者可能已經想到了我們在「終極密碼」這種遊戲中會使用的策略，也就是每次都先檢查最中間的數字，如果中間的數字比我們要找的數字大，我們要找的數量就只剩原本的一半（因為在後段的數字顯然都會比我們要找的數字大），這樣的方法，就稱作二分搜尋法。\n舉一個實際的例子，假設今天有一排編號好的櫃子，裡面擺著八個由小到大排序好的數字。假設我們知道裡面的數字包含 55，但我們不知道在哪一個編號櫃子中。讓我們來比較簡易搜尋（從第一格往後一個一個檢查）跟二分搜尋法有什麼差別。\n從上面的圖可以看到，一般的搜尋方法需要花五個步驟才能找到 55。\n而在二分搜尋法中，我們先打開最中間的櫃子，發現裡面的數字是 41。因為 55 比 41 大，因此我們知道從一號櫃到三號櫃都不會有 55，接下來只需要檢查五號櫃到七號櫃。\n同樣的邏輯，我們打開剩下三個可能性中最中間的櫃子，發現六號櫃裡面的數字是 61，因為 61 比 55 大，我們可以知道七號櫃的數字一定也比 55 大，得知 55 一定就在五號櫃之中。\n接下來，要再次來關心兩個搜尋方法的時間複雜度。簡易搜尋的情況中，我們可以輕鬆地知道最壞的情況就是剛好七個步驟（要找的數字是 80 ）。而二分搜尋法，我們可以先練習去計算各種情況需要的步驟，而最終的答案如下表：\n從上表我們可以發現，二分搜尋法最慘最慘，也只需要三個步驟。\n推廣到有 n 個櫃子時，我們可以發現：二分搜尋法在每進行一個步驟時，就可以排除掉一半的可能性。每次都能減少一半，因此二分搜尋法最糟最糟也只需要以 2 為底的 log n 個步驟就能完成。\n二分搜尋法在程式碼中的例子，對於程式新手可能需要花比較多的理解。如果你是對程式有一定理解的人，可以嘗試動手實做看看。而如果下方的程式碼對於讀者還有些吃力的話，也可以先多多熟悉語法後回來複習即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Numbers = [5,17,33,41,55,61,80] Find = 55 ​ low = 0 high = len(Numbers) - 1 ​ while low \u0026lt;= high: mid = (low + high) // 2 if Numbers[mid] \u0026gt; Find: high = mid - 1 elif Numbers[mid] \u0026lt; Find: low = mid + 1 else: break ​ print(mid) 小結 在這篇文章中，我們分別了解了 O(1)、O(n)、O(logn) 的時間複雜度，以及對應到的三個常見演算法。而在接下來的文章中，我們會開始認識新朋友，在演算法中佔有重要地位的「排序法」，以及在更進階的例子。\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276285230_7f886f0bca_o.jpg","permalink":"/2022-07-23/common-time-complexity/","title":"初學者學演算法｜從時間複雜度認識常見演算法"},{"content":" 剛剛用日常上班前挑衣服的例子和沒學過程式的 00 說明時間複雜度的概念很好理解耶～！\n例子是這樣的\u0026hellip;\n一早要出門的時候，想要從衣櫃中找出紅色的上衣。\n其中一種方式是像左圖一樣，這是掏寶上很熱門的「疊衣服褲子收納神器」，雖然看起來整理的很乾淨，但如果你要從中找到紅色的衣服，你就得要由上而下一件一件找，最糟的情況就是一直翻到最下面才能找到你要的紅色衣服。\n另一種方式是像右圖一樣，把衣服用立起來的方式，一眼就可以看到紅色的衣服在哪，直接拿出來，幾乎不用找。\n左圖的那種方式，時間複雜的就是 O(n)，n 就是衣服的件數，雖然紅色的衣服有可能就放在最上面，一眼就可以看到，但在探討時間複雜度的時候都要考慮最差的情況，所以如果你有 n 件衣服，最差的情況就是要把 n 件衣服都翻過才會找到紅色那件。\n右圖的方式它的時間複雜度是 O(1)，在你沒有忘記其實衣服已經被丟到洗衣籃的前提下，你看一眼，翻都不用翻就可以把紅衣服直接取出（請先忽略掉人腦內建的視覺搜尋系統，那是另一個有趣的故事 XD）。這種不用一個一個找，就直接取出的，時間複雜度就是 O(1)。\n有了這個時間複雜度的概念後，是不是覺得左邊的那個商品實用性沒這麼高啦～ XDD\n真的是沒想到學演算法還可以用在購物吧！\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276282210_c2a38fae3c_o.jpg","permalink":"/2022-07-23/learn-time-complexity-by-clothes/","title":"從找衣服了解時間複雜度"},{"content":" 參考網站 - gRPC 說明影片 @ BESG\nSOURCE CODE\n對應的程式碼可檢視 besg-grpc 的 repository。\ngRPC 是什麼：以 Golang 說明與實作 說明 RPC 的全名是 remote procedure call，主要是作為電腦和電腦間溝通使用。A 電腦可以呼叫 B 電腦執行某些程式，B 電腦會將結果回傳給 A 電腦，A 電腦在收到回應後會再繼續處理其他任務。RPC 的好處在於，雖然 A 電腦是發送請求去請 B 電腦做事，但其呼叫的方式，就很像是 A 電腦直接在呼叫自己內部的函式一般。\ngRPC 也是基於這樣的概念，讓想要呼叫 server 處理請求的 client，在使用這支 API 時就好像是呼叫自己內部的函式一樣簡單自然。從功能面來說，gRPC 就像 Web 常用的 Restful API 一樣，都是在處理請求和回應，並且進行資料交換，但 gRPC 還多了其他的功能和特色。\ngRPC 是由 Google 開發的開源框架，它快速有效、奠基在 HTTP/2 上提供低延遲（low latency），支援串流，更容易做到權限驗證（authentication）。在下面的文章中，將會對於 gRPC 能提供的特色有更多說明。\nProtocol Buffers 是什麼 Protocol Buffers @ Google Developer Protocol Buffers 筆記 @ pjchender.dev 在學習 gRPC 時，需要同時了解什麼是 Protocol Buffers。在傳統的 Restful API 中，最常使用的資料交換格式通常是 JSON；但到了 gRPC 中，資料交換的格式則是使用名為 Protocol Buffers 的規範／語言。\njson 1 2 3 4 5 { \u0026#34;firstName\u0026#34;: \u0026#34;Sushiro\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Global\u0026#34;, \u0026#34;age\u0026#34;: 6 } protocol buffers 1 2 3 4 5 6 // Protocol Buffers message User { string first_name = 1; string last_name = 2; int32 age = 3; } 也就是說，當我們想要使用 gRPC 的服務來交換資料前，必須先把資料「格式」和「方法」都定義清楚。\nTIP:\n使用 gRPC 前，不只需要先把資料交換的格式定義清楚，同時也需要把資料交換的方法定義清楚。\n這裡要稍微釐清一點很重要的是，Protocol Buffers 可以獨立使用，不一定要搭配 gRPC；但使用 gRPC 一定要搭配 Protocol Buffers。\n實作將 Protocol Buffers 編譯成在 Golang 中可使用的檔案 對應的程式碼可檢視 besg-grpc repository 中的 proto 資料夾。\nSTEP 1：撰寫 Protocol Buffers 檔案 使用 message 定義資料交換的格式。 使用 service 定義呼叫 API 的方法名稱。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 syntax = \u0026#34;proto3\u0026#34;; // 定義要使用的 protocol buffer 版本 package calculator; // for name space option go_package = \u0026#34;proto/calculator\u0026#34;; // generated code 的 full Go import path message CalculatorRequest { int64 a = 1; int64 b = 2; } message CalculatorResponse { int64 result = 1; } service CalculatorService { rpc Sum(CalculatorRequest) returns (CalculatorResponse) {}; } STEP 2：安裝編譯 Protocol Buffer 所需的套件 此部份可參考 編譯 Protocol Buffers（Compiling） 段落。\n安裝 compiler (macOS) 1 2 3 4 5 6 7 8 9 10 11 # 安裝 compiler，安裝完後就會有 protoc CLI 工具 brew install protobuf protoc --version # Ensure compiler version is 3+ # --- 使用 golang 才需要安裝以下兩個套件 --- # 安裝 protoc-gen-go 後可以將 proto buffer 編譯成 Golang 可使用的檔案 go get github.com/golang/protobuf/protoc-gen-go # 安裝 grpc-go 後，可以在 Golang 中使用 gRPC go get -u google.golang.org/grpc STEP 3：編譯 Protocol Buffer 檔案 進到放有 .proto 檔的資料夾後，在終端機輸入下述指令：\n1 protoc *.proto --go_out=plugins=grpc:. --go_opt=paths=source_relative 在成功編譯好後，應該會看到同樣的資料夾位置出現 *.pb.go 的檔案，這就是編譯好後可以在 Golang 中使用 Protocol Buffer 和 gRPC 的檔案。\n實作 gRPC Server 對應的程式碼可檢視 besg-grpc repository 中的 server 資料夾。\nSTEP 1：建立 gRPC server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Server struct {} func main() { fmt.Println(\u0026#34;starting gRPC server...\u0026#34;) lis, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:50051\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v \\n\u0026#34;, err) } grpcServer := grpc.NewServer() calculatorPB.RegisterCalculatorServiceServer(grpcServer, \u0026amp;Server{}) if err := grpcServer.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v \\n\u0026#34;, err) } } STEP 2：實作 Protocol Buffer 中的 service 1 2 3 4 5 6 7 8 9 10 11 12 func (*Server) Sum(ctx context.Context, req *calculatorPB.CalculatorRequest) (*calculatorPB.CalculatorResponse, error) { fmt.Printf(\u0026#34;Sum function is invoked with %v \\n\u0026#34;, req) a := req.GetA() b := req.GetB() res := \u0026amp;calculatorPB.CalculatorResponse{ Result: a + b, } return res, nil } STEP 3：啟動 server 在終端機中輸入：\n1 go run server/server.go 即可啟動 gRPC server。\n補充：使用 Bloom RPC 進行測試 在只有 server 的情況下，可以使用 BloomRPC 這套工具來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。\n使用時只需要匯入 proto 檔後，即可看到對應可呼叫的方法和可帶入的參數，能這麼方便也是因為在 protocol buffer 中已經把傳輸的資料格式和能對應呼叫的方法都定好的緣故。\n實作 gRPC Client 完整程式碼可檢視 besg-grpc repository 中的 client 資料夾。\nSTEP 1：與 gRPC server 建立連線 1 2 3 4 5 6 7 8 9 10 11 12 func main() { conn, err := grpc.Dial(\u0026#34;localhost:50051\u0026#34;, grpc.WithInsecure()) if err != nil { log.Fatalf(\u0026#34;failed to dial: %v\u0026#34;, err) } defer conn.Close() client := calculatorPB.NewCalculatorServiceClient(conn) doUnary(client) } STEP 2：使用 Protocol Buffers 中定義好的 Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func doUnary(client calculatorPB.CalculatorServiceClient) { fmt.Println(\u0026#34;Staring to do a Unary RPC\u0026#34;) req := \u0026amp;calculatorPB.CalculatorRequest{ A: 3, B: 10, } res, err := client.Sum(context.Background(), req) if err != nil { log.Fatalf(\u0026#34;error while calling CalculatorService: %v \\n\u0026#34;, err) } log.Printf(\u0026#34;Response from CalculatorService: %v\u0026#34;, res.Result) } STEP 3：向 server 發送請求 在終端機中輸入：\n1 go run client/client.go 即可執行 client.go 並向剛剛起動好的 server 發送請求。\ngRPC 解決了什麼 gRPC 和 REST API 的比較 比較 gRPC 服務與 HTTP API @ microsoft docs\n簡單來說，gRPC 在效能上比起 REST API 好非常多：\n項目 gRPC Restful API 資料傳輸格式（Payload） Protocol Buffer - 更快且更小 JSON, XML, formData - 較慢且較大 通訊協定 HTTP/2 HTTP 傳輸方式 支援一般的「請求-回應」、伺服器端串流、Client 端串流、與雙向串流（streaming） 僅能透過 Client 發送請求、Server 給予回應 API 方法命名 沒有限制，一般會直接描述該方法要做的事，例如 createUser, getUser。不需要思考路由命名。 使用動詞（GET, POST, PUT, PATCH, DELETE）搭配資源來命名。需要根據不同的行為來定義不同的路由。 Client 呼叫 API 的方式 就像呼叫一般的函式 透過特定的 Endpoint，給予符合的資料型別 Server 建立 API 的方式 根據文件（Protocol Buffer）實作功能，不需要額外檢查資料型別與方法正確性。 根據文件（Swagger）實作功能，但須額外檢查資料型別。 根據文件產生程式碼 Protocol Buffers OpenAPI / Swagger 此外，gRPC 的 server，預設就是非同步的，因此不會阻塞任何進來的請求，並可以平行處理多個請求。gRPC Client 則可以選擇要用同步（阻塞）或非同步的方式處理。\n使用 Protocol Buffers 的好處 節省網路傳輸量：速度更快、檔案更小 節省 CPU 消耗：Parse JSON 本身是 CPU intensive 的任務；Parse Protocol Buffer（binary format）因為更接近底層機器表徵資料的方式，消耗的 CPU 資源較低 跨程式語言：Protocol Buffer 可以根據不同的程式語言編譯出不同的檔案 可以寫註解、型別清楚明確 TIP\n節省網路傳輸量和 CPU 消耗在行動裝置上的影響可能更重要。\n跨程式語言的好處 透過 Protocol Buffer 定義好資料的傳輸欄位（message）和呼叫的方法（service）後，gRPC 即可在不同程式語言上運行，這非常適合微服務（micro-services）的應用情境，只要雙方一起定義好 schema 後，就可以用不同的程式語言進行開發。\n使用 HTTP/2 的好處 HTTP/2 vs HTTP/1 - Performance Comparison? Demo：Performance difference between HTTP2 and HTTP1.1 瀏覽器允許的併發請求資源數是有限制的-分析 @ ITRead01 傳統的 HTTP/1.1 在每個 TCP 連線中只允許向 server 發送單一個請求，但當網頁載入時，往往會需要向同一個伺服器發送多個請求（例如、圖檔、CSS、靜態檔、JS 等），因此為了要避開這樣的限制、加快載入的速度，瀏覽器會實作多個平行的（parallel） TPC 連線（每個瀏覽器實作不同，因此數量的上限也不同），以處理同時向伺服器發出的多個請求。\n在 HTTP/2 中則可在同一個 TCP 連線中進行多個請求和回應，並且可以由 server 主動推送資源給 client，而並非一定要透過 client 主動請求；此外支援 HTTP Header 的壓縮，減少資料傳數量；HTTP/2 也是使用 binary 的方式在傳輸資料。\ngRPC 的四種類型 Unary：類似傳統 API，client 發送 request 而 server 回傳 response Server Streaming：透過 HTTP/2，client 發送一次 request，而 server 可以回傳多次資料 Client Streaming：client 發送多次資料，直到告知 server 資料傳完後，server 再給予 response Bi Directional Streaming：兩邊都用串流的方式傳送資料 圖片來源：gRPC Golang - Master Class: Build Modern API \u0026amp; MicroServices @ Udemy\n1 2 3 4 5 6 7 8 9 10 11 12 13 service GreetService { // Unary rpc Greet(GreetRequest) returns (GreetResponse) {}; // Streaming Server rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {}; // Streaming Client rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}; // Bi-directional Streaming rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {}; } gRPC 的缺點 Protocol Buffer 不像 JSON 是 Human Readable。 需要額外的學習時間和導入成本。 瀏覽器原生目前還不支援，須透過套件 grpc-web 來處理。 其他 推薦工具 BloomRPC：方便用來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。 錯誤排除 protoc-gen-go: program not found or is not executable\n1 2 # 需要把 $GOPATH/bin 加到 .zshrc/.bashrc 等 $ echo \u0026#39;export PATH=$PATH:$GOPATH/bin\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc 參考資料 Go Tutorial @ gRPC.io Introduction to gRPC @ gRPC.io Protocol Buffers @ Google Developer gRPC - Golang Master Class: Build Modern API \u0026amp; MicroServices @ Udemy 比較 gRPC 服務與 HTTP API @ Microsoft Docs ","date":"2022-07-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52276040314_2afa0e7026_o.png","permalink":"/2022-07-22/grpc-basic-introduction/","title":"gRPC 基本介紹"},{"content":" 參考網站 - JavaScript 資料結構與演算法：氣泡排序 Bubble Sort、插入排序 Insertion Sort 實作與分析 - 彭彭直播\n排序演算法 氣泡排序法(bubble sort) 概要 使用雙層迴圈，由後往前。 每輪固定最右邊的值，接著倆倆比較大小，將大的放右邊。 下輪則 - 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度 如果陣列長度是 4，要比對 3+2+1 總共 6 次。 如果陣列長度是 7，要比對 6+5+\u0026hellip;+1 總共 21 次。 如果陣列長度是 n，要比對 (n-1)+(n-2)+\u0026hellip;+1 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 可以加入一個 flag 來做判定，假設比較完第一輪發現沒有交換的情況發生，則代表已經排序完成，不需要再跑下一輪，即可稍微優化排序。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作氣泡排序演算法 function bubbleSort(arr){ // arr 是一個數字陣列 for(let i=arr.length-1;i\u0026gt;=1;i--){ let swap=false; // 假設沒有交換發生 for(let j=0;j\u0026lt;i;j++){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; swap=true; // 紀錄發生交換 } } if(!swap){ // 發現一整輪中都沒有交換發生，直接判定排序完成 break; } } } let data = [1, 6, 3, 4]; console.log(bubbleSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 插入排序法(insertion sort) 概要 使用雙層迴圈，由前往後。 從第二筆開始，每輪將該筆資料往前比較大小，將大的放右邊：每輪比較從 (i - 1) ~ 0。 下輪則 + 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度(複雜度同氣泡排序法) 如果陣列長度是 4，要比對 1+2+3 總共 6 次。 如果陣列長度是 7，要比對 1+2+\u0026hellip;+6 總共 21 次。 如果陣列長度是 n，要比對 1+2+\u0026hellip;+(n-1) 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 假設當前比對的值與第一個要比較的值一比較，恰好正確，則代表前面皆已經排序完成，可以進到下一輪。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 實作插入排序演算法 function insertionSort(arr){ // arr 是一個數字陣列 for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i-1;j\u0026gt;=0;j--){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 [arr[j], arr[j+1]]=[arr[j+1], arr[j]]; // javascript 交換的語法糖 }else{ // 任何一次比較，發現順序對了，這一輪就不用繼續了 break; } } } } let data = [1, 6, 3, 4]; console.log(insertionSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 大型資料量的進階探討 O(N²)：(讀作 big-O N平方) 是相當可怕的，排序的執行時間將會是資料量的平方倍數成長。\n演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 產生隨機資料 let data=[]; for(let i=0;i\u0026lt;100000;i++){ data.push(Math.random()*1000000); } // 資料量是 100,000，我的演算法時間複雜度是 O(N^2)，預期要花 100,000^2 = 10,000,000,000 次的比較運算 // 我們的電腦一秒鐘跑 10 億個指令(粗略預估 1 GB) console.time(); // 插入排序法，大約跑了10幾秒 //insertionSort(data); // 使用 JavaScript 內建的排序功能 sort()，大約跑了 0.2 ~ 0.3 秒 // 很有機會是使用快速排序 Quick Sort(快速排序法) 或其變形 data.sort(); console.timeEnd(); ","date":"2022-07-21T00:00:00Z","image":"/2022-07-21/bubble-sort-and-insertion-sort/hqdefault_huc19c1d5e8083f3ca093a0303b2a8247b_19175_120x120_fill_q75_box_smart1.jpg","permalink":"/2022-07-21/bubble-sort-and-insertion-sort/","title":"彭彭的課程 - 氣泡排序、插入排序的實作與分析"},{"content":" 參考網站 - 尚硅谷Vue3技術\n創建 Vue 3.0 工程 使用 vue cli 創建 官方文檔：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 1 2 3 4 5 6 7 8 9 10 11 12 ## 查看 @vue/cli 版本，確保 @vue/cli 版本在 4.5.0 以上 vue --version ## 安裝或升級你的 @vue/cli npm install -g @vue/cli ## 創建 vue create vue_test ## 啟動 cd vue_test npm run serve 使用 vite 創建(Vue作者的團隊開發) 官方文檔：https://v3.cn.vuejs.org/guide/installation.html#vite vite官網：https://vitejs.cn/ 優勢： 開發環境中，無需打包操作，可快速的冷啟動。 輕量快速的熱重載(HMR)。 真正的按需編譯，不再等待整個應用編譯完成。 傳統 grunt、gulp、webpack 與 vite 構建對比圖： 1 2 3 4 5 6 7 8 9 10 11 ## 創建工程 npm init vite-app \u0026lt;project-name\u0026gt; ## 進入工程目錄 cd \u0026lt;project-name\u0026gt; ## 安裝依賴 npm install ## 啟動 npm run dev 安裝 Vue 開發者工具 Vue.js devtools\n拉開序幕的 Setup Vue3.0 中一個新的配置項，值為一個函數。 是所有 Composition API (組合式API) 的表演舞台。 組件中所用到的數據、方法等等，均要配置在 setup 中。 setup 函數的： 若返回一個對象，則對象中的屬性、方法，在模板中均可直接使用。(重點關注!) 若返回一個渲染函數，則可以自定義渲染內容。(了解即可) 返回對象 1 2 3 4 5 6 7 8 export default { setup() { const name = \u0026#34;測試\u0026#34; return { name } } } 返回渲染函數(需引入 h ) 1 2 3 4 5 6 import { h } from \u0026#34;vue\u0026#34; export default { setup() { return () =\u0026gt; { return h(\u0026#39;h1\u0026#39;, \u0026#39;尚硅谷\u0026#39;)} } } 注意： 不要與Vue2.x配置混用。 Vue2.x配置(data、methods、computed\u0026hellip;)中可以訪問到setup中的屬性、方法，但在setup中不能訪問到Vue2.x配置(data、methods、computed\u0026hellip;)。 如果有重名，setup優先。 setup 不能是一個 async 函數，因為返回值不再是 return 的對象，而是一個 promise，模板看不到 return 對象中的屬性；後期可以返回一個 Promise 實例，但需要 Suspense 與 異步組件(動態組件) 的配合：點我前往 Suspense ref 函數 作用：定義一個響應式的數據。 語法： 1 const xxx = ref(initValue) 將數據加工成一個 RefImpl (Reference: 引用；Implete: 實現) = (引用實現的實例對象)。 js 中操作數據：xxx.value。 模板中讀取數據：\u0026lt;div\u0026gt;{{xxx}}\u0026lt;/div\u0026gt; 備註： 接收的數據可以是基本類型，也可以是對象類型。 基本類型的數據：響應式依然是靠 Object.defineProperty() 的 get 與 set 完成的。 對象類型的數據：內部求助了 Vue3.0 中的一個新函數\u0026mdash;- reactive reactive 函數 作用：定義一個對象類型的響應式數據(基本類型別用他，用ref函數)。 語法： 1 2 3 4 const xxx = reactive({ name: \u0026#34;測試\u0026#34;, age: 18 }) 接收一個對象或數組，返回一個代理對象(Proxy對象)。 reactive 定義的響應式數據是深層次的。 內部基於 ES6 的 Proxy 實現，通過代理對象操作源對象內部數據都是響應式的，並通過 Reflect 操作源對象內部的數據。 js、模板中操作數據均不需要 .value Vue 2.0 中的響應式原理 實現原理： 對象類型：通過 Object.defineProperty() 對屬性的讀取、修改進行攔截(數據劫持)。 數組類型：通過重寫更新數組的一系列方式來實現攔截。(對數組的變更方法進行了包裹)。 1 2 3 4 5 6 7 8 Object.defineProperty(data, \u0026#34;count\u0026#34;, { get() { }, set() { } }) 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue2 中實現響應式 let p = {} Object.defineProperty(p, \u0026#34;name\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 name 時調用 return person.name }, set(value) { console.log(\u0026#34;有人修改了 name 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.name = value } }) Object.defineProperty(p, \u0026#34;age\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 age 時調用 return person.age }, set(value) { console.log(\u0026#34;有人修改了 age 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.age = value } }) 存在問題： 新增屬性、刪除屬性，介面不會更新，需使用 $set、$delete。 直接通過下標修改數組，介面不會更新，需使用 $set、$delete。 問題情況演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { data() { return { person: { name: \u0026#34;張三\u0026#34;, age: 18, hobby: [\u0026#34;學習\u0026#34;, \u0026#34;吃飯\u0026#34;] } } }, methods: { addSex() { this.person.sex = \u0026#34;女\u0026#34; // 此時畫面不會更新 this.$set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 Vue.set() // Vue.set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) }, deleteName() { delete this.person.name // 此時畫面不會更新 this.$delete(this.person, \u0026#34;name\u0026#34;) // 需使用 $delete 畫面才會更新 // 或是使用 Vue.delete() // Vue.delete(this.person, \u0026#34;name\u0026#34;) }, updateHobby() { this.person.hobby[0] = \u0026#34;逛街\u0026#34; // 此時畫面不會更新 this.$set(this.person.hobby, 0, \u0026#34;逛街\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 splice() // this.person.hobby.splice(0, 1, \u0026#34;逛街\u0026#34;) } } } Vue 3.0 中的響應式原理 實現原理： 通過 Proxy(代理)：攔截對象中任意屬性的變化，包含屬性值的讀寫、屬性的新增、屬性的刪除等。 通過 Reflect(反射)：對被代理對象的屬性進行操作。 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue3 中實現響應式 const p = new Proxy(person, { // 有人讀取p的某個屬性時調用 get(target, propName) { console.log(`有人讀取了p身上的${propName}屬性`) return Reflect.get(target, propName) }, // 有人新增或修改p的某個屬性時調用 set(target, propName, value) { console.log(`有人修改了p身上的${propName}屬性，我要去更新介面了！`) Reflect.set(target, propName, value) }, // 有人刪除p的某個屬性時調用 deleteProperty(target, propName) { console.log(`有人刪除了p身上的${propName}屬性，我要去更新介面了！`) return Reflect.deleteProperty(target, propName) } }) setup 的兩個注意點 setup 執行的時機：在 beforeCreate 之前執行一次，this 是 undefined。 setup 的參數 props：值為對象，包含：組件外部傳遞過來，且組件內部聲明接收了的屬性。 context：上下文對象： attrs：值為對象，包含：組件外部傳遞過來，但沒有在 props 配置中聲明的屬性，相當於 Vue 2.0 的 this.$attrs。 slots：接收的插槽內容，相當於 Vue 2.0 的 this.$slots。 emit：分發自定義事件的函數，相當於 Vue 2.0 的 this.$emit。 watch 函數 與 Vue 2.0 中的 watch 配置功能一致。 兩個小\u0026quot;坑\u0026quot;： 監視 ref 定義的響應式數據時，不需加 .value。 監視 reactive 定義的響應式數據時，oldValue 無法正確捕獲、強制開啟了深度監視(deep配置失效)。 監視 reactive 定義的響應式數據中的某個屬性時，deep 配置有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import { ref, reactive, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(10) const msg = ref(\u0026#34;測試\u0026#34;) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 情況一：監視 ref 定義的響應式數據 watch(sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況二：同時監視多個 ref 定義的響應式數據 watch([sum, msg], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum或msg變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) /* * 情況三：監視 reactive 定義的響應式數據的全部屬性 * 1. 注意: 此數無法正確的獲取 oldValue * 2. 注意: 強制開啟了深度監視(deep配置無效) */ watch(person, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: false }) // 此處的 deep 配置無效 // 情況四：監視 reactive 定義的響應式數據的某個屬性 watch(() =\u0026gt; person.name, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況五：監視 reactive 定義的響應式數據的某些屬性 watch([() =\u0026gt; person.name, () =\u0026gt; person.age], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name或age變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 特殊情況：監視 reactive 定義的響應式數據的某些對象屬性 watch(() =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的job變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: true }) // 此處由於監視的是 reactive 所定義的對象中的某個屬性，所以 deep 配置有效 return { sum, msg } } } watch 時 value 的問題 若監視的數據為 ref 求助 reactive 生成的響應式數據，則可使用以下兩種方式進行監視： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { ref, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = ref({ name: \u0026#34;張三\u0026#34;, name: 18, job: { job1: { salary: 20 } } }) watch(sum, (newValue, oldValue) =\u0026gt; { // 監視的是 sum 這個 RefImpl 數據，因此不需要 .value console.log(\u0026#34;sum的值變化了\u0026#34;, newValue, oldValue) }) // 方法一: watch(person.value, (newValue, oldValue) =\u0026gt; { // 監視 person.value 的 Proxy 對象 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }) // 方法二: watch(person, (newValue, oldValue) =\u0026gt; { // 深度監視 person 的 Proxy 對象的屬性 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }, { deep: true }) return { person } } } watchEffect 智能版 watch，不用指名監視哪個屬性，監視的回調中用到哪個屬性，就監視哪個屬性(而且是深層次的)。 watchEffect 有點像 computed： 但 computed 注重計算出來的值(回調函數的返回值)，所以必須要寫返回值。 而 watchEffect 更注重的是過程(回調函數的函數體)，所以不用寫返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { ref, reactive, watchEffect } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) watchEffect(() =\u0026gt; { const x1 = sum.value const x2 = person.job.job1.salary console.log(\u0026#34;watchEffect 配置的回調執行了\u0026#34;) }) } } 自定義 hook 函數 hook 本質是一個函數，把 setup 函數中使用的 Composition API 進行了封裝。 類似於 vue 2.0 中的 mixin。 自定義 hook 的優勢：重複使用代碼，讓 setup 中的邏輯更清楚易懂。 命名通常建議以 \u0026ldquo;use\u0026rdquo; 開頭，例如： 一個獲取鼠標點擊位置的 hook src/hooks/usePoint.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { reactive, onMounted, onBeforeUnmount} from \u0026#34;vue\u0026#34; export default function() { // 獲取鼠標點擊位置 相關的數據 let point = reactive({ x: 0, y: 0 }) // 獲取鼠標點擊位置 相關的方法 function savePoint(event) { console.log(event.pageX, event.pageY) point.x = event.pageX point.y = event.pageY } // 獲取鼠標點擊位置 相關的生命週期鉤子 onMounted(() =\u0026gt; { window.addEventListener(\u0026#34;click\u0026#34;, savePoint) }) onBeforeUnmount(() =\u0026gt; { window.removeEventListener(\u0026#34;click\u0026#34;, savePoint) }) return point } Demo.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 import usePoint from \u0026#34;@/hooks/usePoint\u0026#34; export default { name: \u0026#34;Demo\u0026#34;, setup() { // 使用自定義的 hook const point = usePoint() return { point } } } toRef 作用：創建一個 ref 對象，其 value 值指向(引用)另一個對象中的某個屬性(返回值為一個 ObjectRefImpl 對象，為響應式)。 語法： 1 const name = toRef(person, \u0026#34;name\u0026#34;) 應用：要將響應式對象中的某個屬性單獨提供給外部使用時。 擴展：toRefs 與 toRef 功能一致，但可以批量創建多個 ref 對象，語法： 1 toRefs(person) 使用範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { reactive, toRef, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) const name1 = person.name // name1 僅為賦值，無響應式 const name2 = toRef(person, \u0026#34;name\u0026#34;) // name2 的值會指向(引用) person 的 name return { // errors： // name1: person.name, // 僅為賦值，無響應式 // name2: ref(person.name) // 初始值正常，但修改時不會改到 person 的 name，因為此寫法僅是將 \u0026#34;ref(pserson.name)\u0026#34; 賦值給 name2，而非將 name2 指向 person 的 name // success： // 模板中使用 {{ person.name }}...等： // person, // 一個一個給出，模板中使用 {{ name }}...等： // name: toRef(person, \u0026#34;name\u0026#34;), // age: toRef(person, \u0026#34;age\u0026#34;), // salary: toRef(person.job.job1, \u0026#34;salary\u0026#34;) // 一次全給出，模板中可直接使用 {{ name }}、{{ age }}、{{ job.job1.salary }} ...toRefs(person) } } } 其他的 Composition API 1. shallowReactive 與 shallowRef shallow：淺層的 shallowReactive：只處理對象最外層屬性的響應式(淺響應式)。 shallowRef：只處理基本數據類型的響應式，不進行對象的響應式處理。 什麼時候使用？ 如果有一個對象數據，結構比較深，但變化時只是外層屬性變化 =\u0026gt; shallowReactive。 如果有一個對象數據，後續功能不會修改該對象中的屬性，而是生成新的對象來替換 =\u0026gt; shallowRef。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { shallowRef, shallowReactive, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = shallowReactive({ // 只考慮第一層數據的響應式 name: \u0026#34;張三\u0026#34;, // 響應式 age: 18, // 響應式 job: { // 非響應式 job1: { salary: 20 } } }) let x = shallowRef({ // 基本類型時同 ref，但對象類型不是響應式(value 會變成一般的 Object 而不是 Proxy ) y: 0 }) return { x, ...toRefs(person) } } } 2. readonly 與 shallowReadonly readonly：讓一個響應式數據變為唯讀的(深層唯讀)。 shallowReadonly：讓一個響應式數據變為唯讀的(淺層唯讀)。 應用場景：不希望數據被修改時。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { ref, reactive, toRefs, readonly, shallowReadonly} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 將 sum 變為唯讀，保護數據不被修改 sum = readonly(sum) // 將 person 的所有屬性變為唯讀，保護所有屬性數據不被修改 person = readonly(person) // 將 person 的\u0026#34;第一層屬性數據\u0026#34;變為唯讀(name、age無法修改，但 job 可以) person = shallowReadonly(person) return { sum, ...toRefs(person) } } } toRaw 與 markRaw raw：原始。 toRaw： 作用：將一個由 reactive 生成的響應式對象轉為普通對象。 應用場景：用於讀取響應式對象對應的普通對象，對這個普通對象的所有操作，不會引起頁面更新。 markRaw： 作用：標記一個對象，使其永遠不會再成為響應式對象。 應用場景： 有些值不應被設置為響應式的，例如複雜的第三方類庫等。 當渲染具有不可變數據源的大列表時，跳過響應式轉換可以提高性能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { ref, reactive, toRaw, markRaw} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) function showRawPerson() { const p = toRaw(person) console.log(p) // 返回的不再是 Proxy，而是 Object } function addCar() { let car = { name: \u0026#34;奔馳\u0026#34;, price: 40} person.car = markRaw(car) // 標記 person.car 不是響應式的數據(數據依舊可修改，但畫面不會變) } return { sum, ...toRefs(person), showRawPerson, addCar } } } customRef 作用：創建一個自定義的 ref，並對其依賴項跟蹤和更新觸發進行顯示控制。 實現防抖效果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt; {{ keyWord }} \u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, customRef } from \u0026#34;vue\u0026#34; export default { setup() { // 使用 vue 提供的 ref // let keyWord = ref(\u0026#34;hello\u0026#34;) // 自定義的一個 ref function myRef(value, delay) { let timer return customRef((track, trigger) =\u0026gt; { return { get() { console.log(`有人從 myRef 這個容器中讀取數據了，我把${value}給他了`) track() // 通知 Vue 追蹤數據的變化(提前與 get 商量一下，讓它認為這個 value 是有用的) return value }, set(newValue) { console.log(`有人把 myRef 這個容器中的數據改為了${newValue}`) clearTimeout(timer) timer = setTimeout(() =\u0026gt; { value = newValue trigger() // 通知 Vue 去重新解析模板，以便觸發 get }, delay) } } }) } // 使用自定義的防抖 ref let keyWord = myRef(\u0026#34;hello\u0026#34;, 500) return { keyWord } } } \u0026lt;/script\u0026gt; provide 與 inject 作用：實現祖孫組件間通信。 套路：父組件有一個 provide 選項來提供數據，後代組件有一個 inject 選項來開始使用這些數據。 具體寫法： 1. 祖組件中： 1 2 3 4 5 6 7 8 9 10 11 12 import { reactive, toRefs, provide } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;App\u0026#34;, setup() { let car = reactive({ name: \u0026#34;奔馳\u0026#34;, price: \u0026#34;40W\u0026#34; }) provide(\u0026#34;car\u0026#34;, car) // 給自己的後代組件傳遞數據 return { ...toRefs(car) } } } 2. 後代組件中： 1 2 3 4 5 6 7 8 9 import { inject } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;Son\u0026#34;, setup() { let car = inject(\u0026#34;car\u0026#34;) console.log(car) return { car } } } 響應式數據的判斷 isRef：檢查一個值是否為一個 ref 對象。 isReactive：檢查一個對象是否是由 reactive 創建的響應式代理。 isReadonly：檢查一個對象是否是由 readonly 創建的唯讀代理。 isProxy：檢查一個對象是否是由 reactive 或是 readonly 方法創建的代理。 Teleport teleport：傳送、瞬間移動。 作用：能夠將我們的 組件 html 結構 移動到指定的位置。 具體寫法： 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;!-- to 也能寫 css select，例如 to=\u0026#34;#app\u0026#34; --\u0026gt; \u0026lt;div v-if=\u0026#34;isShow\u0026#34; class=\u0026#34;mask\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;h3\u0026gt; 我是一個彈窗 \u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt; 關閉彈窗 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; Suspense suspense：懸疑、懸而未決的。 作用：等待異步組件時，渲染一些額外內容，讓使用者有更好的用戶體驗。 使用步驟： 異步引用組件 1 2 import { defineAsyncComponent } from \u0026#34;vue\u0026#34; // 宣告異步組件時使用 const Child = defineAsyncComponent(() =\u0026gt;. import (\u0026#34;./components/Child.vue\u0026#34;)) 使用 Suspense 包裹組件，並配置好 default 與 fallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App組件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加載中......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 全局 API 的轉移 Vue 2.0 有許多全局 API 和配置。 例如：註冊全局組件、註冊全局指令等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 註冊全局組件 Vue.component(\u0026#34;MyButton\u0026#34;, { data() { return { count: 0 } }, template: \u0026#34;\u0026lt;button @click=\u0026#39;count++\u0026#39;\u0026gt;Clicked {{ count }}\u0026lt;/button\u0026gt;\u0026#34; }) // 註冊全局指令 Vue.directive(\u0026#34;focus\u0026#34;, { inserted: el =\u0026gt; el.focus() }) Vue 3.0 中對這些 API 做出了調整： 將全局的 API，即： Vue.xxx 調整到應用實例(app)上 2.0 全局 API(Vue) 3.0 實例 API(app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties ","date":"2022-07-17T00:00:00Z","image":"/2022-07-17/atguigu-vue3-note/index_huc185496ed55e6f95ddd80689badb475a_232407_120x120_fill_q75_box_smart1.jpeg","permalink":"/2022-07-17/atguigu-vue3-note/","title":"尚硅谷 Vue3 視頻筆記"},{"content":"Markdown 是讓你快速撰寫筆記，流暢管理知識，支援多種衍生功能的生產力工具\n標題 當您想要將一段文字標示為標題的時候，請使用這個語法。\n請在行首輸入 # 符號，並在後面加上一個空白後，再輸入標題文字。\n標題有分成 6 個層級，# 的數量愈多，層級越低。\n1 2 3 4 5 6 # 第一層級標題 h1 ## 第二層級標題 h2 ### 第三層級標題 h3 #### 第四層級標題 h4 ##### 第五層級標題 h5 ###### 第六層級標題 h6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-16T00:00:00Z","image":"/2022-07-16/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"/2022-07-16/markdown-syntax/","title":"Markdown 語法指南"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"/2019-03-08/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"/2019-03-05/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"/2019-03-05/emoji-support/","title":"Emoji Support"}]