[{"content":" 參考文章 CORS跨域與Nginx反向代理 CORS on Nginx Nginx解决CORS跨域解决方案 在 Nginx 的 ProxyPass Upstream 設定 CORS （跨來源資源共享） CORS跨域 跨域資源共享 - CORS 跨域資源共享(CORS)是一種機制，它使用額外的 HTTP 頭來告訴瀏覽器，讓運行在一個 origin (domain) 上的Web應用被准許訪問來自不同源服務器上的指定的資源。當一個資源從與該資源本身所在的服務器不同的域、協議或端口請求一個資源時，資源會發起一個跨域 HTTP 請求。\n比如，站點 http://domain-a.com 的某 HTML 頁面通過 \u0026lt;img\u0026gt; 的 src 請求 http://domain-b.com/image.jpg。網絡上的許多頁面都會加載來自不同域的CSS樣式表，圖像和腳本等資源。\n出於安全原因，瀏覽器限制從腳本內發起的跨源HTTP請求。例如，XMLHttpRequest和Fetch API遵循同源策略。這意味著使用這些API的Web應用程序只能從加載應用程序的同一個域請求HTTP資源，除非響應報文包含了正確CORS響應頭。\n跨域時部分瀏覽器預設不攜帶cookie，因此為了攜帶cookie需要在前端設定xmlhttprequest的withCrendetalls屬性。 「同源」定義 「同源」定義很簡單，以下三個參數都相同：\n1 [protocol]://[domain]:[port] 白話說，當你在 https://www.example.com/product.html 頁面\n嘗試對以下路徑發出請求，都違反同源：\nhttp://www.example.com/api/products/40.json https://www.example2.com/api/products/40.json https://www.example.com:8080/api/products/40.json 乖孩子遵守同源，不會被打：\nhttps://www.example.com/api/products/40.json 簡單請求和複雜請求 簡單請求與複雜請求的差別是複雜請求會自動發出一個 OPTIONS 的預檢請求，當請求得到確認後，才開始真正發送請求。\n綜上，我們要解決兩個問題：\nOPTIONS 請求的正確響應 跨域請求正確響應 OPTIONS 請求的正確響應 參考網址\n解決的方式有多種，既可以在Web Server解決，也可以在源碼層解決。因為問題比較普遍，故我們選擇在Web Server解決，下面我們以 Nginx 為例，說明解決方案。 假設訪問的地址為 /example , Nginx 配置如下: 1 2 3 4 5 6 7 location /example { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 為了解決跨域問題，添加如下內容: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 location /example { + if ($request_method = \u0026#39;OPTIONS\u0026#39;) { + add_header Access-Control-Allow-Origin *; + add_header Access-Control-Max-Age 1728000; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; + add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; + add_header Content-Length 0 ; + return 204; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($request_method = 'OPTIONS') {...} 當請求方法為 OPTIONS 時:\n添加允許源 Access-Control-Allow-Origin 為 * (可根據業務需要更改) 添加緩存時長 Access-Control-Max-Age，當下次請求時，無需再發送 OPTIONS 請求 添加允許的方法，允許的首部 添加一個內容長度為0，類型為 text/plain; charset=utf-8 , 返回狀態碼為 204 的首部 至此，完成 OPTIONS 請求的正確響應。\n跨域請求正確響應 添加如下內容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 location /example { if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header Access-Control-Allow-Origin *; add_header Access-Control-Max-Age 1728000; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; add_header Content-Length 0 ; return 204; } + if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) { + add_header Access-Control-Allow-Origin $http_origin; + add_header Access-Control-Allow-Credentials true; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Expose-Headers Content-Length,Content-Range; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) {...}，當 origin 為合法域名(可根據業務調整或去除合法域名驗證)時:\n添加允許源 Access-Control-Allow-Origin 為 $http_origin (可根據業務需要更改) 添加允許認證 Access-Control-Allow-Credentials 為 true ，允許接收客戶端 Cookie(可根據業務需要更改。 但要注意，當設置為true時，Access-Control-Allow-Origin 不允許設置為 *) 添加允許的方法，暴露的首部 至此，完成跨域請求正確響應。\n以上，是對跨域請求在Web Server的解決方案，主要是通過響應 OPTIONS 方法和添加允許源來解決。\n當然，如果本地開發中，可以在利用 webpack-dev-server 的 proxy 選項來快速解決跨域問題：\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // webpack.congf.js module.exports = { //... devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, pathRewrite: {\u0026#39;^/api\u0026#39; : \u0026#39;\u0026#39;} } } } } 當訪問地址如 /api/foo?q=bar 時，則通過代理訪問的實際地址是: http://localhost:3000/foo?q=bar。\nNginx反向代理 nginx反向代理，通過修改nginx配置檔案實現反向代理，請求統一通過nginx分發請求\nNginx配置（192.168.75.139） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 負載均衡 upstream my_site { server 192.168.75.138:8080; server 192.168.75.137:8080; server 192.168.75.136:8080; } server { listen 8081; server_name localhost; location ^~ /api/ { proxy_pass http://my_site/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location = / { proxy_pass http://my_site/nginx/indexNginxCrossQuest.jsp; } location = /nginx/ { proxy_pass http://my_site/nginx/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location ~ \\.(html|htm|ico|png|jpg|jpeg|js|css|bmp)$ { proxy_pass http://my_site; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 瀏覽器請求（192.168.75.1） 綜合對比 CORS Nginx反向代理 前端程式碼配置 credentials=true 無 後端程式碼配置 setHeader：Allow-Origin、Allow-Methods等 無 服務端配置 無 Nginx配置 移植靈活性 高、無額外配置 低、每增加一個環境都需要增加配置 安全性 高、來源可控、直接追溯 X-Forwarded-For追溯多級來源 安全控制 黑白名單 更新配置 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305241864_c3ef911be4_o.jpg","permalink":"/2022-08-23/nginx-cors-and-reverse-proxy/","title":"nginx CORS 跨域與反向代理"},{"content":" 參考文章 IT Note SSL憑證教學 - xoops 免費SSL憑證申請 nginx config產生器 Qualys 的 SSL 伺服器測試工具 版本一 步驟 1 - 下載安裝及執行的腳本 1 2 3 wget https://dl.eff.org/certbot-auto --no-check-certificate chmod +x ./certbot-auto ./certbot-auto -n 生成證書，只需要輸入郵件地址和網站根目錄，提示以下內容，說明安裝完成 1 2 3 Saving debug log to /var/log/letsencrypt/letsencrypt.log Missing command line flags. For non-interactive execution, you will need to specify a plugin on the command line. Run with \u0026#39;--help plugins\u0026#39; to see a list of options, and see https://eff.org/letsencrypt-plugins for more detail on what the plugins do and how to use them. 步驟 2 - nginx設定隱藏目錄訪問 1 2 3 location ~ /.well-known { allow all; } 步驟 3 - 生成域名證書 1 ./certbot-auto certonly --email tony@hack.idv.tw --agree-tos --no-eff-email --webroot -w /var/www/ -d hack.idv.tw 到目錄內查看 1 cd /etc/letsencrypt/live/ 萬用字元的申請指令 (需要驗證dns) 1 certbot-auto certonly -d *.manpc.tk --manual --preferred-challenges dns 步驟 4 - 設定nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 server { listen 80; # IPv4 listen [::]:80; server_name hack.idv.tw ; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; #rewrite ^(.*) https://$host$1 permanent; return 301 https://www.itnotetk.com$request_uri; #跳轉到Https } server { listen 443 ssl http2; server_name hack.idv.tw ; ssl on; ssl_certificate /etc/letsencrypt/live/hack.idv.tw/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/hack.idv.tw/privkey.pem; client_max_body_size 256m; ssl_dhparam /etc/nginx/certs/dhparam.pem; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_stapling on; ssl_ciphers \u0026#34;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\u0026#34;; ssl_prefer_server_ciphers on; #add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains; preload\u0026#34;; add_header Strict-Transport-Security \u0026#34;max-age=31536000; includeSubDomains;preload\u0026#34; always; # ... Let\u0026rsquo;s Encrypt憑證只有90天 需要手動續約 1 0 1 * * * /root/certbot-auto renew --disable-hook-validation --renew-hook \u0026#34;/etc/init.d/nginx reload\u0026#34; 版本二 網路出處\nLet’s Encrypt 是一家新的證書頒發機構（Certificate Authority，簡稱 CA），其提供免費的 TLS/SSL 憑證再配合 Certbot 這個自動化工具，讓一般的網站可以很容易地使用 HTTPS 的安全加密網頁，設定很簡單，憑證的更新也可以自動處理。 以下我以 Ubuntu Linux 14.04 的系統為例，示範 nginx 伺服器使用 Let’s Encrypt 憑證設定 HTTPS 安全加密網頁的方法。 步驟 1 - 從 Certbot 官方網站下載 certbot-auto 指令稿，並設定其執行權限 1 2 wget https://dl.eff.org/certbot-auto chmod a+x certbot-auto certbot-auto 要放在哪裡都可以，建議一開始就找一個適合的地方放好，例如建立一個 /opt/letsencrypt 目錄，把 certbot-auto 放在這裡 1 2 mkdir /opt/letsencrypt mv certbot-auto /opt/letsencrypt/ 步驟 2 - 執行 certbot-auto ，讓它自動安裝所有相依套件 1 /opt/letsencrypt/certbot-auto 執行 certbot-auto 時，會需要輸入密碼取得 root 權限 步驟 3： 安裝完成所有需要的系統套件後，接著我們要透過 webroot 的方式，使用既有的 nginx 網頁伺服器來向 Let’s Encrypt 取得憑證，而在認證的過程會需要在網頁根目錄中建立一個 .well-known/acme-challenge/ 目錄，讓 Let’s Encrypt 的伺服器來讀取其中的內容。 一般的 nginx 伺服器通常會設定把句點開頭的隱藏檔案都擋掉，遇到這樣的狀況就會無法進行認證，這時候可以再加一小段設定，讓 .well-known/acme-challenge/ 目錄可以被正常讀取。 1 2 3 4 5 6 location ^~ /.well-known/acme-challenge/ { # the usual settings } location ~ /\\. { deny all; } 步驟 4 - 使用 certonly 功能下載憑證 1 /opt/letsencrypt/certbot-auto certonly --webroot -w /var/www/blog.gtwang.org/ -d blog.gtwang.org -d gtwang.org 步驟 5 - 輸入自己的 Email 信箱 步驟 6 - 閱讀使用條款，選擇「Agree」繼續 步驟 7 - 下載完成後，會出現類似這樣的成功訊息 1 2 3 4 5 6 7 8 IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem. Your cert will expire on 2016-08-13. To obtain a new version of the certificate in the future, simply run Certbot again. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let\u0026#39;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 這樣就成功取得 Let’s Encrypt 的憑證了，而 nginx 用的憑證就儲存在 /etc/letsencrypt/live/blog.gtwang.org/ 目錄之下，其中 fullchain.pem 就是 nginx 需要憑證，而 privkey.pem 則是需要保護好的私鑰，關於憑證檔案的詳細說明，請參考 Certbot 的說明文件。 Certbot 還有提供另外一個 standalone 的方式來向 Let’s Encrypt 取得憑證，這種方式是由 Certbot 建立一個獨立的網頁伺服器，提供 Let’s Encrypt 讀取驗證用的資料，不過這樣的做法需要綁定 80 或 443 連接埠，所以通常還會需要暫停既有的網頁伺服器，對於一般的網站而言，會造成網站有幾秒鐘的斷線現象，所以我個人不喜歡這樣的方式。 接下來要設定 nginx 伺服器，使用這個新憑證來提供 HTTPS 的安全加密網頁。 步驟 8 - 要讓 nginx 啟用 HTTPS 安全加密網頁，只要加上 SSL 相關的幾行設定即可，其餘的設定保持不變，以下是我個人使用的 nginx 伺服器設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server { # 傾聽 HTTPS 標準埠號 443 listen 443; # 同時啟用 IPv6 的 HTTPS 安全加密網頁 listen [::]:443; server_name blog.gtwang.org; root /var/www/blog.gtwang.org/; index index.php index.html index.htm; # 啟用 SSL ssl on; # 設定 SSL 憑證 ssl_certificate /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.gtwang.org/privkey.pem; # 其他 SSL 選項 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # omit SSLv3 because of POODLE (CVE-2014-3566) ssl_ciphers \u0026#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS\u0026#39;; ssl_prefer_server_ciphers on; # ... } ssl_protocols 的部分記得要 把SSLv3拿掉 ，避免 POODLE 攻擊（CVE-2014-3566）。 步驟 9 - 設定好之後，檢查一下設定檔是否正確 1 service nginx configtest 步驟 10 - 確認無誤之後，重新載入設定檔 1 service nginx reload 這樣就完成 nginx 伺服器的設定了，接著就可以開啟 HTTPS 加密的網址來測試了，正常來說，使用 Google Chrome 瀏覽器開啟自己主機的 HTTPS 加密網址，應該就會顯示一個綠色的鎖頭，這樣就代表我們安裝的 SSL 憑證是有效的。 Let’s Encrypt 的憑證使用期限只有三個月，在憑證到期前的一個月可以使用 certbot-auto 來更新憑證，在實際更新之前我們可以加入 --dry-run 參數，先進行測試。 1 /opt/letsencrypt/certbot-auto renew --dry-run 若測試沒問題，就可以使用正式指令來更新 1 /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade 而為了方便起見，可以將這個更新指令寫在 /opt/letsencrypt/renew.sh 指令稿中 1 2 #!/bin/sh /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade --post-hook \u0026#34;service nginx reload\u0026#34; 這裡我又加上一個 --post-hook 的設定，讓憑證更新完後，可以自動重新載入 nginx 伺服器的設定，讓憑證生效。\n接著把這個 /opt/letsencrypt/renew.sh 指令稿寫進 crontab 中\n1 2 # m h dom mon dow command 30 2 * * 0 /opt/letsencrypt/renew.sh 官方的建議是這個指令可以一天執行兩次，讓伺服器的憑證隨時保持在最新的狀態，這裡我是設定讓伺服器每週日凌晨兩點半進行憑證的檢查與更新，Certbot 只有在憑證到期前一個月才會進行更新，如果憑證尚未到期，就不會更新 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305205270_220313b3c4_o.png","permalink":"/2022-08-23/nginx-ssl-with-lets-encrypt/","title":"nginx 設定 ssl ＋ 自動續約 Let’s Encrypt 免費域名證書"},{"content":" 本文翻譯自：LINK BUILDING FOR SEO:The Definitive Guide (2022)\n這是一篇完整的 2022 年連結優化指南。\n因此，如果你想要取得權威網站的反向連結。\n你將會在這篇新指南中，享受本文可操作的技巧。\n讓我們往深入其中吧。\n第 1 章：連結優化基礎 在本章節，我將向你解答此問題：「什麼是連結建立？」\n同時，我也會向你展現為何連結建立，在 2022 年的今天仍然很重要。\n讓我們開始吧！\n什麼是連結建立？ 「連結建立」是一種打造單向超連結（又名反向連節），到另一個網站的方法。\n希望藉此改善網站的搜尋引擎能見度。\n常見的連結優化策略包含內容行銷、建立有用的工具、電子郵件推廣、破損連結優化與公共關係。\n為什麼連結這麼重要？ 若要理解它，你將需要跳上時光機，並重返早期網路時代的 Google 。\n在過去的日子，搜尋引擎如 Yahoo！與 Alta Vista 是主要支配者。\n他們排序搜尋結果的方式，100% 是基於網頁上的內容\n輸入：Google\n現今他們知名的 PageRank 演算法改變了這場遊戲。\nGoogle 不是單純分析網頁的內容，而是查看有多少人連結到該頁面。\n而他們是正確的。\n在接近 20 年以後，連結仍然是衡量網頁品質的最好方法。\n這就是為何 Google 仍然將反向連節視為排名的信號之一。\n此外，由於企鵝演萬法的更新，Google 現在專注在連結的品質（而非連結數量）\n你可能會疑惑：\n什麼是高品質的連結，具體是什麼？我又該如何打造他們？\n這就是我要在下一個章節涵蓋的內容。\n繼續往下看\u0026hellip;\n第 2 章：如何找到高品質的連結 在我們深入連結優化的逐步策略前，知道什麼是好（或壞）連結很重要。\n這樣，你可以專注在優化能改善 Google 排名的連結。\n因此，以下是如何辨認值得優化連結的方法：\n頁面權重 請問與你連結的那個網頁，在 PageRank 中是不是個有力人士？\n如果是的話，那將會讓你的排名擁有一個巨大的影響。\n事實上，從多年的測試中，我已經發現頁面權重的傳遞，將比任何其他因素更重要。\n這是因為來自一個權威性頁面的連結，將提供更多權重值（又被稱為 PageRank）給你的網站。\n（筆記：雖然 Google 並沒有公開分享關於 PageRank 的資訊，他們仍然將其視為演算法的基礎）\n你可以使用 Semrush ，輕易的察看 PageRank 的大約指標。\n只要在 Semrush 填入網址，並查看「Page Authority Score」數值。\n網站權重 一個連結的品質，同樣受到該網域的「網站權重」決定。\n普遍上來說，一個來自紐約時報的連結，將會比來自一個無名氣部落格的連結，產生還要大的影響力。\n雖然這些連結很難取得，但它們仍然值得爭取。\n同理，Semrush 一樣能派上用場。\n在工具中輸入網域名稱，並查看它的「Authority Score」數值。\n網站相關性 當我們提到連結，一個網站的權重很重要。\n但該網站的關聯性同樣重要。\n舉例來說，假設你經營一個關於「原始人減肥法」的網站。\n你想要從一個權威性的網站取得連結\u0026hellip;.像是單輪車，這樣的連結仍算數嗎？\n根據一位前 Googler 的訪談內容，結果顯示並非如此。\n:::info\n「從一個高 PageRank 頁面取得的連結，在過去通常很有價值。」\n「如今，演算法更注重該網站與你內容的關聯性。」\n「關聯性是新的 PageRank」\n:::\n大致上，你會想要從具權威性的網站取得連結，特別是該網站與你的內容，擁有相近的關聯。\n頁面上連結的位置 請問你的連結，是否內嵌在部分內容中嗎？\n或是埋在網頁的頁尾？\n事實證明，你的連結在頁面上的位置很重要。\n特別是埋藏在頁首與測攔的連結，並不如頁面正文區塊的連結有價值。\n網站底部呢？你會希望你的連結出現在網頁的主要區塊。\n連結是否由編輯方式放上的？ 不論你的連結是否出現在網頁，你應該詢問自己：\n「此連結是否由編輯方式放上去的？」\n換句話說，是否有人將自己網站與你的網站連結，單純是因為他們認為你的網站很讚？\n如果是的話，這就是一個編輯連結（editorial link）\n或是你在一個隨機網站創造帳戶，並在那邊放下一個自己網站的反向連結？\n這就不是編輯連結。\n如你所料，Google 更加重視編輯連結。\n:::info\n引言自 Google\n「以非編輯方式放上一個連結，或未經網站擁有人在網頁上的認證，又被稱為非自然連結。」\n「它可以被視為違反我們的搜尋指南」\n:::\n連結錨點文字 錨點文字是一個可被點擊的文字連結區塊。\n事實證明，Google 使用錨點文字作為排名訊號。\n舉例來說，你取得一個連到你網站的錨點文字：原始人甜點\nGoogle 看到該錨點文字，並說：\n恩\u0026hellip; 這個網站使用「原始人甜點」錨點文字，該連結導向的網頁一定是關於「原始人甜點」。\n當然，如同其他 SEO 技巧，關鍵字豐富的錨點文字已經被濫用。\n現今，建立一大堆準確描述的錨點文字，仍會被視為垃圾內容。\n簡短來說，我不推薦透過關鍵字豐富的錨點文字，用以建立反向連結。\n如果你是真的從錨點文字取得反向連結，還是值得慶祝。\n連結共現 「共現」是指文字與片語共同出現在你的連結上。\nGoogle 可能使用共線作為「子錨點文字」(baby anchor text)\n如果你這樣思考，就能理解：\n那些圍繞在連結上的文字，同樣提供該頁面的線索。\n既然如此，Google 又有什麼理由何不去使用呢？\n連結是否來自客作文章？ 幾年前，Google 站出來說：\n:::info\n「有件事已經無法繼續下去了：客座文章已經結束，他已經變得太過低廉」\n－Matt Cutts，前 Google 垃圾郵件團隊主管\n:::\n這是真的嗎？\n恩\u0026hellip;他取決於當下條件。\n以下這一些紅旗舉動，會使客座文章變得沒有價值。\n某人付費刊登文章 文章包含完全比對的錨點文字 該網站只為了發布客座文章單獨存在 該網站與你的網站不相關 但如果你在一個具權威性、關聯性的網站，發布一個令人驚艷的文章呢？\n在我的經驗，該連結可以幫助你爭取排名\nNofollow vs Dofollow 「rel=\u0026ldquo;nofollow\u0026rdquo;」是一個連結標籤，用來告訴搜尋引擎：不要將此連結當成一個網站背書。\n明顯地，當到了 SEO 領域，你會想要盡可能，取得一個正常「dofollow」連結。\n現在，你可以知道如何衡量連結品質，是時候開始建立他們。\n第 3 章：如何透過內容行銷，取得世界級的連結 內容是解鎖良好反向連結的關鍵，已經不是什麼秘密了。\n但這樣說好了：\n單純發布內容，並不會讓你取得任何連結。\n事實證明，特定類型的內容最適合取得反向連結。\n以下是四種內容類型，幫助你產生更多連結：\n一、視覺資產 它是什麼 視覺資產是：\n圖片 圖表 資訊圖 視覺導向的內容與圖表 它為什麼有用 視覺內容超級容易取得連結。\n舉例來說，當你發布一個圖片在你的網站，任何人在他們的網站分享此圖，當會讓你取得反向連結。\n這個強大的「當你分享我的圖片，請連結我的網站」關係，並不作用於任何文字基礎的內容。\n實際例子 幾年前我在自己的網站，發布了一個關於 Google 點擊率的圖表。\n直到現今，此圖已經被連結數十次（許多來自行銷領域的權威網站）\n確實，即使我使用表格呈現，仍可能取得這些連結。\n但這些連結的建立，有大部一部分（我預估 75%）是因為我以視覺方式呈現。\n事實上，我的許多連結，來自人們直接將我的視覺圖表，張貼到他們的網站上（並作為來源連回我的網站）。\n有趣的事，直到 2022 年的今天，每個月人們仍然連結此圖。\n這就是創造視覺圖表的強大之處。\n二、列點文章 它是什麼 一系列的方法、技術、原因、迷思或關於任何事情。\n它為什麼有用 列點文章將大量的價值，包裝成一份份可一口咬下的內容。\n事實上，當 BuzzSumo 分析一百萬篇文章時，他們發現這些列點文章，相較於其他形式的內容，產生更多反向連節。\n它勝過測驗、影片，甚至是資訊化圖表。\n實際例子 《2022 最新的 19 個 SEO 技巧》這個列表文章，是我最熱門的一個內容。\n沒錯，它產生一大堆分享\u0026hellip;\n以及留言\n但最重要的是，此貼文是一個連結磁鐵。\n它擁有超過 4,000 條連結。\n也因為此文章，擁有這麼多連結指向它，它取得關鍵字「SEO Techniques」的前 5 名。\n三、原創的研究與數據 它是什麼 從產業報告、調查或原創研究中，揭露最新數據的內容。\n它為什麼有用 研究與數據具有高度可連結性。\n當某人引用你的數據，它會與你連結，這些連結增加得非常快。\n實際例子 前些日子，我發布一篇大型 Google 排名因素調查。\n不用說，此貼文滿載了大量原始數據。\n這就是為什麼此貼文至今，可以累計 18,900 則反向連節，這個驚人的數字。\n如我上述提及，這些連結大多數來自人們引用我們的研究：\n四、深度完整的指南 它是什麼 一個關於某主題綜合性資源，其中包含所需要知道的一切事物。\n它為什麼有用 終極指南將驚人數量的資訊集中在一處，並使你的指南，成為該資源的首選。\n實際例子 我曾經從 email 收到人們詢問我，關於每日關鍵字研究的基本概念。\n很不幸地，關於這個非常重要的主題，那時在我的部落格中，並沒有任何內容。\n因此，我創造了一個：《SEO 關鍵字研究：終極指南》\n因為這個多章節的指南，涵蓋了其他網路資源沒有的內容。\n它已經被連結超過 37,700 次。\n現在，你已經創造出一些值得連結的內容，是時候打造一些連結。\n如何做？\n透過非常經典的電子郵件推廣。\n第 4 章：如何透過電子郵件推廣，打造強而有力的連結 如果你想要在 2022 年打造白帽連結，你需要使用電子郵件推廣。\n問題是：\n你的信件如何與部落客與記者們聯繫上，而非被丟進垃圾信件的資料夾中。\n閱讀本章節，找出方法。\n步驟一：找到「可能連結者」 如同名稱所述，可能連結者是一群可能會連結你網站的人。\n我將會在第 6 章，向你展項找出「可能連結者」的一大堆技巧。\n但現在，讓我們先使用簡單的策略，用來辨認出他們：反向工程。\n首先，在 Google 搜尋你的關鍵字。\n在第一頁搜尋結果頁，挑選一個網站連結，並放進連結分析工具（我使用Semrush 為例）\n接著，點擊側攔的「反向連節分析」，再點「反向連節」。\n這個網站會在下方，條列出全部的可能連結者。\n(你如何知道哪個網站值得鎖定、哪個網站要忽略？去查看第二章的內容)\n步驟二：找到他們的電子郵件地址 現在，你已經找出可能連結者，是時候挖出他們的電子郵件地址。\n:::danger\n進階技巧：僅在不得已的情況下，才去使用網站的聯繫表單，因為那一個黑洞\n:::\n以下是執行步驟：\n使用 Hunter.io\nHunter.io 非常適合用於聯繫小型網站與個人部落格。\n單純在工具中輸入網站\n接著，他將會向你展現，與該網域關聯的電子郵件地址。\n但如果你想要接觸大型網站呢？梳理這份清單將會非常痛苦。\n這就是為什麼，針對這些情境，我推薦 VoilaNorbert\nVoilaNorbert 藉由 VoilaNorvert.com ，你只要輸入某人的名字與工作的網域，就能成功運作，而不需輸入網址。\n這樣，你就能接觸到那些可能連結者，並讓他們把你網站連結，放到他們頁面上的。\n同時，它也會向你展現特定對象的電子郵件地址。\n步驟三：寄給他們一個客製化的內容 如果你想使電子郵件推廣規模化，你將會需要使用模板。\n使用模板的技巧在於，不要讓你的模板看起來像模板（下個步驟會解釋更多細節）\n但現在，以下是我執行最好的電子郵件模板之一\n:::info\n嗨（名稱）。\n我今天正尋找關於（某主題）的內容，偶然發現你的文章：（文章標題）\n我發現它的內容非常好！其中，我特別喜歡（他們文章的特定內容）。\n此外，我最近也在（你的主題）發布了一個新指南：（網址）。\n作為一位在撰寫關於（某主題）的人，我認為你也會喜歡它。\n我的指南同樣可能，成為你網頁上的一個不錯的延伸閱讀。\n不論如何，希望你繼續在（對方網站）提供精彩的作品。\n有空再聊。\n:::\n注意到這個範本，內含了許多客製化的資訊，卻不需花費許多力氣。\n第 5 章：黑帽連結優化的真實情況 如果沒有關於黑帽 SEO 的章節，任何連結優化的指南都不完整。\n黑帽連結優化非常容易被發現：\n如果取得反向連節的方法，與 Google 的網站指南違背，它大概就是黑帽。\n這就表示，你應該避免使用黑帽優化連結嗎？\n這個選擇取決於你。\n我個人不建議使用黑帽優化連結（風險與回報不成比例）。\n話雖如此，不論你是一位白帽或黑帽 SEO，你都需要知道 Google 給予黑帽的懲罰。\n因此，我們簡單統整它們：\nGoogle 企鵝 它是什麼： 一個懲罰演算法，用來針對使用垃圾連結建立權重的特定網站。\n例如，可疑的客座文章或文章留言處的垃圾訊息。\n如何避免它： 只有建立白帽連結能避免。\n有數據顯示，你可以藉由最小化完全匹克錨點文字，用以躲避企鵝演算法。\n(我說過錨點文字是另一個內容了，但它的關鍵在於信任)\n換句話說，躲避企鵝演算法最簡單的方式，就是避免使用可疑的連結（或錨點文字）\n手動懲罰與非自然連結 它是什麼： 一位來自 Google 公司員工的手動懲罰。\n它與企鵝演算法不同，Google 將會藉由 Google Search Console 寄給妳一封訊息。\n如何避免它： 除了 Google 以外，沒人知道自己的網站為什麼被手動懲罰。\n我的看法是有某個演算法，指出一個網站正在玩弄系統。\n因此，他們將網站過濾出來並做手動檢驗。\n可知，最好的避免方式是擁有一個非常乾淨的反向連結檔案。\n此外，不像企鵝演算法，你可以透過「禁止連結指向網站」與「申請重新審查」從手動懲罰中恢復。\n第 6 章：我最喜歡的 3 個連結優化策略（按步驟教學） 本章節不需要前言。\n以下是我用實戰經驗驗證，取得世界級反向連結的 3 個策略。\n資源頁面連結優化 首先，什麼是資源頁面？\n資源頁面是指在特定主題中，整合擁有良好內容的連結。\n以下是範例：\n因為這些頁面存在的原因，是將使用者導向適合的地方。\n因此，這是個絕佳的連結建立策略。\n以下是具體步驟：\n步驟 1：找到資源頁面 在 Google 使用這些搜尋字詞。\n他們是專門設計用來挖掘資源頁面：\n關鍵字 + inurl:links 關鍵字 + 「有幫助的資源」 關鍵字 + 「有用的資源」 關鍵字 + 「有用的連結」 步驟 2：檢視該頁面 以下是你需快速回答的問題：\n「來自這個網頁的連結，值得努力爭取嗎？」\n（提醒：使用第 2 章的技巧簡化此步驟）\n舉例來說，這個資源頁擁有一個體面的 URL 分數：12，還不錯。\n它同樣擁有一個具權威性的網站。\n而我的連結，最後將會在此網頁的主體區塊，如同勝利者般。\n步驟 3：找到最符合的內容 注意：\n你可能擁有是世界上最好的內容，但如果它與資源頁的主題不相搭呢？\n你將不會取得該連結。\n因此此步驟的目的，是要找出與你內容相符的資源頁面。\n依但你識別出內容，跳至第四步驟\n步驟 4：寄送此封經測試的模板 以下是我建議的模板：\n:::info\n標題：關於（對方網站）的問題\n\u0026ndash;\n嗨（名字）。\n今早，我在 Google 搜尋關於（主題）的內容時，看到你的優質資源頁：（網址）\n我只是想要跟你說：你的網頁幫了我很大的忙。\n如果沒有此網頁，我將永遠不會找到（該網站連結的資源）。\n有趣的事：我上個月剛發布了一個關於（主題）的指南，它是（簡短摘要）。\n如果你想查看該內容，以下是連結：（）\n此外，我的指南也可能是適合添加到你的網頁。\n不論如何，謝謝你將相關資源條列整理。\n祝你有個美好的一天！\n期待回復。\n（你的名字）\n:::\n:::danger\n如同所有外部接觸的模板，確保此模板盡可能客製化。\n你可以使用一個「看起來一點都不像模板」的模板。\n:::\n破損連結優化 「破損連結優化」一直是我最喜歡的優化策略。\n為什麼？\n透過破損連結優化，你可以替某人的網站提高價值，而非直接請求連結。\n以下是執行步驟：\n1. 安裝 Check My Links 或 LinkMiner 上述兩者工具，都能快速找到任何網頁的破損連結（透過你的 Chrome 瀏覽器）。\n我將會在接下幾分鐘，線你展示如何使用它們。\n2. 找到擁有許多外部連結的頁面 一個網頁越多連結，他們之中越有可能會產生破損連結。\n資源頁非常適用於此情況。\n因此，請盡情使用上文的搜尋字串，找出相應的資源頁。\n4. 查看破損連結 以下，是你執行在步驟一安裝的外掛的地方。\n它將會透漏該頁面的破損連結：\n4. 寄送郵件給該網站管理員，告知關於破損連結的事情 最後，讓經營該網頁的人，知道該頁的破損連結，並作為交換，讓對方連結你的網站。\n以下是我建議的模板：\n:::info\n標題：（對方網站名稱）的問題\n\u0026ndash;\n你好(姓名)，請問你還有再更新你的網站嗎？\n我在搜尋（主題）的內容時，發現你絕佳的網頁：（網頁標題或網址）\n然而，我發現有幾則連結是否已失效：\n（破損連結的網址）\n此外，我最近發布（簡短的內容描述）。\n它可能適合取代（指出特定的破損連結）。\n不論如何，希望這有幫助到你。\n謝謝\n（你的名字）\n:::\n摩天大樓技術 這部影片將手把手，帶你走過全部流程。\n{%youtube 263xIymvLl4 %}\n一旦你觀看完此影片，就是時候進入下一章節：\n非常棒的連結優化案例研究！\n第 7 章：驚人的案例研究 現在，是時候向你展現連結優化實際的例子。\n最棒的部分是，我之前從來沒有分享過這些內容。\n案例一 Julie 如何使用摩天大樓技巧，增加 194.1% 的自然搜尋流量 Julie Adams 的部落格：我們美麗的星球，曾經非常掙扎。\n確實，Julie　曾發布許多良好的內容，單在她的言詞中表示：不論我的內容有多棒，都沒有任何反向連結。\n這就是她決定使用「摩天大樓技術」的時機點。\n因此，她不再只是單純發布另一個良好內容，而是創造出驚人的事物。\n以下是例子：\n她使用電子郵件推廣去創立反向連結，而非單純創造好內容並等待被推廣。\n這使她取得從自然領域的權威網站，取得滿手的連結。\n這些白帽反向連結，使她自然搜尋增加了 194%。\n為何「摩天大樓技術」運作得如此良好？\n:::info\n根據 Julie 所說：\n「讓這件事如此成功的原因，在於建立反向連節就像與他人建立關係。」\n「人們在知道你的網站存在前，不會連結你的內容。」\n「此外，在你主動告訴他們以前，也不會知道你的網站存在。」\n:::\n說的非常好。\n案例二 破損連結優化的回報 去年，我決定執行破損連結優化的行銷活動。\n因此，我遵循在上一章節的流程。\n首先，我使用搜尋字串，以找出含有許多外部連結的網頁。\n接著，我使用 Check My Links 找出破損的連結。\n之後，我寄信給負責該內容的人，並表示自己有發現的破損連結存在。\n（仔細查看該信件有多麼客製化）\n收到對方的回應後，我寄給他們那些失效的連結，以及來自 Backlinko 的一大堆內容，用以進行 1:1 替換。\n而大多數的夥伴，都非常樂意增添我的連結：\n案例三 Matt 如何優化它的電子商務連結 讓我們面對一個事實：\n建立反向連結，對電商網站來說並不容易。\n但他仍有可能，就如同 Matt Lawry 一樣。\n如同多數電商網站擁有者，Matt 對於建立他電商網站的連結有麻煩（一個專注在禮物的澳洲網站）\n畢竟，有誰想要連結到一個 100% 產品導向的頁面。\n這讓 Matt 了解到，它可以使用內容為網站創造反向連結。\n具體來說，Matt 在它的網站創造一篇「摩天大樓」內容：《澳洲琴酒：終極指南》\n當然，Matt 並沒有坐下來並等待連結累積。\n他透過電子郵件，主動推廣自己的內容。\n因為 Matt 聯繫上正確的人（並寄給他們客製化的電子郵件），許多人願意提供連接給他的指南。\n這些連結都加強了 Matt 的電商網站，在搜尋結果頁想要爭取的關鍵字：澳洲琴酒。\n第 8 章：進階連結優化技巧 以下清單，是我為了挑選這幾年，一些進階連結優化的技巧。\n從「連結回收」輕鬆取得反向連結 每當有人在文章中提及你的品牌，他們都會連結你對吧？\n錯。\n我的意思指，他們「應該」連結你，但並非總是會發生。\n以下是我想表達的意思：\n但藉由輕推一把，多數網站擁有人都非常樂意，將提及你的部分轉成一個連結。\n你要如何發現些未含連結的提及呢？BuzzSumo 效果非常好。\n透過反向圖片搜尋，取得「額外」連結 請問你是否發布視覺資產（如資訊圖表、示意圖）？\n如果有，那現在可能有某些網站正使用你的圖片，卻沒有註明來源。\n不要嚇到。事實上，你應該慶祝。\n如同連結重新取得，一封友善的郵件可以將這些機會轉成連結。\n你可以使用 Google 以圖搜尋，找到那些使用你圖片，卻沒有添加連結的人們 :\n在下午寄送電子郵件 以下是我寄送上千封電子郵件後，從中學到的事情。\n在下午（收件者本地時間）寄送你的推廣電子郵件。\n為什麼？\n當你在早上寄送你的訊息，它將會被收件者，與其他 93 封訊息混在一起處理。\n但當你在下午寄送電子，收件夾就會少掉許多競爭者。\n我推薦 Gmail 內建的時間排成功能，幫你規畫推廣信發送時間。\n創造視覺化的概念、點子與策略 以下是來自 Backlinko 實際的作為：\n不管你相不相信，許多人都因為這張簡單片與我連結：\n為何它如此有效？\n恩\u0026hellip;我可以單純透過文字描述 APP 攻勢，但這將使我的內容比較不容易分享。\n另一方面，當你創造一個視覺圖像，你將會擁有部落客樂於分享的內容（並連結你的網站）。\n在結束前寄送試探郵件 你應該在第一封電子郵件推廣中，要求對方提供反向連結嗎？\n簡短回答：可能可以。\n你也可以透過兩階段流程，取得更好的結果。\n（Backlinko 讀者 Mike 發現測試郵件的成效，輾壓直接要求連結的方式）\n這個方法的另一個好處，可以減少你花費的時間。\n與其花費時間，客製化一封沒人閱讀的訊息，先寄送簡短試探郵件更好。\n之後，再針對你下一則訊息進行客製化。\n獲得 Podcast 的訪談 沒錯，客座文章有他的重要地位存在\n但有一個大問題：它需要花費很多時間撰寫！\n進入　Podcast　的世界。\n與其花費時間撰寫大綱、擬草稿、修改客座文章，不如單純出現在 Podcast 節目，並談論你所知道的內容。\n蹦！你就取得了反向連結。\n最好的地方是什麼？\n每個領域都有 Podcast 節目。\n以下反向連節，就是我出現在 Podcast 後建立的。\n使用「連結交集」找出可能連結者 如果某人連結給你的競爭者，他們可能也會提供連結給你對吧？\n沒錯。\n如果某人連結你的 2 位競爭者，他甚至更有可能提供連結給你。\n你如何找到這些，連結超過 1 位以上競爭者的網站。\nSemrush Backlink Gap tool 只要列出 2 到 3 位你最大的網站競爭者。\n這個絕佳的工具，將會向你顯示哪些人與他們連結。\n使用「預先策畫」的連結目標清單 不能否認：找到高品質的反向連結非常困難。\n這是個壞消息。\n好消息是，有些人已經為你預先策畫好，這些高品質的網站\u0026hellip;\n\u0026hellip;以「最佳部落格」清單的形式。\n以下是範例：\n更不用說，如果你再經營一個烘焙部落格，每一個網站清單的頁面，都將會是一個反向連結的好機會。\n你可以透過以下搜尋字詞，找到這些清單：\n最好的「主題」部落格 「主題」部落格清單。 結論 以上這就是我的 2022 連結優化指南。\n從今天的指南中，你最想要優先嘗試哪個策略呢？或你對於某件事有疑問。\n不論如何，在底下留言讓我知道。\n","date":"2022-08-17T00:00:00Z","image":"https://live.staticflickr.com/65535/52290179402_693c7086dc_o.jpg","permalink":"/2022-08-17/seo-backlinks-building-guide/","title":"SEO 反向連結建立：終極指南(2022)"},{"content":" 參考彭彭 - 回呼函式 Callbacks、Promises 物件、Async/Await 非同步流程控制\n前言 Javascript 的主要特點有兩個：\nSingle Thread (單線程) Synchronous (同步) 當主程式中遇到「非同步」的函式如排程、取資料、讀檔\u0026hellip;等相關的函式時(如：setTimeout、fetch\u0026hellip;等)，主程式並不會停止並等待函式執行完成後才繼續往下跑，而是會將其放到 queue 中直到所有程式碼都跑完了，Javascript 會再回頭到 queue 中按順序將 function 拉回來處理。\n1 2 3 4 5 console.log(\u0026#34;程式開始\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;非同步事件\u0026#34;); }, 0) console.log(\u0026#34;程式結束\u0026#34;); 程式開始\n程式結束\n非同步事件 \u0026lt;- 最後執行\n上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行，在 Ajax 的行為中也是一樣，當需要確保擷取到遠端資料才繼續往下執行時，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下舉個例子示範。\n舉例 以下為例，此為一個很基本的回傳n1+n2的結果的函式。\n1 2 3 4 5 6 7 8 9 function add(n1, n2) { return n1+n2; } function test() { let result = add(3, 4); console.log(result) } test(); 1 \u0026gt; 7 但若今天需求需要延遲兩秒再將結果打印出來時。\n1 2 3 4 5 6 7 8 9 10 11 function delayedAdd(n1, n2, delayTime) { window.setTimeout(function() { return n1+n2; }, delayTime); } function test() { let result = delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; undefined 此時會發現打印出來的 result 因為 delayedAdd 還未將結果回傳，導致直接顯示 undefined，此時就需要來解決這種非同步流程的控制。\n方法1：Callbacks 回呼函式 最早期使用的方式，於函式最後設定callback，執行需要做的事情。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Callback 回呼函式 function delayedAdd(n1, n2, delayTime, callback) { // 設定排程，延遲一段時間後執行 window.setTimeout(function() { // 延遲一段時間之後，計算加法，呼叫 callback 函式 callback(n1+n2); }, delayTime); } function test() { delayedAdd(3, 4, 2000, function(result) { console.log(result); }); } test(); 1 \u0026gt; 7 方法2：Promise 物件 近期於ES6提出的新方式。 建立 promise 物件：new Promise(執行函式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 let p = new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); return p; } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 常見寫法，直接 return promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 new Promise(resolve, reject) 的 resolve 與 reject 為 Promise 原生提供，可自行改名但順序不可異動。 resolve 對應.then()且代表成功，而 reject 則對應到 .catch()且代表失敗。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { reject(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); // 因使用 reject 回傳，這裡使用 .catch 來接 promise.catch(function(error){ console.log(error); }); } test(); 1 \u0026gt; 7 方法3：Async/Await ，Promise 的語法糖 Promise的語法糖，以便於更直觀的閱讀與撰寫非同步流程，同 Promise 於ES6提出的新玩意兒。 注意：await 的函式必須要確保有Promise，否則將報錯。 需先宣告為 async 函式，才能使用 await。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; 7 注意：使用 await 時，主程式會確實停止，等待 await 函式執行完成後，才接續往下跑，舉例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); console.log(\u0026#34;Hello\u0026#34;); } test(); 1 2 \u0026gt; 7 \u0026gt; Hello 延伸一：多個 Promise 的資料處理：Promise.all() 若遇到多個 Promise，且需將各個 Promise 的結果進行運算時，可使用 Promise.all() 來處理。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise1 = delayedAdd(3, 4, 2000); let promise2 = delayedAdd(2, 3, 3000); // 多個 Promise 都完成之後，將其數值相乘 Promise.all([promise1, promise2]).then(function(results){ // 此時 results 為一個陣列 \u0026gt; [7, 5]; let answer = results.reduce(function(total, value) { return total * value; }) console.log(answer); }); } test(); 1 \u0026gt; 35 延伸二：多個 Promise 使用 Async/Await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let result1 = await delayedAdd(3, 4, 2000); let result2 = await delayedAdd(2, 3, 3000); let answer = result1 * result2; console.log(answer); } test(); 1 \u0026gt; 35 ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282531224_1f57c841ee_o.jpg","permalink":"/2022-08-13/js-async-programs/","title":"【Callback、Promise、Async/Await】處理非同步事件"},{"content":" 本文參考網址\n什麼是 async？什麼是 await？ 在 JavaScript 的世界，同步 sync 和非同步 async 的愛恨情仇，就如同偶像劇一般的剪不斷理還亂，特別像是setTimeout、setInterval、MLHttpRequest或fetch這些同步非同步混雜的用法，都會讓人一個頭兩個大，幸好 ES6 出現了 promise，ES7 出現了 async、await，幫助我們可以更容易的進行程式邏輯的撰寫。\n對於同步和非同步，最常見的說法是「同步模式下，每個任務必須按照順序執行，後面的任務必須等待前面的任務執行完成，非同步模式則相反，後面的任務不用等前面的，各自執行各自的任務」，但我覺得這樣實在不容易理解，不容易理解的地方在於「中文」的同步和非同步，可能和實際上的解釋剛好相反了 ( 同步的中文字面意思是「一起走」，非同步的中文意思是「不要一起走」，超容易搞錯的 )，因此如果你跟我一樣也很容易搞錯，可以使用我覺得比較好理解的方法：「同一個步道 vs 不同步道」，透過步道的方式，就更容易明白同步和非同步。\n同步：在「同一個步道」比賽「接力賽跑」，當棒子沒有交給我，我就得等你，不能跑。\n非同步：在「不 ( 非 ) 同步道」比賽「賽跑」，誰都不等誰，只要輪到我跑，我就開始跑。\n在 ES7 裡頭 async 的本質是 promise 的語法糖 ( 包裝得甜甜的比較好吃下肚 )，只要 function 標記為 async，就表示裡頭可以撰寫 await 的同步語法，而 await 顧名思義就是「等待」，它會確保一個 promise 物件都解決 ( resolve ) 或出錯 ( reject ) 後才會進行下一步，當 async function 的內容全都結束後，會返回一個 promise，這表示後方可以使用.then語法來做連接，基本的程式長相就像下面這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 async function a(){ await b(); ..... // 等 b() 完成後才會執行 await c(); ..... // 等 c() 完成後才會執行 await new Promise(resolve=\u0026gt;{ ..... }); ..... // 上方的 promise 完成後才會執行 } a(); a().then(()=\u0026gt;{ ..... // 等 a() 完成後接著執行 }); 利用 async 和 await 做個「漂亮的等待」 比較了解 async 和 await 的意思之後，就來試試看做個「漂亮的等待」，過去有使用 ES6 的 promise 來實現 delay ( 如同下方的程式範例 )，這個 delay 透過.then來完成一步一步的串接，雖然邏輯上很清楚，但若要實作比較複雜的流程，就得把每個程式寫在對應的 callback 裏，也就沒有想像的容易，這就是「不太漂亮的等待」 ( 使用 setTimeout 的做法就是不漂亮的等待 )。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 不漂亮的等待 const delay = (s) =\u0026gt; { return new Promise(resolve =\u0026gt; { setTimeout(resolve,s); }); }; delay().then(() =\u0026gt; { console.log(1); // 顯示 1 return delay(1000); // 延遲ㄧ秒 }).then(() =\u0026gt; { console.log(2); // 顯示 2 return delay(2000); // 延遲二秒 }).then(() =\u0026gt; { console.log(3); // 顯示 3 }); 如果我們把上面的範例修改為 async 和 await 的寫法，突然就發現程式碼看起來非常的乾淨，因為 await 會等待收到 resolve 之後才會進行後面的動作，如果沒有收到就會一直處在等待的狀態，所以什麼時候該等待，什麼時候該做下一步，就會非常清楚明瞭，這也就是我所謂「漂亮的等待」。\n注意，await 一定得運行在 async function 內！\n1 2 3 4 5 6 7 8 9 10 11 12 13 ~async function{ // ~ 開頭表示直接執行這個 function，結尾有 () const delay = (s) =\u0026gt; { return new Promise(function(resolve){ // 回傳一個 promise setTimeout(resolve,s); // 等待多少秒之後 resolve() }); }; console.log(1); // 顯示 1 await delay(1000); // 延遲ㄧ秒 console.log(2); // 顯示 2 await delay(2000); // 延遲二秒 console.log(3); // 顯示 3 }(); 搭配 Promise 基本上只要有 async 和 await 的地方，就一定有 promise 的存在，promise 顧名思義就是「保證執行之後才會做什麼事情」，剛剛使用了 async、await 和 promise 改善setTimeout這個容易出錯的非同步等待，針對setInterval，也能用同樣的做法修改，舉例來說，下面的程式碼執行之後，並「不會」如我們預期的「先顯示 1，再顯示 haha0\u0026hellip;haha5，最後再顯示 2」，而是「先顯示 1 和 2，然後再出現 haha0\u0026hellip;haha5」，因為雖然程式邏輯是從上往下，但在 count function 裏頭是非同步的語法，導致自己走自己的路，也造成了結果的不如預期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const count = (t,s) =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); } },s); }; console.log(1); count(\u0026#39;haha\u0026#39;, 100); console.log(2); 這時我們可以透過 async、await 和 promise 進行修正，在顯示 1 之後，會「等待」count function 結束後再顯示 2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ~async function(){ const count = (t,s) =\u0026gt; { return new Promise(resolve =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); resolve(); // 表示完成 } },s); }); }; console.log(1); await count(\u0026#39;haha\u0026#39;, 100); console.log(2); }(); 除了setTimeout和setInterval，這也可以用於像是「輸入文字」的情境，過去我們要做到「連續輸入」文字，可能要層層疊疊寫個好幾個 callback，現在如果使用 async 和 await，就能夠很簡單的實現連續輸入的情境，程式碼看起來也更乾淨簡潔。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // HTML 為一個輸入框、一個按鈕和一個 h1 標籤 // \u0026lt;input id=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/input\u0026gt;\u0026lt;button id=\u0026#34;b\u0026#34;\u0026gt;send\u0026lt;/button\u0026gt; // \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; ~async function(){ const input = () =\u0026gt; { return new Promise(resolve =\u0026gt;{ const btnClick = () =\u0026gt;{ h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, a.value + \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;); // 輸入後在 h1 裡添加內容 a.value = \u0026#39;\u0026#39;; // 清空輸入框 a.focus(); // 將焦點移至輸入框 b.removeEventListener(\u0026#39;click\u0026#39;, btnClick); // removeEventListener 避免重複綁定事件 resolve(); // 完成 }; b.addEventListener(\u0026#39;click\u0026#39;, btnClick); // 綁定按鈕事件 }); }; h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;開始\u0026lt;br/\u0026gt;\u0026#39;); await input(); // 等待輸入，輸入後才會進行下一步 await input(); await input(); h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;結束\u0026#39;); }(); 搭配 Fetch 在我之前的文章 JavaScript Fetch API 使用教學 已經有提到fetch的用法，因為fetch最後回傳的是 promise，理所當然的透過 async 和 await 操作是最恰當不過的。\n舉例來說，先前往 中央氣象局開放資料平台 可以取得許多氣象資料，找到 局屬氣象站-現在天氣觀測報告 ，複製 JSON 格式的連結 ( 需要註冊登入才能看得到連結 )，透過fetch的json()方法處理檔案，目標顯示出「高雄市的即時氣溫」。\n透過 async 和 await 的美化程式碼，得到的結果完全不需要 callback 的輔助，就能按照我們所期望的順序進行。(先顯示「開始抓氣象」，接著顯示「高雄市的氣溫」，最後顯示「總算結束了」)\n1 2 3 4 5 6 7 8 9 10 11 12 ~async function(){ console.log(\u0026#39;開始抓氣象\u0026#39;); // 先顯示「開始抓氣象」 await fetch(\u0026#39;氣象局 json 網址\u0026#39;) // 帶有 await 的 fetch .then(res =\u0026gt; { return res.json(); }).then(result =\u0026gt; { let city = result.cwbopendata.location[14].parameter[0].parameterValue; let temp = result.cwbopendata.location[14].weatherElement[3].elementValue.value; console.log(`${city}的氣溫為 ${temp} 度 C`); }); console.log(\u0026#39;總算結束了\u0026#39;); // 抓完氣象之後再顯示「總算結束了」 }(); 搭配 迴圈 如果要透過 JavaScript 實現「文字慢慢變大」的效果，除了透過 CSS 的 transition 設定之外，通常就是直接使用setInterval來完成，就像下面的程式碼這樣：\n1 2 3 4 5 6 7 8 9 let size = 30; h.style.lineHeight = 0; const timer = setInterval(()=\u0026gt;{ h.style.fontSize = size + \u0026#39;px\u0026#39;; size = size + 1; if(size \u0026gt;= 130){ clearInterval(timer); } },10); 如果搭配 async 和 await，我們就能將同樣的做法，改由「迴圈」實現，因為使用了 await，所以迴圈每次執行時，都會進行「等待」，也就能做到字體慢慢變大的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // HTML 為一個 h1 標籤 \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;hello\u0026lt;/h1\u0026gt; ~async function(){ const delay = t =\u0026gt; { // 先撰寫一個等待的 function return new Promise(resolve =\u0026gt; { setTimeout(resolve, t); }); }; h.style.linHeight = 0; for(let i=30; i\u0026lt;130; i++){ h.style.fontSize = i + \u0026#39;px\u0026#39;; await delay(10); // 迴圈每次執行時，都會在這裡等待 10ms } }(); 同樣的，上面提到的 fetch 或是輸入文字，只要做成 await 的方式，都可以放在迴圈裡面使用，例如透過迴圈不斷的 fetch 資料、透過迴圈不斷的輸入文字\u0026hellip;等，這些就不是 callback 方法能容易辦到的囉\n小結 坦白說只要你一但熟悉了 async 和 await，就真的回不去了，雖然說 callback 仍然是程式開發裡必備的功能，但對於同步和非同步之間的轉換，以後就交給 async 和 await 來處理吧！\n","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52281246237_dd06bc8ef9_o.png","permalink":"/2022-08-13/js-async-await/","title":"Javascript 的 Async/Await"},{"content":" 參考網站\n建立正規式 正則表達式的規則稱作 pattern。在 JavaScript 中可以透過 Regular expression literals 的方式或建構式的方式來建立 regular expressions pattern：\n方法一：Regular expression literals script 載入時即編譯，當 pattern 不會改變時，使用此方式定義 pattern 效能較好。 1 var re = /ab+c/; 方法二：Function Constructor 程式執行過程才會被編譯，效能較差，適合用在 regular expression pattern 可能會改變時使用。 1 2 var re = new RegExp(\u0026#39;ab+c\u0026#39;); var myRe = new RegExp(\u0026#39;d(b+)d\u0026#39;, \u0026#39;g\u0026#39;); Regular expression literals 效能較好，適合 pattern 不會改變的情況；\nFunction Constructor 效能較差，適合用在 pattern 可能動態改變的情況。\n使用正規式 在 JavaScript 中可以使用正規式的函式包含：\nRegExp.prototype.test()：搜尋字串中是否有符合的部分，回傳 true/false。 RegExp.prototype.exec()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.match()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.replace()：尋找字串中匹配的部分，並取代之。 String.prototype.search()：尋找字串中是否有符合的部分，有的話回傳 index，否則回傳 -1。 String.prototype.split()：在字串根據匹配到的項目拆成陣列。 簡單來說，當你想要看字串是否包含某 pattern 時，使用 test 或 search；\n想要更多的資訊（花較多耗效能），則使用 exec 或 match。\n特殊字元 (character) 標籤（flag） 1 2 3 regex = /hello/; // 區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;hello123\u0026#34;, \u0026#34;123hello123\u0026#34;, \u0026#34;123hello\u0026#34;，但不匹配 \u0026#34;hell0\u0026#34;, \u0026#34;Hello\u0026#34; regex = /hello/i; // 不區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;HelLo\u0026#34;, \u0026#34;123HelLO\u0026#34; regex = /hello/g; // 全域搜尋 ES 2019 新增 /s 的標籤，過去 . 可以用來匹配除了換行符號以外（\\n, \\r）的所有字元：\n1 2 3 // 過去 . 可以匹配到除了「換行符號」以外的所有字元 console.log(/./.test(\u0026#39;\\n\u0026#39;)); // → false console.log(/./.test(\u0026#39;\\r\u0026#39;)); // → false 過去雖然可以使用 [\\w\\W] 來匹配到換行符號，但這不是最好的做法：\n1 2 console.log(/[\\w\\W]/.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/[\\w\\W]/.test(\u0026#39;\\r\u0026#39;)); // → true 在 ES 2019 中，只要最後有標記 /s 的標籤，如此 . 將也能夠匹配到換行符號：\n1 2 console.log(/./s.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/./s.test(\u0026#39;\\r\u0026#39;)); // → true 普通字元 // 1 2 var regex = /a/; var regex = /is/; 反斜線 \\ 1 2 3 4 5 6 /* 在「非」特殊字元前面使用反斜線時，表示要把反斜線後的字當作是特殊字元 */ var regex = /\\b/; // b 原本不是特殊字元，這個 b 要當成特殊字元 /* 在特殊字元前面使用反斜線時，表示要把反斜線後的字當作是「非」特殊字元 */ var regex = /if\\(true/; // ( 原本是特殊字元，但這裡要當成非特殊字元 var regex = /1\\+2=3/; // + 原本是特殊字元，但這裡要當成非特殊字元 任意一個字元 . 可以用來匹配除了換行符號（\\n）以外的所有字元： 1 2 3 var regex = /a.man/; // a*man 都會 match，例如 \u0026#34;acman\u0026#34;, \u0026#34;awman\u0026#34;, 但 \u0026#34;a\\nman\u0026#34; 無法匹配。 var regex = /.a/; // 任何一個字元後加上 a 多個字元 [] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 小寫 a 或大寫 A var regex = /[aA]/; // 匹配所有不是 a 或 A 的字 var regex = /[^aA]/; // a, e, i, o, u 都會 match var regex = /[aeiou]/; // 英文字母 var regex = /[a-z]/; // 所有小寫的字母，從小寫 a 到小寫 z var regex = /[A-Z]/; // 所有大寫的字母，從大寫 A 到大寫 Z var regex = /[a-zA-Z]/; // 所有英文字母 // 數字 5 ~ 8 var regex = /[5-8]/; 括號 () 套用到所有 1 2 3 var regex = /^a|^the|^an/; // 套用到裡面所有的 var regex = /^(a|the|an)/; // 等同於 不是（除了） ^ 1 2 3 4 5 /* 不是 a 都會 match */ var regex = /[^a]/; /* 不是數字都會 match */ var regex = /[^0-9]/; 多個字元縮寫 keywords：\\d、\\w、\\s、\\b、\\D、\\W、\\S \\d : digit，[0-9] \\w : word，包含英文大小寫、數字、底線，[A-Za-z0-9_] \\s : space，包含 space, tab, form feed, line feed，[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\D : 不是 digit，等同於 [^\\d] \\W : 不是 word，等同於 [^\\w] \\S : 不是 space，等同於 [^\\s] 1 2 3 4 5 6 7 8 9 10 /* 所有 word + e */ var regex = /\\we/; /* 連續兩個任意的數值 */ var regex = /\\d\\d/; /* 句子中結尾為 s 的單字 */ var regex = /s\\b/; var regex = /\\b[a-z]/g; // 句子中各個單字的第一個字母 其他特殊字元： \\t : tab \\b : word boundary，用來比對單字和單字間的空白，/s\\b/ 則會比對句子中最一個字母是 s 的單字 Word boundary \\b、\\B 透過 \\b 可以配對 word boundary，word boundary 指的是一個字元的前後沒有其他任何字元。\n要注意 \\b 和 [\\b] 是不一樣的，[\\b] 是用來配對 backspace。\n1 2 3 // is 這個單字才會被選到，Th`is` 的 is 不會 let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\bis\\b/); // [ \u0026#39;is\u0026#39;, index: 5, input: \u0026#39;This is an apple.\u0026#39; ] 相反地，\\B 則是 non-word boundary：\nBefore the first character of the string, if the first character is not a word character. After the last character of the string, if the last character is not a word character. Between two word characters Between two non-word characters The empty string 1 2 3 4 // 使用 \\B 會配對到 This 中的 is let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\Bis/); // [ \u0026#39;is\u0026#39;, index: 2, input: \u0026#39;This is an apple.\u0026#39; ] 出現次數 * + ? {} {, } keywords： * 、+、?、{次數}、{最少次數, 最多次數} * : 任意次數，等同於{0,} + : 至少一次（後面要跟著），等同於 {1,} ? : 零或一次（有或沒有），等同於 {0,1} {次數} {最少次數, 最多次數} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var regex = /abc/; // 找到符合 \u0026#34;abc\u0026#34; var regex = /ab*c/; // *表示前一個單字可以是 0 個或多個，因此 ac, abc, abbbbc 都符合規則 var regex = /n?a/; // n 可有可無 var regex = /a{2}/; // a 要 2 次，所以會是 a var regex = /a{2,4}/; // a 介於 2 次到 4 次之間 var regex = /a{2,}/; // 2 次以上的 a 都可以，大括號後面不要有空格 var regex = /(hello){4}/; // 4 次的 hello，hellohellohellohello var regex = /\\d{3}/; // 3 次的數字 開頭與結尾 keywords：^、$ ^ 開頭 $ 結尾 1 2 3 4 5 6 7 8 9 10 11 12 /* 以 A 開頭的字才會匹配到 */ /^A/gm.test(\u0026#39;Abc\u0026#39;); // true /^A/gm.test(\u0026#39;bac\u0026#39;); // false /* 開頭有 He */ var regex = /^He/; /* 結尾有 llo */ var regex = /llo$/; /* 開頭 He 結尾 llo 中間任意字元可以有任意次數 */ var regex = /^He.*llo$/; 或 | 1 2 3 4 5 // and 或 android，match 到 `and`roid 就不 match `android` var regex = /and|android/; // match 到 android 還是會 match and var regex = /android|and/; LookAround Assertions keywords: x(?=y)、x(?!y) Lookahead assertions: x(?=y)、x(?!y) Lookbehind assertions: (?\u0026lt;=y)x、(?\u0026lt;!y)x Look Ahead ?=：後面需要跟著 ?!：後面不能跟著 1 2 3 4 5 6 7 8 9 10 11 12 // foo(?=bar)，foo 後面要跟著 bar 才會配對到 foo const regexp = /foo(?=bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // foo(?!bar)，foo 後面不能跟著 bar，如此才會配對到 foo const regexp = /foo(?!bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foo123\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo123\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // null Look Behind ?\u0026lt;=：前面需要跟著才會匹配到 ?\u0026lt;!：前面不能跟著才會匹配到 1 2 3 4 5 6 7 8 9 10 11 12 // (?\u0026lt;=foo)bar，當 bar 前面有 foo 時才會配對到 bar const regexp = /(?\u0026lt;=foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // (?\u0026lt;!foo)bar，當 bar 前面沒有 foo 時才會配對到 bar const regexp = /(?\u0026lt;!foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 0, input: \u0026#39;bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;123bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;123bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foobar\u0026#39;); // null ❗❗❗ Lookbehind assertions 屬於 ES2018 的語法，須注意相容性。 ❗❗❗\n貪婪模式（Greedy Mode） 預設會啟用貪婪模式，如果想要關閉貪婪模式，也就是讓到一匹配到就停止，可以使用在 * 、 + 等後面加上 ?，例如 .*?、.+?。\npattern 筆記 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export default { // 允許數字、英文字 // 長度4~12 account: /^[0-9A-Za-z]{4,12}$/, // 需包含數字、英文字、英文特殊符號 // 但不得包含符號 \\ // 長度1~24 password: /^(?=.*\\d)(?=.*[a-zA-Z])[a-zA-Z0-9!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~`]{1,24}$/, // 允許數字、英文字、中文字 // 長度2~8 nickName: /^[0-9A-Za-z\\u4E00-\\u9FFF]{2,8}$/, // 允許數字、英文字、中文字、英文特殊符號、空白，但開頭不得為特殊符號或空白 realName: /^(?!(-))(?!(\\s))(?!(,))[A-Za-z\\-\\,\\s\\u4E00-\\u9FFF]{0,20}[^(?=(!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~\\s\\d`)))]$/, // 信箱 createEmail: /^([\\w])([\\-\\._]?[\\w]){0,64}\\@([\\w])([\\-\\._]?[\\w]){0,64}\\.([a-zA-Z]){2,6}$/, // 前三碼英文字、後三碼數字 promotionCode: /^[A-Za-z]{3}[0-9]{3}$/, // 允許數字、英文字、中文字、英文特殊符號、中文特殊符號、空白 // 長度0~100 remark: /^[0-9A-Za-z-_\\u4E00-\\u9FA5+/.*!@#$%\u0026amp;?()=|\u0026#39;:;\u0026lt;\u0026gt;,~！@#￥……\u0026amp;*（）——|{}【】‘；：”“\u0026#39;。，、？%\\s]{0,100}$/, } ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282544509_9802b00af7_o.png","permalink":"/2022-08-13/js-regex/","title":"Javascript 的正則表達式(Regular Expression, regex)"},{"content":" 參考網站\n基礎篇 1. 對 SPA 單頁⾯的理解，優缺點是什麼？ SPA（ single-page application ）僅在 Web 頁⾯初始化時加載相應的 HTML、JavaScript 和 CSS。 ⼀旦頁⾯加載完成，SPA 不會因為⽤戶的操作⽽進⾏⻚⾯的重新加載或跳轉；取⽽代之的是利⽤路由機制實現 HTML 內容的變換，UI 與⽤戶的交互，避免頁⾯的重新加載。 優點： ⽤戶體驗好、快，內容的改變不需要重新加載整個頁⾯，避免了不必要的跳轉和重複渲染 SPA 相對對服務器壓⼒⼩ 前後端職責分離，架構清晰，前端進⾏交互邏輯，後端負責數據處理 缺點： ⾸屏（初次）加載慢：為實現單⻚ Web 應⽤功能及顯示效果，需要在加載⻚⾯的時候將JavaScript、CSS 統⼀加載，部分⻚⾯按需加載 不利於 SEO：由於所有的內容都在⼀個⻚⾯中動態替換顯示，所以在 SEO 上其有著天然的弱勢 2. new Vue() 發生了什麼？ 結論：new Vue()是創建Vue實例，它內部執行了根實例的初始化過程 具體包括以下操作： 選項合併，children, refs, slot, createElement等实例属性的方法初始化 自定義事件處理 數據響應式處理 生命週期鉤子調用 (beforecreate created) 可能的掛載 總結：new Vue()創建了根實例並準備好數據和方法，未來執行掛載時，此過程還會遞歸的應用於它的子組件上，最終形成一個有緊密關係的組件實例樹 3. Vue.use是幹什麼的？原理是什麼？ vue.use 是用來使用插件的，我們可以在插件中擴展全局組件、指令、原型方法等。 檢查插件是否註冊，若已註冊，則直接跳出 處理入參，將第一個參數之後的參數歸集，並在首部塞入 this 上下文 執行註冊方法，調用定義好的 install 方法，傳入處理的參數，若沒有 install 方法並且插件本身為 function 則直接進行註冊 插件不能重複的加載，install 方法的第一個參數是vue的構造函數，其他參數是Vue.set中除了第一個參數的其他參數； 代碼：args.unshift(this) 調用插件的install 方法 代碼：typeof plugin.install === \u0026ldquo;function\u0026rdquo; 插件本身是一個函數，直接讓函數執行。代碼：plugin.apply(null, args) 緩存插件。代碼：installedPlugins.push(plugin) 4. 請說一下響應式數據的理解？ 根據數據類型來做不同處理，數組和對像類型當值變化時如何劫持。 對象內部通過defineReactive方法，使用 Object.defineProperty() 監聽數據屬性的 get 來進行數據依賴收集，再通過 set 來完成數據更新的派發 數組則通過重寫數組方法來實現的。擴展它的 7 個變更⽅法，通過監聽這些方法可以做到依賴收集和派發更新 內部依賴收集是怎麼做到的？每個屬性都擁有自己的dep屬性，存放他所依賴的 watcher，當屬性變化後會通知自己對應的 watcher去更新 響應式流程：\ndefineReactive 把數據定義成響應式的 給屬性增加一個 dep，用來收集對應的那些watcher 等數據變化進行更新\ndep.depend() // get 取值：進行依賴收集\ndep.notify() // set 設置時：通知視圖更新 對象層級過深，性能就會差 不需要響應數據的內容不要放在data中 object.freeze() 可以凍結數據 5. Vue如何檢測數組變化？ 數組考慮性能原因沒有用defineProperty對數組的每一項進行攔截，而是選擇重寫數組 方法以進行重寫。當數組調用到這 7 個方法的時候，執行 ob.dep.notify() 進行派發通知 Watcher 更新 在Vue中修改數組的索引和長度是無法監控到的。需要通過以下7種變異方法修改數組才會觸發數組對應的wacther進行更新。數組中如果是對像數據類型也會進行遞歸劫持 那如果想要改索引更新數據怎麼辦？\n可以通過Vue.set()來進行處理 ➞ 核心內部用的是 splice 方法 1 2 3 4 5 6 7 8 9 // 取出原型方法； const arrayProto = Array.prototype // 拷貝原型方法； export const arrayMethods = Object.create(arrayProto) // 重寫數組方法； def(arrayMethods, method, function mutator (…args) { } ob.dep.notify() // 調用方法時更新視圖 6. Vue.set 方法是如何實現的？ 為什麼$set可以觸發更新，我們給對象和數組本身都增加了dep屬性，當給對像新增不存在的屬性則觸發對象依賴的watcher去更新，當修改數組索引時我們調用數組本身的splice方法去更新數組 官方定義 Vue.set(object, key, value)\n7. Vue中模板編譯原理？ 如何將template轉換成render函數(這裡要注意的是我們在開發時盡量不要使用template，因為將template轉化成render方法需要在運行時進行編譯操作會有性能損耗，同時引用帶有complier包的vue體積也會變大) 默認.vue文件中的 template處理是通過vue-loader 來進行處理的並不是通過運行時的編譯 將 template 模板轉換成 ast 語法樹 - parserHTML 對靜態語法做靜態標記 - markUp 重新生成代碼 - codeGen 模板引擎的實現原理就是new Function + with來進行實現的\nvue-loader中处理template属性主要靠的是 vue-template-compiler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // vue-loader // template =\u0026gt; ast =\u0026gt; codegen =\u0026gt; with+function 實現生成render方法 let {ast, render } = VueTemplateCompiler.compile(\u0026lt;div\u0026gt;{{aaa}}\u0026lt;/div\u0026gt;) console.log(ast, render) // 模板引擎的實現原理 with + new Function console.log(new Function(render).tostring()) // render方法執行完畢後生成的是虛擬 dom // with(this){return _c(‘div’,[_s(aaa)])} // 代碼生成 const ast = parse(template.trim(), options) // 將代碼解析成ast語法樹 if (options.optimize !== false) { optimize(ast, options) // 優化代碼 標記靜態點 標記樹 } const code = generate(ast, options) // 生成代碼 8. Proxy 與 Object.defineProperty 優劣對比 Proxy 的優勢如下 Proxy 可以直接監聽對象而非屬性 Proxy 可以直接監聽數組的變化 Proxy 有多達 13 種攔截方法,不限於 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具備的 Proxy 返回的是一個新對象,我們可以只操作新的對象達到目的,而 Object.defineProperty 只能遍歷對象屬性直接修改 Proxy 作為新標準將受到瀏覽器廠商重點持續的性能優化，也就是傳說中的新標準的性能紅利 Object.defineProperty 的優勢如下 兼容性好，支持 IE9，而 Proxy 的存在瀏覽器兼容性問題，而且無法用 polyfill 磨平，因此 Vue 的作者才聲明需要等到下個大版本( 3.0 )才能用 Proxy 重寫 9. Vue3.x響應式數據原理 Vue3.x改用Proxy替代Object.defineProperty。因為Proxy可以直接監聽對象和數組的變化，並且有多達13種攔截方法。並且作為新標準將受到瀏覽器廠商重點持續的性能優化 Proxy只會代理對象的第一層，那麼Vue3又是怎樣處理這個問題的呢？\n判斷當前Reflect.get的返回值是否為Object，如果是則再通過reactive方法做代理， 這樣就實現了深度觀測 監測數組的時候可能觸發多次get/set，那麼如何防止觸發多次呢？\n我們可以判斷key是否為當前被代理對象target自身屬性，也可以判斷舊值與新值是否相等，只有滿足以上兩個條件之一時，才有可能執行trigger 生命周期篇 Vue的生命週期方法有哪些？一般在哪一步發起請求及原因 總共分為8個階段：創建前/後，載入前/後，更新前/後，銷毀前/後 創建前/後：\nbeforeCreate階段：vue實例的掛載元素el和數據對象data都為undefined，還未初始化。\n說明：在當前階段data、methods、computed以及watch上的數據和方法都不能被訪問。\ncreated階段：vue實例的數據對象data有了，el還沒有。\n說明：可以做一些初始數據的獲取，在當前階段無法與Dom進行交互，如果非要想，可以通過vm.$nextTick來訪問Dom。\n載入前/後：\nbeforeMount階段：vue實例的$el和data都初始化了，但還是掛載之前為虛擬的dom節點。\n說明：當前階段虛擬Dom已經創建完成，即將開始渲染。在此時也可以對數據進行更改，不會觸發updated。\nmounted階段：vue實例掛載完成，data.message成功渲染。\n說明：在當前階段，真實的Dom掛載完畢，數據完成雙向綁定，可以訪問到Dom節點，使用$refs屬性對Dom進行操作。\n更新前/後：\nbeforeUpdate階段：響應式數據更新時調用，發生在虛擬DOM打補丁之前，適合在更新之前訪問現有的DOM，比如手動移除已添加的事件監聽器。\n說明：可以在當前階段進行更改數據，不會造成重渲染。\nupdated階段：虛擬DOM重新渲染和打補丁之後調用，組成新的DOM已經更新，避免在這個鉤子函數中操作數據，防止死循環。\n說明：當前階段組件Dom已完成更新。要注意的是避免在此期間更改數據，因為這可能會導致無限循環的更新。\n銷毀前/後：\nbeforeDestroy階段：實例銷毀前調用，實例還可以用，this能獲取到實例，常用於銷毀定時器，解綁事件。\n說明：在當前階段實例完全可以被使用，我們可以在這時進行善後收尾工作，比如清除計時器。\ndestroyed階段：實例銷毀後調用，調用後所有事件監聽器會被移除，所有的子實例都會被銷毀。\n說明：當前階段組件已被拆解，數據綁定被卸除，監聽被移出，子實例也統統被銷毀。\n補充：\n第一次頁面加載時會觸發：beforeCreate, created, beforeMount, mounted。\ncreated 實例已經創建完成，因為它是最早觸發的原因可以進行一些數據，資源的請求。 (服務器渲染支持created方法) mounted 實例已經掛載完成，可以進行一些DOM操作。 (接口請求) 生命週期鉤子是如何實現的？ Vue的生命週期鉤子就是回調函數而已，當創建組件實例的過程中會調用對應的鉤子方法。 補充：\n內部主要是使用callHook方法來調用對應的方法。核心是一個發布訂閱模式，將鉤子訂閱好(內部採用數組的方式存儲)，在對應的階段進行發布。\nVue 的父組件和子組件生命週期鉤子執行順序 第一次頁面加載時會觸發 beforeCreate, created, beforeMount, mounted 這幾個鉤子。 渲染過程： 父組件掛載完成一定是等子組件都掛載完成後，才算是父組件掛載完，所以父組件的mounted在子組件mouted之後\n父beforeCreate ➡ 父created ➡ 父beforeMount ➡ 子beforeCreate ➡ 子created ➡ 子beforeMount ➡ 子mounted ➡ 父mounted\n子組件更新過程： 影響到父組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響父組件：子beforeUpdate -\u0026gt; 子updated\n父組件更新過程： 影響到子組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響子組件：父beforeUpdate -\u0026gt; 父updated\n銷毀過程： 父beforeDestroy -\u0026gt; 子beforeDestroy -\u0026gt; 子destroyed -\u0026gt; 父destroyed\n重要：父組件等待子組件完成後，才會執行自己對應完成的鉤子。\n組件通信篇 Vue中的組件的data 為什麼是一個函數？ 每次使用組件時都會對組件進行實例化操作，並且調用data函數返回一個對像作為組件的數據源。這樣可以保證多個組件間數據互不影響。 如果data是對象的話，對象屬於引用類型，會影響到所有的實例。所以為了保證組件不同的實例之間data不衝突，data必須是一個函數。 Vue 組件間通信有哪幾種方式？ Vue 組件間通信只要指以下 3 類通信：父子組件通信、隔代組件通信、兄弟組件通信，下面我們分別介紹每種通信方式且會說明此種方法可適用於哪類組件間通信。 props / $emit 適用父子組件通信\n這種方法是 Vue 組件的基礎，相信大部分同學耳聞能詳，所以此處就不舉例展開介紹。 ref 與 $parent / children适用父子组件通信\nref：如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子組件上，引用就指向組件實例 parent / $children：訪問父 / 子實例 EventBus （$emit / $on） 適用於 父子、隔代、兄弟組件通信\n這種方法通過一個空的 Vue 實例作為中央事件總線（事件中心），用它來觸發事件和監聽事件，從而實現任何組件間的通信，包括父子、隔代、兄弟組件。 attrs / listeners 適用於隔代組件通信\nattrs：包含了父作用域中不被prop所識別(且獲取)的特性綁定(class和style除外)。當一個組件沒有聲明任何prop時，這裡會包含所有父作用域的綁定(class和style除外)，並且可以通過v−bind=\u0026ldquo;attrs\u0026rdquo; 傳入內部組件。通常配合 inheritAttrs 選項一起使用。 listeners：包含了父作用域中的(不含.native修飾器的) v-on事件監聽器。它可以通過v−on=\u0026ldquo;listeners\u0026rdquo; 傳入內部組件 provide / inject 適用於隔代組件通信\n祖先組件中通過 provider 來提供變量，然後在子孫組件中通過 inject 來注入變量。 provide / inject API 主要解決了跨級組件間的通信問題，不過它的使用場景，主要是子組件獲取上級組件的狀態，跨級組件間建立了一種主動提供與依賴注入的關係。 Vuex 適用於 父子、隔代、兄弟組件通信\nVuex 是一個專為 Vue.js 應用程序開發的狀態管理模式。每一個 Vuex 應用的核心就是 store（倉庫）。 \u0026ldquo;store\u0026rdquo; 基本上就是一個容器，它包含著你的應用中大部分的狀態 (state)。 組件中寫 name選項有哪些好處及作用？ 可以通過名字找到對應的組件（遞歸組件） 可以通過name屬性實現緩存功能 (keep-alive) 可以通過name來識別組件（跨級組件通信時非常重要） 1 2 3 4 5 Vue.extend = function () { if(name) { Sub.options.componentd[name] = Sub } } keep-alive平時在哪裡使用？原理是？ keep-alive 主要是組件緩存，採用的是LRU算法。最近最久未使用法。 常用的兩個屬性include/exclude，允許組件有條件的進行緩存。 兩個生命週期activated/deactivated，用來得知當前組件是否處於活躍狀態。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract: true, // 抽象組件 props:{ include: patternTypes, // 要緩存的有哪些 exclude: patternTypes, // 要排除的有哪些 max: [String, Number] //最大緩存數量 } if(cache[key]) { // 通過key 找到緩存，獲取實例 vnode.componentInstance = cache[key].componentInstance remove(keys, key) //將key刪除掉 keys.push(key) // 放到末尾 } else { cache[key] = vnode // 沒有緩存過 keys.push(key) //存儲key if(this.max \u0026amp;\u0026amp; keys.length \u0026gt; parseInt(this.max)) { // 如果超過最大緩存數 // 刪除最早緩存的 pruneCacheEntry(cache, keys[0], keys, this._vnode) } } vnode.data.keepAlive = true // 標記走了緩存 Vue.minxin的使用場景和原理？ Vue.mixin的作用就是抽離公共的業務邏輯，原理類似\u0026quot;對象的繼承\u0026quot;，當組件初始化時會調用 mergeOptions方法進行合併，採用策略模式針對不同的屬性進行合併，如果混入的數據和本身組件中的數據衝突，會採用\u0026quot;就近原則\u0026quot;以組件的數據為準。 補充：\nmixin中有很多缺陷\u0026quot;命名衝突問題\u0026quot;、\u0026ldquo;依賴問題\u0026rdquo;、\u0026ldquo;數據來源問題\u0026rdquo;，這裡強調一下mixin的數據是不會被共享的。\n路由篇 Vue-router有幾種鉤子函數？具體是什麼及執行流程是怎樣的？ 路由鉤子的執行流程，鉤子函數種類有：全局守衛、路由守衛、組件守衛。 完整的導航解析流程 導航被觸發 在失活的組件裡調用beforeRouteLeave守衛 調用全局beforeEach守衛 在復用組件裡調用beforeRouteUpdate守衛 調用路由配置裡的beforeEnter守衛 解析異步路由組件 在被激活的組件裡調用beforeRouteEnter守衛 調用全局beforeResolve守衛 導航被確認 調用全局的afterEach鉤子 DOM更新 用創建好的實例調用beforeRouteEnter守衛中傳給next的回調函數 vue-router 兩種模式的區別？ vue-router 有 3 種路由模式：hash、history、abstract。 hash模式：hash + hashChange\n特點：hash雖然在URL中，但不被包括在HTTP請求中；用來指導瀏覽器動作，對服務端安全無用，hash不會重加載頁面。通過監聽 hash（#）的變化來執行js代碼 從而實現 頁面的改變。\n核心代码：\n1 2 3 window.addEventListener(‘hashchange‘,function(){ self.urlChange() }) history模式：historyApi + popState\nHTML5推出的history API，由pushState()記錄操作歷史，監聽popstate事件來監聽到狀態變更。\n因為只要刷新這個url(www.ff.ff/jjkj/fdfd/fdf/fd)就會請求服務器，然而服務器上根本沒有這個資源，所以就會報404，解決方案就配置一下服務器端。\n說明：\n1. hash: 使用 URL hash 值來作路由。支持所有瀏覽器，包括不支持 HTML5 History Api 的瀏覽器\n2. history : 依賴 HTML5 History API 和服務器配置。具體可以查看 HTML5 History 模式\n3. abstract : 支持所有 JavaScript 運行環境，如 Node.js 服務器端。如果發現沒有瀏覽器的 API，路由會自動強制進入這個模式\n屬性作用與對比篇 nextTick在哪裡使用？原理是？ nextTick的回調是在下次DOM更新循環結束之後執行的延遲回調。在修改數據之後立即使用這個方法，獲取更新後的DOM。 nextTick主要使用了宏任務和微任務。原理就是異步方法(promise, mutationObserver, setImmediate, setTimeout)經常與事件循環一起來問。 補充：\nvue多次更新數據，最終會進行批處理更新。內部調用的就是nextTick實現了延遲更新，用戶自定義的nextTick中的回調會被延遲到更新完成後調用，從而可以獲取更新後的DOM。\nVue 為什麼需要虛擬DOM？虛擬DOM的優劣如何？ Virtual DOM 就是用js對象來描述真實DOM，是對真實DOM的抽象，由於直接操作DOM性能低但是js層的操作效率高，可以將DOM操作轉化成對像操作，最終通過diff算法比對差異進行更新DOM(減少了對真實DOM的操作)。虛擬DOM不依賴真實平台環境從而也可以實現跨平台。 補充：\n虛擬DOM的實現就是普通對象包含tag、data、children等屬性對真實節點的描述。(本質上就是在JS和DOM之間的一個緩存)\nVue2的 Virtual DOM 借鑒了開源庫snabbdom的實現。\nVirtualDOM映射到真實DOM要經歷VNode的create、diff、patch等階段。\nVue中key的作用和工作原理，說說你對它的理解 例如： 1 v-for=\u0026#34;(item, itemIndex) in tabs\u0026#34; :key=\u0026#34;itemIndex\u0026#34; key的作用主要是為了高效的更新虛擬DOM，其原理是vue在patch過程中通過key可以精準判斷兩個節點是否是同一個，從而避免頻繁更新不同元素，使得整個patch過程更加高效，減少DOM操作量，提高性能。 補充：\n若不設置key還可能在列表更新時引發一些隱蔽的bug vue中在使用相同標籤名元素的過渡切換時，也會使用到key屬性，其目的也是為了讓vue可以區分它們，否則vue只會替換其內部屬性而不會觸發過渡效果 Vue 中的diff原理 vue的diff算法是平級比較，不考慮跨級比較的情況。內部採用深度遞歸的方式 + 雙指針的方式進行比較。 補充：\n先比較是否是相同節點 相同節點比較屬性，並複用老節點 比較兒子節點，考慮老節點和新節點兒子的情況 優化比較：頭頭、尾尾、頭尾、尾頭 比對查找進行複用 Vue2 與 Vue3.x 的diff算法： Vue2的核心Diff算法採用了雙端比較的算法，同時從新舊children的兩端開始進行比較，借助key值找到可複用的節點，再進行相關操作。 Vue3.x借鑒了ivi算法和 inferno算法，該算法中還運用了動態規劃的思想求解最長遞歸子序列。 (實際的實現可以結合Vue3.x源碼看。) v-if 與 v-for的優先級 v-for優先於v-if被解析 如果同時出現，每次渲染都會先執行循環再判斷條件，無論如何循環都不可避免，浪費了性能 要避免出現這種情況，則在外層嵌套template，在這一層進行v-if判斷，然後在內部進行v-for循環 如果條件出現在循環內部，可通過計算屬性提前過濾掉那些不需要顯示的項 v-if與v-show的區別 v-if 是真正的條件渲染，直到條件第一次變為真時，才會開始渲染。 v-show 不管初始條件是什麼會渲染，並且只是簡單地基於 CSS 的 “display” 屬性進行切換。 注意：v-if 適用於不需要頻繁切換條件的場景；v-show 則適用於需要非常頻繁切換條件的場景。\ncomputed 和 watch 的區別和運用的場景？ computed： 計算屬性。依賴其它屬性值，並且 computed 的值有緩存，只有它依賴的屬性值發生改變，下一次獲取 computed 的值時才會重新計算 computed 的值 watch： 監聽數據的變化。更多的是「觀察」的作用，類似於某些數據的監聽回調 ，每當監聽的數據變化時都會執行回調進行後續操作 運用場景： 當我們需要進行數值計算，並且依賴於其它數據時，應該使用 computed，因為可以利用 computed 的緩存特性，避免每次獲取值時，都要重新計算。 當我們需要在數據變化時執行異步或開銷較大的操作時，應該使用 watch，使用 watch 選項允許我們執行異步操作 ( 訪問一個 API )，限制我們執行該操作的頻率，並在我們得到最終結果前，設置中間狀態。這些都是計算屬性無法做到的。 如何理解自定義指令？ 指令的實現原理，可以從編譯原理 ➡ 代碼生成 ➡ 指令鉤子實現進行概述 在生成 ast 語法樹時，遇到指令會給當前元素添加directives屬性 通過 genDirectives 生成指令代碼 在patch前將指令的鉤子提取到 cbs中，在patch過程中調用對應的鉤子 當執行指令對應鉤子函數時，調用對應指令定義的方法 v-model的原理是什麼？ v-model本質就是一個語法糖，可以看成是value + input方法的語法糖。可以通過model屬性的prop和event屬性來進行自定義。原生的v-model，會根據標籤的不同生成不同的事件和屬性。 v-model 在內部為不同的輸入元素使用不同的屬性並拋出不同的事件： text 和 textarea 元素使用 value 屬性和 input 事件。 checkbox 和 radio 使用 checked 屬性和 change 事件。 select 字段將 value 作為 prop 並將 change 作為事件。 性能優化篇 Vue性能優化 - 編碼階段 盡量減少data中的數據，data中的數據都會增加getter和setter，會收集對應的watcher 如果需要使用v-for給每項元素綁定事件時使用事件代理 SPA 頁面採用keep-alive緩存組件 在更多的情況下，使用v-if替代v-show key保證唯一 使用路由懶加載、異步組件 防抖、節流 第三方模塊按需導入 長列表滾動到可視區域動態加載 圖片懶加載 Vue性能優化 - 用戶體驗 骨架屏 PWA 使用緩存(客戶端緩存、服務端緩存)優化、服務端開啟gzip壓縮等 Vue性能優化 - SEO優化 預渲染 服務端渲染SSR Vue性能優化 - 打包優化 壓縮代碼 Tree Shaking/Scope Hoisting 使用cdn加載第三方模塊 多線程打包happypack splitChunks抽離公共文件 sourceMap優化 ","date":"2022-08-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52282698225_df2b066743_o.jpg","permalink":"/2022-08-12/vue-interview-note/","title":"Vue 基本概念與常見面試題筆記"},{"content":" 本文適合 Vue3 初學者，或者 Vue2 遷移者，當然還是建議 Vue3 官網完全過一遍。\n先推薦兩個 vscode 外掛 Volar 首先推薦 Volar ，使用 vscode 開發 Vue 專案的小夥伴肯定都認識 Vetur 這個神級外掛，有了它可以讓我們得開發如魚得水。 那麼 Volar 可以理解為 Vue3 版本的 Vetur ，程式碼高亮，語法提示，基本上 Vetur 有的它都有。\n功能一：多個根節點編譯器不會報錯 Vue3 是允許我們有多個根節點的，但是我們如果使用 Vetur 就會報錯，不會影響執行，但是看起來就很煩。所以當我們轉向 Volar，那麼就不會出現這個問題了。\n功能二：編輯器分隔 即便 Vue 的元件化開發，可以將單檔案的程式碼長度大幅縮短，但還是動輒幾百行甚是上千行。那麼我們切換 template、script、style 的時候就要頻繁上下翻，雖然有的外掛可以直接定位到 css，但是你回不去啊！所以這個功能簡直是太人性化了。\n安裝完 Volar 以後，開啟一個 .vue 檔案，看 vscode 的右上角，有這麼一個圖示，點一下。\n它就會自動給你分隔成三個頁面，分別對應 template、script、style，這樣就太舒服了有沒有。\n還有很多新功能，可以參考下面這篇文章：\nVolar - vue終極開發神器！\n功能三：ref sugar 語法快捷改動支持 ref sugar 是一個還在 rfc 階段的功能，但是已經持續很久了，現在的 vue3 版本已經可以嚐鮮使用了。具體的用法以及語法我就不展開贅述了，我主要說一下 Volar 和 ref sugar 的結合。\n報錯先不管，是 eslint-plugin-vue 的原因。\n可以看到，在使用了 ref sugar 之後，script 上面出現了一個 ref sugar 的小圖標，並且打了個對勾，那麼我們點一下那個對勾，看看會發生什麼。\n可以看到，我們點擊這個小對勾之後，它由原本的 ref sugar 語法變為了普通的 script setup 模式，驚不驚喜，意不意外。\n功能四：style 裡面的 class 引用 可以看到，在 .foo 這個類名上面，出現了一個 1 reference 的小圖標，代表著當前 class 有一次引用，我們點擊一下這個 1 reference。\n出現了一個彈窗，裡面是當前 class 的具體使用位置。\n功能五：class 追朔 我們創建一個 template 根元素，在裡面寫入：\nsample.vue 1 2 3 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 style 中寫入：\nsample.vue 1 2 3 \u0026lt;style scoped\u0026gt; .foo {} \u0026lt;/style\u0026gt; 除了 style 中的 .foo 上面會出現 1 reference 的小圖標之外，在 class=\u0026quot;foo\u0026quot; 的 foo 下面，會出現一道橫線。\n對於經常使用 vscode 的開發人員來說，這代表什麼意義就不必多說了，我們根據提示，按住 ctrl(command) 然後點擊，會發現光標自己移動到了 style 中的 .foo 之前，哇! awesome!\n功能六：css module 類型提示 css module 一般是 react 技術棧用的會比較多一些，就我個人來說，是從沒在 vue 裡面使用它的，因為 vue 提供了 scoped 作用域，不用擔心樣式衝突，直接使用預處理器會更加簡單方便。\n我們創建如下代碼：\nsample.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$style.foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style module\u0026gt; .foo { } \u0026lt;/style\u0026gt; 然後將鼠標移動到 $style 上\n有點意思，看來 vscode 是讓 Volar 玩明白了。\n功能七：lang 語法提示 vue 可以使用 lang 屬性來選擇使用的語言，比如 template 中的 html/pug、script 中的 ts、style 中的 scss 等。\n但是在以前，我們都是手動輸入的，編輯器，或者說 Vetur 並沒有給我們提供任何提示，有可能你找了很久的莫名其妙的問題，就是因為 lang 寫錯了。\n但是這一切，在有了 Volar 之後，都不同了。\n功能八：template 語法轉換 vue 默認提供了兩種模板供我們使用，但是一般都會使用 html，另外一種叫做 pug。\n相對於 html，pug 更偏向於 yml 那種，簡潔程度特別高。\n在 Volar 中，為我們提供了 html 和 pug 互相轉換的功能。\nsample.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;img /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在我們書寫 template 之後，template 頂部會出現一個小小的 pug 圖標，我們可以看到此時它是沒有被選中的。\n這個時候我們點擊一下這個圖標，讓它選中，神奇的事情發生了。\n我們寫好的 html 模板，被自動轉化成了 pug，再點擊一下，又回到了我們熟悉的 html。\n從功能三開始，基本都是算內測的新功能，我是機緣巧合之下，將 Volar 下到本地進行查看的時候發現的這些。想嚐鮮的可以自己下載源碼，然後在packages/vscode-vue-languageservice/testCases目錄下體驗，希望這些功能可以盡快發布！\nVue 3 Snippets 推薦的第二個外掛叫做 Vue 3 Snippets ，同樣的，他也有自己的 Vue2 版本。它是幹什麼的呢，可以看一下下面這張圖，我只輸入了 \u0026quot;v3\u0026quot; ，它有很多提示，我們就先選擇 v3computed ，選中 Enter 即可。\n然後它就給我們自動寫了如下程式碼：\n是不是超級省事，摸魚的時間又增加了！還有更多有趣的使用方式，小夥伴們自行探索吧。\n建立 Vue3 專案 那麼正式開始學習我們的 Vue3 ，先從建立專案開始。\n使用 vue-cli 建立 輸入下面的命令然後選擇配置項進行安裝即可，這裡注意 vue-cli 的版本一定要在 ==4.5.0== 以上。\n1 2 3 4 5 6 7 8 ### 安裝或者升級 npm install -g @vue/cli ### 檢視版本 保證 vue cli 版本在 4.5.0 以上 vue --version ### 建立專案 vue create my-project ### 然後根據提示一步一步傻瓜式操作就行了 ### ... 使用 Vite 建立 都說 Vue3.0 和 Vite2 更配，各種優化各種快，但都不屬於本文的內容，本文的目的我們只需要知道它特別好用、怎麼用就行了。我這裡是多選擇了 TS，每行都有註釋，一目瞭然。\n1 2 3 4 5 6 7 8 ### 初始化 viete 專案 npm init vite-app \u0026lt;project-name\u0026gt; ### 進入專案資料夾 cd \u0026lt;project-name\u0026gt; ### 安裝依賴 npm install ### 啟動專案 npm run dev 建立完以後我們先來看看入口檔案 main.ts\nmain.ts 1 2 3 4 5 6 // 引入 createApp 函式，建立對應的應用，產生應用的例項物件 import { createApp } from \u0026#39;vue\u0026#39;; // 引入 app 元件 (所有元件的父級元件) import App from \u0026#39;./App.vue\u0026#39;; // 建立 app 應用返回對應的例項物件，呼叫 mount 方法進行掛載，掛載到 #app 節點上去 createApp(App).mount(\u0026#39;#app\u0026#39;); 然後看看根元件 app.vue\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- Vue2 元件中的 html 模板中必須要有一對根標籤，Vue3 元件的 html 模板中可以沒有根標籤 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;!-- 使用子級元件 --\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js + TypeScript App\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // 這裡可以書寫 TS 程式碼 // defineComponent 函式，目的是定義一個元件，內部可以傳入一個配置物件 import { defineComponent } from \u0026#39;vue\u0026#39;; // 引入子級元件 import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; // 暴露出去一個定義好的元件 export default defineComponent({ // 當前元件的名字 name: \u0026#39;App\u0026#39;, // 註冊元件 components: { // 註冊一個子級元件 HelloWorld, }, }); \u0026lt;/script\u0026gt; Composition API 接下來到了重頭戲，Vue3 的招牌特性，Composition API。\n關於 Composition API 這裡有圖解演示，極力推薦。\n圖解 Option API vs Composition API\nComposition API 可以更方便的抽取共通邏輯，但是不要過於在意邏輯程式碼複用，以功能提取程式碼也是一種思路。 順便提一句，Vue3 相容大部分 Vue2 語法，所以在 Vue3 中書寫 Vue2 語法是沒有問題的（廢除的除外），但是既然我們已經升級 Vue3 了，不建議混合使用，除非一些大型特殊專案需要相容兩個版本。\n生命週期鉤子 setup setup 是組合 Composition API 中的入口函式，也是第一個要使用的函式。 setup 只在初始化時執行一次，所有的 Composition API 函式都在此使用。 1 2 3 setup() { console.log(\u0026#39;我執行了\u0026#39;) // 我執行了 }, 可以通過 console.log 看到 setup 是在 beforeCreate 生命週期之前執行的(只執行一次)：\n1 2 3 4 5 6 7 8 9 beforeCreate() { console.log(\u0026#39;beforeCreate執行了\u0026#39;); }, setup() { console.log(\u0026#39;setup執行了\u0026#39;); return {}; }, // setup執行了 // beforeCreate執行了 由此可以推斷出 setup 執行的時候，元件物件還沒有建立，元件實例物件 this 還不可用，此時 this 是 undefined，不能通過 this 來訪問 data、computed、methods、props。 返回物件中的^1.^屬性會與 data 函式返回物件的屬性合併成為元件物件的屬性；^2.^返回物件中的方法會與 methods 中的方法合併成功元件物件的方法。 如果有重名，setup 優先。因為在 setup 中 this 不可用，methods 中可以訪問 setup 提供的屬性和方法，但在 setup 方法中不能訪問 data 和 methods 裡的內容，所以還是不建議混合使用。 setup 函式如果返回物件，物件中的屬性或方法，template 中可以直接使用。 sample.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{number}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const number = 18; return { number, }; }, // ... \u0026lt;/script\u0026gt; 注意：setup 不能是一個 async 函式，因為返回值不再是 return 的物件，而是 promise，template 中就不可以使用 return 中返回物件的資料了。\nsetup 的參數(^1.^props, ^2.^context)：\nprops：是一個物件，裡面有父級元件向子級元件傳遞的資料，並且是在子級元件中使用 props 接收到的所有的屬性。 context：上下文物件，可以通過 es6 語法解構 setup(props, {^(a).^attrs, ^(b).^slots, ^(c).^emit})\n\u0026gt; a). attrs：獲取當前元件標籤上所有沒有通過 props 接收的屬性的物件，相當於 this.$attrs。\n\u0026gt; b). slots：包含所有傳入的插槽內容的物件，相當於 this.$slots。\n\u0026gt; c). emit：用來分發自定義事件的函式，相當於 this.$emit。 演示 attrs 和 props： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;child :msg=\u0026#34;msg\u0026#34; msg2=\u0026#39;哈哈哈\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, ref } from \u0026#39;vue\u0026#39;; // 引入子元件 import Child from \u0026#39;./components/Child.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { Child, }, setup() { const msg = ref(\u0026#39;hello,vue3\u0026#39;); return { msg, }; }, }); \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;msg:{{ msg }}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, props: [\u0026#39;msg\u0026#39;], setup(props, {attrs, slots, emit}) { console.log(\u0026#39;props:\u0026#39;, props); // msg: \u0026#34;hello,vue3\u0026#34; console.log(\u0026#39;attrs:\u0026#39;, attrs); // msg2: \u0026#34;哈哈哈\u0026#34; return {}; }, }); \u0026lt;/script\u0026gt; 演示 emit： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;child @click=\u0026#34;show\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; setup() { const show = () =\u0026gt; { console.log(\u0026#39;name:\u0026#39;, \u0026#39;hzw\u0026#39;); }; return { show, }; }, \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;button\u0026gt;事件分發\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, setup(props, { emit }) { const emitFn = () =\u0026gt; { emit(\u0026#39;show\u0026#39;); }; return { emitFn, }; }, }); \u0026lt;/script\u0026gt; ref 作用：定義一個響應式的資料(一般用來定義一個基本型別的響應式資料 Undefined、Null、Boolean、Number、String) 語法： 1 const xxx = ref(initValue); 注意：script 中操作資料需要使用 xxx.value 的形式，而 template 中不需要新增 .value 用一個例子來演示，實現一個按鈕，點選可以增加數字：\naddNum.vue 1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{count}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;updateCount\u0026#39;\u0026gt;增加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在 Vue2 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // ... data() { return { conunt: 0, }; }, methods: { updateCount() { this.conunt++; }, }, // ... \u0026lt;/script\u0026gt; 在 Vue3 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; // ... setup() { // ref 用於定義一個響應式的資料，返回的是一個 Ref 物件，物件中有一個 value 屬性 // 如果需要對資料進行操作，需要使用該 Ref 物件的 value 屬性 const count = ref(0); function updateCount() { count.value++; } return { count, updateCount }; }, // ... \u0026lt;/script\u0026gt; 在 Vue2 中我們通過 this.$refs 來獲取 dom 節點，Vue3 中我們通過 ref 來獲取節點。\n首先需要在標籤上新增 ref='xxx'，然後再 setup 中定義一個初始值為 null 的 ref 型別，名字要和標籤的 ref 屬性一致。\n1 const xxx = ref(null) 注意 ：一定要在 setup 的 return 中返回，不然會報錯。\n用一個例子來演示，讓輸入框自動獲取焦點：\nautoFocus.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;--- \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; /* ref獲取元素: 利用 ref 函式獲取元件中的標籤元素 功能需求: 讓輸入框自動獲取焦點 */ export default { setup() { const inputRef = ref\u0026lt;HTMLElement|null\u0026gt;(null) onMounted(() =\u0026gt; { inputRef.value \u0026amp;\u0026amp; inputRef.value.focus() }) return { inputRef } }, } \u0026lt;/script\u0026gt; reactive 作用：定義多個數據的響應式，接收一個普通物件然後返回該普通物件的響應式代理器物件(Proxy)，響應式轉換是\u0026quot;深層的\u0026quot;：會影響物件內部所有巢狀的屬性，所有的資料都是響應式的。 語法： 1 const proxy = reactive(obj) 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;h3\u0026gt;姓名:{{user.name}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;年齡:{{user.age}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;wife:{{user.wife}}\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;updateUser\u0026#34;\u0026gt;更新\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const user = reactive({ name: \u0026#39;hzw\u0026#39;, age: 18, wife: { name: \u0026#39;xioaohong\u0026#39;, age: 18, books: [\u0026#39;紅寶書\u0026#39;, \u0026#39;設計模式\u0026#39;, \u0026#39;演算法與資料結構\u0026#39;], }, }); const updateUser = () =\u0026gt; { user.name = \u0026#39;小紅\u0026#39;; user.age += 2; user.wife.books[0] = \u0026#39;金瓶梅\u0026#39;; }; return { user, updateUser, }; }, // ... \u0026lt;/script\u0026gt; computed 與 Vue2 中的 computed 配置功能一致，返回的是一個 ref 型別的物件。 computed 的函式中如果只傳入一個箭頭函式 表示的是 get 操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName1 = computed(() =\u0026gt; { return user.firstName + user.lastName; }); return { user, fullName1, }; computed 的函式中可以傳入一個物件，可以包含 set 和 get 函式，進行讀取和修改的操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName2 = computed({ get() { return user.firstName + \u0026#39;_\u0026#39; + user.lastName; }, set(val: string) { const names = val.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }, }); return { user, fullName2, }; watch 與 Vue2 中的 watch 配置功能一致。 作用：監視指定的一個或多個響應式資料，一旦資料變化，就自動執行監視回撥。 語法：watch(要監聽的資料, 回調函式, 配置) 預設初始時不執行回調，但可以通過配置的 immediate 為 true，來指定初始時立即執行第一次。 通過配置的 deep 為 true，來指定深度監視。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { watch, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName3 = ref(\u0026#39;\u0026#39;); watch( user, ({ firstName, lastName }) =\u0026gt; { fullName3.value = firstName + \u0026#39;_\u0026#39; + lastName; }, { immediate: true, deep: true } ); return { user, fullName3, }; watch 監聽多個數據，使用陣列。\nwatch 監聽非響應式資料的時候需要使用回調函式的形式。\n1 2 3 4 5 6 7 8 9 10 watch( [ () =\u0026gt; user.firstName, () =\u0026gt; user.lastName, fullName3 ], () =\u0026gt; { console.log(\u0026#39;我執行了\u0026#39;) } ) watchEffect 作用：監視資料發生變化時執行回調，不用直接指定要監視的資料，回調函式中使用的哪些響應式資料就監視哪些響應式資料，預設初始時就會執行第一次，從而可以收集需要監視的資料。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { watchEffect, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName4 = ref(\u0026#39;\u0026#39;); watchEffect(() =\u0026gt; { fullName4.value = user.firstName + \u0026#39;_\u0026#39; + user.lastName; }); return { user, fullName4, }; // watchEffect可以實現計算屬性set方法 watchEffect(() =\u0026gt; { const names = fullName3.value.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }); 生命週期對比：\n注意：3.0 中的生命週期鉤子要比 2.X 中相同生命週期的鉤子要快。 Composition API 還新增了以下用於除錯的鉤子函式，但是不怎麼常用：onRenderTracked、onRenderTriggered。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;--onBeforeMount\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;--onMounted\u0026#39;) }) onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;--onBeforeUpdate\u0026#39;) }) onUpdated(() =\u0026gt; { console.log(\u0026#39;--onUpdated\u0026#39;) }) onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;--onBeforeUnmount\u0026#39;) }) onUnmounted(() =\u0026gt; { console.log(\u0026#39;--onUnmounted\u0026#39;) }) } toRefs 作用：把一個響應式物件轉換成普通物件，該普通物件的每個屬性都是一個 ref。 應用：我們使用 reactive 建立的物件，如果想在模板中使用，就必須得使用 xxx.xxx 的形式，如果大量用到的話還是很麻煩的，但是使用 es6 解構以後，會失去響應式，那麼 toRefs 的作用就體現在這，利用 toRefs 可以將一個響應式 reactive 物件的所有原始屬性轉換為響應式的 ref 屬性。當然小夥伴們可以自行開發更多應用場景。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; name:{{name}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, reactive, toRefs } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const state = reactive({ name: \u0026#39;hzw\u0026#39;, }); const state2 = toRefs(state); setInterval(() =\u0026gt; { state.name += \u0026#39;===\u0026#39;; }, 1000); return { // 通過 toRefs 返回的物件，解構出來的屬性也是響應式的 ...state2, }; }, }); \u0026lt;/script\u0026gt; provide 與 inject 作用：實現跨層級元件(祖孫)間通訊。 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;父元件\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;當前顏色: {{color}}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;red\u0026#39;\u0026#34;\u0026gt;紅\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;yellow\u0026#39;\u0026#34;\u0026gt;黃\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;blue\u0026#39;\u0026#34;\u0026gt;藍\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { provide, ref } from \u0026#39;vue\u0026#39; import Son from \u0026#39;./son.vue\u0026#39; export default { name: \u0026#39;ProvideInject\u0026#39;, components: { Son }, setup() { const color = ref(\u0026#39;red\u0026#39;) provide(\u0026#39;color\u0026#39;, color) return { color } } } \u0026lt;/script\u0026gt; son.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;GrandSon /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import GrandSon from \u0026#39;./grandson.vue\u0026#39; export default { components: { GrandSon }, } \u0026lt;/script\u0026gt; grandson.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h3 :style=\u0026#34;{color}\u0026#34;\u0026gt;孫子元件: {{color}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39; export default { setup() { const color = inject(\u0026#39;color\u0026#39;) return { color } } } \u0026lt;/script\u0026gt; 其他特性 Teleport(瞬移) 作用：Teleport 提供了一種乾淨的方法，讓元件的 html 在父元件介面外的特定標籤(很可能是 body )下插入顯示，換句話說就是可以把子元件或者dom節點插入到任何你想插入到的地方去。 語法：使用 to 屬性，引號內使用選擇器。 1 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/teleport\u0026gt; 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;modal-button\u0026gt;\u0026lt;/modal-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import ModalButton from \u0026#39;./components/ModalButton.vue\u0026#39; export default { setup() { return {} }, components: { ModalButton, }, } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;modalOpen = true\u0026#34;\u0026gt; 點我開啟對話方塊 \u0026lt;/button\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;modalOpen\u0026#34; class=\u0026#34;looklook\u0026#34;\u0026gt; 看看我出現在了哪裡 \u0026lt;button @click=\u0026#34;modalOpen = false\u0026#34;\u0026gt; Close \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;modal-button\u0026#39;, setup() { const modalOpen = ref(false) return { modalOpen, } }, } \u0026lt;/script\u0026gt; 可以看到在子元件中的 looklook 元素跑到了 body 下面，而之前的位置默認出現了兩行註釋。\nSuspense(不確定的) 作用：它們允許我們的應用程式在等待非同步元件時渲染一些後備內容，可以讓我們建立一個平滑的使用者體驗。 語法： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;!-- 非同步元件 --\u0026gt; \u0026lt;AsyncComp /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;!-- 後備內容 --\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; vue3 中引入非同步元件的方式：\n1 const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #defaul --\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;AsyncComp/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #fallback --\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) export default { setup() { return { } }, components: { AsyncComp, } } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;AsyncComp22\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name: \u0026#39;AsyncComp\u0026#39;, setup () { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ msg: \u0026#39;abc\u0026#39; }) }, 2000) }) } } \u0026lt;/script\u0026gt; 通過下圖可以看到在非同步元件加載出來之前，顯示的是 fallback 中的內容：\n響應式資料的判斷 作用 isRef：檢查一個值是否為一個 ref 物件 isReactive：檢查一個物件是否是由 reactive 建立的響應式代理 isReadonly：檢查一個物件是否是由 readonly 建立的只讀代理 isProxy：檢查一個物件是否是由 reactive 或者 readonly 方法建立的代理 程式碼演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 setup() { const state1 = ref(1); console.log(\u0026#39;isref:\u0026#39;, isRef(state1)); // isref: true const state2 = reactive({}); console.log(\u0026#39;isReactive:\u0026#39;, isReactive(state2)); // isReactive: true const state3 = readonly({}); console.log(\u0026#39;isReadonly:\u0026#39;, isReadonly(state3)); // isReadonly: true const state4 = reactive({}); console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state2)); // isProxy: true console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state4)); // isProxy: true return {}; }, 其他不常用特性 還有很多很多不常用的新特性，我在日常開發中是沒有用到的，很多都是用來做優化的，感興趣的小夥伴們自行去官網檢視，或者大佬們可以介紹一下應用場景。\nshallowReactive shallowRef readonly shallowReadonly markRaw customRef \u0026hellip; 語法糖 雖然 Composition API 用起來已經非常方便了，但是我們還是有很煩的地方，比如：\n元件引入了還要註冊。 屬性和方法都要在 setup 函式中返回，有的時候僅一個 return 就十幾行甚至幾十行。 \u0026hellip; 不想寫啊怎麼辦\n好辦， Vue3 官方提供了 script setup 語法糖，只需要在 script 標籤中==新增 setup==，元件只需引入不用註冊，屬性和方法也不用返回，setup 函式也不需要，甚至 export default 都不用寫了，不僅是資料、計算屬性和方法，甚至是自定義指令也可以在我們的 template 中自動獲得。\n但是這麼過癮的語法糖，還是稍微添加了一點點心智負擔，因為沒有了 setup 函式，那麼 props、emit、attrs 怎麼獲取呢，就要介紹一下新的語法了。\nsetup script 語法糖提供了三個新的 API 來供我們使用： ==defineProps==、==defineEmit== 和 ==useContext==。\ndefineProps：用來接收父元件傳來的值 props。 defineEmit：用來宣告觸發的事件表。 useContext：用來獲取元件上下文 context。 程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Children msg=\u0026#34;hello\u0026#34; @child-click=\u0026#34;handleClick\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;./components/children.vue\u0026#39; const handleClick = (ctx) =\u0026gt; { console.log(ctx) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;span @click=\u0026#34;sonClick\u0026#34;\u0026gt;msg: {{ props.msg }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useContext, defineProps, defineEmit } from \u0026#39;vue\u0026#39; const emit = defineEmit([\u0026#39;child-click\u0026#39;]) const ctx = useContext() const props = defineProps({ msg: String, }) const sonClick = () =\u0026gt; { emit(\u0026#39;child-click\u0026#39;, ctx) } \u0026lt;/script\u0026gt; 我們點選一下子元件：\n可以看到 context 被列印了出來，其中的 attrs、emit、slots、expose 屬性和方法依然可以使用。props 也可以輸出在頁面上，事件也成功派發。\n其他知識點 接下來介紹一下我使用 Vue3 過程中遇到的問題或者小技巧，不全面，想起什麼就寫什麼吧。\nscript setup 語法糖的坑\n這個很多大佬已經在 Vue3 的 github 上提交 Issues 了，或許會在不久的將來修復，但現在還是要注意一下。\n如果在父元件中通過 ref='xxx' 的方法來獲取子元件實例，那麼子元件不可以使用 script setup 語法糖，否則會報錯。\n程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child ref=\u0026#39;son\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/children.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const son = ref(null) console.log(\u0026#39; ~ son:\u0026#39;, son) \u0026lt;/script\u0026gt; 子元件先不使用語法糖：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const msg = ref(\u0026#39;hello\u0026#39;) return { msg, } }, } 現在把子元件換成 script setup 語法糖再來試一試：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;hello\u0026#39;) \u0026lt;/script\u0026gt; 可以看到現在是獲取不到子元件定義的 msg 屬性的。\nEmit 派發事件可以對引數進行驗證 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child @sonClick=\u0026#39;sonClick\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/Child.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const sonClick = (value) =\u0026gt; { console.log(value) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{ msg }} \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(1)\u0026#34;\u0026gt;我是按鈕1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(2)\u0026#34;\u0026gt;我是按鈕2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;\u0026#39;, emits: { sonClick: (value) =\u0026gt; { if (value === 1) { return true } else { return false } }, }, setup(props, { emit }) { const msg = ref(\u0026#39;hello\u0026#39;) const handleClick = (value) =\u0026gt; { emit(\u0026#39;sonClick\u0026#39;, value) } return { msg, handleClick, } }, } \u0026lt;/script\u0026gt; 我們分別點一下按鈕1和按鈕2，可以看到當我們點了按鈕2的時候，控制檯會發出警告，但是程式會繼續執行，還沒想到什麼適合的應用場景，但是要知道這個知識點，小夥伴們可以在這搞事情。\n跨元件通訊 mitt.js Vue2 中怎麼實現跨元件通訊呢？很多人第一想法就是 event bus。但是 Vue3 移除了 $on、$once、$off 導致不能使用這個方法。但是 Vue 官方給大家推薦了 ==mitt.js==，它的原理就是 event bus。\nmitt.js 教學\n程式碼演示 先安裝： 1 npm i mitt -s 然後封裝成一個 hook： mitt.js 1 2 3 4 import mitt from \u0026#39;mitt\u0026#39; const emitter = mitt(); export default emitter; 使用： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child1 /\u0026gt; \u0026lt;Child2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child1 from \u0026#39;./components/children1.vue\u0026#39; import Child2 from \u0026#39;./components/children2.vue\u0026#39; \u0026lt;/script\u0026gt; children1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件1 \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onUnmounted } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { // 初始化 const msg = ref(\u0026#39;hello\u0026#39;) const changeMsg = () =\u0026gt; { msg.value = \u0026#39;world\u0026#39; } // 監聽事件，更新資料 emitter.on(\u0026#39;change-msg\u0026#39;, changeMsg) // 顯式解除安裝 onUnmounted(() =\u0026gt; { emitter.off(\u0026#39;change-msg\u0026#39;, changeMsg) }) return { msg, changeMsg, } }, } \u0026lt;/script\u0026gt; children2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件2 \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;changeMsg\u0026#39;\u0026gt;點選修改msg\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { const changeMsg = () =\u0026gt; { emitter.emit(\u0026#39;change-msg\u0026#39;) } return { changeMsg, } }, } \u0026lt;/script\u0026gt; 演示 自定義指令 先看看 Vue2 自定義指令的鉤子：\nbind：當指令繫結在對應元素時觸發，只會觸發一次。 inserted：當對應元素被插入到 DOM 的父元素時觸發。 update：當元素更新時，這個鉤子會被觸發（此時元素的後代元素還沒有觸發更新）。 componentUpdated：當整個元件（包括子元件）完成更新後，這個鉤子觸發。 unbind：當指令被從元素上移除時，這個鉤子會被觸發，也只觸發一次。 在 Vue3 中，官方為了更有助於程式碼的可讀性和風格統一，把自定義指令的鉤子名稱改的更像是元件生命週期，儘管他們是兩回事：\nbind =\u0026gt; beforeMount。 inserted =\u0026gt; mounted。 beforeUpdate：新的鉤子，會在元素自身更新前觸發。 update =\u0026gt; 移除！ componentUpdated =\u0026gt; updated。 beforeUnmount：新的鉤子，當元素自身被解除安裝前觸發。 unbind =\u0026gt; unmounted。 過渡動畫 這個沒有什麼大的改動，只是修改了兩個 class 名字，正是因為沒有什麼大的改動，導致我曾經在這裡栽了大跟頭，寫完了怎麼都不對，後來查官網才知道。\n以下是直接引用官網的原文：\nv-enter-from：定義進入過渡的開始狀態。在元素被插入之前生效，在元素被插入之後的下一幀移除。 v-enter-active：定義進入過渡生效時的狀態。在整個進入過渡的階段中應用，在元素被插入之前生效，在過渡/動畫完成之後移除。這個類可以被用來定義進入過渡的過程時間，延遲和曲線函式。 v-enter-to：定義進入過渡的結束狀態。在元素被插入之後下一幀生效 (與此同時 v-enter-from 被移除)，在過渡/動畫完成之後移除。 v-leave-from：定義離開過渡的開始狀態。在離開過渡被觸發時立刻生效，下一幀被移除。 v-leave-active：定義離開過渡生效時的狀態。在整個離開過渡的階段中應用，在離開過渡被觸發時立刻生效，在過渡/動畫完成之後移除。這個類可以被用來定義離開過渡的過程時間，延遲和曲線函式。 v-leave-to：離開過渡的結束狀態。在離開過渡被觸發之後下一幀生效 (與此同時 v-leave-from 被刪除)，在過渡/動畫完成之後移除。 特別注意的是：\nv-enter 改成了 v-enter-form\nv-leave 改成了 v-leave-from\n其他小知識 Vue3 移除了 filter。 獲取元件實例的方法 getCurrentInstance()：\n這個方法可以獲取到當前元件的實例，相當於 Vue2 中的 this，但是它只在==開發環境==起效果，打包以後會報錯，所以大家不要依賴 getCurrentInstance 方法去獲取元件實例來完成一些主要功能。\n更詳細的可以檢視下面這篇文章：\n關於Vue3獲取當前元件例項的 getCurrentInstance 方法的補充 最後，畢竟是個人總結，難免會出現紕漏和錯誤，期待各路大神的補充和糾正。\n參考 參考網站 Vue3官方中文文件 Vue3.0光速上手 Volar - vue終極開發神器！ Vue3.0 新特性以及使用經驗總結 尚矽谷2021最新Vue.JS教程快速入門到專案實戰（Vue3/VueJS技術詳解） 那個忙了一夜的Vue3動畫很好，就是太短了 ","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277578302_d4a3e0c4aa_o.png","permalink":"/2022-08-11/vue3-quick-start/","title":"Vue3.0 快速入門，看完基本可以上手搞開發"},{"content":" 參考網站\n參考網站\n回顧 Option API 在了解 Composition Api 之前，首先回顧下我們使用 Option Api 遇到的問題，我們在 Vue2 中常常會需要在特定的區域（data、methods、watch、computed\u0026hellip;）編寫負責相同功能的代碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return{ val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; Option Api 的缺陷 反覆橫跳 隨著業務複雜度越來越高，代碼量會不斷的加大；由於相關業務的代碼需要遵循 option 的配置寫到特定的區域，導致後續維護非常的複雜，代碼可複用性也不高。\n相信大部分同學都維護過超過200行的 .vue 組件，新增或者修改一個需求，就需要分別在 data、methods、computed 裡修改，滾動條反复上下移動，我稱之為『反复橫跳』，比如我們簡單的加個拍腦門的需求加個累加器，這種寫代碼上下反复橫條的感覺，相信大家都懂的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1 @click=\u0026#34;add\u0026#34;\u0026gt;LSP {{count}}号 double is{{double}}\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ return{ count:1, val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, computed: { double() { return this.count * 2 } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; }, add(){ this.count++ } } } \u0026lt;/script\u0026gt; mixin 和 this 反覆橫跳的本質，在於功能的分塊組織，以及代碼量太大了，如果我們能把代碼控制在一屏，自然就解決了，vue2 裡的解決方案，是使用 mixin 來混合, 我們抽離一個 counter.js： counter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export default { data() { return { count:1 } }, computed: { double() { return this.count * 2 } }, methods:{ add(){ this.count++ } } } App.vue 1 2 3 4 5 6 7 8 import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ ... }, ... } 這樣確實拆分了代碼，但是有一個很嚴重的問題，就是不打開 counter.js，App.vue 裡的 this 上，count、add這些屬性，是完全不知道從哪來的，你不知道是 mixin，還是全局 install，還是 Vue.prototype.count 設置的，數據來源完全模糊，調試爽死你，這也是 option 的一個大問題，this 是個黑盒，template 裡寫的 count 和 double，完全不知道從哪來的。\n如果有兩個 mixin，就更有意思了，比如我們又有一個需求，實時顯示鼠標的坐標位置 x，並且有一個乘以 2 的計算屬性湊巧也叫 double，再整一個 mixin：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { data() { return { x:0 } }, methods:{ update(e){ this.x = e.pageX } }, computed:{ double(){ return this.x*2 } }, mounted(){ window.addEventListener(\u0026#39;mousemove\u0026#39;, this.update) }, destroyed(){ window.removeEventListener(\u0026#39;mousemove\u0026#39;, this.update) } } 這是一個獨立維護的 mixin，可能在 N 個地方用到，他根本不知道會不會有人和他衝突，然後用一下：\nApp.vue 1 2 3 4 5 6 import Counter from \u0026#39;./counter\u0026#39; import Mouse from \u0026#39;./mouse\u0026#39; export default { mixins:[Counter,Mouse], ...... } 兩個 mixin 裡都有 double 這個數，尷尬，看效果，lsp 的 count 被覆蓋了很尷尬，而且在 App.vue 這裡，你完全不知道這個 double 到底是哪個，調試很痛苦。\nComposition Api composition 就是為了解決這個問題存在的，通過組合的方式，把零散在各個 data、methods 的代碼重新組合，一個功能的代碼都放在一起維護，並且這些代碼可以單獨拆分成函數，顯然我們可以更加優雅的組織我們的代碼，函數。讓相關功能的代碼更加有序的組織在一起。\n我們用vue3演示一下功能，具體api就不解釋了直接vue3文檔搞起就可以：\nApp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) let todos = reactive([ { id:0, title:\u0026#39;吃饭\u0026#39;, done:false }, { id:1, title:\u0026#39;睡觉\u0026#39;, done:false }, { id:2, title:\u0026#39;lsp\u0026#39;, done:false }, ]) function addTodo(){ todos.push({ id: todos.length, title: val.value, done: false }) val.value = \u0026#39;\u0026#39; } return {val, todos, addTodo} } } \u0026lt;/script\u0026gt; 利用函數我們可以把功能完整獨立的拆分成模塊或者函數，方便組織代碼，並且解決了 mixin 混亂的問題。\n比如我們的累加器，抽離一個counter.js：\ncounter.js 1 2 3 4 5 6 7 8 9 10 import { ref, computed } from \u0026#39;vue\u0026#39; export default function useCounter(){ let count = ref(1) function add(){ count.value++ } let double = computed(()=\u0026gt;count.value*2) return { count, double, add } } 直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; + import useCounter from \u0026#39;./counter\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) ... + let { count,double,add } = useCounter() return { val, todos, addTodo, + count, double, add } } } 再來一個鼠標位置也不在話下，而且可以很好地利用解構賦值的別名，解決 mixin 的命名衝突問題：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { ref, onMounted, onUnmounted, computed } from \u0026#39;vue\u0026#39; export default function useMouse(){ let x = ref(0) function update(e){ x.value = e.pageX } let double = computed(()=\u0026gt;x.value*2) onMounted(()=\u0026gt;{ window.addEventListener(\u0026#39;mousemove\u0026#39;, update) }) onUnmounted(()=\u0026gt;{ window.removeEventListener(\u0026#39;mousemove\u0026#39;, update) }) return { x, double } } 模板裡直接用 doubelX：\n1 2 3 4 5 6 7 let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } script setup 不過有的同學可能，還有一個小小的吐槽，那就是 setup 函數最後的 return 也是集中的，如果行數太多，一樣會橫條一下下。\n這個好解決，因為本身我們可以把 todos 也抽離成函數，這樣 setup 就全部是數據的來源，非常精簡絲滑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; export default { setup(){ let { val, todos, addTodo } = useTodo() let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } } } 是不是賊爽呢，如果有些同學就是不想啥都抽離，還是覺得統一 return 很麻煩， 我們可以使用 vue3 的 setup script 功能，把 setup 這個配置也優化掉一個功能 export 一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; let { val, todos, addTodo } = useTodo() export { val, todos, addTodo } let { count, double, add } = useCounter() export { count, double, add } let { x, double:doubleX } = useMouse() export { x, doubleX } \u0026lt;/script\u0026gt; 具體看這裡\n","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277524312_b6dc5e213c_o.png","permalink":"/2022-08-11/option-api-vs-composition-api/","title":"圖解 Option API vs Composition API"},{"content":" 【尚硅谷】ES6教程 - 涵盖 ES6~ES11\n給進入 Vue.js 前的 ES6 必備知識\n超级实用的 ES6 特性\n【詳細 MDN 文件】\nECMAScript ES 是 ECMAScript 的簡稱，ECMAScript 是腳本語言的規範。而我們所使用的 JavaScript 是 ECMAScript 的一種實現。 簡言之：ECMA做出規範，各瀏覽器依照規範做出實現，因而不同瀏覽器會有兼容性不同的情況。 ES6 是 ES 的經典版本，是前端工程師崗位的高頻需求，是前端開發工程師求職的必備技能。 現階段前端行業發展迅猛，前端技術也在高速迭代， ES6-ES11 規范增加了很多 JavaScript 新特性。 ES 新特性已經成為前端技術發展的趨勢，語法簡潔，功能豐富，部分特性還有性能提升，前端開發三大框架 Vue、React、Angular 都用到了大量的新特性代碼，框架的升級也在向著新特性語法靠攏。 var 、 let 與 const var 、 let 與 const 在 Javascript 都是用來宣告變數的語法，最大的差別是他們的scope(變數有效範圍)的不同。切分var作用範圍的最小單位為 function，而 let 與 const 的作用範圍是 block 也就是俗稱的大括號：{ } 來切分。 const 所宣告的變數還有另一個特性是無法被重新賦值 (re-assign)。 let 特性 var 可以重複聲明，但 let 不能重複聲明。 演示： 1 2 3 4 5 var testA = \u0026#34;AAA\u0026#34;; var testA = \u0026#34;BBB\u0026#34;; // 不會報錯 let testB = \u0026#34;AAA\u0026#34;; let testB = \u0026#34;BBB\u0026#34;; // 會報錯 let 為塊級作用域 塊級作用域：變數只在代碼塊裡面有效({ ... }、if else、while、for) 在 ES5 中，作用域有：全局、函數、eval(嚴格模式下) 演示： 1 2 3 4 5 6 7 8 9 { var b = \u0026#34;BBB\u0026#34;; } console.log(b); // \u0026#34;BBB\u0026#34;，因為 var 非塊級作用域，所以聲明時會往外層(全局window)添加這個屬性 { let a = \u0026#34;AAA\u0026#34;; } console.log(a); // 會報錯 a is not defined 不存在變數提升 變數提升：代碼執行前會先進行變數搜集，var 聲明的變量在搜集時會先定義一個 undefined 的初始值。 演示： 1 2 3 4 5 6 7 // 在 a 用 var 聲明前輸出 console.log(a); // 不會報錯，會輸出 undefined var a = \u0026#34;AAA\u0026#34;; // 在 b 用 let 聲明前輸出 console.log(b); // 會報錯，Cannot access \u0026#39;b\u0026#39; before initialization let b = \u0026#34;BBB\u0026#34;; 不影響作用域鏈 演示： 1 2 3 4 5 6 7 { let school = \u0026#34;尚硅谷\u0026#34;; function fn() { console.log(school); } fn(); // 輸出 \u0026#34;尚硅谷\u0026#34;，在 fn 內沒有 school，會往外層尋找 } let 經典範例實踐 實作點擊 div 時切換顏色 代碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-header\u0026#34;\u0026gt; 點擊切換顏色 \u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 獲取 div 元素對象 let items = document.getElementsByClassName(\u0026#34;item\u0026#34;); // 遍歷並綁定事件 for (var i = 0; i\u0026lt; items.length; i++) { item[i].onclick = function() { // 修改當前元素的背景顏色 // 最佳寫法應為： this.style.background = \u0026#34;pink\u0026#34;; // 常見錯誤寫法： // items[i].style.background = \u0026#34;pink\u0026#34;; // // 原因： // i 使用 var 來聲明，var 聲明的變數非塊級作用域， // 因此 i 被聲明在全局(window)，此處取 i 會發現 window.i 已經等於 3 // 所以 items[3].style 會找不到。 // // 修正方式： // 將 i 改用 let 來聲明，讓 i 只存在於 for 迴圈中。 } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const 特性 一定要賦初始值，且聲明後值不能被修改。 一般常數使用大寫(淺規則)。 也是塊級作用域 演示： 1 2 3 4 5 { const PLAYER = \u0026#34;UZI\u0026#34;; } console.log(PLAYER); // 會報錯，PLAYER is not defined 對於 Array 和 Object 的元素修改，不算對常數的修改，不會報錯。 演示： 1 2 3 4 { const TEAM = [\u0026#34;UZI\u0026#34;, \u0026#34;MXLG\u0026#34;, \u0026#34;Ming\u0026#34;, \u0026#34;Letme\u0026#34;]; TEAM.push(\u0026#34;Meiko\u0026#34;); // 不會報錯，因為變數所指向的地址沒有改變 } 函式的參數默認值 在 ES5 中必須這麼寫： 1 2 3 4 function printText(text) { text = text || \u0026#34;default\u0026#34;; console.log(text); } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 function printText(text = \u0026#34;default\u0026#34;) { console.log(text); } 二進制與八進制字面量 ES6 支持二進制與八進制的字面量，通過在數字前面添加 0o 或者 0O 即可將其轉換為八進制值、添加 0b 或者 0B 即可將其轉換為二進制值。 1 2 3 4 5 6 7 let oValue = \u0026#34;0o10\u0026#34;; console.log(oValue); // \u0026gt;\u0026gt;\u0026gt; 8 let bValue = 0b10; console.log(bValue); // \u0026gt;\u0026gt;\u0026gt; 2 ES Module 與 import 、 export Javascript 自從 ES6 開始新增了模組系統(ES Module)，我們可以將每個 Javascript 的檔案當作是一個獨立的模組來看待，在 A 檔案匯出(export)在 B 檔案匯入(import)。 a.js 1 2 3 4 5 6 7 export const aString = \u0026#34;This is A String\u0026#34;; export function aFunction() { console.log(\u0026#34;A Function test\u0026#34;) } export const aObject = { a: 1 }; b.js 1 2 3 4 5 6 7 8 9 10 import { aString, aFunction, aObject } from \u0026#34;./a.js\u0026#34;; console.log(aString); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;This is A String\u0026#34; console.log(aObject); // \u0026gt;\u0026gt;\u0026gt; { a: 1 } aFounction(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;A Function test\u0026#34; 當然在 export 也可以不用給變數名稱： c.js 1 2 3 export default function() { console.log(\u0026#34;Hello 008 JS!!!\u0026#34;); } 在另一個檔案就可以這樣來使用： d.js 1 2 3 4 import greeting from \u0026#34;./c.js\u0026#34;; greeting(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello 008 JS!!!\u0026#34; 箭頭函數與 this 從 ES6 開始新增了一種叫做 「箭頭函式表示式」 (Arrow Function expression) 的函式表達式。快速看一下，如何將一般的函式轉換成箭頭函式的寫法： 1 2 3 const plus = function(numA, numB) { return numA + numB; }; 首先我們把參數往前提，然後把關鍵字 function 刪掉改成箭頭符號 =\u0026gt;： 1 2 3 const plus = (numA, numB) =\u0026gt; { return numA + numB; }; 如果這個函式只是想要回傳某個運算結果的時候，可以將 return 以及大括號 { } 省略： 1 const plus = (numA, numB) =\u0026gt; numA + numB; 而只有一個參數的時候，參數前面的小括號( )則可以省略： 1 2 3 4 const saySomething = msg =\u0026gt; console.log(msg); saySomething(\u0026#34;Hello!\u0026#34;); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello!\u0026#34; 另外需要注意的是，在箭頭函式使用 this 時，這時 this 會指向箭頭函式外面的 this，這個規則與原本 function 所宣告的函式不同，而且箭頭函式無法透過 bind() 強制指定裡面的 this。 字串模板 (Template literals) 以往我們在組合 JavaScript 的變數與 HTML 模板的時候，大多會透過「字串結合」 + 的模式，或透過陣列來新增字串，最後再用 [].join(\u0026quot;\u0026quot;) 的方式串接起來。但自 ES6 起，我們可以透過字串模板的語法，將變數、運算式等插入至我們的網頁模板當中，像這樣： 1 2 // 用「`...`」取代單/雙引號 `string text ${expression} string text` 這樣我們就可以將這個 expression 所代表的運算式或數值置入到字串裡頭了。 解構賦值 (Destructuring assignment) ES6 提供了解構賦值的語法，可以將陣列或者物件裡面的資料解開變成獨立的變數： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const user = { id: 42, displayName: \u0026#34;jdoe\u0026#34;, fullName: { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } }; const { id, displayName, fullName } = user; console.log(id); // \u0026gt;\u0026gt;\u0026gt; 42 console.log(displayName); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;jdoe\u0026#34; console.log(fullName); // \u0026gt;\u0026gt;\u0026gt; { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } 除了物件以外，陣列也可以： 1 2 3 4 5 6 7 8 9 const number = [1, 2, 3, 4, 5]; const [x, y] = number; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 ... 展開運算子 (Spread Operator) / 其餘運算子 (Rest Operator) 雖然 ES6 提供的展開運算子與其餘運算子的語法都是 ...，不過它們兩者所代表的涵意還是不太一樣。 展開運算子 展開運算子通常會用在陣列，或者是函式的參數，如： 1 2 3 4 5 const frameworks = [\u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;]; const arr = [\u0026#34;Awesome\u0026#34;, ...frameworks]; console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] 其餘運算子 延續前面的例子，我們可以透過 「其餘運算子」 將剩下的部分拆解出來： 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] const [a, b, ...others] = arr; console.log(a); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Awesome\u0026#34; console.log(b); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Vue.js\u0026#34; console.log(others); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34; 像這樣，我們可以搭配解構賦值的語法，將 arr 陣列拆解處來，並將剩餘的元素透過 ...others 分離。 當然，使用在物件上也是可以的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 其餘 Properties const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 console.log(z); // \u0026gt;\u0026gt;\u0026gt; { a: 3, b: 4 } // 展開 Properties const obj = { x, y, ...z }; console.log(obj); // \u0026gt;\u0026gt;\u0026gt; { x: 1, y: 2, a: 3, b: 4 } 要注意的是，其餘運算子所分離的部分只是陣列或物件的「淺拷貝」，若在多層物件使用時要特別小心。 Promise 物件 為了解決過去同步與非同步的問題，ES6 提供了 Promise 物件： 1 2 3 4 const myPromiseFunc = new Promise((resolve, reject) =\u0026gt; { resolve(someValue); // 完成 // reject(\u0026#34;failure reason\u0026#34;); // 拒絕 }); 當 Promise 的任務被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕這個 Promise，那麼就裡面呼叫 reject() 來拒絕他。 1 2 3 4 5 6 7 8 9 function myAsyncFunction(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } // 透過 .then() 來取代過去的 callback hell myAsyncFunction(...) .then(() =\u0026gt; { ... }); async 與 await 在後來，從 Promise 物件又延伸出 async 與 await 兩個新特性，其實本質上是更簡便的語法糖。 假設我們有兩個非同步任務要處理，並且我們希望在 asyncFunc1 執行完成之後才去執行 asyncFunc2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function asyncFunc1(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } function asyncFunc2(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } const asyncCall = async() =\u0026gt; { const result1 = await asyncFunc1(); const result2 = await asyncFunc2(); }; 像這樣，透過 async 與 await 我們就可以擺脫過去一層層 callback 的惡夢，程式碼也更加簡潔。\n簡寫屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 6 function createCoord(x, y) { return { x: x, y: y } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 6 function createCoord(x, y) { return { x, y } } 方法屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 const math = { add: function(a, b) { return a + b; }, sub: function(a, b) { return a - b; }, multiply: function(a, b) { return a * b; } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 const math = { add(a, b) { return a + b; }, sub(a, b) { return a - b; }, multiply(a, b) { return a * b; } } 陣列方法 ES6 引入了許多有用的陣列方法，例如： find()：查找陣列中的成員，返回 null 表示沒找到 findIndex()：查找陣列成員的索引 some()：檢查某個斷言是否至少一個成員在陣列中 includes：陣列是否包含某項目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const array = [{ id: 1, checked: true }, { id: 2 }]; arr.find(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; { id: 2 } arr.findIndex(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; 1 arr.some(item =\u0026gt; item.checked) // \u0026gt;\u0026gt;\u0026gt; true const numberArray = [1,2,3,4]; numberArray.includes(2); // \u0026gt;\u0026gt;\u0026gt; true ES6 的 class ES6 支持 class 語法，但不是新的對象繼承模型，只是原型鍊的語法糖。 函式中使用 static 關鍵字定義構造函式的方法與屬性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Student { constructor() { console.log(\u0026#34;I\u0026#39;m a student.\u0026#34;); } study() { console.log(\u0026#34;study!\u0026#34;); } static read() { console.log(\u0026#34;Reading Now.\u0026#34;); } } console.log(typeof Student); // \u0026gt;\u0026gt;\u0026gt; Function let stu = new Student(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a student.\u0026#34; stu.study(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;study!\u0026#34; stu.read(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Reading Now.\u0026#34; class 的繼承(extends) extends 允許一個子類繼承父類，需要注意的是，子類的 constructor 函式中需要執行 supre() 函式。 當然你也可以在子類方法中調用父類的方法，如 supre.parentMethodName()。 class 的聲明不會提升 hoisting ，如果你要使用某個 class ，那你必須在使用之前定義他，否則會拋出 reference error 的錯誤。 在 class 中定義函式不需要使用 function 關鍵字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Phone { constructor() { console.log(\u0026#34;I\u0026#39;m a phone.\u0026#34;); } } class MI extends Phone { constructor() { supre(); console.log(\u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34;); } } let mi8 = new MI(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone.\u0026#34; // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34; class 的 super 方法 super 關鍵字被使用於通過函式存取父層 【詳細 MDN 文件】\n語法 1 2 super([arguments]); // calls the parent constructor. super.functionOnParent([arguments]); 當使用建構子，super 關鍵字必須出現在 this 關鍵字之前使用，super 關鍵字也可以使用在呼叫函式與父對象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let parent = { foo() { console.log(\u0026#34;Hello from the Parent\u0026#34;); } } let child = { foo() { super.foo(); console.log(\u0026#34;Hello from the Child\u0026#34;); } } Object.setPrototypeOf(child, parent); child.foo(); // \u0026gt;\u0026gt;\u0026gt; Hello from the Parent // \u0026gt;\u0026gt;\u0026gt; Hello from the Child 非同步處理工具 - Generator(生成器函式) 生成器函式 生成器對像是由一個 generator function 返回的,並且它符合可迭代協議和迭代器協議。 【詳細 MDN 文件】\n語法 1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } let g = gen(); // \u0026#34;Generator { }\u0026#34; 方法 Generator.prototype.next()：返回一個由 yield表達式生成的值。 Generator.prototype.return()：返回給定的值並結束生成器。 Generator.prototype.throw()：向生成器拋出一個錯誤。 範例：一個無限迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function* idMaker() { let index = 0; while(true) yield index++; } let gen = idMaker(); // \u0026#34;Generator { }\u0026#34; console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 0 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 2 // ... 生成器對象 Generator.prototype.next()：返回 yield 表達式生成的值。 Generator.prototype.close()：關閉生成器，因此執行該函式後調用next()方法時將會拋出 StopIteration 錯誤。 Generator.prototype.send()：用於將值發送到生成器。該值由yield表達式返回，並且返回下一個yield表達式生成的值。 Generator.prototype.throw()：向生成器拋出錯誤。 ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52276889089_0bb5aa46f7_o.png","permalink":"/2022-08-10/javascript-es6/","title":"Javascript ES6 特性"},{"content":" 參考網站\nVue CLI 官方webpack相關文檔\n前言 webp 是 2010年 Google 釋出的圖片格式，針對 PNG 可減少 26%，JPEG 約可減少 25% ~ 34%，目前僅 safari、IE 尚不支援，但 safari 在 ios 14 以後開始支援。 若在未提供 .webp 格式圖檔的情況下，使用套件於 webpack 時進行圖片轉檔，但於 development 下會因抓不到虛擬的 XXX.webp 圖檔而導致 npm run 起時噴錯，可使用以下設定解決此問題。 使用 webpack-plugin-image-transform-webp-and-mini 套件將 image 轉檔成 webp 格式 1 npm i webpack-plugin-image-transform-webp-and-mini 新增一個自訂的 webploader 此 loader 功用為：若 resource 的 query (使用 chainWebpack 提供的變數\u0026quot;resourceQuery\u0026ldquo;抓) 字符中含有 \u0026quot;type=webp\u0026quot; 且 resource 為圖片時，將附檔名轉換成 XXX.webp 。 1 2 3 4 5 6 7 8 9 10 11 12 const path = require(\u0026#34;path\u0026#34;) module.exports = function(source, map) { let result = source if (this.resourceQuery \u0026amp;\u0026amp; this.resourceQuery.includes(\u0026#34;type=webp\u0026#34;) \u0026amp;\u0026amp; !this.resource.includes(\u0026#34;data:image\u0026#34;)) { let extname = path.extname(this.resourcePath) result = source.replace(extname, \u0026#34;.webp\u0026#34;) } // return result this.callback(null, result, map) } chainWebpack 設定 套件安裝完成後，vue.config.js 引入套件，並指定webp圖檔存放位置。 引入自訂的 webploader ， 並設定 chainWebpack 的 images 需優先跑 webploader，再跑 url-loader 與 file-loader。 主要解決 Vue-cli 的 development 下，會因實際不存在 \u0026ldquo;XXX.webp\u0026rdquo; 圖檔而導致開發時報錯的問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... const ImageminWebpWebpackPlugin = require(\u0026#34;webpack-plugin-image-transform-webp-and-mini\u0026#34;) // ... chainWebpack: config =\u0026gt; { // ... config.plugins.delete(\u0026#34;preload-index\u0026#34;) config.plugins.delete(\u0026#34;prefetch-index\u0026#34;) // 相關設定建議放於移除 preload-index 與 prefetch-index 之後 config.plugin(\u0026#34;webP\u0026#34;).use(ImageminWebpWebpackPlugin, [ { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34;, logger: false, paths: { dir: path.resolve(__dirname, \u0026#34;./src/assets\u0026#34;), exclude: [] }, miniOptions: false } ]) let rule = config.module.rule(\u0026#34;images\u0026#34;) rule.uses.clear() rule .use(\u0026#34;./webploader.js\u0026#34;) .loader(\u0026#34;./webploader.js\u0026#34;) .end() .use(\u0026#34;url-loader\u0026#34;) .loader(\u0026#34;url-loader\u0026#34;) .options({ limit: 4096, fallback: { loader: \u0026#34;file-loader\u0026#34;, options: { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34; } } }) // ... } 補上是否支援 Webp 的判斷，若支援則於 \u0026lt;html\u0026gt; 補上 class name，供CSS抓取 class name 後改讀 webp 圖片 main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function isSupportWebp() { return new Promise(resolve =\u0026gt; { let result = false const elem = document.createElement(\u0026#34;canvas\u0026#34;) if (elem.getContext \u0026amp;\u0026amp; elem.getContext(\u0026#34;2d\u0026#34;)) { result = elem.toDataURL(\u0026#34;image/webp\u0026#34;).indexOf(\u0026#34;data:image/webp\u0026#34;) === 0 } resolve(result) }) } // 使用自定义过滤器 filter(Vue) ;(async () =\u0026gt; { Vue.prototype.$supportWebp = await isSupportWebp() if (Vue.prototype.$supportWebp) { document.documentElement.classList.add(\u0026#34;webp\u0026#34;) } })() 若有使用 vue-lazyload，則補上 vue-lazyload 提供的 webp 相關設定 \u0026lt;img\u0026gt; 使用 v-lazy 時，src的圖片附檔名皆會轉換成 XXX.webp 1 2 3 4 5 6 7 8 9 10 vue.use(VueLazyload, { filter: { webp(listener) { if (vue.prototype.$supportWebp \u0026amp;\u0026amp; !~listener.src.indexOf(\u0026#34;.webp\u0026#34;)) { listener.src = listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;) listener.el.setAttribute(\u0026#34;data-src\u0026#34;, listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;)) } } } }) 於各個 CSS 中，若 background 使用到需轉 .webp 格式的 img ，補上自行設定的 query (\u0026quot;?type=webp\u0026quot;)，以便 webploader 抓該 query 進行轉換圖檔格式 例如： 1 2 3 4 5 6 7 8 9 10 .page-wrap-main { background: url(\u0026#34;~assets/images/main/bg.png\u0026#34;); background-size: cover; width: 100%; position: relative; .webp \u0026amp; { background-image: url(\u0026#34;~assets/images/main/bg.png?type=webp\u0026#34;); } } ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52282467469_7cf86509a9_o.jpg","permalink":"/2022-08-10/vue-cli-use-webp/","title":"Vue-cli plugin：使用套件將圖片自動轉檔為webp格式"},{"content":" 參考網站\nJavaScript的記憶體空間 在 JavaScript 中，每一個數據都需要一個記憶體空間。記憶體空間分為兩種，棧記憶體（stock） 與 堆記憶體（heap）。 棧是系統自動分配的記憶體空間，由系統自動釋放，堆則是動態分配的記憶體，大小不定不會自動釋放。 基礎資料型別 JavaScript 中的基礎資料型別，這些值都有固定的大小，儲存在 棧記憶體中，由系統自動分配儲存空間，在棧記憶體空間的值，我們可以直接進行操作，因此基礎資料型別都是按照值訪問。 在棧記憶體中的資料發生複製的行為時，系統會自動為新變數開闢一個新的記憶體空間，當複製執行後，兩個記憶體空間的值就互不影響，改變其中一個不會影響另一個 棧記憶體空間資料複製示例 1 2 3 4 5 6 var a = `I am variable a`; var b = a; console.log(b); //`I am variable a` b = `I am variable b`; console.log(a); //`I am variable a` console.log(b); //`I am variable b` 引用資料型別 引用型別的值是儲存在 堆記憶體中的物件，在 JavaScript 中我們不能直接操作物件的堆記憶體空間。因為引用型別的值都是按引用訪問的，所以在操作物件時，實際上是操作物件的引用而不是實際的物件。 引用可以理解為儲存在棧記憶體中的一個地址，該地址指向堆記憶體中的一個實際物件。 引用型別值的複製，系統會為新的變數自動分配一個新的棧記憶體空間 這個棧記憶體空間，儲存著與被複制變量相同的指標，儘管他們在棧記憶體中的記憶體空間的位置互相獨立，但是在堆記憶體中訪問到的物件實際上是同一個，因此當我們改變其中一個物件的值時，實際上就是改變原來的物件。 棧記憶體空間儲存指標（地址），堆記憶體空間儲存實際的物件，我們通過變數訪問物件時，實際上訪問的是物件的引用（地址）。 記憶體中的棧區域存放變數（基本型別的變數包括變數宣告和值）以及指向堆區域儲存位置的指標（引用型別的變數包括變數宣告和指向內容的指標）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var a = { name : `I am object a`, type : \u0026#39;object\u0026#39; } var b = a; console.log(b); // {name: \u0026#34;I am object a\u0026#34;, type: \u0026#34;object\u0026#34;} b.name = `I am object b`; console.log(a); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} console.log(b); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} 基本型別總結 基本資料型別： 基本資料型別 包括 null、undefined、number、string、boolean、symbol(es6) 存放位置 記憶體中的棧區域中 比較 值的比較，判斷是否相等，如果值相等，就相等。一般使用 === 進行比較，因為 == 會進行型別的轉換 拷貝 賦值（通過 = 賦值操作符來賦值），兩個變數的值之間相互沒有影響 引用型別總結 包括 陣列、物件、函式 存放位置 記憶體的棧區域中存放變數和指標，堆區域儲存實際的物件 比較 是引用的比較（就是地址的比較，變數在棧記憶體中對應的指標地址相等就指向同一個物件）判斷是否為同一個物件，示例如下 變數a和變數b的引用不同，物件就不是同一個物件 1 2 3 var a = {name:\u0026#39;Jay\u0026#39;}; var b = {name:\u0026#39;Jay\u0026#39;}; a===b //false 我們對JavaScript中引用型別進行操作的時候，都是操作其物件的引用（儲存在棧記憶體中的指標） 賦值、深拷貝和淺拷貝 (Assignment, deep copy and shallow copy) 賦值：兩個變數的都指向同一個物件，改變其中一個，另一個也會受到影響。 所謂拷貝就是複製，通過複製原物件生成一個新的物件。 淺拷貝 重新在堆記憶體中開闢一個空間，拷貝後新物件獲得一個獨立的基本資料型別 資料，和原物件共用一個原物件內的引用型別 資料，改變基本型別 資料，兩個物件互不影響，改變其中一個物件內的引用型別 資料，另一個物件會受到影響。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var obj1 = obj; function shallowCopy(obj){ var scObj = {}; for(var prop in obj){ if(obj.hasOwnProperty(prop)){ scObj[prop] = obj[prop] } } return scObj; } var obj2 = shallowCopy(obj); console.log(obj === obj1,\u0026#39;obj === obj1\u0026#39;,\u0026#39;賦值\u0026#39;); console.log(obj === obj2,\u0026#39;obj === obj2\u0026#39;,\u0026#39;淺拷貝\u0026#39;); // true \u0026#34;obj === obj1\u0026#34; \u0026#34;賦值\u0026#34; // false \u0026#34;obj === obj2\u0026#34; \u0026#34;淺拷貝\u0026#34; console.log(obj.song === obj2.song); //true obj2.song.name=\u0026#39;雙截棍\u0026#39;; obj2.name=\u0026#39;Jay\u0026#39;; console.log(obj) // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj1); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj2); {name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj===obj1) //true console.log(obj===obj2) //false 深拷貝 不論是物件內的基本型別還是引用型別 都被完全拷貝,拷貝後兩個物件互不影響。 一種比較簡單實現方法是使用 var dcObj = JSON.parse(JSON.stringify(obj)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var dcObj=JSON.parse(JSON.stringify(obj)); console.log(dcObj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj.song === obj.song); //false dcObj.name=\u0026#39;Jay\u0026#39;; dcObj.song.name=\u0026#39;雙截棍\u0026#39;; console.log(obj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj); //{name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} 比較：賦值、深拷貝、淺拷貝： 賦值 新物件仍然指向原物件，改變新物件的基本型別和引用型別的值都會使原物件對應的值一同改變。 淺拷貝 改變新物件基本型別的值不會使原物件對應的值一起改變，但是改變新物件引用型別的值會使原物件對應的值一同改變。 深拷貝 改變新物件基本型別和引用型別的值，都不會影響原物件，兩者互相獨立，互不影響。 ","date":"2022-08-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52277851687_14d13f49a6_o.jpg","permalink":"/2022-08-09/js-deep-copy-vs-shallow-copy/","title":"JavaScript的記憶體空間、賦值和深淺拷貝"},{"content":" 安裝 hugo homebrew (MacOs) 1 brew install hugo scoop (Windows) 1 2 3 4 5 6 7 8 9 10 11 12 # 若未安裝過 Scoop，需先： # 1. 第一次需先設定，允許遠端腳本 # Set-ExecutionPolicy RemoteSigned -Scope CurrentUser # 2. 下載並安裝 Scoop # irm get.scoop.sh | iex # 透過 Scoop 安裝 Hugo scoop install hugo # or 安裝擴展版本 # scoop install hugo-extended apt-get (Linux) 1 sudo apt-get install hugo 利用 hugo 建立網站 1 2 # 進到本地資料夾根目錄後 hugo new site . --force 下載主題模板 (以 hugo-theme-stack 為例) 1 git submodule add git://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack clone 完畢後，把 exampleSite 文件夾中的 config.yaml 複製到站點目錄下，同時刪除此目錄下的 config.toml 文件。\n將 exampleSite/content/* 複製到站點目錄下的 content/\n剩餘主題的設定與文章內容，可依個人需求自行設定，本篇不再贅述。\ngithub 創建一個 public 的 repo，用於存放發布用的 public 資料夾。 前往 repo 的 Settings -\u0026gt; Pages 設定好欲發布的分支與 root path 設定完畢後，github 會分配給你一個公開的網址：https://{your-account}.github.io/{your-repo-name}/，若不需自定義網址與 CI/CD 流程，到此步驟即可完畢。\n設定自定義網址 註冊一個網址 本文使用 freenom 註冊一組免費的網址 註冊完畢後，前往 Manage Domain 選擇 Management Tools -\u0026gt; NameServers 後，此頁面先暫時放置著，待會再回來繼續設定 前往 Cloudflare 後台 登入 Cloudflare 後台，並選擇 網站 DNS 設定如圖： 將註冊的 domain 設定指向到 github server ip 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 設定 CNAME www 指向到剛剛 github 分配給你的 domain (path不需要)： https://{your-account}.github.io/ 將下方兩個 Cloudflare 名稱伺服器複製下來 選擇 Use custom nameservers (enter below) 將剛剛從 Cloudflare 複製的兩個 NameServer，貼到 NameServer 1、NameServer 2 Cloudflare 後台設定強制使用 SSL 點選 SSL/TLS 的 邊緣憑證 打開 一律使用HTTPS 回到 github pages，將網址填寫至 Custom domain，短暫驗證完畢後，即可點選 Save 送出設定 自定義網址已設定完畢，可使用網址打開網站。\n設定 github actions 做 CI/CD 準備材料1：生成 github personal access tokens 前往 github 的個人設定 \u0026quot;Settings\u0026quot;，下方點選 Developer settings\n點選 Generate new token\n設定備註、過期時間、權限後即可生成 token\n建議過期時間可以設定 No expiration (無過期時間)、權限設定 repo 全部勾選 生成後，token 請複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。\n準備材料2：登入 Cloudflare 後台，取得 區域識別碼(Zone) 登入 Cloudflare，選擇自己的 domain 點選 概觀，並於圖中標示處取得 區域識別碼(Zone Id) 準備材料3：取得 Global API Key 於 概觀 下方點選 取得您的 API Token 點選 檢視，輸入密碼後取得 Global API Key 準備材料4：生成 API token 點選 建立 Token -\u0026gt; 建立自訂 Token 設定 token 名稱、權限、TTL PS：權限必須至少擁有 區域 -\u0026gt; 快取清除 -\u0026gt; 清除，以便 CI/CD 後使用 token 清除 DNS cache 設定完畢後即可建立 token 建立後，也請將 token 複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。 材料準備完畢，開始設定 secret 進入 source code 的 repo，點選 Settings -\u0026gt; Secret -\u0026gt; Actions，並將剛剛的四個準備材料設定到 Actions secrets 中 此處 Actions secrets 的名稱如需修改，則待會的 github-actions.yml 內的名稱也需跟著修改，否則會抓不到 secrets 中設定的值哦!\n於 source code repo 根目錄新增 .github/workflows/github-actions.yml github-actions.yml 內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 name: Auto build and publish to public site repository # 只有推送到 main 才觸發 on: push: branches: - \u0026#34;main\u0026#34; pull_request: branches: [\u0026#34;main\u0026#34;] jobs: hugo-publish: name: publish content to public site runs-on: ubuntu-latest steps: # 使用當前 source code 的 repo - name: checkout source code repo uses: actions/checkout@v3 with: # 因為目前的 repo 有使用到 submodule(hugo themes)，所以 submodule 也要一併同步，不然原本的 repo 是沒有 submodule 的內容 submodules: true token: ${{ secrets.ACCESS_TOKEN }} # public 網站是放置在另一個 repo 所以這裡也要 clone 一份下來處理 # 因為我 Hugo 預設是產生檔案到 public 資料夾，所以將 public repo clone 到 ./public/ 內，以便後續 publish - name: clone and checkout public repo uses: actions/checkout@v3 with: # 這裡是 public 網站在 github 上的 repo 名稱 repository: {template/template-public-repo-name} path: public # tip: 需事先產生一把 personal access token 放到 repo 的 secrets 裡 # 然後 secrets 裡的名稱就叫 ACCESS_TOKEN # 參考 https://help.github.com/en/actions/automating-your-workflow-with-github-actions/authenticating-with-the-github_token token: ${{ secrets.ACCESS_TOKEN }} # 使用別人做好的 Hugo Actions - name: setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true # 用 Hugo 產生檔案 - name: build content to public site working-directory: ./ # --cleanDestinationDir 清除舊檔案 run: hugo --minify --gc --cleanDestinationDir # 將檔案 commit 到 網站 public repo - name: deploy and publish updates working-directory: ./public # user.email 還有 user.name 可以取自己喜歡的，一定要設定不然會出錯 run: | # 當 git 有更動時才進行動作 if [[ `git status --porcelain` ]]; then git config --local user.email \u0026#34;{typing your email}\u0026#34; git config --local user.name \u0026#34;{typing your name}\u0026#34; git add . -A git commit -m \u0026#34;build: auto publish\u0026#34; git push origin else echo \u0026#34;content no changes\u0026#34; fi # 清除 cloudflare dns cache - name: clear cloudflare cache uses: nathanvaughn/actions-cloudflare-purge@master with: # Using Zone Id cf_zone: ${{ secrets.CLOUDFLARE_ZONE }} # Using API Token cf_auth: ${{ secrets.CLOUDFLARE_API_TOKEN }} 內容 {} 內的資訊請更換成自己的資訊\n附上 yaml 範例，詳細 github-actions.yaml 文件請查閱 github 官方文件\n建立檔案後，將 commit push 後，即可於 source code repo 的 Actions 頁面查看 CI/CD 的過程。 ","date":"2022-08-01T00:00:00Z","image":"https://live.staticflickr.com/65535/52274839367_8325e83fea_o.jpg","permalink":"/2022-08-01/hugo-github-pages-actions-and-cloudflare/","title":"架設部落格之一條龍免費寶典：Hugo 生成靜態網站、Pages 發布網站、設定 custom domain(free 12 months)、Actions 做 CI/CD"},{"content":" 參考網站 - 初學者都該學會的 HTTP 通訊協定基礎\n參考網站 - Http/2 是什麼?\n目前 HTTP 通訊協定的版本 HTTP/0.9 於 1991 年發表(已廢止) HTTP/1.0 於 1996 年 5 月發表(RFC 1945) HTTP/1.1 於 1997 年 1 月發表(RFC 2068) 於 1999 年 6 月發布 HTTP/1.1 更新版(RFC 2616) 於 2014 年 6 月再次更新 HTTP/1.1 並將規格文件拆成六份 HTTP/2(Wikipedia) 於 2015 年 5 月發布(RFC 7540)(瀏覽器相容性) 僅針對 HTTP/1.1 的 Message Syntax 部分作出強化 HTTP/0.9 (已廢止) 概要 於 1990 年由 Tim Berners-Lee 提出最初的 HTTP 建議(WWW)\n實作重點\n用戶端要求是以 ASCII 字元為主(單行命令即可發出請求 GET/) 用戶端要求會以一個 換行字元 (CRLF) 來結束 伺服器回應是以 ASCII 字元為主，回應內容是 HTML 文件 每次執行完 Request / Response 就會自動關閉連線 主要特色\nClient / Server 架構、Request / Response 協定 跑在 TCP/IP 上的 ASCII 協定 (要求/回應) 被設計用來傳輸 HTML 文件 每完成一次 ASCII 協定就會自動關閉連線 使用 bash 測試 1 2 3 4 5 6 7 8 # 建立連線到 google $ telnet google.com 80 \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about \u0026gt; ... HTTP/1.0 概要 在 1991 到 1995 年之間，所謂 瀏覽器 騰空出世！\n於 1996 年 5 月發表 HTTP/1.0 版 (RFC 1945)\n與 HTTP/0.9 不同的部分\n用戶端要求是以 ASCII 字元為主，但可發送多行命令(含要求標頭) 先送出要求方法，再送出要求標頭，最後以一個額外的換行字元結束 伺服器回應是以 ASCII 字元為主，回應內容會區分為 狀態列 回應標頭 回應內文主體(不僅僅是 HTML 文件，可以是更多內容類型) 每完成一次 Request / Response 交握就會自動關閉 TCP/IP 連線 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.0 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，會自動中斷 TCP 連線 # 若需再發送請求，需重新建立 TCP 連線 $ telnet google.com 80 ... HTTP/1.1 概要 於 1997 年 1 月發表 HTTP/1.1 版 (RFC 1945)\n於 1999 年 6 月發布 HTTP/1.1 更新版 (RFC 2616)\n與 HTTP/1.0 不同的部分\n傳輸協議的效能改進(新增不少 HTTP 標頭定義) 持續連線狀態(persistent connection) 切塊編碼傳輸(chunked encoding transfer) 位元範圍請求(byte range request) 額外快取機制(cache control) 請求管線作業(request pipelining)(需搭配持續連線狀態特性才能用) 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，不會自動中斷 TCP 連線，可再發送請求 $ GET /abc HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.1 404 Page Not Found \u0026gt; ... 目前 HTTP/1.1 的六大規格 RFC 7230 HTTP/1.1：Message Syntax and Routing RFC 7231 HTTP/1.1：Semantics and Content(最重要) RFC 7232 HTTP/1.1：Conditional Requests RFC 7233 HTTP/1.1：Range Requests RFC 7234 HTTP/1.1：Caching RFC 7235 HTTP/1.1：Authentication 關於 HTTP 通訊協定的基本常識 無狀態特性(stateless)：相同的 request，都會得到相同的 response，不會因為狀態不同而改變 分散式架構(distributed)：相同的 request，不同載體發送，都會得到相同的 response 協作的架構(collaborative)：不一定只有 client / server，也可以是 client / proxy / reverse proxy / server 超文本(hypertext = not just \u0026ldquo;text) but with \u0026ldquo;links\u0026rdquo;)：除了內容，還包含連結 初學者應了解 HTTP 的基本運作方式 如何發出 HTTP 要求(HTTP Request)\n要求方法(Request Methods) GET、POST、PUT、DELETE、PATCH、\u0026hellip; 要求標頭(Request Headers) Connection、COntent-Type、\u0026hellip; 斷行符號(CRLF) 要求內容主體(Request Body) 如何回應 HTTP 訊息(HTTP Response)\n回應狀態碼(Response Status Codes) HTTP/1.1 200 OK 回應標頭(Response Headers) 斷行符號(CRLF) 回應內容主題(Response Body) HTTP/2 HTTP/2 各個瀏覽器的支援度 點我查看瀏覽器支援度\nEdge / Firefox / Chrome / Opera 皆在 2015 年起就支援 HTTP/2，基本上不需要太擔心主流瀏覽器的支援性問題。\nPS：如何在 Node.js 中使用 HTTP/2\nHTTP/2 改善了什麼？ http/2標準發布於2015年5月，其主要目的是透過一些措施改善瀏覽器瀏覽網頁 加載的速度(page load) 。目前大多數的瀏覽器已支援 http/2 (chrome, firefox, safari等)標準，又 http/2與 http/1.1有著高度的相容信，舉凡request method(post, get..etc), http status code, url, header 等等，因此對於web developer來說，只需要確保你的網站有支援https(因為瀏覽器只支援https 在http/2上)。那麼http/1.1與http/2到底相差多快呢，點我體驗!\nHTTP/2 是如何改善？ 只需要單一網路連線 (Single TCP connection) 只需要單一網路連線，就可以連接網站伺服器，下載所有需要的資源。大大節省 HTTP/1.1 需要一直建立多個網路連線時的啟動時間浪費。\nRequest and response multiplexing (多路複用) 在 http/1.1 中，client 端時常會同時發起多個 request 至 server 拿取檔案(像是js, css, image等)，以此方式達到快速載入頁面。如下圖在 http/1.1 中會同時與 server 建立3個 TCP connection，但是瀏覽器通常會限制 TCP connection 同時建立的數目。因此在 http/2 協定中，允許 client 端與同一 server 建立單一 TCP connection 並以非同步方式傳輸要的檔案。\n優先權設計 (Prioritization) 伺服器可以決定例如 CSS 或 JavaScript 檔案，哪些要優先傳送。\nHeader compression (標頭壓縮) 每一個 http 的傳輸中都會攜帶一組 header，在 http/1.1 中，header 會是以明文(plain text)傳輸大小通常會是500-800 bytes，若有攜帶 cookie 也有可能會更大。因此在 http/2 中，會將 request 以及 response 的 header 使用 HPACK 演算法壓縮 header 的內容，此方法壓縮後可以減少 85%-88% 的大小。\nServer push (伺服器推送) 在 http/1.1 中，通常 client 端 request 甚麼 server 就會回傳甚麼，例如: 當 client request html 那麼 server 將只會回傳 html。但在 http/2 中，允許 server 主動推送有相關的資料給 client，例如: 當 client 只 request html，但是 server 知道 client request 此 html 後續也會 request css, js 等，因此 server 就會在 client 沒有 request 的情況下主動推送 css, js 檔給 client。那 server 怎麼知道這些檔案是有相關性的呢? web developer 將需要 server push 的檔案加上特定的描述即可。(描述)\n不過，這個功能比較有爭議，一來他需要 Web 開發者額外描述有哪些檔案需要隨著 HTML 一起推送給瀏覽器，不是 Web 伺服器升級 HTTP/2 就自動會有。二來它不管瀏覽器是不是已經有快取這個資源，都會推送而造成頻寬浪費。因此實務上筆者認為可以改用瀏覽器的 Prefetch 功能，讓客戶端的瀏覽器自己處理即可。\nBinary framing layer (二進制影格層) 在 http/2 中，header 與 body 所挾帶的 property 與 http/1.1 相同(ex. verbs, methods)，然而兩者在傳輸上會有不同。在 http/2 中，會將 header 以及 body 編碼成二進制在 server 與 client 端中傳輸，在 http/1.1 中，則是以明文的方式傳輸。將訊息編碼成二進制進行傳輸，此特性是 http/2 的其他特性的根本基礎。\n冷知識：在 HTTP/1.1 定義了四種解析訊息的方式，在 HTTP/2 只需要一種。\n總結 根據 w3Techs 網站，目前使用http/2的網站有45.7%，未來確實會變成主流，身為軟體工程師，還是多少理解來的好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤資訊還請直接點出，萬分感謝。\n","date":"2022-07-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52276290470_787c77a1b5_o.jpg","permalink":"/2022-07-24/beginner-http-lesson/","title":"初學者都該了解的 HTTP 通訊協定基礎"},{"content":" 參考網站 - 初學者學演算法｜從時間複雜度認識常見演算法\n溫故知新 演算法的簡單定義：輸入 + 演算法 = 輸出 時間複雜度：衡量演算法執行好壞的工具 大 O 符號：用來描述演算法在輸入 n 個東西時，所需時間與 n 的關係 在 n 非常大時，好的演算法設計可以省下非常多時間 演算法的速度不是以秒計算，而是以步驟次數 實務上，我們只會紀錄最高次方的那一項，並忽略其所有的係數 目錄：常見的六種時間複雜度與演算法 O(1)：陣列讀取 O(n)：簡易搜尋 O(log n)：二分搜尋 O(nlogn)：合併排序 O(n²)：選擇排序 O(2^n)：費波那契數列 O(1)：陣列讀取 說明 時間複雜度為 O(1) 的演算法，代表著不管你輸入多少個東西，程式都會在同一個時間跑完。在程式設計中，最簡單的例子就是讀取一個陣列中特定索引值的元素(程式麻瓜先別急著吐血，且讓我們在下面慢慢說明)。\n陣列讀取 陣列是程式中儲存東西的一種容器，我們可以想像成一排已經編號好的櫃子。每一個櫃子上的編號我們稱為「索引值」（Index，在程式中這個編號通常從 0 開始），而櫃子裡的物品我們稱為「元素」。例如：假設神奇寶貝大師小明在一個名叫 Pokemons 的陣列裡依序放入他的神奇寶貝們，我們來複習一下陣列、元素、索引值的關係：\n在程式碼中我們把七隻神奇寶貝這樣表達：\n1 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] 這時，假設我們想要知道在這個 Pokemons 陣列中任一個編號所對應到的神奇寶貝，我們都只需要把這個編號對應的元素印出來，就能知道對應的神奇寶貝是誰了。如果我想知道這個陣列中的第 n 號櫃的神奇寶貝是誰（以下假設我們想知道 n= 0），在程式碼中我們可以這樣表達：\n1 2 3 4 n = 0 print(Pokemons[n]) \u0026gt;\u0026gt; \u0026#34;卡丘\u0026#34; 陣列讀取時，因為我們已經知道櫃子的索引值，不管放入的 n 等於多少，程式都可以在 “一個步驟” 就到達 n 所對應到編號的櫃子並取出該元素，像這樣的案例，我們就會說陣列讀取演算法的時間複雜度為 O(1)。\nO(n)：簡易搜尋 說明 時間複雜度為 O(n) 的演算法，代表著執行步驟會跟著輸入 n 等比例的增加。例如當 n = 8，程式就會在 8 個步驟完成。最簡單的例子，就是所謂的簡易搜尋。\n這邊要特別提醒一點，通常程式步驟的時間複雜度會是用程式執行會碰到的最壞狀況 (Worst Case) 來表示，詳細例子我們可以在下面看到。\n簡易搜尋 讓我們沿用上一段的 Pokemons 陣列作為例子。Pokemons 這一排櫃子裡有八隻神奇寶貝，假設每個櫃子的門都被關上，我們事前也不知道各個神奇寶貝的位置，這時如果想要知道「呆獸」神奇寶貝在哪裡時，我們第一個想到的方法會是什麼呢？\n最直觀地想，我們會從第一個櫃子開始試，一次開一個櫃子，直到找到「呆獸」為止。像這樣的搜尋方法，就是最經典簡單的「簡易搜尋」。\n在程式碼中，簡易搜尋的方法可以這樣表達：\n1 2 3 4 5 6 7 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] for Pokemon in Pokemons: if Pokemon == \u0026#34;呆獸\u0026#34;: print(\u0026#34;找到呆獸！\u0026#34;) break else: print(\u0026#34;這個櫃子裡不是呆獸\u0026#34;) 觀察上面的程式碼時，我們可以發現，如果呆獸在第 0 號櫃，我們一個步驟就會找到它，但如果他是在第 6 號櫃，我們要花七個步驟才能找到他。\n還記得我們在上面提過的小小提醒嗎？我們通常會用程式執行會碰到的「最壞狀況」來決定複雜度的表示，也因此，當我們要從 n 個櫃子中找到一隻特定的神奇寶貝，我們最慘最慘的情況需要花剛好 n 個步驟才能找到（想像要找的神奇寶貝在最後一個櫃子的情況）。像這樣的案例，我們就會說簡易搜尋演算法的時間複雜度為 O(n)。\nO(log n)：二分搜尋法 說明 時間複雜度為 O(log n) 的演算法（這邊的 log 都是以二為底），代表當輸入的數量是 n 時，執行的步驟數會是 log n。（讓忘記 log 是什麼的同學們複習一下，當 log n = x 的意思是 n = 2^x，如果這部分的腦細胞尚未復活，且讓我們先記住 n = 2^x，再來看看例子）。\n舉例來說，當 n = 4，程式會在 2 個步驟完成（4 = 2²）；n = 16 時，程式會在 4 個步驟完成（16 = 2⁴），以此類推。\n在程式中，O(log n) 的最常見例子是二分搜尋法。\n二分搜尋法 假設我們在一本字典中想要找到一個單字，這個字以 W 開頭，我們可以用前面提過「簡易搜尋」的邏輯，從第一頁的 A 開始找起，一個一個找到天荒地老海枯石爛。也可以用更珍惜生命的方式，直接翻到字典的後面，找到以 W 開頭的第一個字後再開始往後找。\n同樣的邏輯，假設有一長串有小到大排序好的數字們，我要在其中找特定一個數字，我們一樣可以從第一個往後一個一個檢查。但假設我們想要更珍惜生命，聰明的讀者可能已經想到了我們在「終極密碼」這種遊戲中會使用的策略，也就是每次都先檢查最中間的數字，如果中間的數字比我們要找的數字大，我們要找的數量就只剩原本的一半（因為在後段的數字顯然都會比我們要找的數字大），這樣的方法，就稱作二分搜尋法。\n舉一個實際的例子，假設今天有一排編號好的櫃子，裡面擺著八個由小到大排序好的數字。假設我們知道裡面的數字包含 55，但我們不知道在哪一個編號櫃子中。讓我們來比較簡易搜尋（從第一格往後一個一個檢查）跟二分搜尋法有什麼差別。\n從上面的圖可以看到，一般的搜尋方法需要花五個步驟才能找到 55。\n而在二分搜尋法中，我們先打開最中間的櫃子，發現裡面的數字是 41。因為 55 比 41 大，因此我們知道從一號櫃到三號櫃都不會有 55，接下來只需要檢查五號櫃到七號櫃。\n同樣的邏輯，我們打開剩下三個可能性中最中間的櫃子，發現六號櫃裡面的數字是 61，因為 61 比 55 大，我們可以知道七號櫃的數字一定也比 55 大，得知 55 一定就在五號櫃之中。\n接下來，要再次來關心兩個搜尋方法的時間複雜度。簡易搜尋的情況中，我們可以輕鬆地知道最壞的情況就是剛好七個步驟（要找的數字是 80 ）。而二分搜尋法，我們可以先練習去計算各種情況需要的步驟，而最終的答案如下表：\n從上表我們可以發現，二分搜尋法最慘最慘，也只需要三個步驟。\n推廣到有 n 個櫃子時，我們可以發現：二分搜尋法在每進行一個步驟時，就可以排除掉一半的可能性。每次都能減少一半，因此二分搜尋法最糟最糟也只需要以 2 為底的 log n 個步驟就能完成。\n二分搜尋法在程式碼中的例子，對於程式新手可能需要花比較多的理解。如果你是對程式有一定理解的人，可以嘗試動手實做看看。而如果下方的程式碼對於讀者還有些吃力的話，也可以先多多熟悉語法後回來複習即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Numbers = [5,17,33,41,55,61,80] Find = 55 ​ low = 0 high = len(Numbers) - 1 ​ while low \u0026lt;= high: mid = (low + high) // 2 if Numbers[mid] \u0026gt; Find: high = mid - 1 elif Numbers[mid] \u0026lt; Find: low = mid + 1 else: break ​ print(mid) 小結 在這篇文章中，我們分別了解了 O(1)、O(n)、O(logn) 的時間複雜度，以及對應到的三個常見演算法。而在接下來的文章中，我們會開始認識新朋友，在演算法中佔有重要地位的「排序法」，以及在更進階的例子。\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276285230_7f886f0bca_o.jpg","permalink":"/2022-07-23/common-time-complexity/","title":"初學者學演算法｜從時間複雜度認識常見演算法"},{"content":" 剛剛用日常上班前挑衣服的例子和沒學過程式的 00 說明時間複雜度的概念很好理解耶～！\n例子是這樣的\u0026hellip;\n一早要出門的時候，想要從衣櫃中找出紅色的上衣。\n其中一種方式是像左圖一樣，這是掏寶上很熱門的「疊衣服褲子收納神器」，雖然看起來整理的很乾淨，但如果你要從中找到紅色的衣服，你就得要由上而下一件一件找，最糟的情況就是一直翻到最下面才能找到你要的紅色衣服。\n另一種方式是像右圖一樣，把衣服用立起來的方式，一眼就可以看到紅色的衣服在哪，直接拿出來，幾乎不用找。\n左圖的那種方式，時間複雜的就是 O(n)，n 就是衣服的件數，雖然紅色的衣服有可能就放在最上面，一眼就可以看到，但在探討時間複雜度的時候都要考慮最差的情況，所以如果你有 n 件衣服，最差的情況就是要把 n 件衣服都翻過才會找到紅色那件。\n右圖的方式它的時間複雜度是 O(1)，在你沒有忘記其實衣服已經被丟到洗衣籃的前提下，你看一眼，翻都不用翻就可以把紅衣服直接取出（請先忽略掉人腦內建的視覺搜尋系統，那是另一個有趣的故事 XD）。這種不用一個一個找，就直接取出的，時間複雜度就是 O(1)。\n有了這個時間複雜度的概念後，是不是覺得左邊的那個商品實用性沒這麼高啦～ XDD\n真的是沒想到學演算法還可以用在購物吧！\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276282210_c2a38fae3c_o.jpg","permalink":"/2022-07-23/learn-time-complexity-by-clothes/","title":"從找衣服了解時間複雜度"},{"content":" 參考網站 - gRPC 說明影片 @ BESG\nSOURCE CODE\n對應的程式碼可檢視 besg-grpc 的 repository。\ngRPC 是什麼：以 Golang 說明與實作 說明 RPC 的全名是 remote procedure call，主要是作為電腦和電腦間溝通使用。A 電腦可以呼叫 B 電腦執行某些程式，B 電腦會將結果回傳給 A 電腦，A 電腦在收到回應後會再繼續處理其他任務。RPC 的好處在於，雖然 A 電腦是發送請求去請 B 電腦做事，但其呼叫的方式，就很像是 A 電腦直接在呼叫自己內部的函式一般。\ngRPC 也是基於這樣的概念，讓想要呼叫 server 處理請求的 client，在使用這支 API 時就好像是呼叫自己內部的函式一樣簡單自然。從功能面來說，gRPC 就像 Web 常用的 Restful API 一樣，都是在處理請求和回應，並且進行資料交換，但 gRPC 還多了其他的功能和特色。\ngRPC 是由 Google 開發的開源框架，它快速有效、奠基在 HTTP/2 上提供低延遲（low latency），支援串流，更容易做到權限驗證（authentication）。在下面的文章中，將會對於 gRPC 能提供的特色有更多說明。\nProtocol Buffers 是什麼 Protocol Buffers @ Google Developer Protocol Buffers 筆記 @ pjchender.dev 在學習 gRPC 時，需要同時了解什麼是 Protocol Buffers。在傳統的 Restful API 中，最常使用的資料交換格式通常是 JSON；但到了 gRPC 中，資料交換的格式則是使用名為 Protocol Buffers 的規範／語言。\njson 1 2 3 4 5 { \u0026#34;firstName\u0026#34;: \u0026#34;Sushiro\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Global\u0026#34;, \u0026#34;age\u0026#34;: 6 } protocol buffers 1 2 3 4 5 6 // Protocol Buffers message User { string first_name = 1; string last_name = 2; int32 age = 3; } 也就是說，當我們想要使用 gRPC 的服務來交換資料前，必須先把資料「格式」和「方法」都定義清楚。\nTIP:\n使用 gRPC 前，不只需要先把資料交換的格式定義清楚，同時也需要把資料交換的方法定義清楚。\n這裡要稍微釐清一點很重要的是，Protocol Buffers 可以獨立使用，不一定要搭配 gRPC；但使用 gRPC 一定要搭配 Protocol Buffers。\n實作將 Protocol Buffers 編譯成在 Golang 中可使用的檔案 對應的程式碼可檢視 besg-grpc repository 中的 proto 資料夾。\nSTEP 1：撰寫 Protocol Buffers 檔案 使用 message 定義資料交換的格式。 使用 service 定義呼叫 API 的方法名稱。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 syntax = \u0026#34;proto3\u0026#34;; // 定義要使用的 protocol buffer 版本 package calculator; // for name space option go_package = \u0026#34;proto/calculator\u0026#34;; // generated code 的 full Go import path message CalculatorRequest { int64 a = 1; int64 b = 2; } message CalculatorResponse { int64 result = 1; } service CalculatorService { rpc Sum(CalculatorRequest) returns (CalculatorResponse) {}; } STEP 2：安裝編譯 Protocol Buffer 所需的套件 此部份可參考 編譯 Protocol Buffers（Compiling） 段落。\n安裝 compiler (macOS) 1 2 3 4 5 6 7 8 9 10 11 # 安裝 compiler，安裝完後就會有 protoc CLI 工具 brew install protobuf protoc --version # Ensure compiler version is 3+ # --- 使用 golang 才需要安裝以下兩個套件 --- # 安裝 protoc-gen-go 後可以將 proto buffer 編譯成 Golang 可使用的檔案 go get github.com/golang/protobuf/protoc-gen-go # 安裝 grpc-go 後，可以在 Golang 中使用 gRPC go get -u google.golang.org/grpc STEP 3：編譯 Protocol Buffer 檔案 進到放有 .proto 檔的資料夾後，在終端機輸入下述指令：\n1 protoc *.proto --go_out=plugins=grpc:. --go_opt=paths=source_relative 在成功編譯好後，應該會看到同樣的資料夾位置出現 *.pb.go 的檔案，這就是編譯好後可以在 Golang 中使用 Protocol Buffer 和 gRPC 的檔案。\n實作 gRPC Server 對應的程式碼可檢視 besg-grpc repository 中的 server 資料夾。\nSTEP 1：建立 gRPC server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Server struct {} func main() { fmt.Println(\u0026#34;starting gRPC server...\u0026#34;) lis, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:50051\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v \\n\u0026#34;, err) } grpcServer := grpc.NewServer() calculatorPB.RegisterCalculatorServiceServer(grpcServer, \u0026amp;Server{}) if err := grpcServer.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v \\n\u0026#34;, err) } } STEP 2：實作 Protocol Buffer 中的 service 1 2 3 4 5 6 7 8 9 10 11 12 func (*Server) Sum(ctx context.Context, req *calculatorPB.CalculatorRequest) (*calculatorPB.CalculatorResponse, error) { fmt.Printf(\u0026#34;Sum function is invoked with %v \\n\u0026#34;, req) a := req.GetA() b := req.GetB() res := \u0026amp;calculatorPB.CalculatorResponse{ Result: a + b, } return res, nil } STEP 3：啟動 server 在終端機中輸入：\n1 go run server/server.go 即可啟動 gRPC server。\n補充：使用 Bloom RPC 進行測試 在只有 server 的情況下，可以使用 BloomRPC 這套工具來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。\n使用時只需要匯入 proto 檔後，即可看到對應可呼叫的方法和可帶入的參數，能這麼方便也是因為在 protocol buffer 中已經把傳輸的資料格式和能對應呼叫的方法都定好的緣故。\n實作 gRPC Client 完整程式碼可檢視 besg-grpc repository 中的 client 資料夾。\nSTEP 1：與 gRPC server 建立連線 1 2 3 4 5 6 7 8 9 10 11 12 func main() { conn, err := grpc.Dial(\u0026#34;localhost:50051\u0026#34;, grpc.WithInsecure()) if err != nil { log.Fatalf(\u0026#34;failed to dial: %v\u0026#34;, err) } defer conn.Close() client := calculatorPB.NewCalculatorServiceClient(conn) doUnary(client) } STEP 2：使用 Protocol Buffers 中定義好的 Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func doUnary(client calculatorPB.CalculatorServiceClient) { fmt.Println(\u0026#34;Staring to do a Unary RPC\u0026#34;) req := \u0026amp;calculatorPB.CalculatorRequest{ A: 3, B: 10, } res, err := client.Sum(context.Background(), req) if err != nil { log.Fatalf(\u0026#34;error while calling CalculatorService: %v \\n\u0026#34;, err) } log.Printf(\u0026#34;Response from CalculatorService: %v\u0026#34;, res.Result) } STEP 3：向 server 發送請求 在終端機中輸入：\n1 go run client/client.go 即可執行 client.go 並向剛剛起動好的 server 發送請求。\ngRPC 解決了什麼 gRPC 和 REST API 的比較 比較 gRPC 服務與 HTTP API @ microsoft docs\n簡單來說，gRPC 在效能上比起 REST API 好非常多：\n項目 gRPC Restful API 資料傳輸格式（Payload） Protocol Buffer - 更快且更小 JSON, XML, formData - 較慢且較大 通訊協定 HTTP/2 HTTP 傳輸方式 支援一般的「請求-回應」、伺服器端串流、Client 端串流、與雙向串流（streaming） 僅能透過 Client 發送請求、Server 給予回應 API 方法命名 沒有限制，一般會直接描述該方法要做的事，例如 createUser, getUser。不需要思考路由命名。 使用動詞（GET, POST, PUT, PATCH, DELETE）搭配資源來命名。需要根據不同的行為來定義不同的路由。 Client 呼叫 API 的方式 就像呼叫一般的函式 透過特定的 Endpoint，給予符合的資料型別 Server 建立 API 的方式 根據文件（Protocol Buffer）實作功能，不需要額外檢查資料型別與方法正確性。 根據文件（Swagger）實作功能，但須額外檢查資料型別。 根據文件產生程式碼 Protocol Buffers OpenAPI / Swagger 此外，gRPC 的 server，預設就是非同步的，因此不會阻塞任何進來的請求，並可以平行處理多個請求。gRPC Client 則可以選擇要用同步（阻塞）或非同步的方式處理。\n使用 Protocol Buffers 的好處 節省網路傳輸量：速度更快、檔案更小 節省 CPU 消耗：Parse JSON 本身是 CPU intensive 的任務；Parse Protocol Buffer（binary format）因為更接近底層機器表徵資料的方式，消耗的 CPU 資源較低 跨程式語言：Protocol Buffer 可以根據不同的程式語言編譯出不同的檔案 可以寫註解、型別清楚明確 TIP\n節省網路傳輸量和 CPU 消耗在行動裝置上的影響可能更重要。\n跨程式語言的好處 透過 Protocol Buffer 定義好資料的傳輸欄位（message）和呼叫的方法（service）後，gRPC 即可在不同程式語言上運行，這非常適合微服務（micro-services）的應用情境，只要雙方一起定義好 schema 後，就可以用不同的程式語言進行開發。\n使用 HTTP/2 的好處 HTTP/2 vs HTTP/1 - Performance Comparison? Demo：Performance difference between HTTP2 and HTTP1.1 瀏覽器允許的併發請求資源數是有限制的-分析 @ ITRead01 傳統的 HTTP/1.1 在每個 TCP 連線中只允許向 server 發送單一個請求，但當網頁載入時，往往會需要向同一個伺服器發送多個請求（例如、圖檔、CSS、靜態檔、JS 等），因此為了要避開這樣的限制、加快載入的速度，瀏覽器會實作多個平行的（parallel） TPC 連線（每個瀏覽器實作不同，因此數量的上限也不同），以處理同時向伺服器發出的多個請求。\n在 HTTP/2 中則可在同一個 TCP 連線中進行多個請求和回應，並且可以由 server 主動推送資源給 client，而並非一定要透過 client 主動請求；此外支援 HTTP Header 的壓縮，減少資料傳數量；HTTP/2 也是使用 binary 的方式在傳輸資料。\ngRPC 的四種類型 Unary：類似傳統 API，client 發送 request 而 server 回傳 response Server Streaming：透過 HTTP/2，client 發送一次 request，而 server 可以回傳多次資料 Client Streaming：client 發送多次資料，直到告知 server 資料傳完後，server 再給予 response Bi Directional Streaming：兩邊都用串流的方式傳送資料 圖片來源：gRPC Golang - Master Class: Build Modern API \u0026amp; MicroServices @ Udemy\n1 2 3 4 5 6 7 8 9 10 11 12 13 service GreetService { // Unary rpc Greet(GreetRequest) returns (GreetResponse) {}; // Streaming Server rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {}; // Streaming Client rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}; // Bi-directional Streaming rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {}; } gRPC 的缺點 Protocol Buffer 不像 JSON 是 Human Readable。 需要額外的學習時間和導入成本。 瀏覽器原生目前還不支援，須透過套件 grpc-web 來處理。 其他 推薦工具 BloomRPC：方便用來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。 錯誤排除 protoc-gen-go: program not found or is not executable\n1 2 # 需要把 $GOPATH/bin 加到 .zshrc/.bashrc 等 $ echo \u0026#39;export PATH=$PATH:$GOPATH/bin\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc 參考資料 Go Tutorial @ gRPC.io Introduction to gRPC @ gRPC.io Protocol Buffers @ Google Developer gRPC - Golang Master Class: Build Modern API \u0026amp; MicroServices @ Udemy 比較 gRPC 服務與 HTTP API @ Microsoft Docs ","date":"2022-07-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52276040314_2afa0e7026_o.png","permalink":"/2022-07-22/grpc-basic-introduction/","title":"gRPC 基本介紹"},{"content":" 參考網站 - JavaScript 資料結構與演算法：氣泡排序 Bubble Sort、插入排序 Insertion Sort 實作與分析 - 彭彭直播\n排序演算法 氣泡排序法(bubble sort) 概要 使用雙層迴圈，由後往前。 每輪固定最右邊的值，接著倆倆比較大小，將大的放右邊。 下輪則 - 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度 如果陣列長度是 4，要比對 3+2+1 總共 6 次。 如果陣列長度是 7，要比對 6+5+\u0026hellip;+1 總共 21 次。 如果陣列長度是 n，要比對 (n-1)+(n-2)+\u0026hellip;+1 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 可以加入一個 flag 來做判定，假設比較完第一輪發現沒有交換的情況發生，則代表已經排序完成，不需要再跑下一輪，即可稍微優化排序。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作氣泡排序演算法 function bubbleSort(arr){ // arr 是一個數字陣列 for(let i=arr.length-1;i\u0026gt;=1;i--){ let swap=false; // 假設沒有交換發生 for(let j=0;j\u0026lt;i;j++){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; swap=true; // 紀錄發生交換 } } if(!swap){ // 發現一整輪中都沒有交換發生，直接判定排序完成 break; } } } let data = [1, 6, 3, 4]; console.log(bubbleSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 插入排序法(insertion sort) 概要 使用雙層迴圈，由前往後。 從第二筆開始，每輪將該筆資料往前比較大小，將大的放右邊：每輪比較從 (i - 1) ~ 0。 下輪則 + 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度(複雜度同氣泡排序法) 如果陣列長度是 4，要比對 1+2+3 總共 6 次。 如果陣列長度是 7，要比對 1+2+\u0026hellip;+6 總共 21 次。 如果陣列長度是 n，要比對 1+2+\u0026hellip;+(n-1) 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 假設當前比對的值與第一個要比較的值一比較，恰好正確，則代表前面皆已經排序完成，可以進到下一輪。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 實作插入排序演算法 function insertionSort(arr){ // arr 是一個數字陣列 for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i-1;j\u0026gt;=0;j--){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 [arr[j], arr[j+1]]=[arr[j+1], arr[j]]; // javascript 交換的語法糖 }else{ // 任何一次比較，發現順序對了，這一輪就不用繼續了 break; } } } } let data = [1, 6, 3, 4]; console.log(insertionSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 大型資料量的進階探討 O(N²)：(讀作 big-O N平方) 是相當可怕的，排序的執行時間將會是資料量的平方倍數成長。\n演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 產生隨機資料 let data=[]; for(let i=0;i\u0026lt;100000;i++){ data.push(Math.random()*1000000); } // 資料量是 100,000，我的演算法時間複雜度是 O(N^2)，預期要花 100,000^2 = 10,000,000,000 次的比較運算 // 我們的電腦一秒鐘跑 10 億個指令(粗略預估 1 GB) console.time(); // 插入排序法，大約跑了10幾秒 //insertionSort(data); // 使用 JavaScript 內建的排序功能 sort()，大約跑了 0.2 ~ 0.3 秒 // 很有機會是使用快速排序 Quick Sort(快速排序法) 或其變形 data.sort(); console.timeEnd(); ","date":"2022-07-21T00:00:00Z","image":"/2022-07-21/bubble-sort-and-insertion-sort/hqdefault_huc19c1d5e8083f3ca093a0303b2a8247b_19175_120x120_fill_q75_box_smart1.jpg","permalink":"/2022-07-21/bubble-sort-and-insertion-sort/","title":"彭彭的課程 - 氣泡排序、插入排序的實作與分析"},{"content":" 參考網站 - 尚硅谷Vue3技術\n創建 Vue 3.0 工程 使用 vue cli 創建 官方文檔：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 1 2 3 4 5 6 7 8 9 10 11 12 ## 查看 @vue/cli 版本，確保 @vue/cli 版本在 4.5.0 以上 vue --version ## 安裝或升級你的 @vue/cli npm install -g @vue/cli ## 創建 vue create vue_test ## 啟動 cd vue_test npm run serve 使用 vite 創建(Vue作者的團隊開發) 官方文檔：https://v3.cn.vuejs.org/guide/installation.html#vite vite官網：https://vitejs.cn/ 優勢： 開發環境中，無需打包操作，可快速的冷啟動。 輕量快速的熱重載(HMR)。 真正的按需編譯，不再等待整個應用編譯完成。 傳統 grunt、gulp、webpack 與 vite 構建對比圖： 1 2 3 4 5 6 7 8 9 10 11 ## 創建工程 npm init vite-app \u0026lt;project-name\u0026gt; ## 進入工程目錄 cd \u0026lt;project-name\u0026gt; ## 安裝依賴 npm install ## 啟動 npm run dev 安裝 Vue 開發者工具 Vue.js devtools\n拉開序幕的 Setup Vue3.0 中一個新的配置項，值為一個函數。 是所有 Composition API (組合式API) 的表演舞台。 組件中所用到的數據、方法等等，均要配置在 setup 中。 setup 函數的： 若返回一個對象，則對象中的屬性、方法，在模板中均可直接使用。(重點關注!) 若返回一個渲染函數，則可以自定義渲染內容。(了解即可) 返回對象 1 2 3 4 5 6 7 8 export default { setup() { const name = \u0026#34;測試\u0026#34; return { name } } } 返回渲染函數(需引入 h ) 1 2 3 4 5 6 import { h } from \u0026#34;vue\u0026#34; export default { setup() { return () =\u0026gt; { return h(\u0026#39;h1\u0026#39;, \u0026#39;尚硅谷\u0026#39;)} } } 注意： 不要與Vue2.x配置混用。 Vue2.x配置(data、methods、computed\u0026hellip;)中可以訪問到setup中的屬性、方法，但在setup中不能訪問到Vue2.x配置(data、methods、computed\u0026hellip;)。 如果有重名，setup優先。 setup 不能是一個 async 函數，因為返回值不再是 return 的對象，而是一個 promise，模板看不到 return 對象中的屬性；後期可以返回一個 Promise 實例，但需要 Suspense 與 異步組件(動態組件) 的配合：點我前往 Suspense ref 函數 作用：定義一個響應式的數據。 語法： 1 const xxx = ref(initValue) 將數據加工成一個 RefImpl (Reference: 引用；Implete: 實現) = (引用實現的實例對象)。 js 中操作數據：xxx.value。 模板中讀取數據：\u0026lt;div\u0026gt;{{xxx}}\u0026lt;/div\u0026gt; 備註： 接收的數據可以是基本類型，也可以是對象類型。 基本類型的數據：響應式依然是靠 Object.defineProperty() 的 get 與 set 完成的。 對象類型的數據：內部求助了 Vue3.0 中的一個新函數\u0026mdash;- reactive reactive 函數 作用：定義一個對象類型的響應式數據(基本類型別用他，用ref函數)。 語法： 1 2 3 4 const xxx = reactive({ name: \u0026#34;測試\u0026#34;, age: 18 }) 接收一個對象或數組，返回一個代理對象(Proxy對象)。 reactive 定義的響應式數據是深層次的。 內部基於 ES6 的 Proxy 實現，通過代理對象操作源對象內部數據都是響應式的，並通過 Reflect 操作源對象內部的數據。 js、模板中操作數據均不需要 .value Vue 2.0 中的響應式原理 實現原理： 對象類型：通過 Object.defineProperty() 對屬性的讀取、修改進行攔截(數據劫持)。 數組類型：通過重寫更新數組的一系列方式來實現攔截。(對數組的變更方法進行了包裹)。 1 2 3 4 5 6 7 8 Object.defineProperty(data, \u0026#34;count\u0026#34;, { get() { }, set() { } }) 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue2 中實現響應式 let p = {} Object.defineProperty(p, \u0026#34;name\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 name 時調用 return person.name }, set(value) { console.log(\u0026#34;有人修改了 name 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.name = value } }) Object.defineProperty(p, \u0026#34;age\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 age 時調用 return person.age }, set(value) { console.log(\u0026#34;有人修改了 age 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.age = value } }) 存在問題： 新增屬性、刪除屬性，介面不會更新，需使用 $set、$delete。 直接通過下標修改數組，介面不會更新，需使用 $set、$delete。 問題情況演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { data() { return { person: { name: \u0026#34;張三\u0026#34;, age: 18, hobby: [\u0026#34;學習\u0026#34;, \u0026#34;吃飯\u0026#34;] } } }, methods: { addSex() { this.person.sex = \u0026#34;女\u0026#34; // 此時畫面不會更新 this.$set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 Vue.set() // Vue.set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) }, deleteName() { delete this.person.name // 此時畫面不會更新 this.$delete(this.person, \u0026#34;name\u0026#34;) // 需使用 $delete 畫面才會更新 // 或是使用 Vue.delete() // Vue.delete(this.person, \u0026#34;name\u0026#34;) }, updateHobby() { this.person.hobby[0] = \u0026#34;逛街\u0026#34; // 此時畫面不會更新 this.$set(this.person.hobby, 0, \u0026#34;逛街\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 splice() // this.person.hobby.splice(0, 1, \u0026#34;逛街\u0026#34;) } } } Vue 3.0 中的響應式原理 實現原理： 通過 Proxy(代理)：攔截對象中任意屬性的變化，包含屬性值的讀寫、屬性的新增、屬性的刪除等。 通過 Reflect(反射)：對被代理對象的屬性進行操作。 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue3 中實現響應式 const p = new Proxy(person, { // 有人讀取p的某個屬性時調用 get(target, propName) { console.log(`有人讀取了p身上的${propName}屬性`) return Reflect.get(target, propName) }, // 有人新增或修改p的某個屬性時調用 set(target, propName, value) { console.log(`有人修改了p身上的${propName}屬性，我要去更新介面了！`) Reflect.set(target, propName, value) }, // 有人刪除p的某個屬性時調用 deleteProperty(target, propName) { console.log(`有人刪除了p身上的${propName}屬性，我要去更新介面了！`) return Reflect.deleteProperty(target, propName) } }) setup 的兩個注意點 setup 執行的時機：在 beforeCreate 之前執行一次，this 是 undefined。 setup 的參數 props：值為對象，包含：組件外部傳遞過來，且組件內部聲明接收了的屬性。 context：上下文對象： attrs：值為對象，包含：組件外部傳遞過來，但沒有在 props 配置中聲明的屬性，相當於 Vue 2.0 的 this.$attrs。 slots：接收的插槽內容，相當於 Vue 2.0 的 this.$slots。 emit：分發自定義事件的函數，相當於 Vue 2.0 的 this.$emit。 watch 函數 與 Vue 2.0 中的 watch 配置功能一致。 兩個小\u0026quot;坑\u0026quot;： 監視 ref 定義的響應式數據時，不需加 .value。 監視 reactive 定義的響應式數據時，oldValue 無法正確捕獲、強制開啟了深度監視(deep配置失效)。 監視 reactive 定義的響應式數據中的某個屬性時，deep 配置有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import { ref, reactive, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(10) const msg = ref(\u0026#34;測試\u0026#34;) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 情況一：監視 ref 定義的響應式數據 watch(sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況二：同時監視多個 ref 定義的響應式數據 watch([sum, msg], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum或msg變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) /* * 情況三：監視 reactive 定義的響應式數據的全部屬性 * 1. 注意: 此數無法正確的獲取 oldValue * 2. 注意: 強制開啟了深度監視(deep配置無效) */ watch(person, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: false }) // 此處的 deep 配置無效 // 情況四：監視 reactive 定義的響應式數據的某個屬性 watch(() =\u0026gt; person.name, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況五：監視 reactive 定義的響應式數據的某些屬性 watch([() =\u0026gt; person.name, () =\u0026gt; person.age], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name或age變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 特殊情況：監視 reactive 定義的響應式數據的某些對象屬性 watch(() =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的job變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: true }) // 此處由於監視的是 reactive 所定義的對象中的某個屬性，所以 deep 配置有效 return { sum, msg } } } watch 時 value 的問題 若監視的數據為 ref 求助 reactive 生成的響應式數據，則可使用以下兩種方式進行監視： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { ref, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = ref({ name: \u0026#34;張三\u0026#34;, name: 18, job: { job1: { salary: 20 } } }) watch(sum, (newValue, oldValue) =\u0026gt; { // 監視的是 sum 這個 RefImpl 數據，因此不需要 .value console.log(\u0026#34;sum的值變化了\u0026#34;, newValue, oldValue) }) // 方法一: watch(person.value, (newValue, oldValue) =\u0026gt; { // 監視 person.value 的 Proxy 對象 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }) // 方法二: watch(person, (newValue, oldValue) =\u0026gt; { // 深度監視 person 的 Proxy 對象的屬性 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }, { deep: true }) return { person } } } watchEffect 智能版 watch，不用指名監視哪個屬性，監視的回調中用到哪個屬性，就監視哪個屬性(而且是深層次的)。 watchEffect 有點像 computed： 但 computed 注重計算出來的值(回調函數的返回值)，所以必須要寫返回值。 而 watchEffect 更注重的是過程(回調函數的函數體)，所以不用寫返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { ref, reactive, watchEffect } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) watchEffect(() =\u0026gt; { const x1 = sum.value const x2 = person.job.job1.salary console.log(\u0026#34;watchEffect 配置的回調執行了\u0026#34;) }) } } 自定義 hook 函數 hook 本質是一個函數，把 setup 函數中使用的 Composition API 進行了封裝。 類似於 vue 2.0 中的 mixin。 自定義 hook 的優勢：重複使用代碼，讓 setup 中的邏輯更清楚易懂。 命名通常建議以 \u0026ldquo;use\u0026rdquo; 開頭，例如： 一個獲取鼠標點擊位置的 hook src/hooks/usePoint.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { reactive, onMounted, onBeforeUnmount} from \u0026#34;vue\u0026#34; export default function() { // 獲取鼠標點擊位置 相關的數據 let point = reactive({ x: 0, y: 0 }) // 獲取鼠標點擊位置 相關的方法 function savePoint(event) { console.log(event.pageX, event.pageY) point.x = event.pageX point.y = event.pageY } // 獲取鼠標點擊位置 相關的生命週期鉤子 onMounted(() =\u0026gt; { window.addEventListener(\u0026#34;click\u0026#34;, savePoint) }) onBeforeUnmount(() =\u0026gt; { window.removeEventListener(\u0026#34;click\u0026#34;, savePoint) }) return point } Demo.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 import usePoint from \u0026#34;@/hooks/usePoint\u0026#34; export default { name: \u0026#34;Demo\u0026#34;, setup() { // 使用自定義的 hook const point = usePoint() return { point } } } toRef 作用：創建一個 ref 對象，其 value 值指向(引用)另一個對象中的某個屬性(返回值為一個 ObjectRefImpl 對象，為響應式)。 語法： 1 const name = toRef(person, \u0026#34;name\u0026#34;) 應用：要將響應式對象中的某個屬性單獨提供給外部使用時。 擴展：toRefs 與 toRef 功能一致，但可以批量創建多個 ref 對象，語法： 1 toRefs(person) 使用範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { reactive, toRef, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) const name1 = person.name // name1 僅為賦值，無響應式 const name2 = toRef(person, \u0026#34;name\u0026#34;) // name2 的值會指向(引用) person 的 name return { // errors： // name1: person.name, // 僅為賦值，無響應式 // name2: ref(person.name) // 初始值正常，但修改時不會改到 person 的 name，因為此寫法僅是將 \u0026#34;ref(pserson.name)\u0026#34; 賦值給 name2，而非將 name2 指向 person 的 name // success： // 模板中使用 {{ person.name }}...等： // person, // 一個一個給出，模板中使用 {{ name }}...等： // name: toRef(person, \u0026#34;name\u0026#34;), // age: toRef(person, \u0026#34;age\u0026#34;), // salary: toRef(person.job.job1, \u0026#34;salary\u0026#34;) // 一次全給出，模板中可直接使用 {{ name }}、{{ age }}、{{ job.job1.salary }} ...toRefs(person) } } } 其他的 Composition API 1. shallowReactive 與 shallowRef shallow：淺層的 shallowReactive：只處理對象最外層屬性的響應式(淺響應式)。 shallowRef：只處理基本數據類型的響應式，不進行對象的響應式處理。 什麼時候使用？ 如果有一個對象數據，結構比較深，但變化時只是外層屬性變化 =\u0026gt; shallowReactive。 如果有一個對象數據，後續功能不會修改該對象中的屬性，而是生成新的對象來替換 =\u0026gt; shallowRef。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { shallowRef, shallowReactive, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = shallowReactive({ // 只考慮第一層數據的響應式 name: \u0026#34;張三\u0026#34;, // 響應式 age: 18, // 響應式 job: { // 非響應式 job1: { salary: 20 } } }) let x = shallowRef({ // 基本類型時同 ref，但對象類型不是響應式(value 會變成一般的 Object 而不是 Proxy ) y: 0 }) return { x, ...toRefs(person) } } } 2. readonly 與 shallowReadonly readonly：讓一個響應式數據變為唯讀的(深層唯讀)。 shallowReadonly：讓一個響應式數據變為唯讀的(淺層唯讀)。 應用場景：不希望數據被修改時。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { ref, reactive, toRefs, readonly, shallowReadonly} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 將 sum 變為唯讀，保護數據不被修改 sum = readonly(sum) // 將 person 的所有屬性變為唯讀，保護所有屬性數據不被修改 person = readonly(person) // 將 person 的\u0026#34;第一層屬性數據\u0026#34;變為唯讀(name、age無法修改，但 job 可以) person = shallowReadonly(person) return { sum, ...toRefs(person) } } } toRaw 與 markRaw raw：原始。 toRaw： 作用：將一個由 reactive 生成的響應式對象轉為普通對象。 應用場景：用於讀取響應式對象對應的普通對象，對這個普通對象的所有操作，不會引起頁面更新。 markRaw： 作用：標記一個對象，使其永遠不會再成為響應式對象。 應用場景： 有些值不應被設置為響應式的，例如複雜的第三方類庫等。 當渲染具有不可變數據源的大列表時，跳過響應式轉換可以提高性能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { ref, reactive, toRaw, markRaw} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) function showRawPerson() { const p = toRaw(person) console.log(p) // 返回的不再是 Proxy，而是 Object } function addCar() { let car = { name: \u0026#34;奔馳\u0026#34;, price: 40} person.car = markRaw(car) // 標記 person.car 不是響應式的數據(數據依舊可修改，但畫面不會變) } return { sum, ...toRefs(person), showRawPerson, addCar } } } customRef 作用：創建一個自定義的 ref，並對其依賴項跟蹤和更新觸發進行顯示控制。 實現防抖效果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt; {{ keyWord }} \u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, customRef } from \u0026#34;vue\u0026#34; export default { setup() { // 使用 vue 提供的 ref // let keyWord = ref(\u0026#34;hello\u0026#34;) // 自定義的一個 ref function myRef(value, delay) { let timer return customRef((track, trigger) =\u0026gt; { return { get() { console.log(`有人從 myRef 這個容器中讀取數據了，我把${value}給他了`) track() // 通知 Vue 追蹤數據的變化(提前與 get 商量一下，讓它認為這個 value 是有用的) return value }, set(newValue) { console.log(`有人把 myRef 這個容器中的數據改為了${newValue}`) clearTimeout(timer) timer = setTimeout(() =\u0026gt; { value = newValue trigger() // 通知 Vue 去重新解析模板，以便觸發 get }, delay) } } }) } // 使用自定義的防抖 ref let keyWord = myRef(\u0026#34;hello\u0026#34;, 500) return { keyWord } } } \u0026lt;/script\u0026gt; provide 與 inject 作用：實現祖孫組件間通信。 套路：父組件有一個 provide 選項來提供數據，後代組件有一個 inject 選項來開始使用這些數據。 具體寫法： 1. 祖組件中： 1 2 3 4 5 6 7 8 9 10 11 12 import { reactive, toRefs, provide } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;App\u0026#34;, setup() { let car = reactive({ name: \u0026#34;奔馳\u0026#34;, price: \u0026#34;40W\u0026#34; }) provide(\u0026#34;car\u0026#34;, car) // 給自己的後代組件傳遞數據 return { ...toRefs(car) } } } 2. 後代組件中： 1 2 3 4 5 6 7 8 9 import { inject } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;Son\u0026#34;, setup() { let car = inject(\u0026#34;car\u0026#34;) console.log(car) return { car } } } 響應式數據的判斷 isRef：檢查一個值是否為一個 ref 對象。 isReactive：檢查一個對象是否是由 reactive 創建的響應式代理。 isReadonly：檢查一個對象是否是由 readonly 創建的唯讀代理。 isProxy：檢查一個對象是否是由 reactive 或是 readonly 方法創建的代理。 Teleport teleport：傳送、瞬間移動。 作用：能夠將我們的 組件 html 結構 移動到指定的位置。 具體寫法： 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;!-- to 也能寫 css select，例如 to=\u0026#34;#app\u0026#34; --\u0026gt; \u0026lt;div v-if=\u0026#34;isShow\u0026#34; class=\u0026#34;mask\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;h3\u0026gt; 我是一個彈窗 \u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt; 關閉彈窗 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; Suspense suspense：懸疑、懸而未決的。 作用：等待異步組件時，渲染一些額外內容，讓使用者有更好的用戶體驗。 使用步驟： 異步引用組件 1 2 import { defineAsyncComponent } from \u0026#34;vue\u0026#34; // 宣告異步組件時使用 const Child = defineAsyncComponent(() =\u0026gt;. import (\u0026#34;./components/Child.vue\u0026#34;)) 使用 Suspense 包裹組件，並配置好 default 與 fallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App組件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加載中......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 全局 API 的轉移 Vue 2.0 有許多全局 API 和配置。 例如：註冊全局組件、註冊全局指令等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 註冊全局組件 Vue.component(\u0026#34;MyButton\u0026#34;, { data() { return { count: 0 } }, template: \u0026#34;\u0026lt;button @click=\u0026#39;count++\u0026#39;\u0026gt;Clicked {{ count }}\u0026lt;/button\u0026gt;\u0026#34; }) // 註冊全局指令 Vue.directive(\u0026#34;focus\u0026#34;, { inserted: el =\u0026gt; el.focus() }) Vue 3.0 中對這些 API 做出了調整： 將全局的 API，即： Vue.xxx 調整到應用實例(app)上 2.0 全局 API(Vue) 3.0 實例 API(app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties ","date":"2022-07-17T00:00:00Z","image":"/2022-07-17/atguigu-vue3-note/index_huc185496ed55e6f95ddd80689badb475a_232407_120x120_fill_q75_box_smart1.jpeg","permalink":"/2022-07-17/atguigu-vue3-note/","title":"尚硅谷 Vue3 視頻筆記"},{"content":"Markdown 是讓你快速撰寫筆記，流暢管理知識，支援多種衍生功能的生產力工具\n標題 當您想要將一段文字標示為標題的時候，請使用這個語法。\n請在行首輸入 # 符號，並在後面加上一個空白後，再輸入標題文字。\n標題有分成 6 個層級，# 的數量愈多，層級越低。\n1 2 3 4 5 6 # 第一層級標題 h1 ## 第二層級標題 h2 ### 第三層級標題 h3 #### 第四層級標題 h4 ##### 第五層級標題 h5 ###### 第六層級標題 h6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-16T00:00:00Z","image":"/2022-07-16/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"/2022-07-16/markdown-syntax/","title":"Markdown 語法指南"},{"content":" 指導教師：李菊權(0921-763623) python(版本3.8.2) 安裝至環境變數(Windows10) Add Python 3.8 to PATH 若沒勾選，需自行到(以下兩種方式進入環境變數設定)\n本機 ▸ 內容 控制台 ▸ 系統及安全性 ▸ 系統\n進階系統設定 ▸ 系統內容 ▸ 進階 ▸ 環境變數\n將python.exe目錄新增至環境變數\n(PATH ▸ 編輯 ▸ 新增) 1 2 3 4 5 6 7 8 9 ### python.exe預設位置(Windows10) C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ ### 找python.exe(Windows10) where python.exe \u0026gt; C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\python.exe ### 將以下此段路徑新增至環境變數 ### C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ Python介紹 Python 動態型別(強型別)/直譯式語言 動態型別：使用變數時不須預先宣告型別，依照設定之值而變。 強型別：不同型別無法進行運算。 直譯式語言：不須經過編譯即可直接執行。 副檔名：.py IDLE python官方提供的IDE 推薦開發環境 Anaconda Spyder - 整合開發程式 Python Shell (REPL) Python Shell (REPL) 模式\n進入Python Shell (REPL) 1 2 python \u0026gt;\u0026gt;\u0026gt; # 開頭變成\u0026gt;\u0026gt;\u0026gt;代表進入python shell 離開Python Shell (REPL) 1 quit() 清除當前Python Shell Screen 1 cls Python Plugin 作業系統模組 - os 載入模組 1 import os # 匯入系統模組 打開系統的指定程式 - os.system(程式名) 1 2 os.system(\u0026#34;mspaint\u0026#34;) # 打開小畫家 os.system(\u0026#34;calc\u0026#34;) # 打開計算機 列出目錄中所有檔案 - os.listdir(路徑) 1 os.listdir(\u0026#34;./\u0026#34;) # 當前目錄 取得當前目錄 - os.getcwd() 1 os.getcwd() 檢查目錄是否存在 - os.path.isdir(目錄路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在export目錄 testDir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(testDir): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查檔案是否存在 - os.path.isfile(檔案路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在text.txt testFile = os.getcwd() + \u0026#34;\\\\test.txt\u0026#34; if os.path.isfile(testFile): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查路徑是否存在 - os.path.exists(目錄路徑) 1 2 3 4 5 testPath = \u0026#34;\\\\etc\\\\hosts\u0026#34; if os.path.exists(testPath): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 於指定路徑建立目錄 - os.mkdir(路徑+目錄名) 1 2 3 4 # 檢查當前目錄是否存在export目錄，沒有則建立 new_dir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(new_dir) != True: os.mkdir(new_dir) 影像處理模組 - PIL(Pillow) 安裝 PIL 模組 1 2 ### 使用 pip 安裝 PIL 模組 pip install PIL 載入模組 1 from PIL import Image 打開圖檔 - .open(圖檔路徑) 1 im = Image.open(\u0026#34;test.jpg\u0026#34;) 存檔 - .save(\u0026quot;檔名\u0026quot;, \u0026ldquo;[格式]\u0026rdquo;, [quality = 壓縮值(通常設定80或90)], [subsampling = 0]) 1 2 3 4 5 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 打開圖檔 im.save(\u0026#34;test1.png\u0026#34;) # 轉存成png # 轉存成png並壓縮品質:80 im.save(\u0026#34;test2.png\u0026#34;, quality = 80, subsampling = 0) PIL常用的圖檔格式\n格式 BMP、EPS、GIF、JPEG、JPG、PNG、TIFF、PDF 調整圖片尺寸 - .resize((寬, 高) [, filter(濾波)設定]) 不會自動等比例縮放，需等比例縮放得自行計算比例。\n1 2 3 4 5 6 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 載入圖片 width = 400 # 指定寬度為 400px ratio = float(width)/im.size[0] # 計算長寬比 height = int(im.size[1]*ratio) # 高度依長寬比計算並調整 nim = im.resize((width, height), Image.BILINEAR) nim.save(\u0026#34;test_resized.jpg\u0026#34;) # 另存調整尺寸後的圖檔 濾波設定值\nfilter(濾波) 說明 NEAREST 預設濾波，從輸入的圖檔中選取最近的像素作為輸出像素。 BILINEAR 雙線性內插濾波，再輸入圖像的 2*2 矩陣上進行線性插值。 BICUBIC 雙立方濾波，再輸入圖像的 4*4 矩陣上進行立方插值。 ANTIALIAS 平滑濾波，對所有可以影響輸出像素的輸入像素進行高質量的重採樣濾波，以計算輸出像素值。 圖像繪製工具 - turtle 1 2 3 4 5 6 7 8 9 import turtle # 匯入圖像繪製工具turtle turtle.showturtle() # 打開turtle turtle.forward(100) # turtle往前100 turtle.left(90) # 左轉90度 turtle.circle(30) # 畫半徑30的圓 turtle.reset() # 重新設定 turtle.goto(30,50) # 移動到指定座標 turtle.penup() # 將筆提起 turtle.pendown() # 將筆放下 數字模組 - math 1 2 3 4 5 6 7 8 9 10 11 import math print(math.pi) # 取圓周率 \u0026gt;\u0026gt;\u0026gt; 3.141592653589793 print(math.radians(45)) # 取弧度45度 \u0026gt;\u0026gt;\u0026gt; 0.7853981633974483 print(math.sin(math.radians(45))) # 取sin(45度) \u0026gt;\u0026gt;\u0026gt; 0.7071067811865476 print(math.factorial(5)) # 取階乘(5為1*2*3*4*5) \u0026gt;\u0026gt;\u0026gt; 120 print(math.gcd(27, 9)) # 取最大公因數 \u0026gt;\u0026gt;\u0026gt; 9 亂數模組 - random 1 2 3 4 5 6 7 8 9 10 11 12 import random random.random() # 取0~1的隨機數 \u0026gt;\u0026gt;\u0026gt; 0.5672829418362756 random.randint(1, 10) # 取1~10的隨機數 \u0026gt;\u0026gt;\u0026gt; 4 K = [2,6,9,8,14,20,30] # 先設定一個陣列 random.shuffle(K) # 打亂陣列排列(直接操作該陣列) print(K) \u0026gt;\u0026gt;\u0026gt; [30, 9, 2, 6, 14, 20, 8] 浮點數精度模組 - Decimal 1 2 3 4 5 6 7 print(0.1+0.1+0.1) \u0026gt;\u0026gt;\u0026gt; 0.30000000000000004 # 使用Decimal模組來避免浮點數精度問題 from decimal import Decimal print(Decimal(\u0026#34;0.1\u0026#34;)*3) \u0026gt;\u0026gt;\u0026gt; 0.3 抓DOS模式後方參數的模組 - sys 1 2 3 # sysArgv.py import sys print(sys.argv) 1 2 3 # 於DOS模式執行sysArgv.py並於後方帶參數A、B、C python sysArgv.py A B C \u0026gt;\u0026gt;\u0026gt; [\u0026#39;sysArgv.py\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 資料庫模組 - sqlite3 載入模組 1 import sqlite3 連接資料庫 - .connect() 資料庫連結.connect(資料庫名稱) 1 2 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) Cursor指標指到資料庫(以便使用資料庫物件操作資料庫) - .cursor() 資料庫物件 = 資料庫連結.cursor() 1 2 3 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() 執行SQL語法 - .execute() 資料庫物件.execute(SQL語法) 1 2 3 4 5 6 7 8 9 10 11 12 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() SQL = \u0026#34;CREATE TABLE IF NOT EXISTS UserScore(\u0026#39;Name\u0026#39; Text, \u0026#39;Score\u0026#39; Integer)\u0026#34; cursor.execute(SQL) # 使用變數 name = \u0026#39;Wayne\u0026#39; Score = 80 SQL = f\u0026#34;INSERT INTO UserScore VALUES(\u0026#39;{name}\u0026#39;, {Score})\u0026#34; cursor.execute(SQL) 提交當前的SQL事務(執行完SQL需使用此函式提交) - .commit() 資料庫連結.commit() 1 2 conn.commit() conn.close() 取得所有資料 - .fetchall() 資料庫物件.fetchall() 1 2 3 4 5 6 7 8 9 10 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) rows = cursor.fetchall() for row in rows: # format格式化資料型態 print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(row[0], row[1], row[2])) 取得單筆資料 - .fetchone() 資料庫物件.fetchone() 1 2 3 4 5 6 7 8 9 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) line = cursor.fetchone() if not line == None: print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(line[0], line[1], line[2])) 正規表達式模組 - re 以小寫r開頭再接字串，例如：r\u0026quot;\\d\u0026quot;、r\u0026quot;0-9\u0026quot; 規則寫法 說明 範例 {} 個數 \\d{4}-\\d{6}：台灣電話號碼格式0000-000000為符合 {n,} 至少出現n次 X{2,}：X至少出現2次才符合 ` ` 或 \\d 任意數字 \\d：0-9為符合 - 到 1-5：1 ~ 5為符合,a-z：a ~ z為符合 ^ 否定 ^aeiou：非a,e,i,o,u為符合 . 字元 .：字元皆符合,符號類(例如：\\n)不符合 * 重複前一個字元0~無限多次都符合 err*：err、errr、errrr\u0026hellip;等都為符合 ? 前一個字元可有可無皆符合 colou?r：color、colour皆為符合 + 前一個字元要一次以上才符合 er+：er不符合,err、errr\u0026hellip;等才符合 $ 1.位數由後往前匹配 2.為結尾才匹配 [1-9]\\d$：1 ~ 99皆為符合,100不符合 () 1.僅收集括號內的內容 2.分組別以便.group(組別)可以直接抓到值 r'\u0026lt;h3 class=\u0026quot;LC20lb DKV0Md\u0026quot;\u0026gt;(.*?)\u0026lt;/h3\u0026gt;'：僅回傳\u0026lt;h3\u0026gt;內的文字 \\b 邊界,為邊界則符合 dog\\b：\u0026lsquo;dog \u0026lsquo;符合,\u0026lsquo;dog\u0026rsquo;不符合 \\數字 分組向前參考 貪婪/逐步量詞 (*/?) 貪婪量詞 - *:0次~無限次皆符合。 1 2 3 re.match(r\u0026#34;\u0026lt;.*\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt; 逐步量詞 - ?:回傳最短的量詞。 1 2 3 re.match(r\u0026#34;\u0026lt;.*?\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt; 載入模組 1 import re 分割字串 - re.split(正則, 分割的字串) 1 2 3 print(re.split(\u0026#39;\\d\u0026#39;, \u0026#34;Andy1Ben2Cathy\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;Andy\u0026#39;, \u0026#39;Ben\u0026#39;, \u0026#39;Cathy\u0026#39;] 取代字元 - re.sub(正則, 欲取代的字元, 字串) 1 2 3 re.sub(\u0026#34;\\d\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;Andy1Ben2Cathy\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Andy-Ben-Cathy\u0026#39; 匹配字元 - re.match(欲匹配的文字, 字串) 1 2 3 re.match(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找第一個) - re.search(欲尋找的文字, 字串) 1 2 3 re.search(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找所有) - re.findall(欲尋找的文字, 字串) 1 2 3 re.findall(\u0026#39;\\d{4}-\\d{6}\u0026#39;, \u0026#34;jjladpoiwlkj 0800-123456 hjkpojas 0921-456873\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;0800-123456\u0026#39;, \u0026#39;0921-456873\u0026#39;] 抓html模組 - requests 載入模組 1 import requests GET 抓取檔案 - .get(網址) 1 response = requests.get(\u0026#34;https://www.baidu.com/\u0026#34;) GET 可帶的參數(需使用關鍵字參數) 說明 headers 請求的headers params 參數 cookies client的cookies 抓取標頭(head) - .head(網址) 1 2 # .head() -\u0026gt; 只抓標頭 reshead = requests.head(\u0026#34;https://www.baidu.com/\u0026#34;) 狀態碼 - status_code 1 2 3 print(response.status_code) \u0026gt;\u0026gt;\u0026gt; 200 # 200為正常連線 編碼格式 - encoding 1 2 3 4 5 print(response.encoding) \u0026gt;\u0026gt;\u0026gt; \u0026#39;ISO-8859-1\u0026#39; # 轉編碼為utf-8 response.encoding = \u0026#34;utf-8\u0026#34; html內容 - text 1 2 3 print(response.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt;...\u0026#39; response headers - headers 1 2 3 print(response.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;Server\u0026#39;: \u0026#39;Baby Web Server\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;, \u0026#39;Content-Length\u0026#39;: \u0026#39;467\u0026#39;, \u0026#39;Set-Cookie\u0026#39;: \u0026#39;SESSIONID=00000006; path=/;version=1\u0026#39;, \u0026#39;Date\u0026#39;: \u0026#39;Sun, 03 May 2020 10:41:58 GMT\u0026#39;} request headers - request.headers 其中的User-Agent相當重要，用來判斷使用者的相關資訊用，爬蟲與反爬蟲通常使用此參數。 1 2 3 print(response.request.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;User-Agent\u0026#39;: \u0026#39;python-requests/2.22.0\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;} 抓圖片檔 開檔格式使用wb:二進位格式寫入 w:寫入 / b:二進位格式 1 2 3 4 5 6 7 8 import requests res = requests.get(\u0026#34;https://www.natgeomedia.com/userfiles/PhotoContest/771/sm1100/2019091450912553.jpg\u0026#34;) photo = res.content # w:寫入/b:二進位格式 \u0026#34;wb\u0026#34; =\u0026gt; 二進位格式寫入 with open(\u0026#34;img01.jpg\u0026#34;, \u0026#34;wb\u0026#34;) as file: file.write(photo) 帶request header的請求 先從一般瀏覽器取得header(user-agent) 需使用關鍵字參數 1 2 3 4 5 # 從瀏覽器的開發者工具取得正常的request headers資料 headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} # 在後方帶入關鍵字參數headers res = requests.get(\u0026#34;http://google.com.tw\u0026#34;, headers = headers) POST POST 可帶的參數(需使用關鍵字參數) 說明 data form data請求的data headers 請求的headers cookies client的cookies POST存Session - .Session() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data = { \u0026#34;from\u0026#34;: \u0026#34;/bbs/Gossiping/index.html\u0026#34;, \u0026#34;yes\u0026#34;: \u0026#34;yes\u0026#34; } headers = { \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; } # 先使用POST取得滿18歲的驗證並存放置session內 rs = requests.Session() rs.post(\u0026#34;https://www.ptt.cc/ask/over18\u0026#34;, data = data, headers = headers) # 過滿18歲的驗證後使用get取得網頁內容 response = rs.get(\u0026#34;https://www.ptt.cc/bbs/Gossiping/index.html\u0026#34;, headers = headers) 解析\u0026amp;美化HTML模組 - BeautifulSoup4 載入模組 1 from bs4 import BeautifulSoup BeautifulSoup4的基本元素表 基本元素 說明 tag 標籤：最基本的信息組織單位，分別用\u0026lt;\u0026gt;和\u0026lt;/\u0026gt;標明開頭與結尾。 name 標籤名稱：\u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;的名字是p，格式：\u0026lt;tag\u0026gt;.name。 Attributes 屬性：\u0026lt;tag\u0026gt;.attrs，dict型式。 NavigatString 內容：\u0026lt;tag\u0026gt;.string。 Comment 註釋：標籤內字符串的註釋部分，一種特殊的Comment類型。 解析 - .BeautifulSoup(html, \u0026lsquo;html.parser\u0026rsquo;) 1 2 3 4 5 6 7 8 9 10 demo = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;This is a python demo page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;course\u0026#34;\u0026gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; class=\u0026#34;py1\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-1001870001\u0026#34; class=\u0026#34;py2\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Advanced Python\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(demo, \u0026#39;html.parser\u0026#39;) 美化 - .prettify() 1 print(soup.prettify()) 取得屬性 - .attrs 1 2 3 4 5 print(soup.a.attrs) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;href\u0026#39;: \u0026#39;http://www.icourse163.org/course/BIT-268001\u0026#39;, \u0026#39;class\u0026#39;: [\u0026#39;py1\u0026#39;], \u0026#39;id\u0026#39;: \u0026#39;link1\u0026#39;} 取得tag內容 - .string/.text 1 2 3 4 5 print(soup.a.string) print(soup.a.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; 找第一個標籤 - .find(\u0026quot;標籤\u0026quot;) 1 2 3 soup.find(\u0026#34;a\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; 找全部的標籤 - .find_all(\u0026quot;標籤\u0026quot;, class_=\u0026quot;className\u0026quot;) 可加上class做篩選條件。 1 2 3 4 5 6 7 8 9 # 寫法1： soup.find_all(\u0026#34;p\u0026#34;, class_=\u0026#34;title\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 寫法2： soup.find_all(\u0026#34;p\u0026#34;, {\u0026#34;class\u0026#34;=\u0026#34;title\u0026#34;}) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] 透過選擇器篩選標籤 - .select(同CSS選擇器,Class或ID) 若有空格會有問題，soup.select(.\u0026quot;title p\u0026quot;) 會報錯，空格需使用.find()、.findAll() 1 2 3 4 5 6 7 # 使用Class選擇器 print(soup.select(\u0026#34;.title\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 使用ID選擇器 print(soup.select(\u0026#34;#link1\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt;] json模組 載入模組 1 import json json轉dict - json.loads(\u0026quot;字串\u0026quot;) 1 2 3 4 5 6 7 import json txt = \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; }\u0026#39; data = json.loads(txt) print(type(data)) # 字典型態 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;class \u0026#39;dict\u0026#39;\u0026gt;\u0026#39; dict轉json string - json.dumps(\u0026quot;字典\u0026quot;) 1 2 3 4 5 6 7 import json txt = { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; } jsonData = json.dumps(txt) print(jsonData) # 轉換後為json格式的字串 \u0026gt;\u0026gt;\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34;} csv模組 載入模組 1 import csv 以_csv.reader型態讀取csv檔 - csv.reader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.reader(file) # 一筆一筆取出資料 for row in rows: print(row) 以dict型態讀取csv檔 - csv.DictReader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.DictReader(file) # 一筆一筆取出資料 for row in rows: print(row) 寫入csv檔 - csv.writer(檔案變數) 需先定義一個物件為csv.writer()，在進行寫入。 writerow() ：單行寫入 1 2 3 4 5 6 with open(\u0026#39;Temp.csv\u0026#39;, \u0026#39;w\u0026#39;) as csvfile: writer = csv.writer(csvfile) writer.writerow([\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;]) writer.writerow([\u0026#39;Jessica\u0026#39;, 158, 45]) writer.writerow([\u0026#39;Wayne\u0026#39;, 172, 60]) 以字典型態寫入csv檔 - csv.DictWriter(檔案變數, fieldnames=欄位變數(列表型態)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 with open(\u0026#39;DictTemp.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as csvfile: # 設定欄位變數 rowNames = [\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;] # fieldnames = 指定欄位 writer = csv.DictWriter(csvfile, fieldnames=rowNames) # 寫入欄位名稱 writer.writeheader() #寫入資料 writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Jessica\u0026#39;, \u0026#39;身高\u0026#39;: 156, \u0026#39;體重\u0026#39;: 45}) writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Wayne\u0026#39;, \u0026#39;身高\u0026#39;: 172, \u0026#39;體重\u0026#39;: 60}) 模擬瀏覽器模組(自動化測試) - selenium 安裝 selenium 模組 Anaconda編譯器的話，使用Anaconda Prompt 1 2 ### anaconda 安裝 selenium 模組 conda install selenium 1 2 ### 使用 pip 安裝 selenium 模組 pip install selenium 下載瀏覽器驅動(web driver)\n先查看chrome瀏覽器的版本，Google：Web driver chrome後下載。\n載入模組\n1 from selenium import webdriver 實例化一個瀏覽器視窗(Chrome)，並設定一個瀏覽器物件 檔案名稱勿與selenium模組名稱相同以免衝突而無法執行 1 2 3 from selenium import webdriver driver = webdriver.Chrome() 發送GET請求 - 瀏覽器物件.get(網址) 1 driver.get(\u0026#34;http://www.baidu.com\u0026#34;) 根據dom元件的id/class定位 - 瀏覽器物件.find_element_by_id(id) 或 瀏覽器物件.find_element_by_class(class) 1 2 # 找到id為\u0026#34;kw\u0026#34;的input，並輸入\u0026#34;python\u0026#34; driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(\u0026#34;python\u0026#34;) 送出表單 - 瀏覽器物件.dom元件.submit() 1 2 # 送出id為\u0026#34;su\u0026#34;的表單 driver.find_element_by_id(\u0026#34;su\u0026#34;).submit() 點擊事件 - 瀏覽器物件.dom元件.click() 1 2 # 送出id為\u0026#34;btn\u0026#34;的按鈕 driver.find_element_by_id(\u0026#34;btn\u0026#34;).click() 取得頁面原始碼 - .page_source 1 SourceHtml = driver.page_source 螢幕截圖 - 瀏覽器物件.save_screenshot(截圖的圖檔名稱) 1 driver.save_screenshot(\u0026#34;screen.png\u0026#34;) 獲取cookies - 瀏覽器物件.get_cookie() 1 2 cookies = driver.get_cookie() print(cookies) 關閉實例化的瀏覽器視窗 - 瀏覽器物件.close() 或 瀏覽器物件.quit() 1 2 driver.close() # 或 driver.quit() 資料分析模組 - Pandas 載入模組 1 import pandas 解析list類型 - pandas物件.Series(資料) 1 2 3 4 5 6 7 8 9 import pandas data = [20, 10, 15] pds = pandas.Series(data) print(pds) \u0026gt;\u0026gt;\u0026gt; 0 20 \u0026gt;\u0026gt;\u0026gt; 1 10 \u0026gt;\u0026gt;\u0026gt; 2 15 \u0026gt;\u0026gt;\u0026gt; dtype: int64 解析Data類型 - pandas物件.DataFrame(字典型態的資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 # 取特定欄位 print(data[salary]) \u0026gt;\u0026gt;\u0026gt; 0 1000 \u0026gt;\u0026gt;\u0026gt; 1 5000 \u0026gt;\u0026gt;\u0026gt; 2 2000 可指定x軸或y軸欄位名稱(columns, index) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100], ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) print(df) \u0026gt;\u0026gt;\u0026gt; 國文 數學 英文 自然 社會 \u0026gt;\u0026gt;\u0026gt; 張三 65 92 78 83 70 \u0026gt;\u0026gt;\u0026gt; 李四 62 96 81 63 71 \u0026gt;\u0026gt;\u0026gt; 王五 45 58 30 53 75 \u0026gt;\u0026gt;\u0026gt; 趙雲 90 91 70 90 100 回傳最大值 - Data資料.max() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.max()) \u0026gt;\u0026gt;\u0026gt; 20 回傳最小值 - 資料.min() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.min()) \u0026gt;\u0026gt;\u0026gt; 10 取得指定欄位 - Data資料.loc[x][y] 1 2 3 4 5 6 7 8 9 10 11 12 13 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) print(data.loc[0][1]) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 \u0026gt;\u0026gt;\u0026gt; 1000 輸出成csv(或json)檔案 - Data資料.to_csv(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 或 Data資料.to_json(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 1 2 3 4 5 6 7 8 9 10 11 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100] ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) df.to_csv(\u0026#39;temp.csv\u0026#39;, encoding=\u0026#34;utf-8-sig\u0026#34;) 繪圖模組 - plot 載入模組 1 import matplotlib.pyplot as plt 畫折線圖 - .plot(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出折線圖 plt.plot(x1, y1) 顯示Label - .legend() 要顯示label需執行此function :為點線, --為虛線, 不指定預設為實線 1 2 3 4 5 6 7 8 9 10 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # :為點線, --為虛線, 不指定預設為實線 plt.plot(x1, y1, label=\u0026#34;food\u0026#34;, color=\u0026#34;red\u0026#34;, linestyle=\u0026#34;:\u0026#34;) #要顯示label - 需執行legend() plt.legend() 指定圖表標題 - .title() 1 plt.title(\u0026#34;學生成績\u0026#34;) 指定X/Y軸標題 - .xlabel(X軸標題) / .ylabel(Y軸標題) 1 2 plt.xlabel(\u0026#34;X軸標題\u0026#34;) plt.ylabel(\u0026#34;Y軸標題\u0026#34;) 畫長條圖 - .bar(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出長條圖 plt.bar(x1, y1) 畫圓餅圖 - .pie(資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import matplotlib.pyplot as plt datas = [5,10,20,15] # 畫出圓餅圖 plt.pie(datas) # 讓特定區塊凸出(需與資料數量相同) explode = [0,0,0.05,0] plt.pie(datas, explode = explode) # 指定每個區塊的標題 labels = [\u0026#34;東部\u0026#34;,\u0026#34;南部\u0026#34;,\u0026#34;西部\u0026#34;,\u0026#34;北部\u0026#34;] plt.pie(sizes, labels = labels) # 顯示百分比 plt.pie(sizes,autopct=\u0026#34;%3.1f%%\u0026#34;) 繪圖模組2 - plotly 安裝 plotly 模組 Anaconda編譯器的話，需使用Anaconda Prompt安裝。 使用Jupyter Notebook編輯 1 2 ### anaconda 安裝 plotly 模組 conda install plotly 載入模組(並指定繪圖模式) 1 2 3 4 import plotly # 指定繪圖模式：Scatter, Bar, Pie, Box, Scattergeo, Histogram from plotly.graph_objs import Scatter # 折線散點圖 在線繪圖需收費，需使用離線繪圖 1 plotly.offline.init_notebook_mode(connected=True) 指定X/Y軸資料 1 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] 畫出折線圖 1 2 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定繪圖的mode 1 2 3 # markers：只有點 / lines：只有線 / lines + markers：點 + 線 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72], mode=\u0026#34;markers\u0026#34;)] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定圖表標題(繪圖模式須import Layout) 1 2 3 4 5 6 7 8 9 10 11 12 import plotly from plotly.graph_objs import Scatter, Layout # 離線繪圖模式 plotly.offline.init_notebook_mode(connected=True) data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] # 指定圖表標題 plotly.offline.iplot({\u0026#34;data\u0026#34;:data, \u0026#34;layout\u0026#34;:Layout(title=\u0026#34;成績單\u0026#34;)}) Excel模組 - openpyxl 載入模組 1 import openpyxl 建立工作簿物件 - openpyxl.Workbook() 1 2 # 工作簿物件 workbook = openpyxl.Workbook() 取得指定工作表 1 2 # 工作表物件 sheet = workbook.worksheets[0] 鍵入值 方法一：行列插入 1 2 3 # sheet：工作表物件 sheet[\u0026#39;A1\u0026#39;] = \u0026#34;欄位一\u0026#34; sheet[\u0026#39;B1\u0026#39;] = \u0026#34;欄位二\u0026#34; 方法二：自動換行插入 1 2 3 # sheet：工作表物件 listTitle = [\u0026#34;姓名\u0026#34;, \u0026#34;電話\u0026#34;] sheet.append(listTitle) 取得特定欄位的值 - .value 1 sheet[\u0026#39;A1\u0026#39;].value 存檔 - 工作簿物件.save(檔名) 1 workbook.save(\u0026#39;test.xlsx\u0026#39;) 取檔 - openpyxl.load_workbook(檔名) 1 workbook = openpyxl.load_workbook(\u0026#39;test.xlsx\u0026#39;) 取得總行數 - 工作表物件.max_row 1 print(sheet.max_row) 取得總列數 - 工作表物件.max_column 1 print(sheet.max_column) 到指定欄位 - 工作表物件.cell(row=指定行數, column=指定列數) 1 2 # 印出第3行第2列的值 print(sheet.cell(row=3, column=2).value) Python 資料型態 資料型態說明 資料型態 說明 str 字串 int 整數 bool 布林值 float 浮點數 None 空值 list [] 列表，同Array tuple () 不可變更的Array dict {} 字典，同Object set () 集合，同Object，但key為索引值 Python 運算子 基本運算子 運算子 說明 + 加：數值相加,字串相連接 - 減 * 乘：數值相乘,字串可乘數值(python獨有) / 浮點數除 ** 平方 **0.5 開根號 // 整數除 % 取餘數 指派運算子 運算子 說明 += 原值等於原值加 -= 原值等於原值減 *= 原值等於原值乘 /= 原值等於原值除 判斷運算子 運算子 說明 \u0026gt; 大於 \u0026lt; 小於 == 等於 != 不等於 \u0026gt;= 大於等於 \u0026lt;= 小於等於 邏輯運算子 運算子 說明 and 並且 or 或者 not 反向 Python 函式 回傳資料型態 - type() 1 2 3 4 5 6 7 8 type(3) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; type(True) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; type(None) # Python的空值為None \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 輸入窗 - input() 1 2 3 4 myName = input(\u0026#34;請輸入姓名：\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 請輸入姓名：jessica # 輸入名字後 print(myName) # 取輸入的名字 \u0026gt;\u0026gt;\u0026gt; jessica 字串轉數值 - eval() 1 2 3 num = eval(\u0026#34;3\u0026#34;) print(type(num)) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 特殊符號轉十進位編號 - ord() / chr() 1 2 3 4 5 6 7 # ord 將特殊符號轉換成十進位編號 ord(\u0026#39;⤅\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 10501 # chr 將十進位編號轉換成特殊符號 chr(10501) \u0026gt;\u0026gt;\u0026gt; ⤅ 取最大 / 最小值 - max() / min() 1 2 3 4 min(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 1 max(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 100 取絕對數值 - abs() 1 2 abs(-3.14) \u0026gt;\u0026gt;\u0026gt; 3.14 進制字串轉數字 - eval() 1 2 eval(\u0026#34;0o101\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 65 數字轉字串 - str() 1 2 str(324) \u0026gt;\u0026gt;\u0026gt; \u0026#39;324\u0026#39; 字串轉數字或數字轉整數 - int() 1 2 3 4 int(\u0026#34;324\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 324 int(3.14) \u0026gt;\u0026gt;\u0026gt; 3 浮點數字串轉數字 - float() 1 2 float(\u0026#34;3.1416\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 3.1416 四捨五入 - round(數值 [,位數]) 1 2 3 4 5 6 round(3.1416) \u0026gt;\u0026gt;\u0026gt; 3 # 第二個參數可帶位數 round(3.1416, 3) \u0026gt;\u0026gt;\u0026gt; 3.142 平方 - pow(數值, 平方根) 1 2 3 # 第二個參數為平方根 pow(5, 2) \u0026gt;\u0026gt;\u0026gt; 25 取得長度 - len() 任何資料型態都通用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # String strA = \u0026#34;Hello World\u0026#34; len(strA) \u0026gt;\u0026gt;\u0026gt; 11 # Array arrA = [1, 2, 20, 50, 100] len(arrA) \u0026gt;\u0026gt;\u0026gt; 5 # Object objA = {\u0026#34;itemA\u0026#34;:\u0026#34;123\u0026#34;, \u0026#34;itemB\u0026#34;:\u0026#34;456\u0026#34;} len(objA) \u0026gt;\u0026gt;\u0026gt; 2 編碼 / 解碼 - encode() / decode() 1 2 3 4 5 \u0026#34;中\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; b\u0026#39;\\xe4\\xb8\\xad\u0026#39; b\u0026#39;\\xe4\\xb8\\xad\u0026#39;.decode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;中\u0026#34; 字串轉大小寫 - upper() / lower() 1 2 3 4 5 6 7 StrA = \u0026#34;Hello World!\u0026#34; # 大寫 StrA.upper() \u0026gt;\u0026gt;\u0026gt; \u0026#39;HELLO WORLD!\u0026#39; # 小寫 StrA.lower() \u0026gt;\u0026gt;\u0026gt; \u0026#39;hello world!\u0026#39; 字串取代 - replace(舊字串, 新字串) 1 2 3 StrA = \u0026#34;Hello World!\u0026#34; StrA.replace(\u0026#34;World\u0026#34;, \u0026#34;Jessica\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello Jessica!\u0026#39; 字串判斷的函式 函式 說明 StrA.isalpha() 是否為字母 StrA.isdigit() 是否為數字 StrA.isupper() 是否為大寫 StrA.islower() 是否為小寫 StrA.isidentifer() 是否為識別字 StrA.iskeyword() 是否為關鍵字,需要keyword模組 StrA.isspace() 是否為空白 StrA.istitle() 是否為標題字(第一個字為大寫則是標題字) 字串搜尋的函式 函式 說明 Str.count(文字A) 搜尋文字A出現的次數 StrA.startswith(文字A) 是否為文字A開頭 StrA.endswith(文字A) 是否為文字A結尾 StrA.find(文字A) 搜尋文字A的位置 StrA.rfind(文字A) 搜尋文字A最後出現的位置 印出字串 - print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一般的print(間隔預設自動補空格) print(1, 2, 3) \u0026gt;\u0026gt;\u0026gt; 1 2 3 # 間隔不空格 print(1, 2, 3, sep=\u0026#34;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 123 # 指定間隔文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3 # 指定結尾文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;, end=\u0026#34;!!!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3!!! # 格數化輸出字元(開頭帶一個小寫的\u0026#34;f\u0026#34;) print(f\u0026#39;{變數A}*{變數B}={變數A*變數B}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; A * B = AB 字串格式化 - format() 取代字串中{} 1 2 3 text = \u0026#39;world\u0026#39; print(\u0026#39;hello {}\u0026#39;.format(text)) \u0026gt;\u0026gt;\u0026gt; hello world 可帶關鍵字取代 1 2 3 4 5 name = \u0026#39;Jack\u0026#39; text = \u0026#39;world\u0026#39; print(\u0026#39;hello {name}, hello {text}\u0026#39;.format(name=name, text=text)) \u0026gt;\u0026gt;\u0026gt; hello Jack, hello world 從最後面插入 - append() 1 2 3 4 list1 = [2,4,6,8] list1.append(10) \u0026gt;\u0026gt;\u0026gt; [2,4,6,8,10] 從指定位置插入 - insert(位置, 值) 1 2 3 4 list1 = [2,4,6,8,10] list1.insert(0, -1) \u0026gt;\u0026gt;\u0026gt; [-1,2,4,6,8,10] 條件判斷 條件判斷式 - if\u0026hellip; elif\u0026hellip; else\u0026hellip; 1 2 3 4 5 6 7 # 使用縮排撰寫要做的事 if 條件A: ... elif 條件B: ... else: ... 例外判斷 - try\u0026hellip; except\u0026hellip; 1 2 3 4 5 6 7 8 try: # ... except Exception: print(\u0026#34;有異常錯誤\u0026#34;) except NameError: print(\u0026#34;變數有錯誤\u0026#34;) except TypeError: print(\u0026#34;資料格式錯誤\u0026#34;) except 錯誤分類 錯誤異常判斷 說明 Exception 只要有錯誤 NameError 變數名稱錯誤 ValueError value值錯誤 ZeroDivisionError 除數/分母不可為零的錯誤 TypeError 資料格式錯誤 迴圈 技術式迴圈 - for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 跑range for i in range(1, 6): print(i, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1 2 3 4 5 # 跑在字串 for c in \u0026#34;Mary\u0026#34;: print(c, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;M\u0026#34; \u0026#34;a\u0026#34; \u0026#34;r\u0026#34; \u0026#34;y\u0026#34; # 跑在陣列 for e in [\u0026#34;a\u0026#34;, 3, \u0026#34;Jessica\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; \u0026#34;Jessica\u0026#34; 條件式迴圈 - while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # while迴圈 i = 0 while i \u0026lt; 5: i += 1 print(i) \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; 4 \u0026gt;\u0026gt;\u0026gt; 5 # While判斷(反覆驗證直到ans等於\u0026#34;happy\u0026#34;) ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans != \u0026#34;happy\u0026#34;: ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是happy\u0026#34;) break：跳脫迴圈 1 2 3 4 5 6 7 8 9 ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans.lower() != \u0026#34;happy\u0026#34;: # 當輸入quit時跳出迴圈 if(ans.lower() == \u0026#34;quit\u0026#34;): print(\u0026#34;猜不出來了吧，結束\u0026#34;) break; ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是\u0026#34;, ans) continue：跳過繼續進行下一迴圈 1 2 3 4 5 6 7 8 # i遇4的因數就跳過 i = 0 while i \u0026lt;= 100: i += 1 # continue前要先加1，避免進入無窮迴圈 if i % 4 == 0: continue print(i, end=\u0026#34; \u0026#34;) 自訂函式 自定義函式 - def 一般宣告函式 1 2 3 4 5 6 7 def printStar(_n): return \u0026#34;*\u0026#34; * _n # 執行函式 print(printStar(6)) \u0026gt;\u0026gt;\u0026gt; ****** 設定參數預設值 1 2 3 4 5 6 7 8 9 10 11 def TeaTime(desserts, drink=\u0026#34;咖啡\u0026#34;): print(f\u0026#39;下午茶點心為{desserts},飲料為{drink}\u0026#39;) TeaTime(\u0026#39;馬卡龍\u0026#39;, \u0026#39;紅茶\u0026#39;) # 指定實際參數 TeaTime(\u0026#39;馬卡龍\u0026#39;) # 飲料會顯示預設值:咖啡 TeaTime() # 兩個參數都顯示預設值 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為紅茶 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為咖啡 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為鬆餅,飲料為咖啡 設定不定個數參數(參數為tuple型態) 帶入參數帶星號可將帶入的參數組成一個tuple 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(1, 2, 4, 6) \u0026gt;\u0026gt;\u0026gt; 13 實際參數帶星號可將原為tuple型態的資料拆解開來 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(*range(0, 11)) \u0026gt;\u0026gt;\u0026gt; 55 多個回傳值 1 2 3 4 5 6 7 8 9 10 11 12 # 回傳值用逗號隔開 def divmod(x, y): div = x // y mod = x % y return div, mod # 用{a,b}接多個回傳值 a, b = divmod(100, 7) print(f\u0026#39;100除以7的商數為{a},餘數為{b}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 100除以7的商數為14,餘數為2 操作 List(列表) 建立 建立空list 1 2 3 4 5 # 方法1: list1 = [] # 方法2: list2 = list() 建立list 1 list1 = [1, \u0026#34;taipei\u0026#34;, 2, \u0026#34;tokyo\u0026#34;] # 每個的資料型態不限 從string建立list 1 list1 = list(\u0026#34;Hello\u0026#34;) # list1為 [\u0026#34;H\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] 從range建立list 1 list1 = list(5) # list1為 [0,1,2,3,4] 從字串分割建立list 1 list1 = \u0026#34;1 2 3\u0026#34;.split() # list1為 [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;] 刪除 刪除整個list 1 del list1 刪除list中的某一個(以第一個為例) 1 2 3 4 5 6 7 8 # 方法1 del list1[0] # 方法2 list.remove(0) # 方法3 list.pop([0]) 清除list元素(等於del list[::]) 1 2 3 4 list1 = [2,4,6,8,10] list1.clear() \u0026gt;\u0026gt;\u0026gt; [] list新增元素 1 2 3 list.append(x) # 附加元素到最後 list.extend(L) list.inser(i, x) # 插入元素至指定位置 查詢索引 1 list1.index(\u0026#39;a\u0026#39;) # 查詢a在list1的索引 統計出現的次數 1 list1.count(\u0026#39;a\u0026#39;) # 統計a在list1中出現的次數 元素排序 1 list.sort() # 原地操作 元素倒序 1 list1.reverse() # 原地操作 操作 Dict(字典) 查詢 一般查詢 1 dict1[key] # 若key值不在會報錯 以key查詢，使用dict1.get(key, [default]) - (推薦) 1 2 3 4 5 6 7 8 9 10 11 12 13 # 若無key值則顯示default dict1.get(key, [default]) #example: fruits = {\u0026#34;apple\u0026#34;:\u0026#34;30元\u0026#34;, \u0026#34;banana\u0026#34;:\u0026#34;10元\u0026#34;} Quest = input(\u0026#34;請輸入要查詢的價格的水果：\u0026#34;) print(fruits.get(Quest, \u0026#34;查無此水果\u0026#34;)) \u0026lt;\u0026lt;\u0026lt; apple \u0026gt;\u0026gt;\u0026gt; 30元 \u0026lt;\u0026lt;\u0026lt; orange \u0026gt;\u0026gt;\u0026gt; 查無此水果 查詢所有的key (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.keys() \u0026gt;\u0026gt;\u0026gt; dict_keys([\u0026#39;user1\u0026#39;, \u0026#39;user2\u0026#39;, \u0026#39;user3\u0026#39;]) 查詢所有的values (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.values() \u0026gt;\u0026gt;\u0026gt; dict_values([\u0026#39;小丸子\u0026#39;, \u0026#39;小玉\u0026#39;, \u0026#39;花輪\u0026#39;]) 建立 建立空dict 1 2 3 4 5 # 方法1: dict1 = {} # 方法2: dict2 = dict() 建立dict 1 dict1 = {1:\u0026#34;one\u0026#34;, 2:\u0026#34;tow\u0026#34;, 3:\u0026#34;three\u0026#34;} 新增dict 1 dict1[newKey] = value 更新 更新dict 1 dict1[oldKey] = value 比對更新 - update update 會比對沒有的key並補上，比對有的key進行value更新。 1 2 3 4 5 6 dict1 = {\u0026#39;user1\u0026#39;: \u0026#39;小丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;} dict2 = {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} dict1.update(dict2) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} 刪除 刪除整個dict 1 del dict1 清空整個dict 1 dict1.clear() 刪除list中的某一個(以第一個為例) 1 del dict1[key] 操作 class (類別/物件導向) 封裝成一個類別 - class 類別名稱: python的class會自動執行__init__函式，可自行定義__init__內要做的事。 __init__第一個參數預設為self。 1 2 3 4 5 6 7 class GoogleSpyder: def __init__(self, keyword): self.keyword = keyword self.url_tmp = \u0026#34;http://google.com/search?q=\u0026#34; + keyword + \u0026#34;\u0026amp;start={}\u0026#34; self.headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} googleSpyder = GoogleSpyder(\u0026#34;python\u0026#34;) # 自動執行 __init__ 檔案處理 讀寫模式 模式 說明 r read：讀取(檔案需存在) w write：新建檔案寫入(檔案可不存在，若存在則清空) a append：資料附加到舊檔案後面(游標指在檔案結尾，檔案可不存在) r+ 讀取舊資料並寫入(檔案需存在且游標指在開頭) w+ 清空檔案內容，新寫入的東西可再讀出 a+ 資料附加到舊檔案後面，可讀取資料 b 二進位模式 記憶方式： 1 2 3 4 w、w+ # 會清除原檔案內容 r、r+ # 檔案指標指向檔案開頭 a、a+ # 檔案指標指向檔案結尾 + # 可讀可寫模式 檔案開啟 - open() 操作後需關檔 - close() 1 2 3 4 5 6 7 8 9 10 content = \u0026#34;\u0026#34;\u0026#34;Hello Python 中文測試 abc 123456.321654987 $@^$%^@#$!@#$ \u0026#34;\u0026#34;\u0026#34; file = open(\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) ... file.close() 讀取 - read() myfile.txt 1 testtest123 test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) print(file.read()) file.close() 執行回傳 1 \u0026gt;\u0026gt;\u0026gt; testtest123 寫入 - write() test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) file.write(\u0026#39;testtest123\u0026#39;) file.close() myfile.txt 1 testtest123 移動讀寫頭 - seek() 1 2 3 4 5 6 7 8 9 10 11 12 content = \u0026#34;\u0026#34;\u0026#34;Hello Python\u0026#34;\u0026#34;\u0026#34; file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) # file.write(content) file_content = file.read() print(file_content) file.seek(0) # 移動讀寫頭到開頭 file_content = file.read() print(file_content) file.close() 執行回傳 1 2 \u0026gt;\u0026gt;\u0026gt; Hello Python \u0026gt;\u0026gt;\u0026gt; Hello Python 讀出行數 - readline() \u0026amp; readlines() readline：一行一行讀 readlines：一次讀全部行數 poem.txt 1 2 3 4 松下問童子 言師採藥去 只在此山中 雲深不知處 read.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # readlines() 一次讀出 f = open(r\u0026#39;poem.txt\u0026#39;, \u0026#39;r\u0026#39;) lines = f.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) f.seek(0) # 讀寫頭回到開頭 # readline() 一行一行讀 line = f.readline() while line != \u0026#39;\u0026#39;: print(line, end=\u0026#39;\u0026#39;) line = f.readline() f.close() 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 使用 with-open-as 做讀檔案的動作 - (推薦) 1 2 with open(r\u0026#34;poem.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: print(file.read()) 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 刪除檔案 - remove() 使用os模組 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os file = r\u0026#34;poem2.txt\u0026#34; if os.path.exists(file): os.remove(file) else: print(\u0026#39;No exists file\u0026#39;) 新增目錄 - mkdir() 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): print(\u0026#34;Direct is exists\u0026#34;) else: os.mkdir(dir) 刪除空目錄 - rmdir() 使用os.path.exists判斷檔案是否存在 限定空目錄 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): os.rmdir(dir) else: print(\u0026#34;Direct is undefine\u0026#34;) 刪除目錄與底下全部檔案 - rmtree() 使用shell utility模組 - shutil 需謹慎使用避免刪錯目錄 1 2 3 import shutil shutil.rmtree(\u0026#34;testDir\u0026#34;) Python 語法筆記 兩個變數交換值(Python Only) 1 2 3 4 x = 3 y = 8 x,y = y,x # 交換兩個變數的值 print(x,y) 開頭宣告編碼方式可直接強轉(Python Only) 1 2 3 4 # -*- coding: utf-8 -*- # 轉utf-8 print(\u0026#34;哈囉\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;哈囉\u0026#34; Python函數帶入參數方式 參數以tuple傳入function。 1 2 3 4 5 6 def func1(*args): print(args) func2(1,3,5,7,9) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以tuple拆解，進function在組合回tuple。 1 2 3 4 5 6 def func2(*args): print(args) func2(*(2,4,6,8,10)) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以dict傳入function。 1 2 3 4 5 6 def func3(**kwargs): print(kwargs) func3(even=(2,4,6,8), odd=(1,3,5,7,9)) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 參數以dict拆解，進function在組合回dict(需為參數指定關鍵字)(關鍵字參數)。 1 2 3 4 5 6 def func4(**kwargs): print(kwargs) func4(**{\u0026#34;even\u0026#34;:(2,4,6,8), \u0026#34;odd\u0026#34;:(1,3,5,7,9)}) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 其他 字串運算(Python Only) in：是否含有 1 2 3 # in \u0026#34;or\u0026#34; in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; True not in：是否不含有 1 2 3 # not in \u0026#34;abc\u0026#34; not in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; False 取字串的特定位置字元 格式：開始點:結束點:間隔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 取第1~4個字元(不含第4個) \u0026#34;abcdefg\u0026#34;[1:4] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bcde\u0026#39; # 取第1~4個字元(每次間隔2個) \u0026#34;abcdefg\u0026#34;[1:4:2] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bd\u0026#39; # 取最後一個字元 \u0026#34;abcdefg\u0026#34;[-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;g\u0026#39; # 反轉 \u0026#34;abcdefg\u0026#34;[::-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;gfedcba\u0026#39; SQLite 關聯式資料庫(版本3.31.1) 系統命令(.開頭)，SQL命令(;結尾)\n系統命令 進入資料庫 指令：sqlite3 資料庫名稱 1 2 3 sqlite3 test01.sqlite sqlite\u0026gt; 資料庫 (DB) sqlite指令新增資料庫 1 .open test01 sqlite指令查詢所有資料庫 1 .databases 資料表 (Table) 欄位設定 說明 NM (None)可否允許空值 PK (Primary Key)是否為主鍵 AI (A.I)是否自動產生值 U (Unique)不重複鍵 新增資料表 1 create table studen(ID Integer, name String, score Integer); sqlite指令查詢所有資料表 1 .table 更新資料表 SQL語法：ALTER TABLE 資料庫 ADD COLUMN 欄位名稱 資料型態\n1 ALTER TABLE student ADD COLUMN address String; 資料操作 (CRUD:Create/Read/Update/Delete) 插入資料 SQL語法：INSERT INTO 資料表 VALUES(欄位1, 欄位2, 欄位3)\n1 INSERT INTO student values(1001, \u0026#34;Ben\u0026#34;, 88); 查詢資料 SQL語法：SELECT 欄位 FROM 資料表 [WHERE 條件];\n1 SELECT Score from student WHERE ID = 1001; 刪除資料 SQL語法：DELETE FROM 資料表 [WHERE 條件];\n1 DELETE from student WHERE ID = 1001; 修改資料 SQL語法：UPDATE 資料表 SET 欄位名稱 = 值 [WHERE 條件];\n1 UPDATE student SET Name = \u0026#34;Amanda\u0026#34; WHERE ID = 1001; ","date":"2020-03-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52283398446_ed21ce37f2_o.png","permalink":"/2020-03-15/python-beginner-tutorial/","title":"智慧商業Python數據分析與應用班(版本3.*)"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"/2019-03-08/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"/2019-03-05/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"/2019-03-05/emoji-support/","title":"Emoji Support"}]